- en: 'Chapter 2\. How Vue Works: The Basics'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 2 章\. Vue 工作原理：基础知识
- en: 'In the previous chapter, you learned the essential tools for building a Vue
    application and also created your first Vue application, preparing you for the
    next step: learning how Vue works by writing Vue code.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您学习了构建 Vue 应用程序的基本工具，并创建了第一个 Vue 应用程序，为学习通过编写 Vue 代码了解 Vue 工作原理做好了准备。
- en: This chapter introduces you to the concepts of Virtual Document Object Model
    (Virtual DOM) and the fundamentals of writing a Vue component with Vue Options
    API. It also explores further Vue directives and the Vue reactivity mechanism.
    By the end of the chapter, you will understand how Vue works and be able to write
    and register a Vue component for use in your application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了虚拟文档对象模型（Virtual DOM）的概念和使用 Vue 选项 API 编写 Vue 组件的基础知识。它还探讨了更多的 Vue 指令和
    Vue 响应性机制。通过本章末尾，您将理解 Vue 的工作原理，并能够编写和注册用于应用程序的 Vue 组件。
- en: Virtual DOM Under the Hood
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟 DOM 内部运行机制
- en: Vue doesn’t work directly with the Document Object Model (DOM). Instead, it
    implements its Virtual DOM to optimize the application’s performance on run-time.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Vue 不直接与文档对象模型（DOM）一起工作。相反，它实现了虚拟 DOM 来优化应用程序在运行时的性能。
- en: To build a solid understanding of how Virtual DOM works, we start with the concept
    of the DOM.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 要建立对虚拟 DOM 工作原理的扎实理解，我们首先从 DOM 的概念开始。
- en: The DOM represents the HTML (or XML) document content on the web, in the form
    of an in-memory tree-like data structure (as shown in [Figure 2-1](#figure_01)).
    It acts as a programming interface that connects the web page and the actual programming
    code (such as JavaScript). Tags, such as `<div>` or `<section>`, in the HTML document
    are represented as programmatic nodes and objects.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: DOM 在 Web 上代表 HTML（或 XML）文档内容，以内存中树状数据结构的形式表示（如[图 2-1](#figure_01)所示）。它充当一个连接网页和实际编程代码（如
    JavaScript）的编程接口。HTML 文档中的标签，例如 `<div>` 或 `<section>`，在 DOM 中被表示为编程节点和对象。
- en: '![An image illustrated different HTML elements connected, distributing by nesting
    levels](assets/lvue_0201.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![一个示意图，展示了不同 HTML 元素连接在一起，通过嵌套级别进行分布](assets/lvue_0201.png)'
- en: Figure 2-1\. Example of a DOM tree
  id: totrans-8
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-1\. DOM 树示例
- en: 'After the browser parses the HTML document, the DOM will be available for interaction
    immediately. Upon any layout changes, the browser then paints and repaints the
    DOM constantly in the background. We call the process parsing, and painting the
    DOM screen rasterization or the *pixel-to-screen* pipeline. [Figure 2-2](#figure_02)
    demonstrates how rasterization works:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器解析 HTML 文档后，DOM 将立即可供交互使用。在任何布局更改时，浏览器会在后台持续地绘制和重绘 DOM。我们称这个过程为解析，而绘制 DOM
    屏幕的过程称为光栅化或*像素到屏幕*流水线。[图 2-2](#figure_02)展示了光栅化的工作原理：
- en: '![An image illustrated a flow diagram consisting of five major steps, including
    parsing HTML and CSS code, calculating the CSS styles for elements, planning for
    screen layout, then painting the visual elements, and finally applying the composition
    layer on them on the browsers. It also highlights where repaint and reflow happens
    whenever layout changes happen.](assets/lvue_0202.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![一个示意图，展示了由五个主要步骤组成的流程图，包括解析 HTML 和 CSS 代码、计算元素的 CSS 样式、规划屏幕布局、然后绘制视觉元素，最后在浏览器上应用组合层。它还突出显示了每当布局更改时重绘和回流发生的位置。](assets/lvue_0202.png)'
- en: Figure 2-2\. Browser rasterization process
  id: totrans-11
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-2\. 浏览器光栅化过程
- en: The Layout Update Problem
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布局更新问题
- en: Each paint is costly to the browser’s performance. Since the DOM may consist
    of many nodes, querying and updating single or multiple nodes can be extremely
    expensive.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 每次绘制对浏览器性能都是昂贵的。由于 DOM 可能包含许多节点，查询和更新单个或多个节点可能非常昂贵。
- en: 'Here is a simple example of a list of `li` elements in the DOM:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 DOM 中 `li` 元素列表的一个简单示例：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Adding/removing a `li` element or modifying its content requires querying the
    DOM for that item using `document.getElementById` (or `document.getElementsByClassName`).
    Then you need to perform the desired updates using the appropriate DOM APIs.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 添加/移除 `li` 元素或修改其内容需要使用 `document.getElementById`（或 `document.getElementsByClassName`）查询该项的
    DOM。然后，您需要使用适当的 DOM API 执行所需的更新。
- en: 'For instance, if you want to add a new item to the previous example, you need
    to do the following steps:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您想向前面的示例中添加一个新项目，则需要执行以下步骤：
- en: Query the containing list element by its `id` attribute’s value—`"todo-list"`
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过其 `id` 属性的值查询包含的列表元素——`"todo-list"`
- en: Add the new `li` element using `document.createElement()`
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `document.createElement()` 添加新的 `li` 元素
- en: Set the `textContent` and the relevant attributes to match other element’s standard
    using `setAttribute()`.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `setAttribute()` 设置 `textContent` 和相关属性以匹配其他元素的标准。
- en: 'Append that element to the list element found in step 1 as its child using
    `appendChild()`:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将该元素作为其子元素附加到步骤1中找到的列表元素中，使用 `appendChild()`：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Similarly, suppose you want to change the text content of the 2nd `li` item
    to `"buy groceries"`. In that case, you perform step 1 to get the containing list
    element, then query the target element using `getElementsByClassName()`, and finally
    change its `textContent` to the new content:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，假设您想要更改第二个 `li` 元素的文本内容为 `"购买杂货"`。那么，您需要执行第一步来获取包含的列表元素，然后使用 `getElementsByClassName()`
    查询目标元素，最后将其 `textContent` 更改为新内容：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Querying and updating the DOM on a small scale usually do not enormously impact
    performance. However, these actions can slow the page if performed more repetitively
    (within a few seconds) and on a more complex web page. The performance impact
    is significant when there are consecutive minor updates. Many frameworks, such
    as Angular 1.x, fail to acknowledge and address this performance issue as the
    codebase grows. The Virtual DOM is designed to solve the layout update problem.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在小规模上查询和更新 DOM 通常不会对性能产生巨大影响。但是，如果在更复杂的网页上重复（在几秒钟内）进行这些操作，则可能会减慢页面。当连续进行小更新时，性能影响尤为显著。许多框架，如
    Angular 1.x，在代码基础增长时未能认识和解决这个性能问题。虚拟 DOM 的设计目的就是解决布局更新问题。
- en: What Is Virtual DOM?
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是虚拟 DOM？
- en: Virtual DOM is the *in-memory virtual copy version* of the actual DOM in the
    browser, but it is lighter weight and has extra functionalities. It mimics the
    real DOM structure, with a different data structure (usually `Object`) (see [Figure 2-3](#figure_03)).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟 DOM 是浏览器中实际 DOM 的*内存虚拟副本版本*，但它更轻量且具有额外的功能。它模仿了真实 DOM 结构，使用不同的数据结构（通常是 `Object`）（见
    [图2-3](#figure_03)）。
- en: '![The left side of the image is a sample DOM structure with three nesting levels.
    The first level is a single div element. The second level contains two div and
    single h2 elements. The third level contains a ul and button elements nested in
    the first div of the second level, a text element nested in the second div of
    the second level, and a paragraph element nested in the h2 element. The right
    side of the image is the virtual DOM tree structure, with the same levels and
    relationships of the DOM on the left side, and all the elements changed to JSON
    objects with one property named tag for each. The tag property contains the name
    of the actual component, representing the related DOM element that appeared in
    the DOM tree on the left side.](assets/lvue_0203.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图2-3\. 浏览器 DOM vs. 虚拟 DOM](assets/lvue_0203.png)'
- en: Figure 2-3\. The browser DOM vs. the Virtual DOM
  id: totrans-29
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-3\. 浏览器 DOM vs. 虚拟 DOM
- en: Behind the scenes, the Virtual DOM still uses the DOM API to construct and render
    updated elements in the browser. Thus, it still causes the browser’s repainting
    process, but more efficiently.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，虚拟 DOM 仍然使用 DOM API 在浏览器中构建和渲染更新的元素。因此，它仍会导致浏览器的重绘过程，但更高效。
- en: In short, Virtual DOM is an abstract pattern aiming to free the DOM from all
    the actions that can lead to performance inefficiencies, such as manipulating
    attributes, handling events, and manually updating DOM elements.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，虚拟 DOM 是一个抽象模式，旨在解放 DOM 免受一切可能导致性能低下的操作，比如操纵属性、处理事件以及手动更新 DOM 元素。
- en: How Virtual DOM Works in Vue
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Vue 中虚拟 DOM 的工作原理
- en: 'The Virtual DOM sits between the real DOM and the Vue application code. The
    following is an example of what a node in the Virtual DOM looks like:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟 DOM 位于真实 DOM 和 Vue 应用程序代码之间。以下是虚拟 DOM 中节点的示例：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Let’s call this node VNode. VNode is a *virtual node* that resides within the
    Virtual DOM and represents the actual DOM element in the real DOM.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们称这个节点为 VNode。VNode 是虚拟 DOM 中的*虚拟节点*，表示实际 DOM 中的 DOM 元素。
- en: Through UI interactions, the user tells Vue what state they wish the element
    to be in; Vue then triggers the Virtual DOM to update that element’s represented
    object (`node`) to the desired shape while keeping track of those changes. Finally,
    it communicates with the actual DOM and performs accurate updates on the changed
    nodes accordingly.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通过用户界面交互，用户告诉Vue他们希望元素处于的状态；然后Vue触发虚拟DOM以将该元素的表示对象(`node`)更新到所需形状，并跟踪这些变化。最后，它与实际DOM通信，并根据变更的节点执行准确的更新。
- en: Since the Virtual DOM is a tree of custom JavaScript objects, updating a component
    equals updating a custom JavaScript object. This process doesn’t take long. Because
    we don’t call any DOM API, this update action doesn’t cause a DOM repainting.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于虚拟DOM是一组自定义JavaScript对象的树，更新组件等同于更新自定义JavaScript对象。这个过程不会花费太长时间。因为我们不调用任何DOM
    API，所以这个更新动作不会引起DOM重绘。
- en: Once the Virtual DOM finishes updating itself, it syncs in batch with the actual
    DOM, leading the changes to be reflected on the browser.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦虚拟DOM完成更新，它会批量与实际DOM同步，从而使更改反映在浏览器上。
- en: '[Figure 2-4](#figure_04) illustrates how updates from the Virtual DOM to the
    actual DOM work when adding a new list item and changing the list item’s text.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-4](#figure_04)展示了在添加新列表项并更改列表项文本时，虚拟DOM到实际DOM的更新过程。'
- en: '![A diagram demonstrates how an update happens in actual DOM by comparing the
    differences between actual DOM and virtual DOM and performing a patch update to
    actual DOM.](assets/lvue_0204.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![一个图示展示了如何通过比较实际DOM和虚拟DOM之间的差异，并对实际DOM执行补丁更新来实现更新的过程。](assets/lvue_0204.png)'
- en: Figure 2-4\. Updating from Virtual DOM to actual DOM adding a new element and
    updating the text of an existing element in the list
  id: totrans-41
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-4\. 从虚拟DOM到实际DOM的更新，添加新元素并更新列表中现有元素的文本的过程
- en: Since the Virtual DOM is a tree of objects, we can easily track the specific
    updates that need to be synced with the actual DOM when modifying the Virtual
    DOM. Instead of querying and updating directly on the actual DOM, we can now schedule
    and call the updated APIs with a single render function in one update cycle to
    maintain performance efficiency.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于虚拟DOM是对象树，当修改虚拟DOM时，我们可以轻松地跟踪需要与实际DOM同步的特定更新。现在，我们不再直接查询和更新实际DOM，而是可以在一个更新周期中调度和调用更新的API，并通过单个渲染函数维护性能效率。
- en: Now that we understand how Virtual DOM works, we will explore the Vue instance
    and the Vue Options API.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们理解了虚拟DOM的工作原理，我们将探讨Vue实例和Vue选项API。
- en: The Vue App Instance and Options API
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue 应用实例和选项API
- en: Every Vue application starts with a single Vue component instance as the application
    root. Any other Vue component created in the same application needs to be nested
    inside this root component.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Vue应用程序从一个单一的Vue组件实例作为应用程序根开始。同一应用程序中创建的任何其他Vue组件都需要嵌套在此根组件中。
- en: Note
  id: totrans-46
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the initialization code example in `main.ts` of our Vue project.
    Vite automatically generates the code as part of its scaffolding process.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在我们的Vue项目的`main.ts`中找到初始化代码示例。Vite会在其脚手架过程中自动生成这段代码。
- en: You will also find the example code of this chapter within this file.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在这个文件中找到本章的示例代码。
- en: 'In Vue 2, Vue exposes a `Vue` class (or JavaScript function) for you to create
    a Vue component instance based on a set of configuration options, using the following
    syntax:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vue 2中，Vue为您暴露了一个`Vue`类（或JavaScript函数），您可以根据一组配置选项创建一个Vue组件实例，使用以下语法：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`Vue` receives a component, or the component’s configuration to be more precise.
    A component’s configuration is an `Object` containing all the component’s initial
    configuration options. We call the structure of this argument *Options API*, which
    is another of Vue’s core APIs.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vue`接收一个组件，或者更精确地说是组件的配置。组件的配置是一个包含所有组件初始配置选项的对象。我们称这个参数结构为*选项API*，这是Vue的另一个核心API。'
- en: 'Beginning with Vue 3, you can no longer call `new Vue()` directly. Instead,
    you create the application instance using the `createApp()` method from the `vue`
    package. This change in functionality enhances the isolation of each Vue instance
    created both on dependencies and shared components (if any) and the code readability:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 从Vue 3开始，你不能再直接调用`new Vue()`。相反，你需要使用`vue`包中的`createApp()`方法来创建应用程序实例。这种功能上的变化增强了每个Vue实例的隔离性，包括依赖关系和共享组件（如果有的话），并提升了代码可读性：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`createApp()` also accepts an `Object` of the component’s configurations. Based
    on these configurations, Vue creates a Vue component instance as its application
    root `app`. Then you need to mount the root component `app` to the desired HTML
    element using the `app.mount()` method, as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`createApp()`还接受一个组件配置的对象。根据这些配置，Vue 创建一个 Vue 组件实例作为其应用程序根`app`。然后，您需要使用`app.mount()`方法将根组件`app`挂载到所需的
    HTML 元素上，如下所示：'
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`#app` is the unique id selector for the application’s root element. The Vue
    engine queries for the element using this id, mounts the app instance to it, then
    renders the application in the browser.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`#app`是应用程序根元素的唯一ID选择器。Vue 引擎使用此ID查询元素，将应用实例挂载到它，然后在浏览器中呈现应用程序。'
- en: The next step is to provide the configurations for Vue to build a component
    instance according to Options API.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是提供配置，使 Vue 可以根据选项 API 构建组件实例。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: From this point on, we write code according to Vue 3 API standards.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始，我们根据 Vue 3 API 标准编写代码。
- en: Exploring the Options API
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索选项 API
- en: Options API is Vue’s core API for initializing a Vue component. It contains
    the component’s configurations structured in an Object format.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 选项 API 是 Vue 的核心 API，用于初始化 Vue 组件。它以对象格式结构化组件的配置。
- en: 'We divide its essential properties into four main categories:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其基本属性分为四个主要类别：
- en: State handling
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 状态处理
- en: Including `data()`, which returns the local data state for the component, `computed`,
    `methods`, and `watch` for enabling observation on specific local data, and `props`
    for the incoming data.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 包括`data()`，它返回组件的本地数据状态，`computed`，`methods`和`watch`用于对特定本地数据进行观察，以及用于传入数据的`props`。
- en: Rendering
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染
- en: '`template` for the HTML view template and `render()` as the rendering logic
    for the component.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`template`用于HTML视图模板，`render()`用作组件的渲染逻辑。'
- en: Lifecycle hooks
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期钩子
- en: Such as `beforeCreate()`, `created()`, `mounted()`, etc., for handling different
    stages of a component’s lifecycle.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 例如`beforeCreate()`，`created()`，`mounted()`等，用于处理组件生命周期的不同阶段。
- en: Others
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 其他
- en: Such as `provide()`, `inject()` for handling different customization and communication
    between components. And `components`, a collection of nested component templates
    to use within the component.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 例如`provide()`，`inject()`用于处理不同组件之间的定制和通信。以及`components`，这是一组嵌套组件模板，可在组件内使用。
- en: 'The following is an example structure of our root `App` component based on
    Options API:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是基于选项 API 的根`App`组件的示例结构：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the previous code, an HTML template displays regular text. We can also define
    a local `data` state using `data()` function, which we will discuss further in
    [“Creating Local State with Data Properties”](#local_state).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，HTML 模板显示了常规文本。我们还可以使用`data()`函数定义本地`data`状态，我们将在[“使用数据属性创建本地状态”](#local_state)中进一步讨论。
- en: 'You can also rewrite the previous code to use the `render()` function:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以重写先前的代码以使用`render()`函数：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Both codes will generate the same result ([Figure 2-5](#figure_05)).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 两个代码将生成相同的结果（[图 2-5](#figure_05)）。
- en: '![An image displays a text saying this is the app''s entrance.](assets/lvue_0205.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![一张图片显示了一个文本，说这是应用程序的入口。](assets/lvue_0205.png)'
- en: Figure 2-5\. Sample output of writing a root component using Options API
  id: totrans-78
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-5\. 使用选项 API 编写根组件的示例输出
- en: If you open the Elements tab in the browser’s Developer Tools, you will see
    the actual DOM now contains a div with `id="app"` and a text content `*This is
    the app’s entrance*` ([Figure 2-6](#figure_06)).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在浏览器的开发者工具中打开元素选项卡，您将看到实际的 DOM 现在包含一个带有`id="app"`的 div 和文本内容`*这是应用程序的入口*`（[图
    2-6](#figure_06)）。
- en: '![An image displays the actual DOM with the rendered HTML code.](assets/lvue_0206.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![一张图片显示了包含渲染的实际 DOM 的 HTML 代码。](assets/lvue_0206.png)'
- en: Figure 2-6\. The DOM tree in the browser has a div containing the app’s text
    content
  id: totrans-81
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-6\. 浏览器中的 DOM 树包含一个包含应用程序文本内容的 div
- en: You can also create a new component, `Description`, which renders a static text
    and passes it to `components` of the `App`. Then you can use it as a nested component
    in the `template`, like in [Example 2-1](#nest_components).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以创建一个名为`Description`的新组件，用于呈现静态文本，并将其传递给`App`的`components`。然后您可以在`template`中将其作为嵌套组件使用，如[示例
    2-1](#nest_components)所示。
- en: Example 2-1\. Declare an internal component template to use in the `App`
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-1\. 声明一个内部组件模板以在`App`中使用
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The output stays the same as in [Figure 2-6](#figure_06).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与[图 2-6](#figure_06)中相同。
- en: Note here you must declare either `template` or `render()` function (see [“The
    Render Function and JSX”](ch07.html#render_function)) for the component. However,
    you don’t need these properties in case you are writing the component in Single
    File Component (SFC) standard. We will discuss this component standard in [Chapter 3](ch03.html#unique_chapter_id_03).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里必须声明`template`或`render()`函数（参见[“渲染函数和JSX”](ch07.html#render_function)）用于组件。但是，如果您按照单文件组件（SFC）标准编写组件，则不需要这些属性。我们将在[第3章](ch03.html#unique_chapter_id_03)中讨论这个组件标准。
- en: Next, let’s look at the `template` property syntax.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看`template`属性的语法。
- en: The Template Syntax
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板语法
- en: In Options API, `template` accepts a single string that contains valid HTML-based
    code and represents the component’s UI layout. The Vue engine parses this value
    and compiles it into optimized JavaScript code, then accordingly renders the relevant
    DOM elements.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在Options API中，`template`接受一个包含有效HTML代码的字符串，表示组件的UI布局。Vue引擎解析此值并将其编译为优化的JavaScript代码，然后相应地渲染相关的DOM元素。
- en: 'The following code demonstrates our root component `App`, whose layout is a
    single `div` displaying text—`This is the app’s entrance`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码演示了我们的根组件`App`，其布局是一个单一的`div`显示文本—`这是应用程序的入口`：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For multi-level HTML template code, we can use backtick characters (JavaScript
    template literals), denoted by `` ` `` symbol, and maintain the readability. We
    can rewrite `App`’s template in the previous example to include other `h1` and
    `h2` elements, as in the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多级HTML模板代码，我们可以使用反引号字符（JavaScript模板字面量），由 `` ` `` 符号表示，并保持可读性。我们可以重写前面示例中`App`的模板，以包括其他`h1`和`h2`元素，如下所示：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The Vue engine will render to the DOM with two headings ([Figure 2-7](#figure_10)).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Vue引擎将使用两个标题渲染到DOM中（见图[2-7](#figure_10)）。
- en: '![The image displays two headings, one says This is the app''s entrance in
    large bold font, the other says We are exploring template syntax in smaller bold
    font](assets/lvue_0207.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![该图像显示两个标题，一个说这是应用程序的入口，用大粗体字显示，另一个说我们正在探索模板语法，用小粗体字显示](assets/lvue_0207.png)'
- en: Figure 2-7\. Output of a multi-level template for a component
  id: totrans-96
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-7\. 组件多级模板的输出
- en: The `template` property syntax is essential for creating the binding between
    a specific DOM element and the component’s local data using directives and a dedicated
    syntax. We will explore how to define the data we want to display in the UI next.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`template`属性语法对于使用指令和专用语法创建特定DOM元素与组件本地数据之间的绑定至关重要。接下来我们将探讨如何定义我们想在UI中显示的数据。'
- en: Creating Local State with Data Properties
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数据属性创建本地状态
- en: Most components keep their local state (or local data) or receive data from
    an external source. In Vue, we store the component’s local state using the Options
    API `data()` function property.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数组件保持其本地状态（或本地数据）或从外部源接收数据。在Vue中，我们使用Options API的`data()`函数属性来存储组件的本地状态。
- en: '`data()` is an anonymous function that returns an object representing the local
    data state of a component. We call that returned object the *data object*. When
    initializing the component instance, the Vue engine will add each property of
    this data object to its reactivity system for tracking its changes and triggering
    the re-rendering of the UI template accordingly.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`data()`是一个匿名函数，返回表示组件本地数据状态的对象。我们称该返回的对象为*数据对象*。初始化组件实例时，Vue引擎将此数据对象的每个属性添加到其响应系统中，以跟踪其更改并相应地触发UI模板的重新渲染。'
- en: In short, the data object is the reactive state of a component.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，数据对象是组件的响应式状态。
- en: To inject the data property in the template, we use the *mustache* syntax, denoted
    by double curly braces `{{}}`. Within the HTML template, we wrap the data property
    with the curly braces where we need to inject its value, as seen in [Example 2-2](#mustache).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要在模板中注入数据属性，我们使用*mustache*语法，用双花括号 `{{}}` 表示。在 HTML 模板中，我们在需要注入数值的地方用花括号包裹数据属性，如在[示例 2-2](#mustache)中所见。
- en: Example 2-2\. Inject title to display in the HTML template
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-2\. 注入标题以在 HTML 模板中显示
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the previous code, we declare the local data property `title` and inject
    its value in the template of `App` by using the `{{ title }}` expression. The
    output in the DOM equals the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们声明了本地数据属性`title`，并通过使用`{{ title }}`表达式将其值注入到`App`的模板中。DOM中的输出等于以下代码：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can also combine an inline static text with double curly braces within
    the same element tag:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在同一元素标记内将内联静态文本与双花括号结合起来使用：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Vue automatically preserves the static text and replaces only the expression
    with the correct value. The result equals the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Vue 自动保留静态文本，并仅用正确的值替换表达式。结果等同于以下内容：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'All data object properties are available for access directly and internally
    through the component instance `this`. And `this` is accessible in any component’s
    local methods, computed properties, and lifecycle hooks. For example, we can print
    out `title` to the console after creating a component with the hook `created()`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 所有数据对象属性都可以直接通过组件实例`this`在组件的本地方法、计算属性和生命周期钩子中访问。例如，在使用`created()`钩子创建组件后，我们可以将`title`打印到控制台上：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-113
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: We cast `this` as a `ComponentOptions<Data>` type. We will enable full TypeScript
    support for the Vue component in Vue 3 using `defineComponent`, which we will
    discuss further in [“Using defineComponent() for TypeScript Support”](ch03.html#define_component).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`this`转换为`ComponentOptions<Data>`类型。我们将在 [“使用 defineComponent() 支持 TypeScript”](ch03.html#define_component)
    中进一步讨论如何为 Vue 3 启用完整的 TypeScript 支持。
- en: You can debug the reactivity of a data property by using the Vue Devtools. On
    the main page of our application, open the browser’s Developer Tools, head to
    the Vue tab, and select the `Root` component displayed in the Inspector panel.
    Once this is selected, a right-side panel will appear, showing the component data
    object’s properties. When you hover on the `title` property, a pen icon will appear,
    allowing you to edit the property value ([Figure 2-8](#figure_18)).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用 Vue Devtools 调试数据属性的响应性。在应用程序的主页面上，打开浏览器的开发者工具，转到 Vue 选项卡，并选择检查器面板中显示的`Root`组件。一旦选择了这个组件，右侧将出现一个面板，显示组件数据对象的属性。当您悬停在`title`属性上时，会出现一个铅笔图标，允许您编辑属性值（[图 2-8](#figure_18)）。
- en: '![A screenshot displays the Vue Devtool, with title property is highlighted
    and a pen icon appeared on the right of the row next to the property value.](assets/lvue_0208.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![一张截图显示了 Vue Devtools，突出显示了标题属性，并在属性值旁边的行右侧出现了铅笔图标。](assets/lvue_0208.png)'
- en: Figure 2-8\. How to debug and edit a data property using Vue Devtools
  id: totrans-117
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-8\. 如何使用 Vue Devtools 调试和编辑数据属性
- en: Click on that edit icon button, modify the `title` value, and hit Enter; the
    application UI instantly reflects the new value.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 点击编辑图标按钮，修改`title`的值，然后按回车；应用程序 UI 立即反映新值。
- en: You have learned how to use `data()` and double curly braces `{{}}` to inject
    the local data to the UI template. This is a type of one-way data binding.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经学会如何使用`data()`和双大括号`{{}}`将本地数据注入到 UI 模板中。这是一种单向数据绑定。
- en: Before we explore the two-way binding and other directives in Vue, let’s look
    at reactivity in Vue.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索 Vue 中的双向绑定和其他指令之前，让我们先了解一下 Vue 中的响应性。
- en: How Reactivity in Vue Works
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue 中响应性的工作原理
- en: To understand how reactivity works, let’s take a quick look at how the Virtual
    DOM processes all the received information, creates, and keeps track of created
    VNodes before yielding to the actual DOM ([Figure 2-9](#figure_05_01)).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解响应性的工作原理，让我们快速看一下虚拟 DOM 如何处理所有接收到的信息，创建并跟踪创建的 VNode，然后将其传递给实际 DOM（[图 2-9](#figure_05_01)）。
- en: '![A diagram demonstrates how a render happens from Virtual DOM to actual DOM
    when a component data changes, in five different flow states.](assets/lvue_0209.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![一张图表展示了当组件数据发生变化时，从虚拟 DOM 到实际 DOM 的渲染过程，有五种不同的流程状态。](assets/lvue_0209.png)'
- en: Figure 2-9\. The flow of Virtual DOM’s rendering process
  id: totrans-124
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-9\. 虚拟 DOM 渲染过程的流程
- en: 'We can describe the previous process diagram as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将前面的流程图描述如下：
- en: Once you define the local data, in Vue.js 2.0, the internal Vue engine uses
    JavaScript’s built-in `Object.defineProperty()` to establish the *getters and
    setters* for each related piece of data and enables relevant data reactivity.
    In Vue.js 3.0, however, the Vue engine uses the ES5 Proxy-based mechanism^([1](ch02.html#id564))
    for performance enhancement, doubling run-time performance and reducing the memory
    needed by half. We will explain more about this reactivity mechanism in [Chapter 3](ch03.html#unique_chapter_id_03).
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦定义了本地数据，在 Vue.js 2.0 中，内部 Vue 引擎使用 JavaScript 内置的`Object.defineProperty()`为每个相关的数据片段建立*getter和setter*，并启用相关的数据响应性。然而，在
    Vue.js 3.0 中，Vue 引擎使用基于 ES5 代理机制的机制^([1](ch02.html#id564)) 来提升性能，运行时性能翻倍，内存需求减半。我们将在
    [第三章](ch03.html#unique_chapter_id_03) 中更详细地解释这种响应性机制。
- en: After setting up the reactivity mechanism, the Vue engine uses *watcher* objects
    to keep track of any data update triggered by the setters. Watchers help the Vue
    engine detect changes and update the Virtual DOM and the actual DOM through a
    *Queue* system.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置了响应式机制后，Vue引擎使用*观察者*对象来跟踪由设置器触发的任何数据更新。观察者帮助Vue引擎检测更改并通过*队列*系统更新虚拟DOM和实际DOM。
- en: Vue uses the Queue system to avoid inefficient multiple updates of the DOM within
    a short time. A watcher adds itself to the Queue upon a related component’s data
    change. The Vue engine sorts it by a specific order for consumption. Until the
    Vue engine finishes consuming and flushing that watcher from the Queue, only one
    watcher of the same component exists within the Queue, regardless of the number
    of data changes. This consumption process is done by `nextTick()` API, which is
    a Vue function.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Vue使用队列系统来避免在短时间内无效的多次DOM更新。当相关组件的数据发生变化时，观察者将自身添加到队列中。Vue引擎按照特定顺序对其进行消费。直到Vue引擎完成对队列中观察者的消费和刷新，即使有多个数据变化，同一组件的观察者在队列中也只存在一个。这个消费过程是通过`nextTick()`
    API完成的，这是一个Vue函数。
- en: Finally, after the Vue engine consumes and flushes all the watchers, it triggers
    the `run()` function of each watcher to update the component’s real DOM and Virtual
    DOM automatically, and the application renders.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在Vue引擎消费和刷新所有观察者之后，它会触发每个观察者的`run()`函数来自动更新组件的真实DOM和虚拟DOM，并使应用程序渲染。
- en: 'Let’s perform another example. This time we use `data()` and the help of `created()`
    to demonstrate reactivity in the application. `created()` is the lifecycle hook
    that the Vue engine triggers after creating the component instance and before
    mounting it to the DOM element. At this point, we won’t discuss this hook further
    but use this hook to perform a timer update on a data property `counter` with
    `setInterval`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行另一个例子。这次我们使用`data()`并借助`created()`来展示应用程序中的响应性。`created()`是Vue引擎在创建组件实例后但在将其挂载到DOM元素之前触发的生命周期钩子。在这一点上，我们不会进一步讨论这个钩子，而是利用这个钩子来对数据属性`counter`执行定时器更新，使用`setInterval`：
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This code increments the `counter` every one second.^([2](ch02.html#id574))
    We also use `setTimeout()` to clear the interval after 5 seconds. On the browser,
    you can see the displayed value changing from 0 to 5 every second. The final output
    will equal the string:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码每秒增加`counter`。^([2](ch02.html#id574)) 我们还使用`setTimeout()`来在5秒后清除间隔。在浏览器上，您可以看到每秒从0到5变化的显示值。最终输出将等于字符串：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: After understanding the concept of reactivity and rendering in Vue, we are ready
    to explore how to perform two-way data binding.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解了Vue中的响应性和渲染概念之后，我们准备探讨如何执行双向数据绑定。
- en: Two-Way Binding with v-model
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`v-model`实现双向绑定
- en: Two-way binding refers to how we sync data between a component’s logic and its
    view template. When a component’s data field changes programmatically, the new
    value reflects on its UI view. And vice versa, when a user makes changes to the
    data field on the UI view, the component automatically gets and saves the updated
    value, keeping both the internal logic and the UI synchronized. A good example
    of two-way binding is the form input field.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 双向绑定指的是如何在组件逻辑和视图模板之间同步数据。当组件的数据字段在程序中改变时，新值会反映在其UI视图上。反之，当用户在UI视图上对数据字段进行更改时，组件会自动获取并保存更新后的值，保持内部逻辑和UI的同步。一个很好的双向绑定例子是表单输入字段。
- en: Two-way data binding is a complex yet beneficial use case for application development.
    One common scenario for two-way binding is form input synchronization. Proper
    implementation saves developing time and reduces complexity to maintain data consistency
    between the actual DOM and component data. But implementing two-way binding is
    a challenge.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 双向数据绑定是应用开发中复杂但有益的用例。双向绑定的一个常见场景是表单输入同步。正确实现可以节省开发时间，并减少在实际DOM和组件数据之间维护数据一致性的复杂性。但实现双向绑定是一个挑战。
- en: Fortunately, Vue makes two-way binding much simpler with the `v-model` directive.
    Binding the `v-model` directive to a component’s data model will automatically
    trigger updating the template when the data model changes, and vice versa.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Vue通过`v-model`指令使双向绑定变得更简单。将`v-model`指令绑定到组件的数据模型将自动触发在数据模型更改时更新模板，反之亦然。
- en: The syntax is straightforward; the value passing to `v-model` is the name alias
    declared in the `data` return object.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 语法很简单；传递给`v-model`的值是在`data`返回对象中声明的名称别名。
- en: 'Assume we have a `NameInput` component that receives text input from the user,
    with the following `template` code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个`NameInput`组件，它从用户那里接收文本输入，具有以下`template`代码：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We want to sync the the input value received with a local data model, naming
    `name`. To do so, we add `v-model="name"` to the `input` element and declare the
    data model in `data()` accordingly:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将接收到的输入值与名为`name`的本地数据模型同步。为此，我们在`input`元素中添加`v-model="name"`，并相应地在`data()`中声明数据模型：
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The value of `name` will change whenever the user changes the `input` field
    on run-time.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在运行时更改输入字段时，`name`的值也会相应更改。
- en: 'To have this component render in the browser, we add `NameInput` as one of
    the components for the application:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要使此组件在浏览器中渲染，我们将`NameInput`添加为应用程序的组件之一：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can track this data change by opening the Vue tab in the browser’s Developer
    Tools. Within the Inspector tab, find and select the `NameInput` element under
    the `Root` element, and you will see the component’s data displayed on the right
    panel of the Vue tab ([Figure 2-10](#figure_15)).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在浏览器的开发者工具中打开Vue选项卡来跟踪此数据更改。在检查器选项卡中，找到并选择“Root”元素下的“NameInput”元素，您将在Vue选项卡的右侧面板上看到组件的数据显示（[图2-10](#figure_15)）。
- en: '![A screenshot of developer tools opened at the bottom of the browser, with
    Vue is the active tab and displays the component''s information on the right panel.](assets/lvue_0210.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![屏幕截图显示了开发者工具打开在浏览器底部，Vue是活动选项卡，并在右侧面板显示了组件的信息。](assets/lvue_0210.png)'
- en: Figure 2-10\. Debug the input component using the Vue tab in Developer Tools
  id: totrans-149
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-10\. 使用Vue选项卡在开发者工具中调试输入组件
- en: When you change the input field, the `name` property under `data` displayed
    on the right side of the Vue tab also will get the updated value ([Figure 2-11](#figure_16)).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当您更改输入字段时，右侧Vue选项卡下的`data`中的`name`属性也会得到更新的值（[图2-11](#figure_16)）。
- en: '![A screenshot displays how the input field with new value typed will also
    reflect on the ''name'' data property seen in Vue tab.](assets/lvue_0211.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![屏幕截图显示了当在Vue选项卡中看到“名称”数据属性上的新值输入字段时，输入字段如何反映。](assets/lvue_0211.png)'
- en: Figure 2-11\. Input value changes sync with the relevant component’s data model
  id: totrans-152
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-11\. 输入值更改与相关组件的数据模型同步
- en: You can use the same approach for building a checklist with multiple options.
    In this scenario, you need to declare the data model as an `Array` and add the
    `v-model` binding on each checkbox input field. [Example 2-3](#course_checklist)
    demonstrates how it looks for a `Course``Checklist`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用相同的方法构建包含多个选项的清单。在这种情况下，您需要将数据模型声明为`Array`并在每个复选框输入字段上添加`v-model`绑定。[示例2-3](#course_checklist)演示了如何为`CourseChecklist`设置。
- en: Example 2-3\. Create a course checklist using `v-model` and checkbox input
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例2-3\. 使用`v-model`和复选框输入创建课程清单
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Vue automatically adds or removes an input value to the `list` array according
    to the user’s interaction ([Figure 2-12](#figure_17)).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 根据用户的交互，Vue会自动将输入值添加或从`list`数组中移除（[图2-12](#figure_17)）。
- en: '![A screenshot displays a course checklist, with three options presented as
    checkbox for selecting.](assets/lvue_0212.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![屏幕截图显示了课程清单，提供了三个复选框选项供选择。](assets/lvue_0212.png)'
- en: Figure 2-12\. Screenshot of the list value after the user makes a selection
  id: totrans-158
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-12\. 用户进行选择后列表值的屏幕截图
- en: Using v-model.lazy Modifier
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用v-model.lazy修饰符
- en: 'Updating a data value on every user keystroke can be too much, especially when
    displaying that input value in other places. Remember Vue re-renders the template
    UI according to the data changes. By enabling two-way syncing on every input key
    received, you expose your application to potential unnecessary re-rendering. To
    reduce this overhead, you can use the `v-model.lazy` modifier instead of the regular
    `v-model` to bind with the data model:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户每次按键时更新数据值可能会过于频繁，特别是在其他位置显示输入值时。请记住，Vue会根据数据更改重新渲染模板UI。通过使用`v-model.lazy`修饰符而不是常规的`v-model`来绑定数据模型，可以减少此开销：
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This modifier ensures the `v-model` will only track changes triggered by the
    `onChange` event of that input element.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此修饰符确保`v-model`仅跟踪由该输入元素的`onChange`事件触发的更改。
- en: Using `v-model.number` and `v-model.trim` Modifiers
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`v-model.number`和`v-model.trim`修饰符
- en: If the data model you are binding to `v-model` should be a number type, you
    can use the modifier `v-model.number` to convert the input value to a number.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要绑定到`v-model`的数据模型应为数字类型，则可以使用修饰符`v-model.number`将输入值转换为数字。
- en: Similarly, if you want to ensure the string data model free from trailing whitespaces,
    you can use `v-model.trim` instead.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，如果你想确保字符串数据模型没有尾随的空白字符，你可以使用`v-model.trim`。
- en: That’s all for two-way binding. Next we’ll examine the more common directive
    `v-bind` for one-way binding.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是双向绑定的全部内容。接下来我们将详细讨论更常见的指令`v-bind`，用于单向绑定。
- en: Binding Reactive Data and Passing Props Data with v-bind
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定响应数据和传递Props数据与v-bind
- en: Previously we learned to use `v-model` for two-way binding and double curly
    braces `{{}}` for one-way data injection. But to perform one-way binding of data
    to another element as an attribute’s values or other Vue components as props,
    we use `v-bind`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们学习了使用`v-model`进行双向绑定，使用双大括号`{{}}`进行单向数据注入。但是要将数据进行单向绑定到另一个元素的属性值或其他Vue组件的props，我们使用`v-bind`。
- en: '`v-bind`, denoted by `:`, is the most used Vue directive in any application.
    We can bind an element’s attribute (or component’s props) or more to JavaScript
    expressions, following this syntax:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-bind`，以`:`表示，是任何应用程序中最常用的Vue指令。我们可以将元素的属性（或组件的props）或更多绑定到JavaScript表达式，遵循以下语法：'
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Or, for short, with `:` syntax:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '或者，使用`: `语法：'
- en: '[PRE25]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'For example, we have `imageSrc` data, an image URL. To display the image using
    `<img>` tag, we perform the following binding to its `src` attribute:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们有`imageSrc`数据，一个图片的URL。为了使用`<img>`标签显示图片，我们对其`src`属性执行以下绑定：
- en: Example 2-4\. Binding a source to an image
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-4\. 绑定图片的源
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Vue takes the value of `imageSrc` and binds it to the `src` attribute, resulting
    in the following code on the DOM:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Vue获取`imageSrc`的值并将其绑定到`src`属性，从而在DOM上生成如下的代码：
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Vue updates the `src` whenever `imageSrc`’s value changes.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当`imageSrc`的值发生变化时，Vue会更新`src`。
- en: 'Also, you can add `v-bind` on an element as a standalone attribute. `v-bind`
    accepts an object containing all the attributes to bind as properties and the
    expressions as their values. [Example 2-5](#v_bind_02) rewrites [Example 2-4](#v_bind_01)
    to demonstrate this use case:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将`v-bind`作为独立属性添加到元素上。`v-bind`接受一个包含要绑定的所有属性和它们值的表达式的对象。[示例 2-5](#v_bind_02)重新编写[示例 2-4](#v_bind_01)以演示此用例：
- en: Example 2-5\. Binding source and alt text to an image using an object
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-5\. 使用对象将源和alt文本绑定到图片
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In [Example 2-5](#v_bind_02), we bind an object `image` with two properties,
    `src` for the image URL and `alt` for its alt text to the element `<img>`. The
    Vue engine will automatically parse `image` into relevant attributes by its properties’
    names, and then generate the following HTML code in the DOM:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 2-5](#v_bind_02)中，我们绑定一个对象`image`，包含两个属性，`src`表示图片的URL，`alt`表示其alt文本，绑定到`<img>`元素上。Vue引擎将自动根据属性名称解析`image`为相应的属性，并在DOM中生成以下HTML代码：
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Binding to Class and Style Attributes
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定到Class和Style属性
- en: When binding to `class` or `style` attributes, you can pass expressions in array
    or object type. The Vue engine knows how to parse and unite them into the proper
    styling or class name string.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当绑定到`class`或`style`属性时，你可以以数组或对象类型传递表达式。Vue引擎知道如何解析并将它们合并为适当的样式或类名字符串。
- en: 'For example, let’s add some classes to our `img` in [Example 2-5](#v_bind_02):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在[示例 2-5](#v_bind_02)中给我们的`img`添加一些类：
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This code generates an `<img>` element with the class as a single string `"cat
    image"`, as in the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码生成了一个`<img>`元素，类名为单个字符串`"cat image"`，如下所示：
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can also perform dynamic class names by binding the `class` attribute to
    an object whose properties’ values are according to the Boolean `isVisible` data
    value:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过将`class`属性绑定到一个对象来执行动态类名绑定，对象的属性值根据布尔型数据值`isVisible`而定：
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here we define the `img` element to have `cat` class when `isVisible` is `true`,
    and `image` otherwise. The generated DOM element for when `isVisible` is `true`
    now becomes:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们定义了`img`元素，当`isVisible`为`true`时具有`cat`类，否则具有`image`类。当`isVisible`为`true`时生成的DOM元素现在是：
- en: '[PRE33]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Output is similar when `isVisible` is `false`, with `image` instead of `cat`
    for the class name.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当`isVisible`为`false`时，输出与之类似，但`class`名为`image`而非`cat`。
- en: 'You can use the same approach with the `style` attribute or pass an object
    containing CSS rules in CamelCase format. For example, let’s add some margins
    to our image in [Example 2-5](#v_bind_02):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用相同的方法处理`style`属性，或者传递一个包含以驼峰格式命名的CSS规则的对象。例如，在[示例 2-5](#v_bind_02)中给我们的图片添加一些边距：
- en: '[PRE34]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This code generates inline stylings for the `img` element with `margin-block:
    10px` and `margin-inline: 15px` applied.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '这段代码为`img`元素生成内联样式，应用了`margin-block: 10px`和`margin-inline: 15px`。'
- en: 'You can also combine several style objects into a single `style` array. Vue
    knows how to unite them into a single style rule string, as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将几个样式对象合并为一个单独的`style`数组。Vue 知道如何将它们统一成一个单一的样式规则字符串，如下所示：
- en: '[PRE35]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output DOM element will be:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的 DOM 元素将是：
- en: '[PRE36]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Using v-bind for Style
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 v-bind 进行样式绑定
- en: In general, inline style is not a good practice. Hence I don’t recommend using
    `v-bind` for organizing component stylings. We will discuss the proper way of
    working with styling in Vue in [Chapter 3](ch03.html#unique_chapter_id_03).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，内联样式并不是一个良好的实践。因此，我不推荐使用`v-bind`来组织组件的样式。我们将在[第 3 章](ch03.html#unique_chapter_id_03)中讨论在
    Vue 中正确处理样式的方法。
- en: Next, let’s iterate over a data collection in a Vue component.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在 Vue 组件中遍历一个数据集合。
- en: Iterating over Data Collection Using v-for
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 v-for 遍历数据集合
- en: Dynamic list rendering is essential to reduce repetitive code, increase code
    reusability, and maintain the format consistency between a group of similar element
    types. Some examples are a list of articles, active users, and TikTok accounts
    you follow. The data is dynamic in these examples, while the type of content and
    the UI layout remain similar.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 动态列表渲染对于减少重复代码、增加代码可重用性以及保持类似元素类型组的格式一致性至关重要。例如文章列表、活跃用户和你关注的 TikTok 账号列表。在这些示例中，数据是动态的，而内容类型和
    UI 布局保持相似。
- en: 'Vue provides a `v-for` directive to accomplish the goal of iterating through
    an iterative data collection, such as an array or object. We use this directive
    directly on an element, following this syntax:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Vue 提供了`v-for`指令，用于完成对迭代数据集（如数组或对象）的迭代目标。我们可以直接在元素上使用该指令，遵循以下语法：
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`elem` is just an alias for each element in the data source `list`.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`elem`只是数据源`list`中每个元素的别名。'
- en: 'For example, if we want to iterate through an array of numbers `[1, 2, 3, 4,
    5]` and print out the element value, we use the following code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想要遍历一个数字数组`[1, 2, 3, 4, 5]`并打印出元素的值，我们可以使用以下代码：
- en: '[PRE38]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This code equals writing the following native HTML code:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码等同于编写以下的原生 HTML 代码：
- en: '[PRE39]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: One significant advantage of using `v-for` is to keep the template consistent
    and map the data content dynamically to the relevant element, regardless of how
    the data source may change over time.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`v-for`的一个重要优势是保持模板的一致性，并动态地将数据内容映射到相关元素，无论数据源如何随时间变化。
- en: Each block generated by the `v-for` iteration has access to other components’
    data and the specific list item. Take [Example 2-6](#tasks), for instance.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 每个由`v-for`迭代生成的块都可以访问其他组件的数据和特定的列表项。例如，可以看[示例 2-6](#tasks)。
- en: Example 2-6\. Writing a task list component using `v-for`
  id: totrans-216
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-6\. 使用`v-for`编写任务列表组件
- en: '[PRE40]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[Figure 2-13](#figure_11) displays the output:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-13](#figure_11) 显示了输出：'
- en: '![Output is a list with each row display description of a task](assets/lvue_0213.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![输出是一个包含每行任务描述的列表](assets/lvue_0213.png)'
- en: Figure 2-13\. Output of tasks list with the default title for each row
  id: totrans-220
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-13\. 每行具有默认标题的任务列表输出
- en: Keeping the Uniqueness with the Key Attribute
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持唯一性与键属性
- en: Here we *must* define a unique `key` attribute for each iterated element. Vue
    uses this attribute to keep track of each element rendered for a later update.
    See [“Make the Element Binding Unique with Key Attribute”](#key_attribute) for
    discussion on its importance.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们*必须*为每个迭代的元素定义一个唯一的`key`属性。Vue 使用此属性来跟踪每个渲染的元素，以便后续更新。有关其重要性的讨论，请参见[“使用
    Key 属性使元素绑定唯一”](#key_attribute)。
- en: 'Also, `v-for` supports an optional second argument, `index`, the current element’s
    appearance index in the iterating collection. We can rewrite [Example 2-6](#tasks)
    as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`v-for`支持一个可选的第二个参数`index`，表示当前元素在迭代集合中的索引位置。我们可以如下重写[示例 2-6](#tasks)：
- en: '[PRE41]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This code block generates the following output ([Figure 2-14](#figure_12)):'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码块生成以下输出（[图 2-14](#figure_12)）：
- en: '![Output is the list of 3 rows, with a prefix of the index for each row, from
    0 to 2](assets/lvue_0214.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![输出是包含3行列表，每行都有从0到2的索引前缀](assets/lvue_0214.png)'
- en: Figure 2-14\. Output of the task list with each task’s index
  id: totrans-227
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-14\. 每个任务索引输出的任务列表
- en: So far, we have covered iteration with array collection. Let’s look at how we
    iterate through the properties of an object.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了数组集合的迭代。接下来让我们看看如何遍历对象的属性。
- en: Iterating Through Object Properties
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历对象属性
- en: 'In JavaScript, an `Object` is a type of *key-value map table*, with each object’s
    property being the *unique key* of the table. To iterate through the properties
    of an object, we use similar syntax with array iteration:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，`Object`是一种*键值映射表*类型，其中每个对象属性都是表的*唯一键*。要遍历对象的属性，我们使用与数组迭代类似的语法：
- en: '[PRE42]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here `value` stands for the value of a property and `name` for that property’s
    key.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`value`表示属性的值，`name`表示属性的键。
- en: 'The following shows how we iterate through properties of an object collection
    and print out each property’s `name` and `value` according to the format `<name>:
    <value>`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '下面展示了如何遍历对象集合的属性，并根据格式`<name>: <value>`打印出每个属性的`name`和`value`：'
- en: '[PRE43]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[![1](assets/1.png)](#co_how_vue_works__the_basics_CO1-1)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_how_vue_works__the_basics_CO1-1)'
- en: 'Define a `collection` object with three properties: `title`, `description`,
    and `priority`'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个包含三个属性`title`、`description`和`priority`的`collection`对象。
- en: '[![2](assets/2.png)](#co_how_vue_works__the_basics_CO1-2)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_how_vue_works__the_basics_CO1-2)'
- en: Iterate through the properties of `collection`
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历`collection`属性。
- en: '[Figure 2-15](#figure_13) shows the output.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-15](#figure_13)显示了输出。'
- en: '![Output is a list with each row display the title, description, and priority
    of a collection object](assets/lvue_0215.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![输出是列表，每行显示集合对象的标题、描述和优先级](assets/lvue_0215.png)'
- en: Figure 2-15\. Output of collection object with default title
  id: totrans-241
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-15\. 默认标题的集合对象输出。
- en: 'We still have access to the index appearance of the present pair as the third
    argument, as in the following syntax:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以访问当前对的索引外观作为第三个参数，如以下语法所示：
- en: '[PRE44]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As noted earlier, we always have to define a `key` attribute value for each
    iterating element. This attribute is significant in making the element update
    binding unique. We will explore the `key` attribute next.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们总是必须为每个迭代元素定义`key`属性值。该属性在使元素更新绑定唯一方面非常重要。接下来我们将探讨`key`属性。
- en: Make the Element Binding Unique with Key Attribute
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`key`属性使元素绑定唯一。
- en: The Vue engine tracks and updates the elements rendered with `v-for` by a simple
    in-place patch strategy. However, in various scenarios, we need to take complete
    control over list reordering or prevent unwanted behavior when the list element
    relies on its child component’s state.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Vue引擎通过一种简单的就地修补策略跟踪和更新使用`v-for`渲染的元素。然而，在各种场景中，我们需要完全控制列表重新排序或防止列表元素依赖其子组件状态时出现不希望的行为。
- en: 'Vue provides an additional attribute: a `key`, as a *unique identity for each
    node element*, binds to a specific iterated list item. The Vue engine uses it
    as a hint to track, reuse, and reorder the rendered nodes and their nested elements
    instead of in-place patching.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Vue提供了一个额外的属性：`key`，作为*每个节点元素的唯一标识符*，绑定到特定的迭代列表项。Vue引擎将其用作提示，以跟踪、重用和重新排序渲染的节点及其嵌套元素，而不是直接修补。
- en: 'The syntax usage of a `key` attribute is straightforward. We use `v-bind:key`
    (`:key` for short) and bind a *unique* value to that list element:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`key`属性的语法用法很简单。我们使用`v-bind:key`（简写为`:key`），并为该列表元素绑定一个*唯一*值：'
- en: '[PRE45]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Keeping the Key’s Uniqueness
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持`key`的唯一性。
- en: The `key` should be the item’s *distinct identifier* (id) or its *appearance
    index* in the list.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`key`应该是项目的*唯一标识符*（id）或列表中的*外观索引*。'
- en: As a good practice, you must always provide the `key` attribute when using `v-for`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 作为良好的实践，使用`v-for`时必须始终提供`key`属性。
- en: Nevertheless, Vue will throw a warning on the browser console if no `key` is
    presented. Also, if you enable ESLint in your application, it throws an error
    and instantly warns you about the missing `key` attribute, as shown in [Figure 2-16](#figure_14).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果没有提供`key`，Vue会在浏览器控制台上抛出警告。此外，如果在应用程序中启用了ESLint，它会抛出错误并立即警告您缺少`key`属性，如[图 2-16](#figure_14)所示。
- en: '![ESLint tool highlights and displays warning when we try to iterate a list
    with item key presented](assets/lvue_0216.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![当我们尝试使用项目键迭代列表时，ESLint工具会突出显示并显示警告](assets/lvue_0216.png)'
- en: Figure 2-16\. ESLint warning when no key is presented
  id: totrans-255
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-16\. 当没有提供`key`时的ESLint警告
- en: Valid Values for the Key Attribute
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`key`属性的有效值'
- en: A key should be a string or numeric value. An object or array is *not* a valid
    key to use.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`key`应为字符串或数字值。对象或数组*不是*有效的键使用。'
- en: The `key` attribute is helpful, even beyond the scope of `v-for`. Without a
    `key` attribute, applying the built-in list transition and animation effect is
    impossible. We’ll discuss more about the benefits of `key` in [Chapter 8](ch08.html#unique_chapter_id_07).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`key`属性非常有用，甚至超出了`v-for`的范围。没有`key`属性，无法应用内置的列表过渡和动画效果。我们将在[第8章](ch08.html#unique_chapter_id_07)进一步讨论`key`的好处。'
- en: Adding Event Listener to Elements with v-on
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`v-on`为元素添加事件监听器
- en: 'To bind a DOM event to a listener, Vue exposes the built-in directive `v-on`
    (for short `@`) for element tags. The `v-on` directive accepts the following value
    types:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将DOM事件绑定到监听器，Vue为元素标签暴露了内置指令`v-on`（缩写为`@`）。`v-on`指令接受以下值类型：
- en: Some inline JavaScript statements in the form of a string
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些内联的JavaScript语句，形式为字符串
- en: Name of the component method declared in the component options under `methods`
    property
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`methods`属性下声明的组件选项中的组件方法名称
- en: 'We use `v-on` with the following format:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下格式与`v-on`一起使用：
- en: '[PRE46]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Or with the shorter version using `@`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用较短版本的`@`：
- en: '[PRE47]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note
  id: totrans-267
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: From this point on, we will use `@` to denote `v-on`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在起，我们将使用`@`来表示`v-on`。
- en: 'Then add this directive directly on any element as an attribute:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 然后直接在任何元素上作为属性添加该指令：
- en: '[PRE48]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: For code readability, especially in a complex codebase, I recommend keeping
    the JavaScript expression inside a component’s method and exposing the use through
    its name on the directive, as in [Example 2-7](#click_print).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 为了代码可读性，特别是在复杂的代码库中，建议将JavaScript表达式保持在组件方法内部，并通过其名称在指令上公开使用，如[示例2-7](#click_print)。
- en: Example 2-7\. Change `printMsg`’s value on button click using `v-on` directive
  id: totrans-272
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-7\. 使用`v-on`指令在按钮点击时改变`printMsg`的值
- en: '[PRE49]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: If the user hasn’t clicked the button, the display message below the button
    will be “Nothing to print yet” ([Figure 2-17](#figure_22)).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户尚未点击按钮，则按钮下方的显示消息将是“尚未打印任何内容”（见[图2-17](#figure_22)）。
- en: '![A screenshot shows a message ''Nothing to print yet!''](assets/lvue_0217.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![一张截图显示一个消息''尚未打印任何内容！''](assets/lvue_0217.png)'
- en: Figure 2-17\. “Nothing to print yet” message appears as default
  id: totrans-276
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-17\. 默认显示“尚未打印任何内容”消息
- en: Otherwise, the message will change to “Button is clicked!” ([Figure 2-18](#figure_23)).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，消息将变成“按钮已点击！”（见[图2-18](#figure_23)）。
- en: '![A text showing ''Button is clicked!'' appears after the Click me button ](assets/lvue_0218.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![一个文本显示''按钮已点击！''在点击我按钮后出现](assets/lvue_0218.png)'
- en: Figure 2-18\. “Button is clicked!” message appears after user clicks the button
  id: totrans-279
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-18\. 用户点击按钮后显示“按钮已点击！”消息
- en: Handling Events with v-on Event Modifiers
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`v-on`事件修饰符处理事件
- en: 'Before the browser dispatches an event on a target element, it constructs that
    event’s propagation path list using the current DOM tree structure. The last node
    in this path is the target itself, and the other preceding nodes are its ancestors,
    respectively, in order. Once dispatched, the event travels through one or all
    three main event phases ([Figure 2-19](#figure_24)):'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器将事件分派到目标元素之前，它会使用当前DOM树结构构建该事件的传播路径列表。此路径的最后一个节点是目标元素本身，前面的节点依次是其祖先。一旦分派，事件将通过一个或所有三个主要事件阶段传播（见[图2-19](#figure_24)）：
- en: Capturing (or capture phase)
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获（或捕获阶段）
- en: The event travels (or propagates) from the top ancestor down to the target element.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 事件从顶层祖先元素传播到目标元素。
- en: Target
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 目标
- en: The event is at the target element.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 事件在目标元素上。
- en: Bubbling
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 冒泡
- en: The event travels (or bubbles) from the target element up to its ancestor.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 事件从目标元素向上冒泡到其祖先。
- en: We usually interfere with this event propagation flow programmatically within
    the listener logic. With `v-on`’s modifiers, we can interfere directly on the
    directive level.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常在监听器逻辑内部通过编程干预事件传播流程。利用`v-on`的修饰符，我们可以直接干预指令级别。
- en: 'Use `v-on` modifiers following this format:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下格式跟随`v-on`修饰符：
- en: '[PRE50]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '![A diagram shows the levels of propagation phases, from bottom up and top
    down.](assets/lvue_0219.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![图示显示传播阶段的级别，从底部向上和从顶部向下。](assets/lvue_0219.png)'
- en: Figure 2-19\. Flow of propagation for a click event
  id: totrans-292
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-19\. 点击事件传播流程图
- en: One advantage of modifiers is that they keep the listener as generic and reusable
    as possible. We do not need to worry internally about event-specific details,
    such as `preventDefault` or `stopPropagation`.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 修饰符的一个优势是使监听器尽可能通用和可重用。我们无需在内部担心特定于事件的细节，如`preventDefault`或`stopPropagation`。
- en: Take [Example 2-8](#event_propagation), for instance.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 参考[示例2-8](#event_propagation)。
- en: Example 2-8\. Manually stop the propagation using `stopPropagation()`
  id: totrans-295
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-8\. 使用`stopPropagation()`手动停止事件传播
- en: '[PRE51]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Here we have to stop the propagation ourselves with `e.stopPropagation`, adding
    another validation layer to make sure `e` exists. [Example 2-9](#v_on_stop) shows
    how we can rewrite [Example 2-8](#event_propagation) using the `@click.stop` modifier.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要自己使用`e.stopPropagation`停止事件传播，添加另一个验证层确保`e`存在。[示例 2-9](#v_on_stop)展示了我们如何使用`@click.stop`修饰符重写[示例 2-8](#event_propagation)。
- en: Example 2-9\. Stop propagation using `@click.stop` modifier
  id: totrans-298
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-9\. 使用`@click.stop`修饰符停止事件传播
- en: '[PRE52]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[Table 2-1](#on_modifiers_table) shows the complete list of event modifiers
    available, briefly explaining the equivalent event functionalities or behavior.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 2-1](#on_modifiers_table)显示了可用的事件修饰符的完整列表，并简要解释了等效的事件功能或行为。'
- en: Table 2-1\. Event modifiers for `v-on` directive
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-1\. `v-on`指令的事件修饰符
- en: '| Modifier | Description |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| Modifier | Description |'
- en: '| --- | --- |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `.stop` | Instead of calling `event.stopPropagation()` |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| `.stop` | 而不是调用`event.stopPropagation()` |'
- en: '| `.prevent` | Instead of calling `event.preventDefault()` |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| `.prevent` | 而不是调用`event.preventDefault()` |'
- en: '| `.self` | Trigger the event listener *only if* the event’s target is the
    element where we attach the listener. |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| `.self` | 仅当事件的目标是我们附加监听器的元素时才触发事件监听器。 |'
- en: '| `.once` | Trigger the event listener *at most once* |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| `.once` | 最多触发一次事件监听器 |'
- en: '| `.capture` | Instead of passing `{ capture: true }` as the third parameter
    for `addEventListener()`, or `capture="true"` in the element. This modifier triggers
    the listener in the *capturing phase* order, instead of regular bubbling phase
    order. |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| `.capture` | 而不是将`{ capture: true }`作为`addEventListener()`的第三个参数传递，或者在元素上添加`capture="true"`。这个修饰符以*捕获阶段*的顺序触发监听器，而不是常规的冒泡阶段顺序。
    |'
- en: '| `.passive` | Mainly to opt-in for *better scroll performance* and prevent
    triggering `event.preventDefault()`. We use it instead of passing `{ passive:
    true }` as the third parameter for `addEventListener()` or adding `passive="true"`
    to the element. |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| `.passive` | 主要是为了选择*更好的滚动性能*并防止触发`event.preventDefault()`。我们使用它来代替将`{ passive:
    true }`作为`addEventListener()`的第三个参数传递，或者在元素上添加`passive="true"`。 |'
- en: Chaining Modifiers
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修饰符链式调用
- en: Event modifiers support chaining. This means you can write expressions such
    as `@click.stop.prevent=" printMessage">` on the element tag. This expression
    equals calling both `event.stop` `Propagation()` and `event.preventDefault()`
    inside the event handler, in the order in which they appear.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 事件修饰符支持链式调用。这意味着你可以在元素标签上写诸如`@click.stop.prevent="printMessage">`的表达式。此表达式相当于在事件处理程序中依次调用`event.stopPropagation()`和`event.preventDefault()`。
- en: Detecting Keyboard Events with Key Code Modifiers
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用键码修饰符检测键盘事件
- en: While event modifiers are for interfering with the event propagation flow, *key
    modifiers* help detect special keys of keyboard events such as `keyup`, `keydown`,
    and `keypress`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然事件修饰符用于干预事件传播流程，*键修饰符*帮助检测键盘事件的特殊键，如`keyup`、`keydown`和`keypress`。
- en: 'Usually, to detect a specific key, we need to perform two steps:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，要检测特定的键，我们需要执行两个步骤：
- en: Identify the key code, `key`, or the `code` represented by that key. For instance,
    the `keyCode` for `Enter` is 13, its `key` is “Enter”, and its `code` is “Enter.”
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别键码、`key`或由该键表示的`code`。例如，`Enter`键的`keyCode`是13，其`key`是“Enter”，其`code`是“Enter”。
- en: When firing the event handler, within the handler, we need to check manually
    that `event.keyCode` (or `event.code` or `event.key`) matches the target key code.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在触发事件处理程序时，我们需要在处理程序内部手动检查`event.keyCode`（或`event.code`或`event.key`）是否与目标键码匹配。
- en: This approach is not efficient for maintaining reusable and clean code in a
    large codebase. `v-on` comes with built-in key modifiers as a better alternative.
    If we want to detect if the user types the *Enter* key, we add the modifier `.enter`
    to the related `keydown` event, following the same syntax when using event modifiers.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法不适合在大型代码库中维护可重用和清晰的代码。`v-on`提供了内置的键修饰符作为更好的选择。如果我们想要检测用户是否按下了*Enter*键，我们可以在相关的`keydown`事件上添加修饰符`.enter`，使用事件修饰符时遵循相同的语法。
- en: Let’s assume we have an input element, and we log a message to the console whenever
    a user presses *Enter*, as seen in [Example 2-10](#enter_key_check).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个输入元素，当用户按*Enter*键时，我们会在控制台记录一条消息，如[示例 2-10](#enter_key_check)所示。
- en: Example 2-10\. Manual check if `keyCode` is 13 stands for Enter key
  id: totrans-319
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-10\. 手动检查`keyCode`是否为13表示Enter键
- en: '[PRE53]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We now can rewrite it using `@keydown.enter`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以用`@keydown.enter`来重写它。
- en: Example 2-11\. Checking for Enter key pressed by `@keydown.enter` modifier
  id: totrans-322
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-11\. 使用 `@keydown.enter` 修饰符检查 Enter 键是否按下
- en: '[PRE54]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The app behaves the same in both cases.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 应用在两种情况下的应用程序行为相同。
- en: A few other commonly used key modifiers are `.tab`, `.delete`, `.esc`, and `.space`.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 几个其他常用的关键修饰符是`.tab`、`.delete`、`.esc`和`.space`。
- en: 'Another popular use case is to capture a special keys combination, such as
    *Ctrl & Enter* (*CMD & Enter* for MacOS) or *Shift + S*. In these scenarios, we
    chain the *system* key modifiers (`.shift`, `.ctrl`, `.alt` and `.meta` for *CMD*
    key in MacOS) with *key code* modifiers, as in the following example:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见用例是捕获特殊键组合，例如 *Ctrl & Enter*（MacOS 上的 *CMD & Enter*）或 *Shift + S*。在这些场景中，我们将*系统*键修饰符（`.shift`、`.ctrl`、`.alt`
    和 MacOS 中的 `.meta` 用于 *CMD* 键）与*键码*修饰符链接起来，就像以下示例中所示：
- en: '[PRE55]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Or chaining the shift modifier and key code modifier for `S` key (`keyCode`
    is `83`):'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 或者在按下 `S` 键（`keyCode` 为 `83`）时链式调用 Shift 修饰符和键码修饰符：
- en: '[PRE56]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Chaining System Modifiers and Key Code Modifiers
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接系统修饰符和键码修饰符
- en: You *must* use key code modifiers instead of standard key modifiers, meaning
    `.13` in place of `.enter` for this type of chaining.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种链接中，您*必须*使用键码修饰符而不是标准键修饰符，例如`.13`代替`.enter`。
- en: 'Also, to capture the exact key combinations for triggering an event, we use
    the `.exact` modifier:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了捕获触发事件的确切键组合，我们使用 `.exact` 修饰符：
- en: '[PRE57]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Combining `.shift` and `.exact` makes sure the click event fires when the user
    presses *only* the Shift key while clicking the button.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 结合 `.shift` 和 `.exact` 确保在用户仅按下 Shift 键点击按钮时触发点击事件。
- en: Conditional Rendering Elements with v-if, v-else, and v-else-if
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `v-if`、`v-else` 和 `v-else-if` 进行条件渲染元素
- en: We also can generate or remove an element from the DOM, a scenario called *conditional
    rendering*.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以根据需要在 DOM 中生成或删除元素，这称为*条件渲染*。
- en: Assume we have a Boolean data property `isVisible`, which decides if Vue should
    render a text element into the DOM and make it visible to the user. Binding directive
    `v-if` to `isVisible` by placing `v-if="isVisible"` on the text element enables
    reactively rendering the element only when `isVisible` is `true` ([Example 2-12](#example_v_if)).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个布尔数据属性 `isVisible`，用于决定 Vue 是否应将文本元素渲染到 DOM 中并向用户显示。通过将 `v-if="isVisible"`
    绑定到文本元素，只有当 `isVisible` 为 `true` 时才会反应性地渲染元素（参见[示例 2-12](#example_v_if)）。
- en: Example 2-12\. Example usage for `v-if`
  id: totrans-338
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-12\. 使用 `v-if` 的示例用法
- en: '[PRE58]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'When setting `isVisible` to `false`, the generated DOM elements will look like
    this:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 当将`isVisible`设置为`false`时，生成的 DOM 元素如下所示：
- en: '[PRE59]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Otherwise, the text element will be visible in the DOM:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，文本元素将在 DOM 中可见：
- en: '[PRE60]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: If we want to render a different component for the opposite condition (`isVisible`
    is `false`), `v-else` is the right choice. Unlike `v-if`, you use `v-else` without
    binding to any data property. It takes the correct condition value based on the
    immediate preceding `v-if` usage in the same context level.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要为相反条件（`isVisible` 为 `false`）渲染不同的组件，则 `v-else` 是正确的选择。与 `v-if` 不同，您无需绑定任何数据属性即可使用
    `v-else`。它基于同一上下文级别中即将使用的 `v-if` 的正确条件值。
- en: Using v-else
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `v-else`
- en: '`v-else` works only when `v-if` exists, and it must always present last in
    a chaining conditional rendering.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-else` 仅在存在 `v-if` 时起作用，并且必须始终出现在链式条件渲染的最后。'
- en: For example, as [Example 2-13](#v_if_simple) shows, we can create a component
    with the following code block with both `v-if` and `v-else`.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如[示例 2-13](#v_if_simple)所示，我们可以创建一个组件，其中包含以下代码块，同时具有 `v-if` 和 `v-else`。
- en: Example 2-13\. Conditional display of different texts using `v-if` and `v-else`
  id: totrans-348
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-13\. 使用 `v-if` 和 `v-else` 进行条件显示不同文本
- en: '[PRE61]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In short, you can translate the previous conditions into similar logical expressions
    as:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，您可以将上述条件转换为类似的逻辑表达式：
- en: '[PRE62]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: As in any `if…else` logic expression, we can always extend the condition check
    with an `else if` condition block. This condition block equals a `v-else-if` directive
    and also requires a JavaScript condition statement. [Example 2-14](#v_else_if)
    shows how to display a text, `I’m the subtitle text`, when `isVisible` is `false`
    and `showSubtitle` is `true`.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在任何 `if…else` 逻辑表达式中一样，我们始终可以通过 `else if` 条件块扩展条件检查。此条件块等同于 `v-else-if` 指令，并且还需要一个
    JavaScript 条件语句。[示例 2-14](#v_else_if) 展示了当 `isVisible` 为 `false` 且 `showSubtitle`
    为 `true` 时如何显示文本 `I’m the subtitle text`。
- en: Example 2-14\. Condition chaining with `v-if`, `v-else-if`, and `v-else`
  id: totrans-353
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-14\. 使用 `v-if`、`v-else-if` 和 `v-else` 进行条件链接
- en: '[PRE63]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Order of v-else-if
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`v-else-if` 的顺序'
- en: If we use `v-else-if`, we *must* present it on elements appearing after the
    element with assigned `v-if` attribute.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 `v-else-if`，我们*必须*将其呈现在分配了 `v-if` 属性的元素之后。
- en: While using `v-if` means to render an element conditionally, there are situations
    where it won’t be efficient to mount/unmount an element from the DOM so frequently.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用 `v-if` 意味着有条件地渲染元素，但在需要频繁挂载/卸载元素的情况下效率并不高。
- en: In such cases, it’s better to use `v-show`.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，最好使用 `v-show`。
- en: Conditional Displaying Elements with v-show
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `v-show` 有条件地显示元素
- en: Unlike `v-if`, `v-show` only toggles the visibility of the target element. Vue
    still renders the target element regardless of the status of the condition check.
    Once rendered, Vue controls the visibility using the CSS `display` rule to hide/show
    the element conditionally.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `v-if` 不同，`v-show` 只是切换目标元素的可见性。Vue 仍然会根据条件检查的状态渲染目标元素。一旦渲染，Vue 使用 CSS 的 `display`
    规则有条件地隐藏/显示元素。
- en: Let’s take [Example 2-12](#example_v_if) and change the directive from `v-if`
    to `v-show`, as in [Example 2-15](#event_propagation_2).
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以参考[示例 2-12](#example_v_if)，将指令从 `v-if` 更改为 `v-show`，如同[示例 2-15](#event_propagation_2)中那样。
- en: Example 2-15\. Hide/show the element using `v-show`
  id: totrans-362
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-15\. 使用 `v-show` 隐藏/显示元素
- en: '[PRE64]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The UI output is the same as when we use `v-if`. However, in the browser DOM
    (*you can debug in the Elements tab of the Developer Tools*), the text element
    exists in the DOM but is not visible to the user:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: UI 输出与使用 `v-if` 时相同。然而，在浏览器 DOM（*您可以在开发者工具的元素标签中进行调试*）中，文本元素存在于 DOM 中但对用户不可见：
- en: '[PRE65]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The target element has an inline `style` with `display:none` applied. When toggling
    `isVisible` to `true`, Vue will remove this inline style.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 目标元素具有带有 `display:none` 的内联 `style`。当将 `isVisible` 切换为 `true` 时，Vue 将移除此内联样式。
- en: Note
  id: totrans-367
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`v-show` is more efficient if the toggling frequency is high at runtime, while
    `v-if` is an ultimate choice if the condition is not likely to change.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行时切换频率高，则 `v-show` 更有效，而如果条件不太可能改变，则 `v-if` 是终极选择。
- en: Dynamically Displaying HTML Code with v-html
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `v-html` 动态显示 HTML 代码
- en: We use `v-html` to inject plain HTML code into the DOM dynamically, in the form
    of a string, as in [Example 2-16](#v_html_code).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `v-html` 将纯 HTML 代码以字符串形式动态注入到 DOM 中，例如[示例 2-16](#v_html_code)。
- en: Example 2-16\. Using v-html to render inner HTML content
  id: totrans-371
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-16\. 使用 `v-html` 渲染内部 HTML 内容
- en: '[PRE66]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The Vue engine will parse the directive value as *static HTML code* and place
    it into the `innerHTML` property of the `div` element. The result should look
    like:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: Vue 引擎会将指令值解析为*静态 HTML 代码*，并将其放置在 `div` 元素的 `innerHTML` 属性中。结果应如下所示：
- en: '[PRE67]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Security Concern with v-html
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `v-html` 存在安全问题
- en: You should use `v-html` to render only trusted content or perform server-side
    rendering.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该仅用 `v-html` 渲染受信任的内容或执行服务器端渲染。
- en: Also, a valid HTML string can contain a `script` tag and the browser will trigger
    the code within this `script` tag, leading to a potential security threat. Thus,
    using this directive on client-side rendering is not recommended.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，有效的 HTML 字符串可以包含 `script` 标签，浏览器将触发此 `script` 标签中的代码，可能导致安全威胁。因此，不建议在客户端渲染时使用此指令。
- en: Displaying Text Content with v-text
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `v-text` 显示文本内容
- en: '`v-text` is an alternative way of injecting data as the element’s content besides
    the double curly braces `{{}}`. However, unlike `{{}}`, Vue won’t update the text
    rendered if there are any changes.'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-text` 是注入数据作为元素内容的替代方法，除了双花括号 `{{}}`。然而，与 `{{}}` 不同，如果有任何更改，Vue 不会更新渲染的文本。'
- en: 'This directive is beneficial when you need to predefine a placeholder text,
    then override the text only once after a component finishes loading:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要预定义占位文本并在组件加载完成后仅一次覆盖文本时，此指令非常有益：
- en: '[PRE68]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Here Vue will render the application displaying *placeholder text* and will
    eventually replace it with “Hello World” received from `text`.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: Vue 将渲染应用程序，显示*占位文本*，并最终用从`text`接收到的“Hello World”替换它。
- en: Optimizing Renders with v-once and v-memo
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `v-once` 和 `v-memo` 优化渲染
- en: '`v-once` helps render static content and preserves performance from the re-rendering
    static element. Vue renders elements with this directive presented *only once*
    and will not update it regardless of any re-rendering.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-once` 有助于渲染静态内容并保持性能不受重新渲染静态元素的影响。Vue 使用此指令渲染的元素*仅一次*，并且无论重新渲染多少次，都不会更新它。'
- en: 'To use `v-once`, place the directive as is on the element tag:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `v-once`，直接将指令放置在元素标签上：
- en: '[PRE69]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: In the previous example, Vue renders `name` once for the `div` tag, and regardless
    of what value `name` receives from the user through `input` field and by `v-model`,
    the content of this `div` won’t be updated ([Figure 2-20](#figure_25)).
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，Vue 为 `div` 标签仅渲染 `name` 一次，不管 `name` 从用户通过 `input` 字段和 `v-model` 接收到的值是什么，该
    `div` 的内容都不会更新（见图 2-20）。
- en: '![Input field display new value as Maya Shavin, while the below text is still
    Maya.](assets/lvue_0220.png)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![输入字段显示新值为“Maya Shavin”，而下面的文本仍为“Maya”。](assets/lvue_0220.png)'
- en: Figure 2-20\. Text remains the same though the input value has changed
  id: totrans-389
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-20\. 尽管输入值已更改，文本保持不变
- en: While `v-once` is excellent for defining a block of elements as static content,
    we use `v-memo` to memorize a block of parts (or components) within a template
    conditionally.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `v-once` 适用于将一组元素定义为静态内容，但我们使用 `v-memo` 条件性地记忆模板中的一部分（或组件）。
- en: '`v-memo` accepts an array of JavaScript expressions as its value. We place
    it on the top element where we want to control its and its children’s re-rendering.
    Vue then validates these JavaScript conditional expressions and only triggers
    the re-rendering on the target block of elements when fulfilling those condition(s).'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-memo` 接受一个 JavaScript 表达式数组作为其值。我们将其放在我们想要控制重新渲染的顶级元素上及其子元素。Vue 然后验证这些 JavaScript
    条件表达式，并且仅在满足条件时触发目标元素块的重新渲染。'
- en: Take rendering a gallery of image cards, for instance. Assume we have an array
    of images. Each image is an object with a `title`, `url`, and `id`. Users can
    select an image card by clicking on the card, and the selected card will have
    a blue border.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 以渲染图像卡片库为例。假设我们有一个图像数组。每个图像是一个带有 `title`、`url` 和 `id` 的对象。用户可以通过点击卡片选择图像，选择的卡片将具有蓝色边框。
- en: 'First, let’s define the `images` data array and `selected` image card id in
    the component data object:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在组件数据对象中定义 `images` 数据数组和 `selected` 图像卡片 id：
- en: '[PRE70]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Then we define the layout for the list rendering to the `template`, adding
    a conditional memorization `v-memo` for the list item to re-render only if the
    image item is no longer selected, or vice versa:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们为列表渲染定义布局到 `template`，添加一个条件记忆 `v-memo`，以便仅在图像项目不再选择或相反时重新渲染列表项：
- en: '[PRE71]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[![1](assets/1.png)](#co_how_vue_works__the_basics_CO2-1)'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_how_vue_works__the_basics_CO2-1)'
- en: We set the re-rendering to only if the condition check `selected === image.id`
    results differently from the previous check.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置重新渲染条件仅在检查 `selected === image.id` 的结果与先前检查结果不同时触发。
- en: The output will look like [Figure 2-21](#figure_26).
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将类似于图 2-21。
- en: '![A screenshot displays a gallery of cat images, each image with a title text
    at the bottom.](assets/lvue_0221.png)'
  id: totrans-400
  prefs: []
  type: TYPE_IMG
  zh: '![屏幕截图显示一张猫图片库，每张图片底部有标题文字。](assets/lvue_0221.png)'
- en: Figure 2-21\. Images gallery output
  id: totrans-401
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-21\. 图像库输出
- en: 'Every time you select an image by clicking on the image card, Vue will only
    re-render two items: the previously selected item and the currently selected one.
    For optimizing large list rendering, this directive can be very powerful.'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 每次通过点击图像卡片选择图像时，Vue 只重新渲染两个项目：先前选择的项目和当前选择的项目。对于优化大型列表渲染，这个指令非常强大。
- en: '`v-memo` Availability'
  id: totrans-403
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`v-memo` 可用性'
- en: '`v-memo` is available only in Vue 3.2 and above.'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-memo` 仅在 Vue 3.2 及以上版本中可用。'
- en: We have learned how to write a component using the `template` syntax and some
    common Vue directives, except `v-slot`. We will resume discussing the power of
    `v-slot` in [Chapter 3](ch03.html#unique_chapter_id_03).
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何使用 `template` 语法编写组件和一些常见的 Vue 指令，除了 `v-slot`。我们将在 [第三章](ch03.html#unique_chapter_id_03)
    中继续讨论 `v-slot` 的强大之处。
- en: Next, we will learn how to register a component globally, making it available
    for use in other components of the same application without explicitly importing
    them.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何全局注册组件，使其可以在同一应用程序的其他组件中使用，而无需显式导入它们。
- en: Registering a Component Globally
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局注册组件
- en: Using the `components` property of Options API to register a component only
    enables its availability explicitly within the current component. Any of the present
    component’s nested elements won’t have access to use the registered one.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Options API 的 `components` 属性注册组件仅允许显式在当前组件内部使用注册的组件。任何当前组件的嵌套元素将无法使用已注册的组件。
- en: 'Vue exposes the instance method `Vue.component()`, which receives two input
    parameters as arguments:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: Vue 提供了实例方法 `Vue.component()`，接收两个输入参数作为参数：
- en: A string stands for the component’s registered name (alias).
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串表示组件的注册名称（别名）。
- en: A component instance, either an SFC imported as a module or an object containing
    the component’s configurations, following Options API.
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件实例，无论是作为模块导入的 SFC 还是包含组件配置的对象，都遵循选项 API。
- en: To register a component globally, we trigger `component()` on the created `app`
    instance, as seen in [Example 2-17](#global_component).
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 要全局注册一个组件，我们在创建的 `app` 实例上触发 `component()`，正如在 [例子 2-17](#global_component)
    中所见。
- en: Example 2-17\. Register `MyComponent` as global component and use it in the
    `App` template
  id: totrans-413
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子 2-17\. 将 `MyComponent` 注册为全局组件并在 `App` 模板中使用
- en: '[PRE72]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'If you have a `MyComponent` as an SFC file (see [Chapter 3](ch03.html#unique_chapter_id_03)),
    you can rewrite [Example 2-17](#global_component) to the following:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个作为 SFC 文件的 `MyComponent`（见[第三章](ch03.html#unique_chapter_id_03)），你可以将
    [例子 2-17](#global_component) 重写为以下形式：
- en: '[PRE73]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: And `MyComponent` will always be available for reuse in any component nested
    within the `app` instance.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 并且 `MyComponent` 将始终在 `app` 实例内任何嵌套组件中可复用。
- en: Importing the same component again in every component file can be repetitive
    and inconvenient. In reality, sometimes you need to reuse a component multiple
    times across an application. In this scenario, registering components as global
    components is an excellent practice.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个组件文件中再次导入同一组件可能会显得重复且不方便。实际上，有时你需要在应用程序中多次重用一个组件。在这种情况下，将组件注册为全局组件是一个很好的实践。
- en: Summary
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter explored Virtual DOM and how Vue uses it to achieve its performance
    goal. We learned how to control the component rendering with JSX and functional
    components, handle built-in Vue directives, and use them to process the component’s
    local data for displaying on the UI template reactively. We also learned about
    the reactivity fundamentals and how to create and register the Vue component using
    Options API with the template syntax. These are the basics for going further into
    the Vue component mechanism in the next chapter.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了虚拟 DOM 及其在 Vue 中实现性能目标的方法。我们学习了如何使用 JSX 和函数组件控制组件渲染，处理内置 Vue 指令，并使用它们来处理组件的本地数据以在
    UI 模板上进行响应显示。我们还学习了响应性基础知识以及如何使用选项 API 和模板语法创建和注册 Vue 组件。这些是深入理解下一章节中 Vue 组件机制的基础。
- en: ^([1](ch02.html#id564-marker)) Visit the [JavaScript Proxy documentation](https://oreil.ly/SRqbn).
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch02.html#id564-marker)) 访问[JavaScript 代理文档](https://oreil.ly/SRqbn)。
- en: ^([2](ch02.html#id574-marker)) 1 second = 1000 milliseconds
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch02.html#id574-marker)) 1 秒 = 1000 毫秒
