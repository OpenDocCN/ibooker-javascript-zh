- en: Chapter 9\. React Server Components
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章 React 服务器组件
- en: In the previous chapter, we dove into the world of React frameworks, particularly
    focusing on Next.js and Remix. We explored the reasons why you might choose to
    use a framework in the first place, including the benefits of abstraction, the
    conventions that speed up development, the comprehensive solutions they offer
    for common problems, and their overall impact on enhancing productivity.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们深入研究了React框架的世界，特别是关注了Next.js和Remix。我们探讨了为什么你可能首先选择使用框架，包括抽象的好处，加速开发的规范，它们为常见问题提供的全面解决方案，以及它们对提高生产力的整体影响。
- en: We delved into the details of Remix and Next.js, demonstrating the common approaches
    each framework takes to solve similar problems by implementing our own bare-bones
    framework, and teased Next.js’ server-first direction, fully embracing React Server
    Components (RSCs).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们深入探讨了Remix和Next.js的细节，通过实现我们自己的基础框架，展示了每个框架解决类似问题的常见方法，并预告了Next.js对服务器优先方向的支持，充分拥抱React服务器组件（RSC）。
- en: Speaking of RSCs, they are an interesting trend in the React ecosystem designed
    to improve the performance, efficiency, and user experience of React applications.
    This advanced application architecture combines the best aspects of server rendered
    multipage apps (MPAs) and client-rendered SPAs, delivering a seamless user experience
    without compromising on performance or maintainability. In this chapter, we will
    discuss the core concepts, benefits, and underlying mental models and mechanisms
    around which RSCs work. For the latest information, always visit [react.dev](https://react.dev).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到RSC（React Server Components），它们是React生态系统中的一个有趣的趋势，旨在改善React应用的性能、效率和用户体验。这种先进的应用架构结合了服务器渲染的多页面应用（MPA）和客户端渲染的单页面应用（SPA）的最佳方面，提供了无缝的用户体验，而又不损害性能或可维护性。在本章中，我们将讨论RSC的核心概念、好处，以及RSC工作的基本心智模型和机制。获取最新信息，请访问[react.dev](https://react.dev)。
- en: RSCs introduce a new type of component that “runs” on the server and is otherwise
    excluded from the client-side JavaScript bundle. These components can run during
    build time, allowing you to read from the filesystem, fetch static content, or
    access your data layer. By passing data as props from server components to interactive
    client components in the browser, RSCs maintain a highly efficient and performant
    application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: RSC引入了一种在服务器上“运行”的组件类型，否则不包含在客户端JavaScript捆绑包中。这些组件可以在构建时运行，允许您从文件系统中读取、获取静态内容或访问您的数据层。通过将数据作为props从服务器组件传递到浏览器中的交互式客户端组件，RSC保持了高效和高性能的应用程序。
- en: How then do server components work? Let’s dive a little deeper into what server
    components are to understand this with a little more fidelity.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，服务器组件是如何工作的呢？让我们更深入地了解一下服务器组件是什么，以便更加精准地理解。
- en: 'As just described, a server component is a special type of component that is
    executed on the server alone. To understand this better, let’s remember that a
    React component is nothing more than a function that returns a React element:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 正如刚刚描述的，服务器组件是一种仅在服务器上执行的特殊类型组件。要更好地理解这一点，让我们记住一个React组件只不过是一个返回React元素的函数：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this snippet, `Component` is a function that returns `<div>hi!</div>`. Of
    course, `<div>hi!</div>` returns another React element since `<` in React is an
    alias for `React.createElement`. We covered this in [Chapter 2](ch02.html#ch02)
    on JSX. In case you’re drawing blanks here, now’s a good time to quickly refresh
    that information and come back. Ultimately, all components return React elements,
    which is virtual DOM.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码片段中，`Component`是一个返回`<div>hi!</div>`的函数。当然，`<div>hi!</div>`也会返回另一个React元素，因为在React中，`<`是`React.createElement`的别名。关于这点，我们在[第2章](ch02.html#ch02)讨论过。如果你对这有任何疑问，现在是快速复习一下然后回来的好时机。最终，所有组件都会返回虚拟DOM。
- en: 'Server components are no different. If `Component` is executed either on the
    server or the client, it returns vDOM. In [Chapter 3](ch03.html#ch03), we saw
    how React elements are just JavaScript objects that have the following schema:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器组件也不例外。如果`Component`在服务器端或客户端执行，它都会返回vDOM。在[第3章](ch03.html#ch03)中，我们看到React元素只是具有以下模式的JavaScript对象：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Invoking our `Component` function in both client and server environments will
    return a React element, as shown.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端和服务器环境中调用我们的`Component`函数将返回一个React元素，如下所示。
- en: With server components, they are *only* invoked (or called) on the server, and
    the resulting JavaScript object representing an element is sent over the network
    to a client. Of course, client components are the regular React components we’re
    used to.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于服务器组件而言，它们只在服务器上被调用，并且生成的表示元素的JavaScript对象被发送到客户端。当然，客户端组件就是我们通常使用的普通React组件。
- en: Benefits
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优势
- en: 'Understanding this, we start to see some of the benefits of server components:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这一点，我们开始看到服务器组件的一些好处：
- en: They execute only on the server side, on machines whose computational power
    *we* control. This leads to more predictable performance, as we don’t do computations
    on unpredictable client devices.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们只在我们控制计算能力的服务器端执行。这导致性能更可预测，因为我们不在不可预测的客户端设备上执行计算。
- en: They execute in our secure server environments, so we can do secure operations
    in server components without worrying about leaking tokens and other secure information.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们在我们安全的服务器环境中执行，因此我们可以在服务器组件中执行安全操作，而不必担心泄漏令牌和其他安全信息。
- en: Server components can be asynchronous since we can wait for them to complete
    executing on our servers before we share them with clients over the network.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器组件可以是异步的，因为我们可以等待它们在服务器上执行完毕，然后再与客户端分享。
- en: This is the true power of server components. Going forward, let’s explore how
    server components interplay with server-side rendering.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是服务器组件的真正力量。接下来，让我们探讨服务器组件如何与服务器端渲染互动。
- en: Server Rendering
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器渲染
- en: We’ve covered server rendering at length in prior chapters, so we won’t go too
    far into its details here. Instead, we’ll focus specifically on the interplay
    between server components and server rendering.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的章节中详细讨论了服务器端渲染，所以我们不会在这里深入其细节。相反，我们将专注于服务器组件与服务器渲染之间的互动。
- en: Essentially, server components and server rendering can be thought of as two
    separate independent processes where one process solely takes care of rendering
    components on the server and generating a tree of React elements, and another
    process—the server renderer—further takes this tree of React elements and converts
    it into markup that can be streamed to clients over the network.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，服务器组件和服务器渲染可以被视为两个独立的过程，其中一个过程完全负责在服务器上渲染组件并生成一棵React元素树，另一个过程——服务器渲染器——进一步接管这棵React元素树，并将其转换为可以通过网络流式传输到客户端的标记。
- en: If we consider these two processes, one to render components to React elements,
    and another to render React elements to HTML strings or streams, we start understanding
    how these two concepts fit together. Let’s call the first process the *RSCs renderer*
    that turns server components into a tree of React elements, and the second process
    the *server renderer* that turns the React elements into a stream of HTML.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑这两个过程，一个是将组件渲染为React元素，另一个是将React元素渲染为HTML字符串或流，我们开始理解这两个概念如何结合在一起。让我们称第一个过程为*RSCs渲染器*，它将服务器组件转换为一棵React元素树，第二个过程称为*服务器渲染器*，它将React元素转换为HTML流。
- en: 'With this understanding, the interplay between server components and server
    rendering can be understood as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个理解，服务器组件和服务器渲染之间的相互作用可以理解如下：
- en: On the server, a tree of JSX is turned into a tree of elements.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在服务器上，一棵JSX树被转换为一棵元素树。
- en: 'This tree of JSX:'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这棵JSX树：
- en: '[PRE2]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Becomes this tree of elements:'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 成为这棵元素树：
- en: '[PRE3]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: On the server, this tree of elements is then further serialized into a string
    or stream.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在服务器上，这棵元素树进一步被序列化为字符串或流。
- en: This is sent to a client as a big stringified JSON object.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这被发送到客户端作为一个大的字符串化的JSON对象。
- en: React on the client side can read this parsed JSON and render it as usual.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端上的React可以读取这个解析后的JSON并像往常一样进行渲染。
- en: 'If we illustrate this as code from the server side, it would look something
    like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将其表现为服务器端的代码，它看起来会像这样：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This server code snippet is taken directly from [Chapter 6](ch06.html#ch06)
    where we discussed server-side React, except we’ve added a step to process server
    components before passing them to the server-side renderer—the second process
    in our example.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务器端代码片段直接取自[第六章](ch06.html#ch06)，在将其传递给服务器端渲染器（我们示例中的第二个过程）之前，我们已添加了处理服务器组件的步骤。
- en: 'Logically, this is exactly how server components and server-side rendering
    fit together: they are complementary processes.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从逻辑上讲，这正是服务器组件和服务器端渲染如何结合在一起的方式：它们是互补的过程。
- en: Again, it’s worth noting that we’re using `renderToString` just for illustrative
    purposes and—as mentioned in [Chapter 6](ch06.html#ch06)—it’s almost always better
    to lean on a more asynchronous, interruptible API like `renderToPipeableStream`
    or similar for the vast majority of use cases.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 再次值得注意的是，我们仅仅是出于说明目的使用了`renderToString`，正如在[第6章](ch06.html#ch06)中提到的那样——在绝大多数情况下，更好的做法几乎总是依赖于一个更为异步、可中断的
    API，如`renderToPipeableStream`或类似的。
- en: Now that we understand the interplay between server rendering and server components,
    let’s dive a little bit deeper into this magical `turnServerComponentsIntoTree​OfElements`
    function we invoked in the previous code snippet. What is it doing? How does it
    turn server components into a tree of elements? Is it a React renderer? Let’s
    find out.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们理解了服务器渲染和服务器组件之间的相互作用，让我们更深入地了解一下我们在前面的代码片段中调用的这个神奇的`turnServerComponentsIntoTreeOfElements`函数。它在做什么？它如何将服务器组件转换为元素树？它是一个
    React 渲染器吗？让我们找出答案。
- en: Under the Hood
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在底层
- en: The short and potentially oversimplified answer is yes, `turnServerComponentsIntoTreeOfElements`
    is a kind of React renderer. It recursively goes into a React tree, starting from
    a high level like `<App />`, and recursively calls each component to get the React
    element (the plain JavaScript object) it returns.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 简短而可能过于简化的答案是，`turnServerComponentsIntoTreeOfElements`是一种 React 渲染器。它从一个高级别（比如`<App
    />`）递归地进入一个 React 树，每次调用每个组件以获取它返回的 React 元素（普通的 JavaScript 对象）。
- en: 'Let’s lay out a reference implementation of this and then discuss what it does:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们列出这个的参考实现，然后讨论它的功能：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'While this snippet can look a little scary, let’s be clear: it’s just a big
    `if/else` tree that returns things based on its arguments. Let’s go branch by
    branch and understand what happens, starting with its input argument `jsx`.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码看起来可能有点吓人，但让我们明确一点：它只是一个大的`if/else`树，根据其参数返回不同的结果。让我们逐个分支地了解发生了什么，从其输入参数`jsx`开始。
- en: 'For the first branch, if we consider a React element like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个分支，如果我们考虑一个像这样的 React 元素：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The child `"hi!"` is just a string. If we pass this string to our server component
    renderer, we want to return the string as is. The idea is to return types of things
    that React on the client side and on the server side can understand. React can
    understand and render strings, numbers, and booleans on the client and on the
    server side, so we’ll leave them as is.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 子元素`"hi!"`只是一个字符串。如果我们将这个字符串传递给我们的服务器组件渲染器，我们希望将字符串原样返回。这个想法是返回 React 在客户端和服务器端都能理解和渲染的类型。React
    可以在客户端和服务器端理解和渲染字符串、数字和布尔值，因此我们将它们保持不变。
- en: 'Next up, if we’ve got an array, let’s map over it and recursively process each
    element through our function. Arrays can be a bunch of children, like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果我们有一个数组，让我们对其进行映射，并递归处理每个元素。数组可以是一堆子元素，就像这样：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Fragments, for example, represent children as arrays. So similarly, let’s just
    process them by recursively calling our function on each child and move on.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，片段将子元素表示为数组。因此，让我们通过递归调用我们的函数处理每个子元素并继续前进。
- en: 'Next is where it gets really interesting: we process objects. Let’s keep in
    mind that all React elements are objects, but not all objects are React elements.
    How do we know an object is a React element? It has a `$$typeOf` property with
    a symbol value—specifically `Symbol.for(''react.element'')`. Therefore, we check
    if the object has this key/value pair, and if it does, we process it as a React
    element. We do it in this section from the snippet:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来变得非常有趣：我们处理对象。请记住，所有的 React 元素都是对象，但并非所有对象都是 React 元素。我们如何知道一个对象是 React 元素？它有一个`$$typeOf`属性，其值为一个符号——具体来说是`Symbol.for('react.element')`。因此，我们检查对象是否具有这个键/值对，如果有，我们将其处理为一个
    React 元素。我们在代码片段的这一部分做到了这一点：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Nested within the truthy branch of the `if` statement, we do another check:
    is the `jsx.type` a `"string"` or a `"function"`? We do this because React elements
    can have both as a type. Strings are used for built-in DOM elements like `"div"`,
    `"span"`, etc. Functions are used for custom components like `<Footer />`. If
    it’s a string, we know it’s a built-in DOM element, so we can just return it as
    is, but recursively call our function on its props—since its props can have children
    that are concurrent React components. If it’s a function, we know it’s a custom
    component, so we call it with its props and recursively call our function on the
    JSX it returns until it finally returns a string, number, boolean, array of those
    types, or a React element with a string type, which would fall into the other
    branch.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在`if`语句的真分支内部嵌套，我们再做一次检查：`jsx.type`是`"string"`还是`"function"`？我们这样做是因为 React
    元素可以同时具有这两种类型。字符串用于内置 DOM 元素，如`"div"`、`"span"`等。函数用于自定义组件，如`<Footer />`。如果它是一个字符串，我们知道它是一个内置
    DOM 元素，所以我们可以直接返回它，但递归地调用我们的函数处理它的 props —— 因为它的 props 可能包含作为子节点的并发 React 组件。如果它是一个函数，我们知道它是一个自定义组件，所以我们用其
    props 调用它，并递归地调用我们的函数处理它返回的 JSX，直到最终返回一个字符串、数字、布尔值、这些类型的数组或带有字符串类型的 React 元素，它会落入另一个分支中。
- en: 'Notice the `await` before we call the function component? Since this is executed
    on the server side, we can `await` the function component in case it’s a server
    component! This is the magic of server components: we can `await` them on the
    server side, and they’ll return a React element that we can then pass to `renderToString`
    or `renderToPipeableStream` to render it to a string or a stream of strings that
    we can send to the client. Indeed, this is what our function is doing: it’s just
    `await`ing all the `async` things recursively to produce a tree of elements (a
    JavaScript object) with all of its data dependencies resolved.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在调用函数组件之前我们有一个`await`吗？因为这是在服务器端执行的，我们可以在这种情况下`await`函数组件！这就是服务器组件的魔力：我们可以在服务器端`await`它们，它们会返回一个
    React 元素，然后我们可以将其传递给`renderToString`或`renderToPipeableStream`以将其渲染为一个字符串或字符串流，我们可以发送到客户端。确实，这就是我们的函数正在做的事情：它只是递归地`await`所有`async`事务以生成一个元素树（一个
    JavaScript 对象），并解决其所有数据依赖项。
- en: Finally, if the object is not a React element, we know it’s just a regular object,
    so we recursively call our function on each value in the object and return the
    result. The object is usually just props, so in the `else` branch, we’re just
    recursively calling our function on each prop value and return the result, effectively
    unwrapping any components that might be passed as props using patterns like render
    props, as discussed in [Chapter 5](ch05.html#ch05).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果对象不是一个 React 元素，我们知道它只是一个普通对象，所以我们递归地在对象的每个值上调用我们的函数并返回结果。通常对象只是 props，所以在`else`分支中，我们只是递归地在每个
    prop 值上调用我们的函数并返回结果，有效地展开可能作为 props 传递的任何组件，如渲染 props 中所讨论的[第 5 章](ch05.html#ch05)。
- en: That’s it! That’s our little minimal RSCs renderer. It’s not perfect, but it’s
    a good start. We can use it to render our server components to React elements
    that we can then send to clients.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！这就是我们的小型最小 RSCs 渲染器。它并不完美，但它是一个很好的开始。我们可以使用它来将我们的服务器组件渲染为 React 元素，然后将其发送到客户端。
- en: 'Once we have that, we just pass it to `renderToString` or `renderToPipeableStream`,
    or even serialize it and send it directly to a browser, and React on the client
    side will be able to render it because it’s literally just a tree of React elements
    that React can understand. There is, however, one more challenge to doing this
    that we need to address: serialization.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们拥有了这个，我们只需将其传递给 `renderToString` 或 `renderToPipeableStream`，甚至序列化它并直接发送到浏览器，React
    在客户端将能够渲染它，因为它实际上只是 React 元素的树，React 能够理解。然而，这里还有一个挑战需要解决：序列化。
- en: Serialization
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 序列化
- en: Things get a little tricky when we try to serialize React elements. Serializing
    React elements is a fundamental aspect of ensuring that your application is rendered
    correctly and efficiently during the initial load, because the same rendered output
    from the server needs to match the client for React to correctly reconcile and
    diff things. When your application is being rendered on the server, the React
    elements created need to be turned into HTML strings that can be sent to the browser.
    This process of turning React elements into strings is referred to as *serialization*.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试对 React 元素进行序列化时，情况变得有些棘手。序列化 React 元素是确保您的应用程序在初始加载期间正确且高效地渲染的基本方面，因为来自服务器的相同渲染输出需要与客户端匹配，以便
    React 正确地协调和差异化。当应用程序在服务器上进行渲染时，创建的 React 元素需要转换为可以发送到浏览器的 HTML 字符串。这个将 React
    元素转换为字符串的过程被称为*序列化*。
- en: 'In a typical React application, React elements are objects in memory. They’re
    created by invoking `React.createElement` or using JSX syntax. These elements
    represent the intended rendering of a component, but they are not yet actual DOM
    elements. They’re more like instructions for how the DOM should look:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的 React 应用程序中，React 元素是内存中的对象。它们是通过调用`React.createElement`或使用 JSX 语法创建的。这些元素表示组件的预期渲染，但它们还不是实际的
    DOM 元素。它们更像是 DOM 应该如何看起来的指令：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When rendering on the server using a function like `ReactDOMServer.renderToString`,
    these React elements are serialized into HTML strings. This serialization process
    traverses the React element tree, generates the corresponding HTML for each element,
    and concatenates it all into a single HTML string:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用像`ReactDOMServer.renderToString`这样的函数在服务器上渲染时，这些 React 元素将被序列化为 HTML 字符串。这个序列化过程遍历
    React 元素树，为每个元素生成相应的 HTML，并将其连接成单个 HTML 字符串：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This HTML string can then be sent to the client, where it will be used as the
    initial markup for the page. Once the JavaScript bundle is loaded on the client,
    React will “hydrate” the DOM, attaching event handlers and filling in any dynamic
    content.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将此 HTML 字符串发送到客户端，其中它将被用作页面的初始标记。一旦客户端加载了 JavaScript 包，React 将“水合”DOM，附加事件处理程序并填充任何动态内容。
- en: The serialization step is crucial for several reasons. First, it allows the
    server to send a complete, ready-to-display HTML page to the client as quickly
    as possible. This improves the perceived load time of the page, as users can start
    interacting with the content sooner.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化步骤在多个方面都是至关重要的。首先，它允许服务器尽快将完整、准备好显示的 HTML 页面发送给客户端。这提高了页面的感知加载时间，因为用户可以更快地开始与内容交互。
- en: Furthermore, serializing React elements into an HTML string allows for a consistent
    and predictable initial render, irrespective of the environment. The HTML produced
    is static and will look the same whether rendered on the server or the client.
    This consistency is essential for ensuring a smooth user experience, as it prevents
    any flickering or layout shifts that might occur if the initial render were different
    from the final render.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，将 React 元素序列化为 HTML 字符串允许进行一致和可预测的初始渲染，无论环境如何都一样。生成的 HTML 是静态的，无论是在服务器上还是客户端上渲染，看起来都是一样的。这种一致性对确保流畅的用户体验至关重要，因为它防止了任何可能导致初始渲染与最终渲染不同而产生闪烁或布局变化的情况。
- en: Lastly, serialization facilitates the process of hydration on the client side.
    When the JavaScript bundle loads on the client, React needs to attach event handlers
    and fill in any dynamic content. Having a serialized HTML string as the initial
    markup ensures that React has a solid base to work from, making the rehydration
    process more efficient and reliable.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，序列化有助于在客户端执行水合作用的过程。当 JavaScript 包在客户端加载时，React 需要附加事件处理程序并填充任何动态内容。将序列化的
    HTML 字符串作为初始标记确保 React 有一个坚实的基础来工作，使再水合作用过程更高效和可靠。
- en: Even though we need to serialize components to strings, we can’t just use `JSON.stringify`
    because React elements are not regular JavaScript objects. They’re objects with
    a special `$$typeof` property that React uses to identify them, and the value
    of these properties is a symbol. Symbols cannot be serialized and sent over the
    network, so we need to do something else.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们需要将组件序列化为字符串，但我们不能简单地使用`JSON.stringify`，因为 React 元素不是常规的 JavaScript 对象。它们是具有特殊`$$typeof`属性的对象，React
    使用该属性来识别它们，而这些属性的值是一个符号。符号不能被序列化和发送到网络，因此我们需要做些其他的事情。
- en: 'This isn’t actually that difficult thanks to built-in support from JavaScript
    runtimes, including the browser and Node.js where our server lives. This built-in
    support comes to us in the form of `JSON.stringify` and `JSON.parse`. These functions
    recursively either serialize or deserialize JSON objects, which React elements
    are. Their API is as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上这并不难，多亏了 JavaScript 运行时的内置支持，包括浏览器和我们的服务器所在的 Node.js。这种内置支持以`JSON.stringify`和`JSON.parse`的形式提供给我们。这些函数可以递归地序列化或反序列化
    JSON 对象，而 React 元素就是这些对象。它们的 API 如下：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'where `replacer` is a function that receives a key and a value, and can return
    a replacement value if certain conditions are met. In our case, we want to replace
    the value of `$$typeof` with a serializable type, like a string. Here’s how we’d
    do that:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`replacer`是一个函数，接收一个键和一个值，并在满足某些条件时返回一个替换值。在我们的情况下，我们希望将`$$typeof`的值替换为可序列化的类型，如字符串。下面是我们如何做到这一点：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'That’s it! We’re done. To deserialize this on the client side, we do the opposite:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们完成了。要在客户端上反序列化它，我们做相反的操作：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: And that’s it! We can now serialize and deserialize React elements. We can now
    render server components on the server and send them to clients. This handles
    our first load; however, we still need to handle updates and navigation. Let’s
    tackle navigation first and deal with updates later.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们现在可以序列化和反序列化 React 元素。我们现在可以在服务器上渲染服务器组件并将它们发送到客户端。这处理了我们的首次加载；然而，我们仍然需要处理更新和导航。让我们首先解决导航，稍后再处理更新。
- en: Navigation
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导航
- en: 'If we have a link in our RSCs-enabled app, something like:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的 RSCs 可用的应用中有一个链接，类似于：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'clicking on this would do a full-page navigation, which would cause the browser
    to make a request to the server, which would then render the page and send it
    back to the browser. This is how we used to do things in PHP-land so many years
    ago, and it comes with certain friction and a feeling of slowness. We can do better:
    with RSCs, we can implement soft navigation, where state is persisted between
    route transitions. We do this by sending the server the URL we want to navigate
    to, and the server sends us back the JSX tree for that page. Then, React in the
    browser rerenders the entire page with the new JSX tree, and we have a new page
    without a full-page refresh. This is exactly what we’re going to do.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 点击这个链接将会进行全页面导航，这会导致浏览器向服务器发出请求，然后渲染页面并将其发送回浏览器。这就是多年前在 PHP 领域中我们所做的事情，它带来了一定的阻力和一种慢的感觉。我们可以做得更好：使用
    RSCs，我们可以实现软导航，在路由转换之间保持状态。我们通过向服务器发送我们要导航到的 URL，服务器会返回该页面的 JSX 树给我们。然后，浏览器中的
    React 重新渲染整个页面，使用新的 JSX 树，我们就有了一个新页面，而无需进行全页面刷新。这正是我们要做的。
- en: 'To do that, we need to tweak our client-side code a little bit. We need to
    add an event listener to all links in our app that prevents the default behavior
    of the link, and instead sends a request to the server for the new page. We can
    do that like so:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要稍微调整我们的客户端代码。我们需要为应用中的所有链接添加一个事件监听器，以阻止链接的默认行为，并改为向服务器发送新页面的请求。我们可以这样做：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We’re adding the event listener to the `window` because of performance: we
    don’t want to add an event listener to every single link in our app, which could
    be a large number of event listeners that could slow things down. Instead, we
    add one event listener to the `window` and check if the target of the click is
    a link. This is called *event delegation*.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将事件监听器添加到`window`上是为了性能考虑：我们不希望为应用中的每个链接都添加一个事件监听器，因为这可能会导致大量的事件监听器降低速度。相反，我们在`window`上添加一个事件监听器，并检查点击的目标是否是一个链接。这被称为*事件委托*。
- en: If the user does click on an `A` element, we then prevent the default behavior
    of the link, and instead call a `navigate` function that we’ll define in a second.
    This function will send a request to the server for the new page, and then we’ll
    have React render it on the client.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户确实点击了`A`元素，我们将阻止链接的默认行为，而是调用稍后将定义的`navigate`函数。该函数将向服务器发送新页面的请求，然后我们将在客户端上使用
    React 渲染它。
- en: 'Let’s define the `navigate` function:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义`navigate`函数：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'What we’re doing here is pretty straightforward: we’re sending a request to
    the server for the new page, deserializing the response into a React element,
    and then rendering that element into the root of our app. This will cause React
    to rerender the page with the new JSX tree, and we’ll have a new page without
    a full-page refresh. But what is `root`? To understand that, we need to look at
    our full client-side JavaScript file:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的事情非常简单：我们向服务器发送一个新页面的请求，将响应反序列化为一个 React 元素，然后将该元素渲染到我们应用程序的根中。这将导致 React
    使用新的 JSX 树重新渲染页面，我们将获得一个新页面而无需完整页面刷新。但是 `root` 是什么？要理解这一点，我们需要查看我们完整的客户端 JavaScript
    文件：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We get a root from React when we initially hydrate the page, and we can use
    that root to render new elements into it. This is how React works under the hood,
    and we’re just using the same API that React uses internally. This is a good thing
    because it means we’re not doing anything special or hacky, we’re just using React’s
    public API.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们最初为页面进行水合作用时，我们从 React 那里得到一个根，并且我们可以使用该根来将新元素渲染到其中。这就是 React 在幕后的工作原理，我们只是使用
    React 在内部使用的相同 API。这是一件好事，因为这意味着我们没有做任何特殊或巧妙的事情，我们只是使用 React 的公共 API。
- en: 'Finally, we need to have our server respond with just the JSX tree object for
    the next page when given a `jsx-only` header instead of responding with a full
    HTML string. We can do that like so:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当收到一个 `jsx-only` 头部时，我们需要让服务器仅响应下一页的 JSX 树对象，而不是响应完整的 HTML 字符串。我们可以这样做：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice how when the header is present, we’re not sending JSON but just a string?
    This is because we need to `JSON.parse` this on the client side, and `JSON.parse`
    expects a string, not a JSON object. This is just a quirk of the API, but it’s
    not too bad.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意当头部存在时，我们不发送 JSON 而只发送一个字符串？这是因为我们需要在客户端进行 `JSON.parse`，而 `JSON.parse` 预期一个字符串，而不是一个
    JSON 对象。这只是 API 的一个怪癖，但并不太糟糕。
- en: Now, we have a way to navigate to new pages without a full-page refresh. We
    can now handle navigation in our RSCs-enabled app. All anchor link navigations
    happen smoothly and fluently without a full-page refresh. But what about updates?
    How do we handle updates? Let’s tackle that next.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了一种在没有完整页面刷新的情况下导航到新页面的方法。我们现在可以处理启用了 RSCs 的应用程序中的导航。所有锚链接导航都可以在没有完整页面刷新的情况下顺利进行。但是更新呢？我们如何处理更新？让我们接着来解决这个问题。
- en: Making Updates
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进行更新
- en: While there are a ton of positives to RSCs, there are also some limitations
    to be aware of, namely the added mental overhead of having to think about two
    different types of components (server and client). This is because not all components
    can be server components.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 RSCs 有很多优点，但也有一些需要注意的限制，即需要考虑两种不同类型的组件（服务器和客户端）所带来的额外心理负担。这是因为并非所有组件都可以是服务器组件。
- en: 'For example, consider this simple counter component that increments the counter
    value by 1 when a user clicks the + button:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑这个简单的计数器组件，当用户点击 + 按钮时，它会将计数器值增加 1：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This component can never be a server component for two reasons:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件永远不能成为服务器组件，原因有两个：
- en: It uses `useState`, which is a client-side-only API. This means that the server
    doesn’t know what the initial value of `count` is, so it can’t render the initial
    HTML. This is a problem because the server needs to render the initial HTML before
    the client can take over and render the interactive UI.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用了 `useState`，这是一个仅在客户端使用的 API。这意味着服务器不知道 `count` 的初始值是多少，因此无法渲染初始 HTML。这是一个问题，因为服务器需要在客户端接管并渲染交互式
    UI 之前渲染初始 HTML。
- en: In a serverful environment, the concept of “state” is shared among multiple
    clients. However, in React, prior to the introduction of RSCs, state was localized
    to the current application. This difference poses a risk. It could lead to the
    leakage of state between multiple clients, potentially exposing sensitive information.
    Due to this discrepancy and the associated security risks, RSCs do not support
    the use of `useState` on the server side. This is because server-side state is
    fundamentally different from client-side state.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在服务器端环境中，“状态”的概念是在多个客户端之间共享的。然而，在 React 中，在引入 RSCs 之前，状态是局限于当前应用程序的。这种差异存在风险。它可能导致状态在多个客户端之间泄漏，潜在地暴露敏感信息。由于这种差异及相关的安全风险，RSCs
    不支持在服务器端使用 `useState`。这是因为服务器端状态与客户端状态在根本上是不同的。
- en: Moreover, the dispatcher (`setState`) function from `useState` would need to
    be serialized to be sent over the network to the client, and functions are not
    serializable, so this would be impossible.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，`useState`中的调度器（`setState`）函数需要被序列化以便发送到客户端，但函数是不可序列化的，所以这是不可能的。
- en: 'It uses `onClick`, which is a client-side-only API. This is because servers
    aren’t interactive: you can’t click on a running process in a server, so `onClick`
    in server components is a bit of an impossible state. Moreover, all props for
    server components are supposed to be serializable because the server needs to
    be able to serialize the props and send them to the client, and functions are
    not serializable.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用`onClick`，这是一个仅在客户端使用的API。这是因为服务器不是交互式的：你不能在服务器上点击运行中的进程，因此在服务器组件中使用`onClick`是一种不可能的状态。此外，服务器组件的所有props都应该是可序列化的，因为服务器需要能够序列化props并将其发送到客户端，而函数是不可序列化的。
- en: 'Therefore, what used to be a simple counter now needs to be broken apart into
    a server part and a client part *if* we want to harness the power of server components,
    like so:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在一个简单的计数器现在需要分解为服务器部分和客户端部分，*如果*我们想利用服务器组件的功能，如下所示：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is a bit of a contrived example, but it illustrates the point that you
    can’t just take any React component and turn it into a server component. You need
    to think about what parts of your component are server renderable and what parts
    are client renderable. This introduces a bit of friction where even though in
    this example it’s pretty obvious what parts are server renderable and what parts
    are client renderable, in a real-world application at scale, it may not be so
    obvious.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有些牵强的例子，但它说明了一个观点，即你不能只是拿任何React组件并将其转换为服务器组件。你需要考虑你的组件哪些部分是可以在服务器端渲染的，哪些部分是可以在客户端渲染的。这带来了一些摩擦，即使在这个例子中，哪些部分是服务器端可渲染的，哪些部分是客户端可渲染的显而易见，但在实际的大规模应用中，可能并不那么明显。
- en: The outcome of this, though, is largely rewarding because what we just did was
    factor out a tiny portion of our counter application that is intended to be interactive,
    and *only* this portion of our app will actually make it to our users as part
    of a JavaScript bundle; the rest will not. As a consequence, we ship drastically
    smaller JavaScript bundles over the network, which means faster load times and
    better performance for our users both in terms of CPU, with less work needing
    to be done to parse and execute the JavaScript, and in terms of network, with
    less data needing to be downloaded.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这样做的结果在很大程度上是有益的，因为我们刚刚将计数器应用程序的一个小部分因素分离出来，该部分旨在交互，*只有*这部分应用程序将作为JavaScript包的一部分发送给用户；其余部分则不会。因此，我们通过网络传输的JavaScript包大大减少，这意味着更快的加载时间和更好的性能，无论是CPU方面，因为需要解析和执行JavaScript的工作更少，还是网络方面，因为需要下载的数据更少。
- en: This is why we want to render *as much as we can safely* on the server to leave
    the code out of client-side bundles.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们希望尽可能多地在服务器上渲染，以便将代码留出客户端捆绑包之外。
- en: Under the hood
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在底层
- en: The extra mental overhead aside, let’s talk about how React delineates and works
    with server components and client components separately under the hood. This is
    important to understand because it will help us understand how to make updates
    to our application.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 除了额外的心理负担之外，让我们谈谈React如何在底层分别处理服务器组件和客户端组件。这一点很重要，因为它将帮助我们理解如何更新我们的应用程序。
- en: Client components are designated as such by adding a `"use client"` directive
    at the top of a file containing a client component. RSCs require next-generation
    tooling to differentiate server and client components based on the use of such
    directives.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端组件通过在包含客户端组件的文件顶部添加`"use client"`指令来指定。RSC（React 服务器组件）需要下一代工具来根据这些指令的使用区分服务器端和客户端组件。
- en: 'Through the use of a next-generation bundler or bundler configuration, bundlers
    are able to produce separate module graphs for React apps: a server graph and
    a client graph. The server graph is never rolled into a bundle since it’s never
    served to users, but all files that start with the `"use client"` directive are
    rolled into either one client bundle or multiple bundles per component that can
    be lazy loaded. This implementation detail is dependent on the frameworks that
    are built on top of RSCs.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用下一代捆绑器或捆绑器配置，捆绑器能够为React应用生成单独的模块图：一个服务器图和一个客户端图。服务器图从不捆绑到捆绑包中，因为它从不提供给用户，但所有以`"use
    client"`指令开头的文件都捆绑到一个客户端捆绑包或可以懒加载的多个组件捆绑包中。此实现细节取决于构建在RSCs之上的框架。
- en: So conceptually, we’ve got a server graph that executes on the server, and one
    or more client bundles that are downloaded and executed when they’re required
    on the client. But how does React know when to import and execute client components?
    To understand this, we’ll have to consider a typical React tree. Let’s do this
    using our counter example.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 因此在概念上，我们有一个在服务器上执行的服务器图，以及在客户端需要时下载和执行的一个或多个客户端捆绑包。但是React如何知道何时导入和执行客户端组件呢？为了理解这一点，我们将不得不考虑一个典型的React树。让我们通过我们的反例来做这个。
- en: In [Figure 9-1](#figure9-1), we visualize the tree of components for our counter
    application where orange components are rendered on the server, and green ones
    on the client. Since the root of the tree is a server component, the entire tree
    is rendered on the server. However, the `InteractiveClientPart` component is a
    client component, so it’s not rendered on the server. Instead, the server renders
    a placeholder for the client component, which is a reference to the specific module
    that the client bundler produced. This module reference essentially says, “when
    you get to this point in the tree, it’s time to use this specific module.”
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图9-1](#figure9-1)中，我们可视化了我们反例计数应用程序组件树的树形结构，其中橙色组件在服务器上渲染，绿色组件在客户端上渲染。由于树的根是服务器组件，整个树在服务器上渲染。然而，`InteractiveClientPart`组件是一个客户端组件，因此不会在服务器上渲染。相反，服务器为客户端组件渲染一个占位符，这是对客户端捆绑器生成的特定模块的引用。这个模块引用实际上表示，“当你到达树中的这一点时，是时候使用这个特定的模块了。”
- en: '![RSCs and Client Components](assets/frea_0901.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![RSCs和客户端组件](assets/frea_0901.png)'
- en: Figure 9-1\. A component tree showing client and server components
  id: totrans-113
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9-1\. 显示客户端和服务器组件的组件树
- en: The module isn’t necessarily always only lazy loaded, but can be loaded from
    the initial bundle as well, since bundlers add a whole bunch of modules in the
    bundles we ship to users. It could literally be `getModuleFromBundleAtPosition([0,4])`
    or something similar. The point is that the server sends a reference to the right
    client module, and React on the client side fills in the gap.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 模块不一定总是仅懒加载，而是可以从初始捆绑包中加载，因为捆绑工具将一整堆模块添加到我们向用户提供的捆绑包中。它可能是`getModuleFromBundleAtPosition([0,4])`或类似的东西。关键是服务器发送到正确客户端模块的引用，而客户端React则填补空白。
- en: 'When this happens, React will replace the module reference with the actual
    module from the client bundle. This is a bit of a simplification, but it should
    give us a good enough understanding of the mechanism. The client component is
    then rendered on the client, and the client component can then be interacted with
    as usual. This is why RSCs require a next-generation bundler: they need to be
    able to produce separate module graphs for server and client components.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当这发生时，React将使用客户端捆绑包中的实际模块替换模块引用。这有点简化，但应该足以让我们理解机制。然后在客户端上渲染客户端组件，并且可以像往常一样与客户端组件交互。这就是为什么RSCs需要下一代捆绑器：它们需要能够为服务器和客户端组件生成单独的模块图。
- en: 'In practice, this means that in the case of our counter example, the server
    would render the following tree:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 实际操作中，这意味着在我们的反例中，服务器将呈现以下树：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This tree would be sent to the client side, and as React renders it and encounters
    the module reference, React would intelligently replace the module reference with
    the actual module from the client bundle. This is how React knows when to import
    and execute client components.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 此树将被发送到客户端，并且当React渲染它并遇到模块引用时，React将智能地用客户端捆绑包中的实际模块替换模块引用。这就是React知道何时导入和执行客户端组件的方式。
- en: Thus, we can see that the bundler is able to still render an entire tree on
    the server, and only leave “holes” to be filled in on the client while rendering
    even the children of client components recursively on the server, producing a
    full tree. The client then fills any holes necessary by downloading and executing
    client bundles.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以看到，捆绑器能够在服务器上仍然渲染整个树，在客户端只留下“空洞”，在服务器上递归渲染客户端组件的子组件，生成一个完整的树。然后，客户端通过下载和执行客户端捆绑包来填补任何必要的空洞。
- en: 'Server components can also be wrapped into Suspense boundaries, with frameworks
    doing the requisite work to stream them down to users from the server side as
    they become “ready”: that is, as any data they require is fetched and any other
    operations needed are completed asynchronously.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器组件也可以包装成悬念边界，框架将它们从服务器流式传输给用户，当它们变得“就绪”时：也就是说，它们需要的任何数据被获取并且任何其他所需操作都被异步完成。
- en: OK, hopefully now we understand how client components are split from server
    components, enabling updates in RSCs-oriented applications. Client components
    marked with `"use client"` can contain localized state and event handlers like
    `onClick` without issue.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，希望现在我们理解了客户端组件如何从服务器组件中分离，从而实现在面向RSCs的应用程序中进行更新。带有 `"use client"` 标记的客户端组件可以包含本地化状态和事件处理程序，如
    `onClick`，没有问题。
- en: Given that we’ve now closed the loop with client components and understand how
    server components are executed on the server and how client components are included
    in client bundles, we need to discuss some nuance around these topics.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于我们现在已经在客户端组件中闭环，并理解了服务器端如何执行服务器组件以及客户端组件如何包含在客户端捆绑包中，我们需要讨论一些关于这些主题的微妙之处。
- en: Nuance
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 细微差别
- en: There’s a common misconception that server components execute only on the server
    and client components execute only on the client. This isn’t true. Server components
    do indeed execute only on the server and output objects representing React elements,
    but client components do not execute exclusively on the client.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个普遍的误解，即服务器组件仅在服务器上执行，客户端组件仅在客户端上执行。这并不正确。服务器组件确实只在服务器上执行并输出表示React元素的对象，但客户端组件并不仅在客户端上执行。
- en: 'To understand this deeper, let’s discuss what “components execute” even means.
    When we say “components execute,” we mean that the function that represents the
    component is called. For example, let’s say we have a component like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要更深入理解这一点，让我们讨论一下“组件执行”究竟是什么意思。当我们说“组件执行”时，我们指的是调用表示组件的函数。例如，假设我们有一个像这样的组件：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When we say "`MyComponent` executes,” we mean that the function `MyComponent`
    is called with its props and returns a React element—which is a plain JavaScript
    object that looks like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说“`MyComponent`执行”时，我们的意思是调用 `MyComponent` 函数及其props，并返回一个React元素——这是一个看起来像这样的纯JavaScript对象：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is what we mean when we say “components execute.”
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们说“组件执行”时的意思。
- en: During server rendering, client components execute on the server and output
    objects representing React elements. These elements are then serialized into a
    string of HTML and sent to the client where the browser renders the HTML markup.
    Thus, client components also execute on the server, return some objects representing
    React elements, and then the server serializes them into HTML and sends them to
    the client.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器渲染期间，客户端组件在服务器上执行并输出表示React元素的对象。然后，这些元素被序列化为HTML字符串并发送到客户端，浏览器在那里呈现HTML标记。因此，客户端组件也在服务器上执行，并返回一些表示React元素的对象，然后服务器将它们序列化为HTML发送到客户端。
- en: 'To get a more accurate representation of this, we can make the following true
    statements:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更准确地表示这一点，我们可以作出以下真实的陈述：
- en: Server components execute on the server, output objects representing React elements.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器组件在服务器上执行，输出表示React元素的对象。
- en: Client components execute on the server, output objects representing React elements.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端组件在服务器上执行，输出表示React元素的对象。
- en: A big object representing all React elements from both client and server components
    exists on the server.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器上存在一个表示所有React元素的大对象，包括客户端和服务器组件。
- en: This is turned into a string and sent to the client.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这被转换为字符串并发送到客户端。
- en: From this point, server components are never executed on the client.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从这一点来看，服务器组件永远不会在客户端执行。
- en: Client components are executed exclusively on the client.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端组件专门在客户端上执行。
- en: With this perspective, the execution boundaries of both server and client components
    become more clear. We may be splitting hairs here, but it’s worth adding more
    detail to fully understand and appreciate the interplay between both types of
    components.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个角度来看，服务器和客户端组件的执行边界变得更加清晰。我们可能在这里钻牛角尖，但值得添加更多细节来充分理解和欣赏这两种类型组件之间的相互作用。
- en: Rules of Server Components
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器组件的规则
- en: Now that we understand how server components work under the hood, let’s discuss
    some rules that we need to follow when working with server components, or more
    broadly, things to keep in mind when working with server components.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们理解了服务器组件的内部工作原理，让我们讨论一些在使用服务器组件时需要遵循的规则，或者更广泛地说，在处理服务器组件时需要牢记的事情。
- en: Serializability Is King
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可序列化才是王道
- en: With server components, all props must be serializable. This is because the
    server needs to be able to serialize the props and send them to the client, as
    we’ve discussed earlier. Therefore, props cannot be functions or other nonserializable
    values in server components. This makes the render props pattern we discussed
    in [Chapter 5](ch05.html#ch05) effectively obsolete.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于服务器组件，所有的props必须是可序列化的。这是因为服务器需要能够序列化props并将其发送到客户端，正如我们之前讨论的那样。因此，在服务器组件中，props不能是函数或其他不可序列化的值。这使得我们之前在[第5章](ch05.html#ch05)讨论过的渲染属性模式实际上已经过时。
- en: 'At this point, based on our understanding of how RSCs are rendered on the server
    and then sent to the client on soft navigation, we should understand why this
    rule exists. Let’s say we have a server component like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们理解了RSC（服务器组件）是如何在服务器上渲染，然后在软导航时发送到客户端的基础上，我们应该理解为什么存在这个规则。假设我们有这样一个服务器组件：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This would cause an error. We could, however, work around this by encapsulating
    the `onClick` prop inside the `ClientComponent`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致错误。然而，我们可以通过将`onClick`属性封装在`ClientComponent`中来解决这个问题。
- en: No Effectful Hooks
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 没有有副作用的Hooks
- en: The server is a vastly different environment from the client. It’s not interactive,
    it doesn’t have a DOM, and it doesn’t have a window. Therefore, hooks that are
    effectful are not supported in server components.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器与客户端是完全不同的环境。它不是交互式的，没有DOM，也没有窗口。因此，在服务器组件中不支持有副作用的钩子。
- en: Some frameworks, like Next.js, have lint rules that completely ban all hooks
    in server components, but this is not entirely necessary. RSCs can use hooks that
    do not depend on state, effects, or browser-only APIs. For example, the `useRef`
    hook is perfectly fine to use in server components because it doesn’t depend on
    state, effects, or browser-only APIs. However, this may not be all bad, since
    it biases us toward more safely working with components.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一些框架，如Next.js，有严格的lint规则，完全禁止在服务器组件中使用所有的hooks，但这并非完全必要。RSCs可以使用不依赖于状态、效果或仅浏览器API的hooks。例如，`useRef`
    hook 在服务器组件中使用是完全可以的，因为它不依赖于状态、效果或仅浏览器API。然而，这未必全是坏事，因为这让我们更倾向于更安全地处理组件。
- en: State Is Not State
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态不等同于状态
- en: State in server components is not the same as state in client components. This
    is because server components are rendered on the server, and client components
    are rendered on the client. This means that state in server components may be
    shared between clients since server-client relationships are broadcast-style relationships
    instead of unicast (one client, one state), and thus the risks of leaking state
    between clients is high.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器组件中的状态与客户端组件中的状态并不相同。这是因为服务器组件在服务器上渲染，客户端组件在客户端上渲染。这意味着服务器组件中的状态可能在客户端之间共享，因为服务器-客户端关系是广播式关系，而不是单播（一个客户端，一个状态），因此在客户端之间泄漏状态的风险很高。
- en: Combined with the hooks rule, this means that any components that require state
    via `useState` or `useReducer` or similar are best suited to be client components.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 结合钩子规则，这意味着通过`useState`、`useReducer`或类似方式需要状态的任何组件最适合作为客户端组件。
- en: Client Components Cannot Import Server Components
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端组件不能导入服务器组件
- en: Client components cannot import server components. This is because server components
    are executed only on the server, but client components are executed on both, including
    on browsers.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端组件不能导入服务器组件。这是因为服务器组件仅在服务器上执行，而客户端组件在两者上都执行，包括在浏览器上。
- en: 'This means that if we have a client component like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果我们有这样一个客户端组件：
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: it would cause an error because the client component is trying to import a server
    component. This is impossible because, since server components execute only on
    the server, the server component we’re importing here may further import things
    that are not available in the client runtime environment, like Node.js APIs. This
    would cause errors on the client.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端组件试图导入服务器组件时，会导致错误。这是不可能的，因为服务器组件仅在服务器上执行，我们在这里导入的服务器组件可能会进一步导入在客户端运行时环境中不可用的内容，比如
    Node.js API。这会在客户端上引发错误。
- en: 'For all we know, the server component could look like this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 就我们所知，服务器组件可能是这样的：
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When we try to run this on the client side because a client component imported
    it, we’d get an error because the `readFile` function and the `"node:fs/promises"`
    module are not available in the browser. This is why client components cannot
    import server components.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们试图在客户端运行此代码时，因为客户端组件导入了它，我们会得到一个错误，因为在浏览器中并不存在 `readFile` 函数和 `"node:fs/promises"`
    模块。这就是为什么客户端组件不能导入服务器组件的原因。
- en: 'However, client components can *compose* server components via props. For example,
    we could rewrite our client component to look like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，客户端组件可以通过 props *组合* 服务器组件。例如，我们可以重新编写我们的客户端组件如下：
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'and then in whatever parent server component contains this client component,
    we could do this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，无论父服务器组件包含这个客户端组件的什么情况下，我们都可以这样做：
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This would work because there’s no explicit import of a server component from
    a client component, but the parent server component is passing a server component
    as a prop to the client component. The only reason the imports are forbidden is
    to prevent the possibility of including server components in the client bundle,
    and bundlers only pay attention to import statements, not prop composition.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这将有效，因为客户端组件并没有显式地从客户端组件导入服务器组件，而是父服务器组件将服务器组件作为 prop 传递给客户端组件。导入语句被禁止的唯一原因是为了防止客户端捆绑包中包含服务器组件的可能性，而捆绑工具只关注导入语句，而不是
    prop 组合。
- en: Client Components Are Not Bad
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端组件并不差
- en: It’s worth noting that up until server components were introduced, client components
    were the only type of component we had in React. This means that all of our existing
    components are client components, and that’s OK. Client components are not bad,
    and they’re not going away. They’re still the bread and butter of React applications,
    and they’re still the most common type of component we’ll be writing.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在引入服务器组件之前，React 中只有客户端组件这一类型的组件。这意味着我们所有现有的组件都是客户端组件，这没问题。客户端组件并不差，而且它们不会消失。它们仍然是
    React 应用程序的核心，也是我们将要编写的最常见的组件类型。
- en: We mention that here because there has been some confusion around this topic,
    and server components have been perceived by some as a superior replacement for
    client components. This is not true. Server components are a new type of component
    that we can use in addition to client components, but they’re not a replacement
    for client components.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里提到这一点是因为有些人对此存在一些困惑，并且有人认为服务器组件是客户端组件的一种更优秀的替代品。这是不正确的。服务器组件是我们可以额外使用的一种新类型的组件，但它们并不是客户端组件的替代品。
- en: Server Actions
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器动作
- en: Server components are a powerful new feature in React, but they’re not the only
    new feature. RSCs also work in tandem with a new directive `"use server"` that
    marks server-side functions that can be called from client-side code. We call
    these functions *server actions*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器组件是 React 中一个强大的新特性，但它们并不是唯一的新特性。RSC（服务器组件）还与一个新的指令 `"use server"` 配合工作，标记了可以从客户端代码调用的服务器端函数。我们称这些函数为
    *服务器动作*。
- en: Any async function can have `"use server"` as the first line of its body to
    signal to React and to the bundler that this function can be called from client-side
    code, but must only execute on the server. When calling a server action on the
    client, it will make a network request to the server that includes a serialized
    copy of any arguments passed. If the server action returns a value, that value
    will be serialized and returned to the client.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 任何异步函数的体的第一行都可以有 `"use server"`，以向 React 和打包工具表明此函数可以从客户端代码调用，但必须仅在服务器上执行。在客户端调用服务器动作时，将向服务器发出网络请求，其中包括传递的任何参数的序列化副本。如果服务器动作返回一个值，该值将被序列化并返回给客户端。
- en: Instead of individually marking functions with `"use server"`, you can also
    add the directive to the top of a file to mark all exports within that file as
    server actions that can be used anywhere, including imported in client code.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 与其逐个标记函数为 `"use server"`，你也可以在文件顶部添加指令，将文件中的所有导出标记为服务器操作，这些操作可以在任何地方使用，包括在客户端代码中导入。
- en: Forms and Mutations
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表单和突变
- en: 'In [Chapter 8](ch08.html#ch08), we discussed how Next.js and Remix handle forms
    and mutations. React is adding (or has added) first-class primitives for these
    as well. Consider this form:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 8 章](ch08.html#ch08) 中，我们讨论了 Next.js 和 Remix 如何处理表单和突变。React 也正在添加（或已经添加了）这些功能的一流基元。考虑这个表单：
- en: '[PRE30]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this example, `requestUsername` is a server action passed to a `<form>`.
    When a user submits this form, there is a network request to the server function
    `requestUsername`. When calling a server action in a form, React will supply the
    form’s `FormData` as the first argument to the server action.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`requestUsername` 是一个传递给 `<form>` 的服务器操作。当用户提交这个表单时，将向服务器函数 `requestUsername`
    发送网络请求。在表单中调用服务器操作时，React 将表单的 `FormData` 作为服务器操作的第一个参数提供。
- en: By passing a server action to the form action, React can progressively enhance
    the form. This means that forms can be submitted before the JavaScript bundle
    is loaded.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 将服务器操作传递给表单操作后，React 可以逐步增强表单。这意味着在 JavaScript bundle 加载之前就可以提交表单。
- en: Outside of Forms
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在表单之外
- en: It’s worth noting that server actions are exposed server endpoints and can be
    called anywhere in client code.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，服务器操作是暴露的服务器端点，可以在客户端代码的任何地方调用。
- en: 'When using a server action outside of a form, we can call the server action
    in a transition, which allows us to display a loading indicator, show optimistic
    state updates, and handle unexpected errors. Here’s an example of a server action
    outside of a form:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当在表单之外使用服务器操作时，我们可以在过渡中调用服务器操作，这使我们可以显示加载指示器，显示乐观状态更新，并处理意外错误。以下是表单之外的服务器操作示例：
- en: '[PRE31]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Thus, we can see that server actions are a powerful new feature in React that
    allow us to call server-side functions from client-side code. This really is intended
    only to be used in libraries or frameworks, as working with these directives in
    vanilla React is a bit cumbersome and requires quite a bit of work wiring things
    up. However, it’s a powerful feature that enables a lot of interesting use cases.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以看到服务器操作是 React 中的一个强大的新功能，允许我们从客户端代码中调用服务器端函数。这实际上只适用于库或框架，因为在原始的 React
    中使用这些指令有些繁琐，并且需要大量的工作来连接这些东西。然而，这是一个强大的功能，可以实现许多有趣的用例。
- en: The Future of React Server Components
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React 服务器组件的未来
- en: 'RSCs are expected to evolve and improve over time. The React team is actively
    working on refining the implementation, addressing potential issues, and expanding
    the feature set. Some areas of ongoing development include:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: RSC 预计会随时间演变和改进。React 团队正在积极完善实现，解决潜在问题，并扩展功能集。一些正在进行开发的领域包括：
- en: Better bundler integration
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的捆绑器集成
- en: The React team is partnering with bundler developers to ensure better support
    for RSCs in bundlers like Webpack, Rollup, and others. This will make it easier
    to build RSCs-compatible frameworks and applications.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: React 团队正在与捆绑器开发人员合作，确保在像 Webpack、Rollup 等捆绑器中更好地支持 RSC。这将使构建与 RSC 兼容的框架和应用程序变得更加容易。
- en: Ecosystem support
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 生态系统支持
- en: As RSCs gain traction, more tools, libraries, and frameworks will likely emerge
    to support and extend this new application architecture. This will enable developers
    to more easily adopt RSCs in their projects and benefit from their performance
    and efficiency improvements.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 RSC 的推广，可能会出现更多工具、库和框架来支持和扩展这种新的应用架构。这将使开发人员更容易在其项目中采用 RSC，并从其性能和效率改进中受益。
- en: RSCs represent a significant advancement in the React ecosystem, offering improved
    performance, simplified data fetching, and a better user experience. As RSCs continue
    to evolve and gain adoption, they’re expected to become an essential tool for
    building modern, efficient, and user-friendly React applications. With this comprehensive
    understanding of RSCs, you are now well-equipped to explore and experiment with
    this cutting-edge experimental feature in your own projects.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: RSC 代表了 React 生态系统中的重大进展，提供了改进的性能、简化的数据获取和更好的用户体验。随着 RSC 的不断演进和采用，预计它们将成为构建现代、高效和用户友好的
    React 应用程序的重要工具。通过全面了解 RSC，您现在可以充分装备，探索并在自己的项目中尝试这一前沿实验性功能。
- en: Chapter Review
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节回顾
- en: In this chapter, we exclusively focused on React Server Components (RSCs), a
    significant advancement in the React ecosystem aimed at enhancing the performance,
    efficiency, and user experience of React applications. RSCs represent an innovative
    application architecture that combines the best attributes of server-rendered
    multipage apps (MPAs) and client-rendered single-page apps (SPAs). This approach
    delivers a seamless user experience without compromising on performance or maintainability.
    We delved into the core concepts, benefits, and the underlying mental models and
    mechanisms of RSCs. A key highlight was the introduction of a new type of component
    that operates on the server, excluded from the client-side JavaScript bundle,
    and can run during build time. This advancement leads to a more efficient and
    effective application structure.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们专注于 React 服务器组件（RSCs），这是 React 生态系统中的一个重大进展，旨在提升 React 应用的性能、效率和用户体验。RSCs
    代表了一种创新的应用架构，结合了服务器渲染的多页面应用（MPAs）和客户端渲染的单页面应用（SPAs）的优点。这种方法可以在不妥协性能或可维护性的情况下提供无缝的用户体验。我们深入探讨了
    RSCs 的核心概念、优势以及其背后的思维模型和机制。一个关键亮点是引入了一种新类型的组件，它在服务器上运行，在客户端 JavaScript 包中排除，并可以在构建时运行。这一进展导致了更高效和有效的应用结构。
- en: It’s worth noting that, at the time of writing, RSCs are a hot topic in the
    React and web engineering space, and some of the details we covered may have changed.
    As always, we recommend having a look at [react.dev](https://react.dev) and React’s
    various community channels for the latest information.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在撰写本文时，RSC（React Server Components）在 React 和 Web 工程领域是一个热门话题，我们所涵盖的一些细节可能已经发生了变化。因此，我们建议查看
    [react.dev](https://react.dev) 和 React 的各种社区渠道以获取最新信息。
- en: Review Questions
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复习问题
- en: What is the main value of React server components?
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React 服务器组件的主要价值是什么？
- en: Can client components import server components? Why or why not?
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端组件能导入服务器端组件吗？为什么？
- en: What are some trade-offs between server components and traditional client-only
    React apps?
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器组件与传统的仅客户端 React 应用之间有哪些权衡？
- en: What are module references and how does React process them during reconciliation?
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是模块引用，React 在调和过程中如何处理它们？
- en: How do server actions make React apps more accessible?
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器动作如何使 React 应用更易访问？
- en: Up Next
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来
- en: In the following chapter, we are going to take a slightly different path. We’ve
    spent most of our journey so far deeply embedded in the world of React, exploring
    its intricate inner workings, innovative strategies for state management, asynchronous
    rendering capabilities, and finally, its powerful frameworks. Now, we’re going
    to take a step back and broaden our perspective.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将走一条略有不同的道路。到目前为止，我们大部分时间都深入研究了 React 的世界，探索了其复杂的内部工作机制、创新的状态管理策略、异步渲染能力，最终还有其强大的框架。现在，我们要退后一步，拓宽我们的视野。
- en: We’re going to venture beyond React, diving into the world of alternative UI
    libraries and frameworks that have grown alongside and sometimes in response to
    React’s dominance. These alternatives have not only adopted some of React’s best
    features, but have also introduced unique innovations of their own, giving us
    exciting new paradigms and possibilities in UI development.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将超越 React，深入探讨与 React 主导并行发展甚至对其有所回应的替代 UI 库和框架的世界。这些替代方案不仅吸收了一些 React 的最佳特性，还引入了自己的独特创新，为我们在
    UI 开发中带来了令人兴奋的新范式和可能性。
- en: 'In the forthcoming exploration, we will be delving into the workings and philosophies
    of some of these other UI libraries, such as Vue, Angular, Solid, Qwik, and Svelte.
    We will look at their unique strategies for managing state, handling side effects,
    and how they compare to React in terms of performance and developer experience.
    Each alternative comes with its own set of pros and cons, which might make it
    a better fit for certain types of projects or developer preferences:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的探索中，我们将深入探讨其他一些 UI 库的工作原理和理念，例如 Vue、Angular、Solid、Qwik 和 Svelte。我们将研究它们在状态管理、处理副作用方面的独特策略，以及在性能和开发者体验方面与
    React 的比较。每种替代方案都有其一系列的优缺点，这些可能使其更适合特定类型的项目或开发者偏好：
- en: Vue
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Vue
- en: Vue offers a progressive framework that is incrementally adoptable, meaning
    you can start small and gradually adopt more of Vue’s features as you need them.
    Vue is renowned for its elegant API and focus on developer experience. It introduces
    a reactivity model that’s simple yet powerful, driven by its core concept of reactive
    dependencies tracked during render.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Vue 提供了一个渐进式框架，可以逐步采用，这意味着您可以从小处开始，并根据需要逐渐采用更多的 Vue 特性。Vue 以其优雅的 API 和开发者体验而闻名。它引入了一个简单但强大的响应式模型，其核心概念是在渲染期间跟踪的响应性依赖。
- en: Angular
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Angular
- en: Angular is a complete, opinionated framework with a steeper learning curve,
    but offers robust solutions out of the box. Its dependency injection system and
    declarative templates offer a different approach to application structure and
    state management compared to React.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 是一个完整且主观的框架，学习曲线较陡，但提供了开箱即用的强大解决方案。其依赖注入系统和声明式模板为应用程序结构和状态管理提供了与 React
    不同的方法。
- en: Solid
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Solid
- en: Solid is another contender that is gaining attention in the JavaScript community.
    It promises fine-grained reactivity with a programming model similar to React,
    but with a focus on faster, more efficient rendering. How Solid tracks dependencies
    could be a breath of fresh air for developers looking for more efficiency at runtime.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Solid 是另一个在 JavaScript 社区中引起关注的竞争者。它承诺通过类似于 React 的编程模型实现精细粒度的响应性，并专注于更快、更高效的渲染。Solid
    如何跟踪依赖关系可能对寻求运行时更高效性能的开发人员来说是一种全新的体验。
- en: The Qwik framework
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Qwik 框架
- en: Qwik introduces an interesting approach by focusing on optimal loading performance
    with “predictable” prefetching. It brings a unique perspective to how we can structure
    and deliver our JavaScript for optimal user experience.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Qwik 通过“可预测”的预取重点优化加载性能，引入了一种独特的视角，展示了我们如何为了最佳用户体验结构化和传递 JavaScript。
- en: Svelte
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Svelte
- en: Svelte has been turning heads by compiling components at build time into imperative
    code that directly manipulates the DOM, leading to faster initial load times and
    smooth updates. Its reactivity model, marked by reactive statements, offers an
    intriguing contrast to the virtual DOM diffing strategy adopted by React.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Svelte 通过在构建时将组件编译为直接操作 DOM 的命令式代码而引人注目，导致更快的初始加载时间和平滑的更新。其响应性模型以反应式语句为特征，与
    React 采用的虚拟 DOM 差异化策略形成鲜明对比。
- en: While exploring these frameworks and libraries, we’ll keep our knowledge of
    React as a touchstone. This will not only help us understand the other libraries
    better but also deepen our understanding of React by offering points of comparison
    and contrast.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索这些框架和库的同时，我们将把 React 的知识作为一个基准。这不仅有助于我们更好地理解其他库，还通过比较和对比深化了我们对 React 的理解。
- en: Get ready to uncover the unique ways these alternate UI libraries approach reactivity,
    state management, side effects, and more. By studying these alternatives, we can
    glean insights that might inform our approach to problem-solving, regardless of
    the library or framework we choose to use. It’s a big, diverse world of JavaScript
    out there, and we’re about to dive in headfirst.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好揭示这些替代 UI 库在响应性、状态管理、副作用等方面的独特方法。通过研究这些替代方案，我们可以获得洞见，这些洞见可能会影响我们解决问题的方式，无论我们选择使用哪个库或框架。JavaScript
    的世界是如此广阔多样，我们即将全面投入其中。
- en: Buckle up! The journey is about to get even more exciting.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 快系好安全带！旅程即将变得更加刺激。
