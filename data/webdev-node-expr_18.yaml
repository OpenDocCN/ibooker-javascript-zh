- en: Chapter 18\. Security
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第18章 安全
- en: Most websites and applications these days have some kind of security requirement.
    If you are allowing people to log in, or if you’re storing personally identifiable
    information (PII), you’ll want to implement security for your site. In this chapter,
    we’ll be discussing *HTTP Secure* (HTTPS), which establishes a foundation on which
    you can build a secure website, and authentication mechanisms, with a focus on
    third-party authentication.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如今大多数网站和应用程序都有某种安全性要求。如果您允许用户登录，或者存储个人身份信息（PII），则需要为您的网站实施安全性。在本章中，我们将讨论*HTTP安全*（HTTPS），它为您构建安全网站奠定了基础，并介绍认证机制，重点介绍第三方认证。
- en: Security is a big topic that could fill up an entire book. For that reason,
    our focus is going to be on leveraging existing authentication modules. Writing
    your own authentication system is certainly possible, but is a large and complicated
    undertaking. Furthermore, there are good reasons to prefer a third-party login
    approach, which we will discuss later in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 安全是一个大课题，可以写成一本书。因此，我们的重点将放在利用现有的认证模块上。编写自己的认证系统当然是可能的，但是这是一个庞大而复杂的工作。此外，有很多理由倾向于使用第三方登录方法，我们将在本章后面讨论。
- en: HTTPS
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTPS
- en: The first step in providing secure services is using HTTPS. The nature of the
    internet makes it possible for a third party to intercept packets being transmitted
    between clients and servers. HTTPS encrypts those packets, making it extremely
    difficult for an attacker to get access to the information being transmitted.
    (I say “very difficult,” not “impossible,” because there’s no such thing as perfect
    security. However, HTTPS is considered sufficiently secure for banking, corporate
    security, and healthcare.)
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 提供安全服务的第一步是使用HTTPS。互联网的性质使得第三方有可能拦截客户端和服务器之间传输的数据包。HTTPS对这些数据包进行加密，使得攻击者极难获取传输的信息。（我说“非常困难”，而不是“不可能”，因为没有绝对安全的事物。然而，HTTPS被认为对于银行业务、企业安全和医疗保健是足够安全的。）
- en: You can think of HTTPS as sort of a foundation for securing your website. It
    does not provide authentication, but it lays the groundwork for authentication.
    For example, your authentication system probably involves transmitting a password;
    if that password is transmitted unencrypted, no amount of authentication sophistication
    will secure your system. Security is as strong as the weakest link, and the first
    link in that chain is the network protocol.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把HTTPS看作是保护网站安全的基础。它并不提供认证，但它为认证奠定了基础。例如，你的认证系统可能涉及传输密码；如果密码未加密传输，无论认证有多复杂，都无法保护你的系统。安全性如同链条中的最弱环节一般，而这个链条的第一环就是网络协议。
- en: The HTTPS protocol is based on the server having a *public-key certificate*,
    sometimes called an SSL certificate. The current standard format for SSL certificates
    is called *X.509*. The idea behind certificates is that there are *certificate
    authorities* (CAs) that issue certificates. A certificate authority makes *trusted
    root certificates* available to browser vendors. Browsers include these trusted
    root certificates when you install a browser, and that’s what establishes the
    chain of trust between the CA and the browser. For this chain to work, your server
    must use a certificate issued by a CA.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: HTTPS协议基于服务器拥有的*公钥证书*，有时也称为SSL证书。当前SSL证书的标准格式称为*X.509*。证书的理念是有*证书颁发机构*（CA）发布证书。证书颁发机构将*受信任的根证书*提供给浏览器供应商。在安装浏览器时，浏览器会包含这些受信任的根证书，这就建立了CA与浏览器之间的信任链。为了使这个链条有效，你的服务器必须使用由CA颁发的证书。
- en: The upshot of this is that to provide HTTPS, you need a certificate from a CA,
    so how does one go about acquiring such a thing? Broadly speaking, you can generate
    your own, get one from a free CA, or purchase one from a commercial CA.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 结论是，要提供HTTPS，您需要从CA获取证书，那么如何获取这样的证书呢？大体上讲，您可以自己生成，从免费的CA获取，或者从商业CA购买。
- en: Generating Your Own Certificate
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成您自己的证书
- en: 'Generating your own certificate is easy, but generally suitable only for development
    and testing purposes (and possibly for intranet deployment). Because of the hierarchical
    nature established by certificate authorities, browsers will trust only certificates
    generated by a known CA (and that’s probably not you). If your website uses a
    certificate from a CA that’s not known to the browser, the browser will warn you
    in very alarming language that you’re establishing a secure connection with an
    unknown (and therefore untrusted) entity. In development and testing, this is
    fine: you and your team know that you generated your own certificate, and you
    expect this behavior from browsers. If you were to deploy such a website to production
    for consumption by the public, they would turn away in droves.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 生成自己的证书很容易，但通常仅适用于开发和测试目的（可能也适用于内部部署）。由于证书颁发机构建立的层次结构，浏览器只信任由已知 CA 生成的证书（而您可能不是）。如果您的网站使用来自浏览器不认识的
    CA 的证书，浏览器将以非常警告的语言警告您正在与一个未知的（因此不受信任的）实体建立安全连接。在开发和测试中，这没问题：您和您的团队知道您生成了自己的证书，并且您希望浏览器表现出这种行为。如果您要将此类网站部署到面向公众的生产环境中，他们会大量流失。
- en: Note
  id: totrans-10
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you control the distribution and installation of browsers, you can automatically
    install your own root certificate when you install the browser. This will prevent
    people using that browser from being warned when they connect to your website.
    This is not trivial to set up, however, and applies only to environments in which
    you control the browser(s) being used. Unless you have a very solid reason to
    take this approach, it’s generally more trouble than it’s worth.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您控制浏览器的分发和安装，可以在安装浏览器时自动安装您自己的根证书。这将防止使用该浏览器的人在连接到您的网站时收到警告。然而，这并不是一件容易设置的事情，并且仅适用于您控制使用的浏览器的环境。除非您有非常充分的理由采取这种方法，否则通常比值得的麻烦多。
- en: To generate your own certificate, you’ll need an OpenSSL implementation. [Table 18-1](#implement_info)
    shows how to acquire an implementation.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成自己的证书，您需要一个 OpenSSL 实现。[表 18-1](#implement_info) 显示如何获取一个实现。
- en: Table 18-1\. Acquiring an implementation for different platforms
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 表 18-1\. 获取不同平台的实现
- en: '| Platform | Instructions |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| Platform | Instructions |'
- en: '| --- | --- |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| macOS | `brew install openssl` |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| macOS | `brew install openssl` |'
- en: '| Ubuntu, Debian | `sudo apt-get install openssl` |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| Ubuntu, Debian | `sudo apt-get install openssl` |'
- en: '| Other Linux | Download from [*http://www.openssl.org/source/;*](http://www.openssl.org/source/;)
    extract tarball and follow instructions |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| Other Linux | 从 [*http://www.openssl.org/source/;*](http://www.openssl.org/source/;)
    下载并解压 tarball，然后按照说明进行操作 |'
- en: '| Windows | Download from [*http://gnuwin32.sourceforge.net/packages/openssl.htm*](http://gnuwin32.sourceforge.net/packages/openssl.htm)
    |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| Windows | 从 [*http://gnuwin32.sourceforge.net/packages/openssl.htm*](http://gnuwin32.sourceforge.net/packages/openssl.htm)
    下载 |'
- en: Tip
  id: totrans-20
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you are a Windows user, you may need to specify the location of the OpenSSL
    configuration file, which can be tricky due to Windows pathnames. The surefire
    way is to locate the *openssl.cnf* file (usually in the *share* directory of the
    installation), and before you run the `openssl` command, set the `OPENSSL_CNF`
    environment variable: `SET OPENSSL_CONF=openssl.cnf`.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是 Windows 用户，可能需要指定 OpenSSL 配置文件的位置，由于 Windows 路径名可能比较复杂。确定可行的方法是找到 *openssl.cnf*
    文件（通常在安装的 *share* 目录中），在运行 `openssl` 命令之前设置 `OPENSSL_CONF` 环境变量：`SET OPENSSL_CONF=openssl.cnf`。
- en: 'Once you’ve installed OpenSSL, you can generate a private key and a public
    certificate:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完 OpenSSL 后，您可以生成私钥和公共证书：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You will be asked for some details, such as your country code, city, and state,
    fully qualified domain name (*FQDN*, also called *common name* or *fully qualified
    hostname*), and email address. Since this certificate is for development/testing
    purposes, the values you provide are not particularly important (in fact, they’re
    all optional, but leaving them out will result in a certificate that will be regarded
    with even more suspicion by a browser). The common name (FQDN) is what the browser
    uses to identify the domain. So if you’re using *localhost*, you can use that
    for your FQDN, or you can use the IP address of the server, or the server name,
    if available. The encryption will still work if the common name and domain you
    use in the URL don’t match, but your browser will give you an additional warning
    about the discrepancy.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在申请证书时，您将被要求提供一些详细信息，如您的国家代码、城市和州、完全合格的域名（FQDN，也称为通用名称或完全合格的主机名）和电子邮件地址。由于此证书是用于开发/测试目的，您提供的值并不特别重要（事实上，它们都是可选的，但是省略它们会导致浏览器更加怀疑您的证书）。通用名称（FQDN）是浏览器用来识别域名的。因此，如果您使用
    *localhost*，您可以将其用作您的FQDN，或者如果可用，您可以使用服务器的IP地址或服务器名称。如果在URL中使用的通用名称和域名不匹配，加密仍将起作用，但您的浏览器将额外警告您有关不匹配的信息。
- en: 'If you’re curious about the details of this command, you can read about them
    on the [OpenSSL documentation page](http://bit.ly/2q64psm). It is worth pointing
    out that the `-nodes` option doesn’t have anything to do with Node, or even the
    plural word “nodes”: it actually means “no DES,” meaning the private key is not
    DES-encrypted.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对这个命令的详细内容感兴趣，可以在[OpenSSL 文档页面](http://bit.ly/2q64psm)上了解更多。值得指出的是，`-nodes`
    选项与 Node 或者复数形式的 "nodes" 没有关系：它实际上意味着 "no DES"，即私钥未经DES加密。
- en: The result of this command is two files, *meadowlark.pem* and *meadowlark.crt*.
    The Privacy-Enhanced Electronic Mail (PEM) file is your private key, and should
    not be made available to the client. The CRT file is the self-signed certificate
    that will be sent to the browser to establish a secure connection.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令的结果是两个文件，*meadowlark.pem* 和 *meadowlark.crt*。Privacy-Enhanced Electronic
    Mail (PEM) 文件是您的私钥，不应该提供给客户端。CRT 文件是自签名证书，将被发送到浏览器以建立安全连接。
- en: Alternatively, there are websites that will provide free self-signed certificates,
    such as [this one](http://bit.ly/354ClEL).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，有些网站提供免费的自签名证书，比如[这个网站](http://bit.ly/354ClEL)。
- en: Using a Free Certificate Authority
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用免费证书颁发机构
- en: 'HTTPS is based on trust, and it’s an unfortunate reality that one of the easiest
    ways to gain trust on the internet is to buy it. And it’s not all snake oil, either:
    establishing the security infrastructure, insuring certificates, and maintaining
    relationships with browser vendors is expensive.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: HTTPS 建立在信任的基础上，遗憾的是，获得互联网上信任的最简单方式之一是购买它。而且这并非都是蛇油，建立安全基础设施、保险证书以及与浏览器供应商维持关系都是昂贵的事情。
- en: 'Buying a certificate is not your only legitimate option for production-ready
    certificates: [Let’s Encrypt](https://letsencrypt.org), a free, automated CA based
    on open source, has become a great option. As a matter of fact, unless you’re
    already invested in an infrastructure that offers free or inexpensive certificates
    as its part of your hosting (AWS, for example), Let’s Encrypt is a great option.
    The only downside to Let’s Encrypt is that the maximum lifetime for their certificates
    is 90 days. This downside is offset by the fact that Let’s Encrypt makes it very
    easy to automatically renew the certificates, and recommends setting up an automated
    process to do so every 60 days to ensure the certificates don’t expire.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 购买证书并不是生产准备好证书的唯一合法选择：[Let's Encrypt](https://letsencrypt.org)，一个基于开源的免费自动化CA，已经成为一个很好的选择。事实上，除非您已经投资于提供免费或廉价证书作为托管服务一部分的基础设施（例如AWS），否则Let's
    Encrypt是一个很好的选择。Let's Encrypt 的唯一不足是其证书的最大生存期为90天。这个缺点可以通过Let's Encrypt非常容易地自动续订证书来抵消，并建议每60天设置一个自动化流程来确保证书不会过期。
- en: All of the major certificate vendors (such as Comodo and Symantec) offer free
    trial certificates that last anywhere from 30 to 90 days. This is a valid option
    if you want to test a commercial certificate, but you will need to purchase a
    certificate before the trial period is up if you want to ensure continuity of
    service.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 所有主要的证书供应商（如Comodo和Symantec）都提供免费试用证书，有效期从30到90天不等。如果您想测试商业证书，这是一个有效的选择，但是在试用期结束之前，您需要购买证书以确保服务的连续性。
- en: Purchasing a Certificate
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 购买证书
- en: 'Currently, 90% of the approximately 50 root certificates distributed with every
    major browser are owned by four companies: Symantec (which purchased VeriSign),
    Comodo Group, Go Daddy, and GlobalSign. Purchasing directly from a CA can be quite
    expensive: it usually starts around $300 per year (though some offer certificates
    for less than $100 per year). A less expensive option is going through a reseller,
    from whom you can get an SSL certificate for as little as $10 per year or less.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，每个主要浏览器分发的大约50个根证书中，有90%归属于四家公司：Symantec（购并VeriSign）、Comodo Group、Go Daddy和GlobalSign。直接从CA（证书颁发机构）购买可能非常昂贵：通常起价约为每年$300（尽管有些提供少于每年$100的证书）。通过经销商是一个更便宜的选择，你可以以每年至少$10或更少的价格获得SSL证书。
- en: 'It’s important to understand exactly what it is you’re paying for, and why
    you would pay $10, $150, or $300 (or more) for a certificate. The first important
    point to understand is that there is no difference whatsoever in the level of
    encryption offered between a $10 certificate and a $1,500 certificate. This is
    something that expensive certificate authorities would rather you not know: their
    marketing tries hard to obscure this fact.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 确切了解你支付的内容及其原因是非常重要的，不论是支付$10、$150还是$300（或更高）的证书。理解的第一个重要点是，$10的证书和$1,500的证书在加密级别上完全没有任何区别。这是昂贵的证书颁发机构宁愿你不知道的事实：他们的营销努力掩盖这一事实。
- en: 'If you choose to go with a commercial certificate vendor, I recommend the following
    three considerations in making your choice:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果选择商业证书供应商，我建议在做出选择时考虑以下三个因素：
- en: Customer support
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 客户支持
- en: If you ever have problems with your certificate, whether it be browser support
    (customers will let you know if your certificate is flagged by their browser as
    not trustworthy), installation issues, or renewal hassles, you will appreciate
    good customer support. This is one reason you might purchase a more expensive
    certificate. Often, your hosting provider will resell certificates, and in my
    experience, they provide a higher level of customer support, because they want
    to keep you as a hosting client as well.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在使用证书时遇到问题，无论是浏览器支持（客户会告诉你他们的浏览器是否将你的证书标记为不可信任）、安装问题还是续订麻烦，你会感激良好的客户支持。这是你可能购买更昂贵证书的一个原因。通常，你的托管提供商将转售证书，根据我的经验，他们提供更高水平的客户支持，因为他们也希望保持你作为托管客户。
- en: Single-domain, multisubdomain, wildcard, and multidomain certificates
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 单域、多子域、通配符和多域证书
- en: The most inexpensive certificates are usually *single domain*. That may not
    sound so bad, but remember that it means that if you purchase a certificate for
    *meadowlarktravel.com*, then the certificate will not work for *www.meadowlarktravel.com*,
    or vice versa. For this reason, I tend to avoid single-domain certificates, though
    it can be a good option for the extremely budget conscious (you can always set
    up redirects to funnel requests to the proper domain). *Multisubdomain certificates*
    are good in that you can purchase a single certificate that covers *meadowlarktravel.com*,
    *www.meadowlark.com*, *blog.meadowlarktravel.com*, *shop.meadowlarktravel.com*,
    etc. The downside is that you have to know in advance what subdomains you want
    to use.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最便宜的证书通常是*单域*的。这听起来可能不那么糟糕，但请记住，这意味着如果你为*meadowlarktravel.com*购买了证书，那么该证书对*www.meadowlarktravel.com*或反之无效。因此，我倾向于避免单域证书，尽管对于极度节约成本的人来说可能是一个不错的选择（你始终可以设置重定向来引导请求到正确的域名）。*多子域*证书之所以好，是因为你可以购买一个覆盖*meadowlarktravel.com*、*www.meadowlark.com*、*blog.meadowlarktravel.com*、*shop.meadowlarktravel.com*等所有子域的单一证书。缺点是你必须预先知道要使用哪些子域。
- en: If you see yourself adding or using different subdomains over the course of
    a year (that need to support HTTPS), you might be better off going with a *wildcard*
    certificate, which are generally more expensive. But they will work for *any*
    subdomain, and you never have to specify what the subdomains are.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划在一年内增加或使用不同的子域（需要支持HTTPS），你可能最好选择*通配符*证书，它们通常更昂贵。但它们适用于*任何*子域，并且你不需要指定子域是什么。
- en: Lastly, there are *multidomain certificates*, which, like wildcard certificates,
    tend to be more expensive. These certificates support whole multiple domains so,
    for example, you could have *meadowlarktravel.com*, *meadowlarktravel.us*, *meadowlarktravel.com*,
    and the *www* variants.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有*多域证书*，就像通配符证书一样，往往更昂贵。这些证书支持多个完整的域，因此，例如，您可以拥有*meadowlarktravel.com*、*meadowlarktravel.us*、*meadowlarktravel.com*以及*www*变体。
- en: Domain, organization, and extended validation certificates
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 域名、组织和扩展验证证书
- en: 'There are three kinds of certificates: domain, organization, and extended validation.
    *Domain certificates*, as the name indicates, simply provide confidence that you’re
    doing business with the *domain* that you think you are. *Organization certificates*,
    on the other hand, provide some assurance about the actual organization you’re
    dealing with. They’re more difficult to get: there’s usually paperwork involved,
    and you must provide things like state and/or federal business name records, physical
    addresses, etc. Different certificate vendors will require different documentation,
    so make sure to ask your certificate vendor what’s required to get one of these
    certificates. Lastly are *extended validation certificates*, which are the Rolls
    Royce of SLL certificates. They are like organization certificates in that they
    verify the existence of the organization, but they require a higher standard of
    proof, and can even require expensive audits to establish your data security practices
    (though this seems to be increasingly rare). They can be had for as little as
    $150 for a single domain.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种类型的证书：域名、组织和扩展验证。*域名证书*如其名称所示，仅提供您确实正在与您认为的*域名*进行业务。另一方面，*组织证书*则对您正在打交道的实际组织提供了一些保证。这些证书更难获取：通常涉及文件工作，您必须提供州和/或联邦商业名称记录、物理地址等。不同的证书供应商可能需要不同的文件，因此，请确保向您的证书供应商询问获取这些证书所需的文件。最后是*扩展验证证书*，它们是SSL证书的劳斯莱斯。它们类似于组织证书，因为它们验证组织的存在，但它们要求更高的证明标准，甚至可能需要昂贵的审计来建立您的数据安全实践（尽管这种情况似乎越来越少见）。单个域名的扩展验证证书可以低至150美元。
- en: I recommend either the less expensive domain certificates or the extended validation
    certificates. Organization certificates, while they verify the existence of your
    organization, are not displayed any differently than browsers, so in my experience,
    unless the user actually examines the certificate (which is rare), there will
    be no apparent difference between this and a domain certificate. Extended validation
    certificates, on the other hand, usually display some clues to users that they
    are dealing with a legitimate business (such as the URL bar being displayed in
    green, and the organization name being displayed next to the SSL icon).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议使用更便宜的域名证书或扩展验证证书。组织证书虽然验证了您的组织的存在，但与浏览器显示无异，因此根据我的经验，除非用户确实检查证书（这种情况很少），否则这与域名证书之间没有明显区别。另一方面，扩展验证证书通常会向用户显示一些线索，表明他们正在与合法的企业打交道（例如，URL栏显示为绿色，并且组织名称显示在SSL图标旁边）。
- en: If you’ve dealt with SSL certificates before, you might be wondering why I didn’t
    mention certificate insurance. I’ve omitted that price differentiator because
    essentially it’s insurance against something that’s almost impossible. The idea
    is that if someone suffers financial loss due to a transaction on your website,
    and they can *prove it was due to inadequate encryption*, the insurance is there
    to cover your damages. While it is certainly possible that, if your application
    involves financial transactions, someone may attempt to take legal action against
    you for financial loss, the likelihood of it being due to inadequate encryption
    is essentially zero. If I were to attempt to seek damages from a company due to
    financial loss linked to their online services, the absolute last approach I would
    take is to attempt to prove that the SSL encryption was broken. If you’re faced
    with two certificates that differ only in price and insurance coverage, buy the
    cheaper certificate.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前处理过SSL证书，你可能会想为什么我没有提到证书保险。我省略了这一价格差异化因素，因为本质上这是针对几乎不可能发生的情况的保险。其理念是，如果有人因为你网站上的交易而遭受了财务损失，并且他们能够*证明这是由于不足的加密措施*，那么保险将赔偿你的损失。尽管有可能，如果你的应用涉及财务交易，某人可能会因财务损失而对你提起法律诉讼，但由于加密不足导致的情况几乎为零。如果我试图因为与公司的在线服务相关的财务损失而寻求赔偿，我最后绝不会采取的方法就是试图证明SSL加密已被破解。如果你面对两张唯一区别在价格和保险覆盖范围的证书，那么选择便宜的证书吧。
- en: The process of purchasing a certificate starts with the creation of a private
    key (as we did previously for the self-signed certificate). You will then generate
    a *certificate signing request* (CSR) that will be uploaded during the certificate
    purchase process (the certificate issuer will provide instructions for doing this).
    Note that the certificate issuer never has access to your private key, nor is
    your private key transmitted over the internet, which protects the security of
    the private key. The issuer will then send you the certificate, which will have
    an extension of *.crt*, *.cer*, or *.der* (the certificate will be in a format
    called Distinguished Encoding Rules or DER, hence the less common *.der* extension).
    You will also receive any certificates in the certificate chain. It is safe to
    email this certificate because it won’t work without the private key you generated.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 购买证书的过程从创建私钥开始（就像我们之前为自签名证书所做的那样）。然后，你将生成一个*证书签名请求*（CSR），在证书购买过程中上传该请求（证书颁发机构将提供操作说明）。请注意，证书颁发机构永远不会访问你的私钥，也不会通过互联网传输你的私钥，这保护了私钥的安全性。颁发机构将随后发送证书给你，其扩展名为*.crt*、*.cer*或*.der*（证书将采用称为Distinguished
    Encoding Rules或DER的格式，因此也有较少见的*.der*扩展名）。你还将收到证书链中的任何证书。可以安全地通过电子邮件发送这些证书，因为没有你生成的私钥，这些证书无法正常工作。
- en: Enabling HTTPS for Your Express App
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为你的Express应用启用HTTPS
- en: You can modify your Express app to serve your website over HTTPS. In practice
    and in production, this is extremely uncommon, which we’ll learn about in the
    next section. However, for advanced applications, testing, and your own understanding
    of HTTPS, it’s useful to know how to serve HTTPS.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以修改你的Express应用程序以通过HTTPS提供网站服务。在实践和生产中，这是极不常见的，我们将在下一节中了解更多。然而，对于高级应用程序、测试以及对HTTPS的理解，了解如何提供HTTPS服务是非常有用的。
- en: 'Once you have your private key and certificate, using them in your app is easy.
    Let’s revisit how we’ve been creating our server:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了私钥和证书，在你的应用中使用它们就很容易。让我们重新审视一下我们一直在创建服务器的方式：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Switching over to HTTPS is simple. I recommend that you put your private key
    and SSL cert in a subdirectory called *ssl* (though it’s quite common to keep
    it in your project root). Then you just use the `https` module instead of `http`,
    and pass an `options` object along to the `createServer` method:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到HTTPS很简单。我建议你将私钥和SSL证书放在名为*ssl*的子目录中（尽管将其放在项目根目录中也很常见）。然后，你只需使用`https`模块而不是`http`，并向`createServer`方法传递一个`options`对象：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That’s all there is to it. Assuming you’re still running your server on port
    3000, you can now connect to *[*https://localhost:3000*](https://localhost:3000)*.
    If you try to connect to *[*http://localhost:3000*](http://localhost:3000)*, it
    will simply time out.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这么简单。假设你仍在使用端口3000运行服务器，现在你可以连接到[*https://localhost:3000*](https://localhost:3000)。如果你尝试连接到[*http://localhost:3000*](http://localhost:3000)，连接将简单超时。
- en: A Note on Ports
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 端口注意事项
- en: Whether you know it or not, when you visit a website, you’re *always* connecting
    to a specific port, even though it’s not specified in the URL. If you don’t specify
    a port, port 80 is assumed for HTTP. As a matter of fact, most browsers will simply
    not display the port number if you explicitly specify port 80\. For example, navigate
    to *[*http://www.apple.com:80*](http://www.apple.com:80)*; chances are, when the
    page loads, the browser will simply strip off the *:80*. It’s still connecting
    on port 80; it’s just implicit.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 不管你知不知道，当你访问一个网站时，你总是连接到一个特定的端口，即使它在 URL 中没有指定。如果你没有指定端口，HTTP 默认使用端口 80。事实上，大多数浏览器在显式指定端口
    80 时将简单地去掉端口号。例如，访问 [*http://www.apple.com:80*](http://www.apple.com:80)；页面加载时，浏览器将会直接省略
    *:80*。它仍然是在端口 80 连接；只是隐含的。
- en: 'Similarly, there’s a standard port for HTTPS, 443\. Browser behavior is similar:
    if you connect to *[*https://www.google.com:443*](https://www.google.com:443)*,
    most browsers will simply not display the *:443*, but that’s the port they’re
    connecting over.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，HTTPS 有一个标准端口 443。浏览器的行为类似：如果你连接到 [*https://www.google.com:443*](https://www.google.com:443)，大多数浏览器将简单地不显示
    *:443*，但实际上它们是连接到这个端口的。
- en: If you’re not using port 80 for HTTP or port 443 for HTTPS, you’ll have to explicitly
    specify the port *and* the protocol to connect correctly. There’s no way to run
    HTTP and HTTPS on the same port (technically, it’s possible, but there’s no good
    reason to do it, and the implementation would be very complicated).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不使用端口 80 进行 HTTP 或端口 443 进行 HTTPS，你将不得不显式指定端口和协议才能正确连接。没有办法在同一个端口上同时运行 HTTP
    和 HTTPS（从技术上讲是可能的，但没有充分理由这样做，而且实现起来非常复杂）。
- en: If you want to run your HTTP app on port 80, or your HTTPS app on port 443 so
    you don’t have to specify the port explicitly, you have two things to consider.
    First is that many systems already have a default web server running on port 80.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在端口 80 运行你的 HTTP 应用，或者在端口 443 运行 HTTPS 应用以免显式指定端口，你需要考虑两件事情。首先是很多系统已经在端口
    80 上运行了默认的 Web 服务器。
- en: The other thing to know is that on most operating systems, ports 1–1023 require
    elevated privileges to open. For example, on a Linux or macOS machine, if you
    attempt to start your app on port 80, it will probably fail with an `EACCES` error.
    To run on port 80 or 443 (or any port under 1024), you’ll need to elevate your
    privileges by using the `sudo` command. If you don’t have administrator rights,
    you will be unable to start the server directly on port 80 or 443.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事需要知道的是，在大多数操作系统上，端口 1–1023 需要特权才能打开。例如，在 Linux 或 macOS 机器上，如果尝试在端口 80 上启动你的应用程序，可能会因为
    `EACCES` 错误而失败。要在端口 80 或 443（或任何低于 1024 的端口）上运行，你需要通过使用 `sudo` 命令提升权限。如果你没有管理员权限，将无法直接在端口
    80 或 443 上启动服务器。
- en: 'Unless you’re managing your own servers, you probably don’t have root access
    to your hosted account: so what happens when you want to run on port 80 or 443?
    Generally, hosting providers have some kind of proxy service that runs with elevated
    privileges that will pass requests through to your app, which is running on a
    nonprivileged port. We’ll learn more about this in the next section.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你管理自己的服务器，否则你可能没有你托管账户的 root 访问权限：那么当你想在端口 80 或 443 上运行时会发生什么呢？一般来说，托管提供商会有某种特权代理服务，将请求传递到运行在非特权端口上的应用程序。我们将在下一节中详细了解更多信息。
- en: HTTPS and Proxies
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTPS 和代理
- en: As we’ve seen, it’s very easy to use HTTPS with Express, and for development,
    it will work fine. However, when you want to scale your site out to handle more
    traffic, you will want to use a proxy server such as NGINX (see [Chapter 12](ch12.xhtml#ch_production_concerns)).
    If your site is running in a shared hosting environment, it is almost certain
    that there will be a proxy server that will route requests to your application.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，使用 Express 来进行 HTTPS 非常简单，并且在开发阶段可以正常工作。然而，当你想要扩展你的网站以处理更多的流量时，你会希望使用像
    NGINX 这样的代理服务器（参见[第 12 章](ch12.xhtml#ch_production_concerns)）。如果你的网站运行在共享主机环境中，几乎可以肯定会有一个代理服务器来路由请求到你的应用程序。
- en: If you’re using a proxy server, then the client (the user’s browser) will communicate
    with the *proxy server*, not your server. The proxy server, in turn, will most
    likely communicate with your app over regular HTTP (since your app and the proxy
    server will be running together on a trusted network). You will often hear people
    say that the HTTPS *terminates* at the proxy server, or that the proxy is performing
    “SSL termination.”
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用代理服务器，那么客户端（用户的浏览器）将与*代理服务器*通信，而不是与您的服务器通信。代理服务器反过来很可能会通过常规的HTTP与您的应用程序通信（因为您的应用程序和代理服务器将在受信任的网络上一起运行）。人们经常会说HTTPS在代理服务器处*终止*，或者代理服务器正在执行“SSL终结”。
- en: For the most part, once you or your hosting provider has correctly configured
    the proxy server to handle HTTPS requests, you won’t need to do any additional
    work. The exception to that rule is if your application needs to handle both secure
    and insecure requests.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分情况下，一旦您或您的托管提供商正确配置了代理服务器以处理HTTPS请求，您就不需要进行任何额外的工作了。唯一的例外是，如果您的应用程序需要处理安全和非安全请求。
- en: There are three solutions to this problem. The first is simply to configure
    your proxy to redirect all HTTP traffic to HTTPS, in essence forcing all communication
    with your application to be over HTTPS. This approach is becoming much more common,
    and it’s certainly an easy solution to the problem.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题有三种解决方案。第一种方法是简单地配置代理将所有HTTP流量重定向到HTTPS，从本质上迫使所有与您的应用程序的通信都是通过HTTPS进行的。这种方法变得越来越普遍，显然是解决问题的简便方法。
- en: 'The second approach is to somehow communicate the protocol used in the client-proxy
    communication to the server. The usual way to communicate this is through the
    `X-Forwarded-Proto` header. For example, to set this header in NGINX:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是以某种方式将客户端代理通信中使用的协议传达给服务器。通常的通信方式是通过`X-Forwarded-Proto`头部。例如，在NGINX中设置此头部：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, in your app, you could test to see if the protocol was HTTPS:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在您的应用程序中，您可以测试协议是否为HTTPS：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Caution
  id: totrans-70
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In NGINX, there is a separate `server` configuration block for HTTP and HTTPS.
    If you fail to set the `X-Forwarded-Protocol` in the configuration block corresponding
    to HTTP, you open yourself up to the possibility of a client spoofing the header
    and thereby fooling your application into thinking that the connection is secure
    even though it isn’t. If you take this approach, make sure you *always* set the
    `X-Forwarded-Protocol` header.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在NGINX中，HTTP和HTTPS有各自独立的`server`配置块。如果在对应于HTTP的配置块中未设置`X-Forwarded-Protocol`，您就有可能使客户端伪造该头部，并误导您的应用程序认为连接是安全的，尽管实际上并非如此。如果您采用这种方法，请确保*始终*设置`X-Forwarded-Protocol`头部。
- en: When you’re using a proxy, Express provides some convenience properties that
    make the proxy more “transparent” (as if you weren’t using one, without sacrificing
    the benefits). To take advantage of that, tell Express to trust the proxy by using
    `app.enable('trust proxy')`. Once you do, `req.protocol`, `req.secure`, and `req.ip`
    will refer to the client’s connection to the proxy, not to your app.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用代理时，Express提供了一些便利属性，使代理更加“透明”（就像您没有使用代理一样，同时又不损失其好处）。要利用这一点，告诉Express信任代理，使用`app.enable('trust
    proxy')`。一旦这样做，`req.protocol`、`req.secure`和`req.ip`将指代客户端与代理的连接，而不是您的应用程序。
- en: Cross-Site Request Forgery
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨站点请求伪造
- en: '*Cross-site request forgery* (CSRF) attacks exploit the fact that users generally
    trust their browser and visit multiple sites in the same session. In a CSRF attack,
    script on a malicious site makes requests of another site: if you are logged in
    on the other site, the malicious site can successfully access secure data from
    another site.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*跨站请求伪造*（CSRF）攻击利用用户通常信任其浏览器并在同一会话中访问多个站点的事实。在CSRF攻击中，恶意站点上的脚本向另一个站点发出请求：如果您在另一个站点上已登录，则恶意站点可以成功访问另一个站点的安全数据。'
- en: 'To prevent CSRF attacks, you must have a way to make sure a request legitimately
    came from your website. The way we do this is to pass a unique token to the browser.
    When the browser then submits a form, the server checks to make sure the token
    matches. The `csurf` middleware will handle the token creation and verification
    for you; all you’ll have to do is make sure the token is included in requests
    to the server. Install the `csurf` middleware (`npm install csurf`); then link
    it in and add a token to `res.locals`. Make sure you link in the `csurf` middleware
    after you link in `body-parser`, `cookie-parser`, and `express-session`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要防止CSRF攻击，您必须有一种方法确保请求确实来自您的网站。我们做的方式是向浏览器传递一个唯一的令牌。然后当浏览器提交表单时，服务器会检查令牌是否匹配。`csurf`中间件会为您处理令牌的创建和验证；您只需确保令牌包含在对服务器的请求中即可。安装`csurf`中间件（`npm
    install csurf`）；然后在链接`body-parser`、`cookie-parser`和`express-session`之后链接它，并在`res.locals`中添加一个令牌。确保在链接`csurf`中间件之前链接`body-parser`、`cookie-parser`和`express-session`：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `csurf` middleware adds the `csrfToken` method to the request object. We
    don’t have to assign it to `res.locals`; we could just pass `req.csrfToken()`
    explicitly to every view that needs it, but this is generally less work.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`csurf`中间件将`csrfToken`方法添加到请求对象中。我们不必将其分配给`res.locals`；我们可以只需将`req.csrfToken()`明确地传递给每个需要它的视图，但这通常会更麻烦一些。'
- en: Note
  id: totrans-78
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the package itself is called `csurf`, but most of the variables and
    methods are `csrf`, without the “u.” It’s easy to get tripped up here, so mind
    your vowels!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，包本身被称为`csurf`，但大多数变量和方法是`csrf`，没有“u”。在这里很容易被绊倒，所以要注意你的元音！
- en: 'Now on all of your forms (and AJAX calls), you’ll have to provide a field called
    `_csrf`, which must match the generated token. Let’s see how we would add this
    to one of our forms:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在所有的表单（和AJAX调用）中，您必须提供一个名为`_csrf`的字段，它必须与生成的令牌匹配。让我们看看如何将其添加到我们的一个表单中：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `csurf` middleware will handle the rest: if the body contains fields, but
    no valid `_csrf` field, it will raise an error (make sure you have an error route
    in your middleware!). Go ahead and remove the hidden field and see what happens.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`csurf`中间件将处理剩余的工作：如果请求体包含字段但没有有效的`_csrf`字段，它将引发错误（确保您的中间件中有一个错误路由！）。试着移除隐藏字段，看看会发生什么。'
- en: Tip
  id: totrans-83
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If you have an API, you probably don’t want the `csurf` middleware interfering
    with it. If you want to restrict access to your API from other websites, you should
    look into the “API key” functionality of an API library like `connect-rest`. To
    prevent `csurf` from interfering with your middleware, link it in before you link
    in `csurf`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个API，您可能不希望`csurf`中间件干扰它。如果您希望限制来自其他网站的对您的API的访问，请查看API库（如`connect-rest`）的“API密钥”功能。为了防止`csurf`干扰您的中间件，将其链接在`csurf`之前。
- en: Authentication
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证
- en: Authentication is a big, complicated topic. Unfortunately, it’s also a vital
    part of most nontrivial web applications. The most important piece of wisdom I
    can impart to you is *don’t try to do it yourself*. If you look at your business
    card and it doesn’t say “Security Expert,” you probably aren’t prepared for the
    complex considerations involved in designing a secure authentication system.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 认证是一个复杂的大课题。不幸的是，它也是大多数非平凡网络应用的重要组成部分。我能给你的最重要的建议是*不要试图自己做*。如果你看看你的名片上没有写“安全专家”，那么你可能没有准备好设计安全认证系统所涉及的复杂考虑。
- en: I’m not saying that you shouldn’t try to understand the security systems in
    your application. I’m just recommending that you don’t try to build it yourself.
    Feel free to study the open source code of the authentication techniques I’m going
    to recommend. It will certainly give you some insight as to why you might not
    want to take on this task unaided!
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不是说你不应该试图理解你的应用程序中的安全系统。我只是建议你不要自己动手构建它。可以自由地研究我即将推荐的认证技术的开源代码。这肯定会让你明白为什么你可能不想单枪匹马地承担这个任务！
- en: Authentication Versus Authorization
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认证与授权
- en: While the two terms are often used interchangeably, there is a difference. *Authentication*
    refers to verifying users’ identities. That is, they are who they say they are.
    *Authorization* refers to determining what a user is authorized to access, modify,
    or view. For example, customers might be authorized to access their account information,
    whereas a Meadowlark Travel employee would be authorized to access another person’s
    account information or sales notes.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这两个术语经常被交替使用，但它们有所不同。*认证*指的是验证用户的身份，即确认他们是他们所说的那个人。*授权*则指确定用户被授权访问、修改或查看什么内容。例如，顾客可能被授权访问他们的账户信息，而Meadowlark
    Travel的员工则被授权访问其他人的账户信息或销售记录。
- en: Note
  id: totrans-90
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Authentication is often abbreviated as *authN* and “authorization” as *authZ*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 认证通常缩写为*authN*，而“授权”缩写为*authZ*。
- en: Usually (but not always), authentication comes first, and then authorization
    is determined. Authorization can be very simple (authorized/not authorized), broad
    (user/administrator), or very fine-grained, specifying read, write, delete, and
    update privileges against different account types. The complexity of your authorization
    system is dependent on the type of application you’re writing.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下（但并非总是如此），认证先进行，然后确定授权。授权可以非常简单（授权/未授权），也可以很广泛（用户/管理员），或者非常细化，指定对不同账户类型的读取、写入、删除和更新权限。你的授权系统的复杂程度取决于你正在编写的应用程序的类型。
- en: Because authorization is so dependent on the details of your application, I’ll
    be giving only a rough outline in this book, using a very broad authentication
    scheme (customer/employee). I will often use the abbreviation “auth,” but only
    when it is clear from the context whether it means “authentication” or “authorization,”
    or when it doesn’t matter.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于授权非常依赖于你的应用程序的细节，所以在本书中我只会提供一个粗略的概述，使用一个非常广泛的认证方案（客户/员工）。我经常会使用“auth”的缩写，但只有在上下文中明确表明它是指“认证”还是“授权”，或者这并不重要时才会这样做。
- en: The Problem with Passwords
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密码的问题
- en: The problem with passwords is that every security system is only as strong as
    its weakest link. And passwords require the user to invent a password—and there’s
    your weakest link. Humans are notoriously bad at coming up with secure passwords.
    In an analysis of security breaches in 2018, the most popular password is “123456.”
    “password” is second. Even in the security conscious year of 2018, people are
    still choosing abysmally bad passwords. Having password policies requiring, for
    example, a capital letter, a number, and a punctuation mark is just going to result
    in a password of “Password1!”.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 密码的问题在于，每个安全系统的强度取决于它最薄弱的环节。而密码要求用户创造一个密码，这就是最薄弱的环节。人类在创建安全密码方面众所周知地很差。在对2018年的安全漏洞进行分析时，最流行的密码是“123456”。“password”排名第二。即使在2018年这样注重安全性的年代，人们仍然选择极其糟糕的密码。例如，密码策略要求包括大写字母、数字和标点符号，结果往往是一个“Password1!”这样的密码。
- en: Even analyzing passwords against a list of common passwords doesn’t do much
    to stop the problem. Then people start writing down their higher-quality passwords
    on notepads, leaving them in unencrypted files on their computers, or emailing
    them to themselves.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 即使分析密码是否与常见密码列表匹配，也无法有效解决问题。随后，人们开始将他们更高质量的密码写在记事本上，存放在未加密的文件中或通过电子邮件发送给自己。
- en: At the end of the day, it’s a problem that you, the app designer, cannot do
    much to fix. However, there are things you can do that promote more secure passwords.
    One is to pass the buck and rely on a third party for authentication. The other
    is to make your login system friendly to password management services, like 1Password,
    Bitwarden, and LastPass.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 归根结底，这是一个你作为应用设计者无法解决的问题。然而，你可以采取一些措施来促进更安全的密码管理。一种方法是将认证责任交给第三方。另一种方法是使你的登录系统适合密码管理服务，比如1Password、Bitwarden和LastPass。
- en: Third-Party Authentication
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三方认证
- en: Third-party authentication takes advantage of the fact that pretty much everyone
    on the internet has an account on at least one major service, such as Google,
    Facebook, Twitter, or LinkedIn. All of these services provide a mechanism to authenticate
    and identify your users through their service.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方认证利用了几乎所有互联网用户至少在一个主要服务上拥有账户的事实，比如谷歌、Facebook、Twitter或LinkedIn。所有这些服务都提供一种机制，通过其服务对用户进行认证和识别。
- en: Note
  id: totrans-100
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Third-party authentication is often referred to as *federated* *authentication*
    or *delegated authentication*. The terms are largely interchangeable, though federated
    authentication is usually associated with Security Assertion Markup Language (SAML)
    and OpenID, and delegated authentication is often associated with OAuth.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方认证通常被称为*联合认证*或*委托认证*。这些术语基本上可以互换使用，尽管联合认证通常与安全声明标记语言（SAML）和OpenID相关联，而委托认证则常与OAuth相关联。
- en: 'Third-party authentication has three major advantages. First, your authentication
    burden is lowered. You do not have to worry about authenticating individual users,
    only interacting with a trusted third party. The second advantage is that it reduces
    *password fatigue*: the stress associated with having too many accounts. I use
    [LastPass](http://lastpass.com), and I just checked my password vault: I have
    almost 400 passwords. As a technology professional, I may have more than your
    average internet user, but it’s not uncommon for even a casual internet user to
    have dozens or even hundreds of accounts. Lastly, third-party authentication is
    *frictionless*: it allows your users to start using your site more quickly, with
    credentials they already have. Often, if users see that they have to create yet
    *another* username and password, they will simply move on.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方认证有三大优势。首先，您的认证负担减轻了。您无需担心单独认证每个用户，只需与信任的第三方交互即可。第二个优势是减少*密码疲劳*：与拥有过多账户相关的压力。我使用[LastPass](http://lastpass.com)，刚刚查看了我的密码保险库：我几乎有400个密码。作为技术专业人员，我可能比普通互联网用户拥有更多账户，但即使是偶尔上网的用户，拥有几十甚至上百个账户也并不罕见。最后，第三方认证是*无摩擦*的：它允许用户使用已有的凭证更快地开始使用您的网站。通常，如果用户发现他们需要再创建*另一个*用户名和密码，他们可能会选择放弃。
- en: If you don’t use a password manager, the chances are, you’re using the same
    password for most of those sites (most people have a “secure” password they use
    for banking and the like, and an “insecure” password they use for everything else).
    The problem with this approach is that if even *one* of the sites you use that
    password for is breached, and your password becomes known, then hackers will try
    using that same password with other services. It’s like putting all of your eggs
    in one basket.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不使用密码管理器，那么您很可能会为大多数网站使用相同的密码（大多数人都有一个用于银行等的“安全”密码，以及一个用于其他所有事务的“不安全”密码）。这种方法的问题在于，如果您使用的任何一个网站遭到入侵，并且您的密码泄露了，黑客将尝试在其他服务中使用相同的密码。这就像把所有的鸡蛋放在一个篮子里一样。
- en: Third-party authentication has its downsides. Hard as it is to believe, there
    *are* folks out there who don’t have an account on Google, Facebook, Twitter,
    or LinkedIn. Then, among the people who *do* have such accounts, suspicion (or
    a desire for privacy) may make them unwilling to use those credentials to log
    onto your website. Many websites solve this particular problem by encouraging
    users to use an existing account, but those who don’t have them (or are unwilling
    to use them to access your service) can create a new login for your service.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方认证也有其不足之处。难以置信的是，*确实*有些人并没有Google、Facebook、Twitter或LinkedIn的账户。此外，即使是拥有这些账户的人，他们出于怀疑（或希望保护隐私）可能不愿意使用这些凭证登录到您的网站上。许多网站通过鼓励用户使用现有账户来解决这个特定问题，但那些没有这些账户的人（或不愿意使用它们访问您的服务的人）可以为您的服务创建一个新的登录账户。
- en: Storing Users in Your Database
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在您的数据库中存储用户
- en: 'Whether or not you rely on a third party to authenticate your users, you will
    want to store a record of users in your own database. For example, if you’re using
    Facebook for authentication, that only verifies a user’s identity. If you need
    to save settings specific to that user, you can’t reasonably use Facebook for
    that: you have to store information about that user in your own database. Also,
    you probably want to associate an email address with your users, and they may
    not wish to use the same email address they use for Facebook (or whatever third-party
    authentication service you use). Lastly, storing user information in your database
    allows you to perform authentication yourself, should you wish to provide that
    option.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是否依赖第三方来认证您的用户，您都希望在自己的数据库中存储用户记录。例如，如果您使用Facebook进行认证，那么这仅验证了用户的身份。如果您需要保存特定于该用户的设置，您不能合理地使用Facebook来实现：您必须在自己的数据库中存储有关该用户的信息。此外，您可能希望将电子邮件地址与您的用户关联起来，而他们可能不希望使用与Facebook（或任何其他第三方认证服务）相同的电子邮件地址。最后，将用户信息存储在您的数据库中允许您自己执行认证，如果您希望提供该选项的话。
- en: 'So let’s create a model for our users, *models/user.js*:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的用户创建一个模型，*models/user.js*：
- en: '[PRE7]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And modify *db.js* with the appropriate abstractions (if you’re using PostgreSQL,
    I’ll leave it as an exercise to hook up this abstraction):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 并且使用适当的抽象修改*db.js*（如果您使用的是PostgreSQL，我会留下这个抽象的实现作为练习）：
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Recall that every object in a MongoDB database has its own unique ID, stored
    in its `_id` property. However, that ID is controlled by MongoDB, and we need
    some way to map a user record to a third-party ID, so we have our own ID property,
    called `authId`. Since we’ll be using multiple authentication strategies, that
    ID will be a combination of a strategy type and a third-party ID, to prevent collisions.
    For example, a Facebook user might have an `authId` of `facebook:525764102`, whereas
    a Twitter user would have an `authId` of `twitter:376841763`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，MongoDB数据库中的每个对象都有自己独特的ID，存储在其`_id`属性中。然而，那个ID是由MongoDB控制的，我们需要一些方法将用户记录映射到第三方ID，所以我们有自己的ID属性，称为`authId`。由于我们将使用多种认证策略，该ID将是策略类型和第三方ID的组合，以防止冲突。例如，Facebook用户的`authId`可能是`facebook:525764102`，而Twitter用户的则可能是`twitter:376841763`。
- en: 'We will be using two roles in our example: “customer” and “employee.”'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将使用两种角色：“客户”和“员工”。
- en: Authentication Versus Registration and the User Experience
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认证与注册及用户体验
- en: Authentication refers to verifying a user’s identity, either with a trusted
    third party, or through credentials you’ve provided the user (such as a username
    and password). Registration is the process by which a user gets an account on
    your site (from our perspective, registration is when we create a user record
    in the database).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 认证是指验证用户身份的过程，可以通过一个可信任的第三方，或者通过您提供给用户的凭据（例如用户名和密码）。注册是指用户在您的站点上获得账户的过程（从我们的角度来看，注册是在数据库中创建用户记录的过程）。
- en: When users join your site for the first time, it should be clear to them that
    they’re registering. Using a third-party authentication system, we could register
    them without their knowledge if they successfully authenticate through the third
    party. This is not generally considered a good practice, and it should be clear
    to users that they’re registering for your site (whether they’re authenticating
    through a third party or not), and provide a clear mechanism for canceling their
    membership.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户第一次加入您的站点时，应清楚地告知他们他们正在注册。使用第三方认证系统，如果他们成功通过第三方进行身份验证，我们可以在未经他们同意的情况下为他们注册。这通常不被视为一种良好的做法，用户应清楚地知道他们是在为您的站点注册（无论他们是否通过第三方进行认证），并提供一个明确的机制来取消他们的会员资格。
- en: 'One user experience situation to consider is “third-party confusion.” If a
    user registers in January for your service using Facebook, then returns in July,
    and is confronted with a screen offering the choices of logging in with Facebook,
    Twitter, Google, or LinkedIn, the user may very well have forgotten what registration
    service was originally used. This is one of the pitfalls of third-party authentication,
    and there is precious little you can do about it. It’s another good reason to
    ask the user to provide an email address: this way, you can give the user an option
    to look up their account by email, and send an email to that address specifying
    what service was used for authentication.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要考虑的一个用户体验情况是“第三方认证混乱”。如果一个用户在一月份使用Facebook注册了您的服务，然后在七月份回来时，看到一个屏幕提供了使用Facebook、Twitter、Google或LinkedIn登录的选项，那么用户很可能已经忘记了最初使用的注册服务。这是第三方认证的一个缺点，对此几乎无能为力。这是请求用户提供电子邮件地址的另一个很好的理由：这样，您可以让用户通过电子邮件查找他们的帐户，并向该地址发送一封电子邮件，指明用于认证的服务。
- en: If you feel that you have a firm grasp on the social networks your users use,
    you can ease this problem by having a primary authentication service. For example,
    if you feel pretty confident that the majority of your users have a Facebook account,
    you could have a big button that says, “Log in with Facebook.” Then, using smaller
    buttons or even just text links, say, “or log in with Google, Twitter, or LinkedIn.”
    This approach can cut down on the instance of third-party confusion.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您觉得自己对用户使用的社交网络有很好的把握，可以通过一个主要的认证服务来简化这个问题。例如，如果您相当有信心大多数用户拥有Facebook账号，您可以设置一个大按钮，上面写着“使用Facebook登录”。然后，使用较小的按钮或者仅仅是文本链接，比如“或者使用Google、Twitter或LinkedIn登录”。这种方法可以减少第三方认证可能带来的混乱情况。
- en: Passport
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 护照（Passport）
- en: '*Passport* is a very popular and robust authentication module for Node/Express.
    It is not tied to any one authentication mechanism; rather, it is based on the
    idea of pluggable authentication *strategies* (including a local strategy if you
    don’t want to use third-party authentication). Understanding the flow of authentication
    information can be overwhelming, so we’ll start with just one authentication mechanism
    and add more later.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*Passport* 是Node/Express的一个非常流行且强大的身份验证模块。它不与任何一个认证机制绑定；相反，它基于可插拔认证*策略*的概念（包括本地策略，如果你不想使用第三方认证）。理解身份验证信息的流程可能会让人感到不知所措，所以我们将从一个认证机制开始，稍后再添加更多。'
- en: 'The detail that’s important to understand is that, with third-party authentication,
    your app *never receives a password*. That is handled entirely by the third party.
    This is a good thing: it’s putting the burden of secure handling and storage of
    passwords on the third party.^([1](ch18.xhtml#idm45053576983016))'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的细节在于，使用第三方认证时，你的应用程序*永远不会接收到密码*。这完全由第三方处理。这是件好事：它将安全处理和存储密码的负担放在了第三方身上。^([1](ch18.xhtml#idm45053576983016))
- en: The whole process, then, relies on redirects (it must, if your application is
    never to receive the user’s third-party password). At first, you might be confused
    about why you can pass *localhost* URLs to the third party and still successfully
    authenticate (after all, the third-party server handling your request doesn’t
    know about *your* *localhost*). It works because the third party simply instructs
    *your browser* to redirect, and your browser is inside your network, and can therefore
    redirect to local addresses.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 整个流程依赖于重定向（如果你的应用程序永远不会接收用户的第三方密码，这一点是必须的）。起初，你可能会对为什么可以向第三方传递*localhost*网址并成功验证感到困惑（毕竟，处理你请求的第三方服务器并不知道*你的*
    *localhost*）。这是因为第三方简单地指示*你的浏览器*重定向，而你的浏览器位于你的网络内，因此可以重定向到本地地址。
- en: The basic flow is shown in [Figure 18-1](#img_security_third_party_authentication).
    This diagram shows the important flow of functionality, making it clear that the
    authentication actually occurs on the third-party website. Enjoy the simplicity
    of the diagram—things are about to get a lot more complicated.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 基本流程如[图 18-1](#img_security_third_party_authentication)所示。此图表显示了功能流程的重要部分，清晰地表明认证实际上是在第三方网站上进行的。享受这张图表的简洁性——事情即将变得更加复杂。
- en: When you use Passport, there are four steps that your app will be responsible
    for. Consider a more detailed view of the third-party authentication flow, as
    shown in [Figure 18-2](#img_security_third_party_authentication_detail).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用Passport时，你的应用程序将负责四个步骤。考虑到第三方认证流程的更详细视图，如[图 18-2](#img_security_third_party_authentication_detail)所示。
- en: '![Third Party Authentication Flow](Images/bwne_1801.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![第三方认证流程](Images/bwne_1801.png)'
- en: Figure 18-1\. Third-party authentication flow
  id: totrans-125
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 18-1\. 第三方认证流程
- en: 'For simplicity, we are using Meadowlark Travel to represent your app, and Facebook
    for the third-party authentication mechanism. [Figure 18-2](#img_security_third_party_authentication_detail)
    illustrates how the user goes from the login page to the secure Account Info page
    (the Account Info page is just used for illustration purposes: this could be any
    page on your website that requires authentication).'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为简单起见，我们使用Meadowlark Travel代表你的应用程序，Facebook代表第三方认证机制。[图 18-2](#img_security_third_party_authentication_detail)展示了用户从登录页面到安全账户信息页面的过程（账户信息页面仅用于说明目的：这可以是你网站上需要身份验证的任何页面）。
- en: 'This diagram shows detail you don’t normally think about, but is important
    to understand in this context. In particular, when you visit a URL, *you* aren’t
    making the request of the server: the browser is actually doing that. That said,
    the browser can do three things: make an HTTP request, display the response, and
    perform a redirect (which is essentially making another request and displaying
    another response…which in turn could be another redirect).'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图表展示了在此背景下你通常不会考虑到但却很重要的细节。特别是，当你访问一个URL时，*你*并不是在向服务器发出请求：实际上是浏览器在执行这个动作。话虽如此，浏览器可以执行三件事情：发出HTTP请求、显示响应并执行重定向（实质上是发出另一个请求并显示另一个响应……这反过来又可能是另一个重定向）。
- en: In the Meadowlark column, you can see the four steps your application is actually
    responsible for. Fortunately, we’ll be leveraging Passport (and pluggable strategies)
    to perform the details of those steps; otherwise, this book would be much, much
    longer.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在Meadowlark栏中，您可以看到您的应用程序实际负责的四个步骤。幸运的是，我们将利用Passport（和可插拔策略）来执行这些步骤的详细信息；否则，这本书会变得更加冗长。
- en: '![Detailed View of Third Party Authentication Flow](Images/bwne_1802.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![第三方认证流程详细视图](Images/bwne_1802.png)'
- en: Figure 18-2\. Detailed view of third-party authentication flow
  id: totrans-130
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图18-2。第三方认证流程详细视图
- en: 'Before we get into implementation details, let’s consider each of the steps
    in a little more detail:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入实现细节之前，让我们更详细地考虑每个步骤：
- en: Login page
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 登录页面
- en: The login page is where the user can choose the login method. If you’re using
    a third-party authentication, it’s usually just a button or a link. If you’re
    using local authentication, it will include username and password fields. If the
    user attempts to access a URL requiring authentication (such as `/account` in
    our example) without being logged in, this is probably the page you will want
    to redirect to (alternatively, you could redirect to a Not Authorized page with
    a link to the login page).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 登录页面是用户可以选择登录方法的地方。如果您使用第三方认证，通常只有一个按钮或链接。如果您使用本地认证，将包括用户名和密码字段。如果用户尝试访问需要身份验证的URL（例如我们示例中的`/account`），而没有登录，则可能需要重定向到此页面（或者，您可以重定向到未授权页面，并附带指向登录页面的链接）。
- en: Construct authentication request
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 构建认证请求
- en: 'In this step, you’ll be constructing a request to be sent to a third party
    (via a redirect). The details of this request are complicated and specific to
    the authentication strategy. Passport (and the strategy plugin) will be doing
    all the heavy lifting here. The auth request includes protection against man-in-the-middle
    attacks, as well as other vectors an attacker might exploit. Usually the auth
    request is short-lived, so you can’t store it and expect to use it later: this
    helps prevent attacks by limiting the window in which an attacker has time to
    act. This is where you can request additional information from the third-party
    authorization mechanism. For example, it’s common to request the user’s name,
    and possibly email address. Keep in mind that the more information you request
    from users, the less likely they are to authorize your application.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在此步骤中，您将构建一个要发送到第三方的请求（通过重定向）。此请求的详细信息复杂且特定于认证策略。Passport（和策略插件）将在此处完成所有重要工作。认证请求包括对中间人攻击的保护，以及其他攻击者可能利用的向量。通常，认证请求的生命周期很短，因此您不能存储它并期望以后使用：这有助于通过限制攻击者有时间行动的窗口来防止攻击。在此处，您可以从第三方授权机制请求附加信息。例如，请求用户的姓名和可能的电子邮件地址是常见的。请注意，您从用户请求的信息越多，他们授权您的应用程序的可能性就越小。
- en: Verify authentication response
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 验证认证响应
- en: Assuming the user authorized your application, you’ll get back a valid auth
    response from the third party, which is proof of the user’s identity. Once again,
    the details of this validation are complicated and will be handled by Passport
    (and the strategy plugin). If the auth response indicates that the user is not
    authorized (if invalid credentials were entered, or your application wasn’t authorized
    by the user), you would then redirect to an appropriate page (either back to the
    login page, or to a Not Authorized or Unable to Authorize page). Included in the
    auth response will be an ID for the user that is unique *to that specific third
    party*, as well as any additional details you requested in step 2\. To enable
    step 4, we must “remember” that the user is authorized. The usual way to do this
    is to set a session variable containing the user’s ID, indicating that this session
    has been authorized (cookies can also be used, though I recommend using sessions).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 假设用户授权了您的应用程序，您将从第三方获得一个有效的认证响应，这是用户身份的证明。再次强调，此验证的详细信息较为复杂，将由Passport（和策略插件）处理。如果认证响应表明用户未经授权（例如输入了无效凭据，或者用户未授权您的应用程序），则应将其重定向到适当的页面（可以是返回登录页面，或者是未授权或无法授权页面）。认证响应中将包括用户在特定第三方身份的ID，以及您在步骤2中请求的任何附加详细信息。为了完成第4步，我们必须“记住”用户已经授权。通常的做法是设置一个包含用户ID的会话变量，指示此会话已经授权（也可以使用cookies，但我建议使用会话）。
- en: Verify authorization
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 验证授权
- en: 'In step 3, we stored a user ID in the session. The presence of that user ID
    allows us to retrieve a user object from the database that contains information
    about what the user is authorized to do. In this manner, we don’t have to authenticate
    with the third party for every request (which would result in a slow and painful
    user experience). This task is simple, and we no longer need Passport for this:
    we have our own user object that contains our own authentication rules. (If that
    object isn’t available, it indicates the request isn’t authorized, and we can
    redirect to the login or Not Authorized page.)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3步，我们在会话中存储了一个用户ID。该用户ID的存在允许我们从数据库中检索用户对象，该对象包含关于用户授权操作的信息。通过这种方式，我们无需为每个请求与第三方进行身份验证（这将导致用户体验缓慢而痛苦）。这项任务很简单，我们不再需要
    Passport 来执行此操作：我们有自己的用户对象，其中包含我们自己的身份验证规则。（如果该对象不可用，则表示请求未经授权，我们可以重定向到登录页面或未授权页面。）
- en: Tip
  id: totrans-140
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Using Passport for authentication is a fair amount of work, as you’ll see in
    this chapter. However, authentication is an important part of your application,
    and I feel that it is wise to invest some time in getting it right. There are
    projects such as [LockIt](http://bit.ly/lock_it) that try to provide a more “off
    the shelf” solution. Another increasingly popular option is [Auth0](https://auth0.com),
    which is very robust but isn’t as easy to set up as LockIt. To make the most effective
    use of LockIt or Auth0 (or similar solutions), however, it behooves you to understand
    the details of authentication and authorization, which is what this chapter is
    designed to do. Also, if you ever need to customize an authentication solution,
    Passport is a great place to start.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Passport 进行身份验证是相当多的工作，正如您在本章中所看到的那样。然而，身份验证是您的应用程序的重要部分，我认为在正确设置方面投入一些时间是明智的。有一些项目（如[LockIt](http://bit.ly/lock_it)）试图提供更“即插即用”的解决方案。另一个越来越受欢迎的选择是[Auth0](https://auth0.com)，它非常强大，但设置起来不像
    LockIt 那样简单。然而，为了最有效地使用 LockIt 或 Auth0（或类似的解决方案），了解身份验证和授权的详细信息对您来说是非常重要的，而这正是本章的设计目的。此外，如果您需要定制身份验证解决方案，Passport
    是一个很好的起点。
- en: Setting up Passport
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置 Passport
- en: To keep things simple, we’ll start with a single authentication provider. Arbitrarily,
    we’ll choose Facebook. Before we can set up Passport and the Facebook strategy,
    we’ll need to do a little configuration in Facebook. For Facebook authentication,
    you’ll need a *Facebook app*. If you already have a suitable Facebook app, you
    can use that, or you can create a new one specifically for authentication. If
    possible, you should use your organization’s official Facebook account to create
    the app. That is, if you worked for Meadowlark Travel, you would use the Meadowlark
    Travel Facebook account to create the app (you can always add your personal Facebook
    account as an administrator of the app for ease of administration). For testing
    purposes, it’s fine to use your own Facebook account, but using a personal account
    for production will appear unprofessional and suspicious to your users.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，我们将从一个身份验证提供者开始。任意地，我们选择了 Facebook。在我们可以设置 Passport 和 Facebook 策略之前，我们需要在
    Facebook 上进行一些配置。对于 Facebook 身份验证，您需要一个*Facebook应用程序*。如果您已经有一个合适的 Facebook 应用程序，您可以使用它，或者您可以为身份验证专门创建一个新的应用程序。如果可能的话，您应该使用您组织的官方
    Facebook 帐户来创建应用程序。也就是说，如果您在 Meadowlark Travel 工作，您将使用 Meadowlark Travel 的 Facebook
    帐户来创建应用程序（您始终可以将您的个人 Facebook 帐户添加为应用程序的管理员，以便更方便地进行管理）。为了测试目的，使用您自己的 Facebook
    帐户是可以的，但是在生产中使用个人帐户会给您的用户留下不专业和可疑的印象。
- en: The details of Facebook app administration seem to change fairly frequently,
    so I am not going to explain the details here. Consult the [Facebook developer
    documentation](http://bit.ly/372bc7c) if you need details on creating and administering
    your app.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Facebook 应用程序管理的详细信息似乎经常更改，因此我不打算在此处详细说明。如果您需要有关创建和管理您的应用程序的详细信息，请参阅[Facebook开发者文档](http://bit.ly/372bc7c)。
- en: 'For development and testing purposes, you will need to associate the development/testing
    domain name with the app. Facebook allows you to use *localhost* (and port numbers),
    which is great for testing purposes. Alternatively, you can specify a local IP
    address, which can be helpful if you’re using a virtualized server, or another
    server on your network for testing. The important thing is that the URL you enter
    into your browser to test the app (for example, *http://localhost:3000*) is associated
    with the Facebook app. Currently, you can associate only one domain with your
    app: if you need to be able to use multiple domains, you will have to create multiple
    apps (for example, you could have Meadowlark Dev, Meadowlark Test, and Meadowlark
    Staging; your production app can simply be called Meadowlark Travel).'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开发和测试目的，您需要将开发/测试域名与该应用关联起来。Facebook 允许您使用*localhost*（和端口号），这对测试非常有利。或者，您可以指定本地
    IP 地址，这在使用虚拟化服务器或网络中的另一台服务器进行测试时会很有帮助。重要的是，您在浏览器中输入的用于测试应用程序的 URL（例如*http://localhost:3000*）与
    Facebook 应用程序关联起来。目前，您只能将一个域名与您的应用程序关联起来：如果您需要使用多个域名，您将不得不创建多个应用程序（例如，您可以拥有 Meadowlark
    Dev、Meadowlark Test 和 Meadowlark Staging；您的生产应用程序可以简称为 Meadowlark Travel）。
- en: Once you’ve configured your app, you will need its unique app ID, and its app
    secret, both of which can be found on the Facebook app management page for that
    app.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 配置完成应用程序后，您将需要其唯一的应用程序 ID 和应用程序密钥，这两者都可以在该应用程序的 Facebook 应用管理页面上找到。
- en: Tip
  id: totrans-147
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'One of the biggest frustrations you’ll probably face is receiving a message
    from Facebook such as “Given URL is not allowed by the Application configuration.”
    This indicates that the hostname and port in the callback URL do not match what
    you’ve configured in your app. If you look at the URL in your browser, you will
    see the encoded URL, which should give you a clue. For example, if I’m using 192.168.0.103:3443,
    and I get that message, I look at the URL. If I see *redirect_uri=https%3A%2F%2F192.68.0.103%3A3443%2F*
    *auth%2Ffacebook%2Fcallback* in the querystring, I can quickly spot the mistake:
    I used 68 instead of 168 in my hostname.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会面临的最大挑战之一可能是收到来自 Facebook 的消息，例如“给定的 URL 未在应用配置中允许”。这表明回调 URL 中的主机名和端口与您在应用中配置的不匹配。如果查看浏览器中的
    URL，您将看到编码的 URL，这应该会给您一个提示。例如，如果我使用了 192.168.0.103:3443，并且收到了那个消息，我会查看 URL。如果我在查询字符串中看到*redirect_uri=https%3A%2F%2F192.68.0.103%3A3443%2F*
    *auth%2Ffacebook%2Fcallback*，我很快就会发现错误：我在主机名中使用了 68 而不是 168。
- en: 'Now let’s install Passport and the Facebook authentication strategy:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们安装 Passport 和 Facebook 认证策略：
- en: '[PRE9]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Before we’re done, there’s going to be a lot of authentication code (especially
    if we’re supporting multiple strategies), and we don’t want to clutter up *meadowlark.js*
    with all that code. Instead, we’ll create a module called *lib/auth.js*. This
    is going to be a large file, so we’re going to take it piece by piece (see *ch18*
    in the companion repo for the finished example). We’ll start with the imports
    and two methods that Passport requires, `serializeUser` and `deserializeUser`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成之前，将会有大量的认证代码（特别是如果我们支持多种策略），我们不希望在*meadowlark.js*中混杂所有这些代码。相反，我们将创建一个名为*lib/auth.js*的模块。这将是一个大文件，因此我们将逐步进行（请参见伴随存储库中的*ch18*以获取完成示例）。我们将从导入和
    Passport 需要的两个方法`serializeUser`和`deserializeUser`开始：
- en: '[PRE10]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Passport uses `serializeUser` and `deserializeUser` to map requests to the
    authenticated user, allowing you to use whatever storage method you want. In our
    case, we are only going to store our database ID (the `_id` property) in the session.
    The way we’re using the ID here makes “serialize” and “deserialize” soft of into
    misnomers: we’re actually just storing a user ID in the session. Then, when needed,
    we can get a user object by finding that ID in the database.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Passport 使用`serializeUser`和`deserializeUser`将请求映射到经过身份验证的用户，允许您使用任何存储方法。在我们的情况下，我们只会将数据库
    ID（即 `_id` 属性）存储在会话中。我们在这里使用 ID 的方式使得“序列化”和“反序列化”有点名不副实：实际上，我们只是在会话中存储了一个用户 ID。然后，当需要时，我们可以通过在数据库中查找该
    ID 来获取用户对象。
- en: Once these two methods are implemented, as long as there is an active session,
    and the user has successfully authenticated, `req.session.passport.user` will
    be the corresponding user object as retrieved from the database.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦实现了这两种方法，只要存在活动会话，并且用户已经成功认证，`req.session.passport.user`将是从数据库检索到的相应用户对象。
- en: 'Next, we’re going to choose what to export. To enable Passport’s functionality,
    we’ll need to do two distinct activities: initialize Passport, and register routes
    that will handle authentication and the redirected callbacks from our third-party
    authentication services. We don’t want to combine these two in one function because
    in our main application file, we may want to choose when Passport is linked into
    the middleware chain (remember that order is significant when adding middleware).
    So, instead of having our module export function that does either of these things,
    we’re going to have it return a function that returns an object that has the methods
    we need. Why not just return an object to start with? Because we need to bake
    in some configuration values. Also, since we need to link the Passport middleware
    into our application, a function is an easy way to pass in the Express application
    object:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将选择导出什么内容。为了启用 Passport 的功能，我们需要执行两个不同的活动：初始化 Passport，并注册处理身份验证和来自第三方身份验证服务的重定向回调的路由。我们不想在一个函数中将这两个活动合并，因为在我们的主应用程序文件中，我们可能希望选择何时将
    Passport 链接到中间件链中（记住在添加中间件时顺序很重要）。因此，我们不是导出执行这些操作中的任一操作的模块导出函数，而是返回一个返回我们需要的方法的对象的函数。为什么不直接返回一个对象？因为我们需要嵌入一些配置值。而且，由于我们需要将
    Passport 中间件链接到我们的应用程序中，使用函数可以轻松地传递 Express 应用程序对象：
- en: '[PRE11]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Before we get into the details of the `init` and `registerRoutes` methods,
    let’s look at how we’ll use this module (hopefully that will make this business
    of returning a function that returns an object a little more clear):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们详细讨论 `init` 和 `registerRoutes` 方法之前，让我们看看我们将如何使用这个模块（希望这能让我们返回一个返回对象的函数的业务更加清晰）：
- en: '[PRE12]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Notice that, in addition to specifying the success and failure redirect paths,
    we also specify a property called `providers`, which we’ve externalized in the
    credentials file (see [Chapter 13](ch13.xhtml#ch_persistence)). We’ll need to
    add the `authProviders` property to *.credentials.development.json*:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，除了指定成功和失败重定向路径外，我们还指定了一个名为 `providers` 的属性，该属性已在凭据文件中外部化（参见[第13章](ch13.xhtml#ch_persistence)）。我们需要将
    `authProviders` 属性添加到 *.credentials.development.json* 文件中：
- en: '[PRE13]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Tip
  id: totrans-161
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Another reason to bundle our authentication code in a module like this is that
    we can reuse it for other projects; as a matter of fact, there are already some
    authentication packages that do essentially what we’re doing here. However, it’s
    important to understand the details of what’s going on, so even if you end up
    using a module someone else wrote, this will help you understand everything that’s
    going on in your authentication flow.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个将认证代码打包成这样一个模块的原因是我们可以将其重用于其他项目；事实上，已经有一些认证包在基本上做我们在这里做的事情。但是，了解正在进行的一切的细节非常重要，因此即使最终使用别人编写的模块，这也将帮助您理解您的认证流程中发生的一切。
- en: 'Now let’s take care of our `init` method (previously a “TODO” in *auth.js*):'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们处理我们的 `init` 方法（先前在 *auth.js* 中作为“TODO”）：
- en: '[PRE14]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This is a pretty dense bit of code, but most of it is actually just Passport
    boilerplate. The important bit is inside the function that gets passed to the
    `FacebookStrategy` instance. When this function gets called (after the user has
    successfully authenticated), the `profile` parameter contains information about
    the Facebook user. Most important, it includes a Facebook ID: that’s what we’ll
    use to associate a Facebook account to our own user object. Note that we namespace
    our `authId` property by prefixing `*facebook:*`. Slight as the chance may be,
    this prevents the possibility of a Facebook ID colliding with a Twitter or Google
    ID (it also allows us to examine user models to see what authentication method
    a user is using, which could be useful). If the database already contains an entry
    for this namespaced ID, we simply return it (this is when `serializeUser` gets
    called, which will put our own user ID into the session). If no user record is
    returned, we create a new user object and save it to the database.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码非常密集，但实际上大部分只是 Passport 的样板代码。关键在于传递给 `FacebookStrategy` 实例的函数内部。当这个函数被调用时（用户成功认证后），`profile`
    参数包含了关于 Facebook 用户的信息。最重要的是，它包括了 Facebook ID：这是我们将使用来关联 Facebook 帐户到我们自己的用户对象的信息。请注意，我们通过在
    `authId` 属性前加上 `*facebook:*` 的前缀来命名空间化我们的属性。尽管可能性微乎其微，但这样可以防止 Facebook ID 与 Twitter
    或 Google ID 冲突（同时也允许我们检查用户模型，查看用户使用的认证方法，这可能会很有用）。如果数据库已经包含了这个命名空间化的 ID 的条目，我们只需返回它（这时会调用
    `serializeUser`，它会将我们自己的用户 ID 放入会话中）。如果没有返回用户记录，我们会创建一个新的用户对象并将其保存到数据库中。
- en: 'The last thing we have to do is create our `registerRoutes` method (don’t worry,
    this one is much shorter):'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的最后一件事是创建我们的 `registerRoutes` 方法（别担心，这个方法要短得多）：
- en: '[PRE15]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now we have the path */auth/facebook*; visiting this path will automatically
    redirect the visitor to Facebook’s authentication screen (this is done by `passport.authenticate('facebook’)`),
    step 2 in [Figure 18-1](#img_security_third_party_authentication). Note that we
    check to see if there’s a querystring parameter `redirect`; if there is, we save
    it in the session. This is so we can automatically redirect to the intended destination
    after completing authentication. Once the user authorizes with Twitter, the browser
    will be redirected back to your site—specifically, to the */auth/facebook/callback*
    path (with the optional `redirect` querystring indicating where the user was originally).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了路径 */auth/facebook*；访问此路径将自动将访问者重定向到 Facebook 的身份验证界面（这是通过 `passport.authenticate('facebook’)`
    完成的），见 [图 18-1](#img_security_third_party_authentication) 第 2 步。请注意，我们检查是否有查询字符串参数
    `redirect`；如果有，我们将其保存在会话中。这样我们就可以在完成身份验证后自动重定向到预定的目标。一旦用户通过 Twitter 授权，浏览器将被重定向回您的站点——具体来说，是到路径
    */auth/facebook/callback*（带有可选的 `redirect` 查询字符串，指示用户最初的位置）。
- en: 'Also on the querystring are authentication tokens that Passport will verify.
    If the verification fails, Passport will redirect the browser to `options.failureRedirect`.
    If the verification is successful, Passport will call `next`, which is where your
    application comes back in. Note how the middleware is chained in the handler for
    */auth/facebook/callback*: `passport.authenticate` is called first. If it calls
    `next`, control passes over to your function, which then redirects to either the
    original location or `options.successRedirect`, if the `redirect` querystring
    parameter wasn’t specified.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，在查询字符串中还有 Passport 将验证的身份验证令牌。如果验证失败，Passport 将重定向浏览器到 `options.failureRedirect`。如果验证成功，Passport
    将调用 `next`，这是您的应用程序再次参与的地方。请注意中间件在处理 */auth/facebook/callback* 的处理程序中是如何链接的：首先调用
    `passport.authenticate`。如果它调用了 `next`，控制权将传递给您的函数，然后根据情况重定向到原始位置或 `options.successRedirect`，如果未指定
    `redirect` 查询字符串参数。
- en: Tip
  id: totrans-170
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Omitting the `redirect` querystring parameter can simplify your authentication
    routes, which may be tempting if you have only one URL that requires authentication.
    However, having this functionality available will eventually come in handy and
    provide a better user experience. No doubt you’ve experienced this yourself before:
    you’ve found the page you want, and you’re instructed to log in. You do, and you’re
    redirected to a default page, and you have to navigate back to the original page.
    It’s not a very satisfying user experience.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 省略 `redirect` 查询字符串参数可能会简化您的身份验证路由，如果只有一个需要身份验证的 URL，这可能会很诱人。但是，将此功能可用将来会很方便，并提供更好的用户体验。毫无疑问，您之前也经历过这种情况：找到想要的页面，然后被要求登录。您登录后，会被重定向到默认页面，然后必须导航回原始页面。这并不是一个令人满意的用户体验。
- en: 'The “magic” that Passport is doing during this process is saving the user (in
    our case, just a database user ID) to the session. This is a good thing, because
    the browser is *redirecting*, which is a different HTTP request: without having
    that information in the session, we wouldn’t have any way to know that the user
    had been authenticated! Once a user has been successfully authenticated, `req.session.passport.user`
    will be set, and that’s how future requests will know that the user has been authenticated.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中 Passport 所做的“魔术”是将用户（在我们的情况下，仅仅是数据库用户 ID）保存到会话中。这是件好事，因为浏览器正在*重定向*，这是一个不同的
    HTTP 请求：如果会话中没有这些信息，我们将无法知道用户是否已经通过了身份验证！一旦用户成功通过身份验证，`req.session.passport.user`
    将被设置，这样未来的请求就会知道用户已经通过了身份验证。
- en: 'Let’s look at our `/account` handler to see how it checks to make sure the
    user is authenticated (this route handler will be in our main application file,
    or in a separate routing module, not in */lib/auth.js*):'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的 `/account` 处理程序如何检查用户是否已经通过了身份验证（此路由处理程序将在我们的主应用程序文件中，或者在一个单独的路由模块中，而不是在
    */lib/auth.js* 中）：
- en: '[PRE16]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now only authenticated users will see the account page; everyone else will be
    redirected to a Not Authorized page.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只有经过身份验证的用户才能看到帐户页面；其他所有人将被重定向到一个未授权页面。
- en: Role-Based Authorization
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于角色的授权
- en: So far, we’re not technically doing any authorization (we’re only differentiating
    between authorized and unauthorized users). However, let’s say we want only customers
    to see their account views (employees might have an entirely different view where
    they can see user account information).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在技术上并没有执行任何授权（我们只是区分了经过授权和未经授权的用户）。然而，假设我们只想让顾客看到他们的账户视图（员工可能有一个完全不同的视图，他们可以在其中查看用户账户信息）。
- en: 'Remember that in a single route, you can have multiple functions, which get
    called in order. Let’s create a function called `customerOnly` that will allow
    only customers:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在单个路由中，你可以有多个按顺序调用的函数。让我们创建一个名为`customerOnly`的函数，它将只允许顾客：
- en: '[PRE17]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let’s also create am `employeeOnly` function that will operate a little differently.
    Let’s say we have a path */sales* that we want to be available only to employees.
    Furthermore, we don’t want nonemployees to even be aware of its existence, even
    if they stumble on it by accident. If a potential attacker went to the */sales*
    path, and saw a Not Authorized page, that is a little information that might make
    an attack easier (simply by knowing that the page is there). So, for a little
    added security, we want nonemployees to see a regular 404 page when they visit
    the */sales* page, giving potential attackers nothing to work with:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们还创建一个`employeeOnly`函数，它将有所不同。假设我们有一个路径*/sales*，我们希望只有员工能够访问。此外，我们不希望非员工甚至意外地知道它的存在。如果潜在的攻击者访问了*/sales*路径，并看到了一个未经授权的页面，这可能会使攻击变得更容易（只需知道页面的存在）。因此，为了增加一点安全性，我们希望非员工在访问*/sales*页面时看到一个普通的404页面，让潜在的攻击者没有可利用的信息：
- en: '[PRE18]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Calling `next(''route’)` will not simply execute the next handler in the route:
    it will skip this route altogether. Assuming there’s not a route further on down
    the line that will handle `/account`, this will eventually pass to the 404 handler,
    giving us the desired result.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`next('route’)`不仅仅会执行路由中的下一个处理程序：它将完全跳过这个路由。假设后面没有处理`/account`的路由，最终将会传递给404处理程序，从而得到我们想要的结果。
- en: 'Here’s how easy it is to put these functions to use:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些功能非常容易：
- en: '[PRE19]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It should be clear that role-based authorization can be as simple or as complicated
    as you wish. For example, what if you want to allow multiple roles? You could
    use the following function and route:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 应该明确的是基于角色的授权可以像你希望的那样简单或者复杂。例如，如果你想允许多个角色怎么办？你可以使用下面的函数和路由：
- en: '[PRE20]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Hopefully that example gives you an idea of how creative you can be with role-based
    authorization. You could even authorize on other properties, such as the length
    of time a user has been a member or how many vacations that user has booked with
    you.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这个例子能让你对基于角色的授权有所了解。你甚至可以根据其他属性进行授权，比如用户成为会员的时间长度或者与你预定的假期数量。
- en: Adding Authentication Providers
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加认证提供者
- en: Now that our framework is in place, adding more authentication providers is
    easy. Let’s say we want to authenticate with Google. Before we start adding code,
    you’ll have to set up a project on your Google account.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的框架已经就位，添加更多认证提供者变得很容易。假设我们想要与Google进行认证。在我们开始添加代码之前，你需要在你的Google账号上设置一个项目。
- en: 'Go to your [Google Developers Console](http://bit.ly/2KcY1X0) and choose a
    project from the navigation bar (if you don’t already have a project, click New
    Project and follow the instructions. Once you’ve selected a project, click “Enable
    APIs and Services” and enable Cloud Identity API. Click Credentials, and then
    Create Credentials, and choose “OAuth client ID,” and then “Web application.”
    Enter the appropriate URLs for your app: for testing you can use *http://localhost:3000*
    for the authorized origins, and *http://localhost:3000/auth/google/callback* for
    authorized redirect URIs.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 前往你的[Google开发者控制台](http://bit.ly/2KcY1X0)，并在导航栏中选择一个项目（如果你还没有项目，点击新建项目并按照指示操作）。一旦选择了项目，点击“启用API和服务”，启用Cloud
    Identity API。点击凭据，然后创建凭据，选择“OAuth客户端ID”，然后选择“Web应用程序”。输入你的应用程序的适当URL：用于测试你可以使用*http://localhost:3000*作为授权来源，*http://localhost:3000/auth/google/callback*作为授权重定向URI。
- en: 'Once you have got everything set up on the Google side, run `npm install passport-google-oauth20`,
    and add the following code to *lib/auth.js*:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在Google端设置好了一切，运行`npm install passport-google-oauth20`，然后将以下代码添加到*lib/auth.js*中：
- en: '[PRE21]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And the following to the `registerRoutes` method:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 并将以下内容添加到`registerRoutes`方法中：
- en: '[PRE22]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Conclusion
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: 'Congratulations on making it through the most intricate chapter! It’s unfortunate
    that such an important feature (authentication and authorization) is so complicated,
    but in a world rife with security threats, it’s an unavoidable complexity. Fortunately,
    projects like Passport (and the excellent authentication schemes based on it)
    lessen our burden somewhat. Still, I encourage you not to give short shrift to
    this area of your application: exercising diligence in the area of security will
    make you a good internet citizen. Your users may never thank you for it, but woe
    be to the owners of an application who allow user data to be compromised because
    of poor security.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜您通过了最复杂的章节！很遗憾，如此重要的功能（认证和授权）如此复杂，但在一个充满安全威胁的世界中，这是不可避免的复杂性。幸运的是，像 Passport
    这样的项目（以及基于它的优秀认证方案）在某种程度上减轻了我们的负担。然而，我鼓励您不要在应用程序的这个领域马虎对待：在安全领域保持谨慎将使您成为一个优秀的网络公民。您的用户可能永远不会因此感谢您，但如果因为安全不当导致用户数据泄露，应用程序的所有者将会后悔不已。
- en: ^([1](ch18.xhtml#idm45053576983016-marker)) It is unlikely that the third party
    is storing passwords either. A password can be verified by storing something called
    a *salted hash*, which is a one-way transformation of the password. That is, once
    you generate a hash from a password, you can’t recover the password. *Salting*
    the hash provides additional protection against certain kinds of attacks.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch18.xhtml#idm45053576983016-marker)) 第三方也不太可能存储密码。密码可以通过存储所谓的*盐值哈希*来验证，这是密码的单向转换。也就是说，一旦你从密码生成了哈希值，就无法恢复密码。*对哈希进行加盐*可以提供额外的保护，防止某些类型的攻击。
