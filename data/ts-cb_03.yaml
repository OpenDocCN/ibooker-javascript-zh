- en: Chapter 2\. Basic Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 基本类型
- en: 'Now that you are all set up, it’s time to write some TypeScript! Starting out
    should be easy, but you will soon run into situations where you’re unsure if you’re
    doing the right thing. Should you use interfaces or type aliases? Should you annotate
    or let type inference do its magic? What about `any` and `unknown`: are they safe
    to use? Some people on the internet said you should never use them, so why are
    they part of TypeScript?'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经准备好了，是时候写一些 TypeScript 代码了！开始起步应该很容易，但很快你会遇到一些不确定是否正确的情况。你应该使用接口还是类型别名？应该注释还是让类型推断发挥魔力？`any`
    和 `unknown` 又怎么样：它们安全吗？有些人在互联网上说你永远不应该使用它们，那为什么它们会成为 TypeScript 的一部分呢？
- en: All these questions will be answered in this chapter. We will look at the basic
    types that make TypeScript and learn how an experienced TypeScript developer will
    use them. You can use this as a foundation for the upcoming chapters, so you get
    a feel for how the TypeScript compiler gets to its types and how it interprets
    your annotations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些问题将在本章中得到解答。我们将查看构成 TypeScript 的基本类型，并了解经验丰富的 TypeScript 开发者如何使用它们。你可以将其作为即将到来的章节的基础，这样你就能感受到
    TypeScript 编译器如何生成类型，以及它如何解释你的注释。
- en: This is about the interaction between your code, the editor, and the compiler.
    And it’s about going up and down the type hierarchy, as we will see in [Recipe
    2.3](#ch02_item_objects). Whether you’re an experienced TypeScript developer or
    just starting out, you’ll find useful information in this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这是关于你的代码、编辑器和编译器之间的互动。它涉及到上下类型层次结构的交互，正如我们将在[食谱 2.3](#ch02_item_objects)中看到的那样。无论你是经验丰富的
    TypeScript 开发者还是刚入门的人，你都会在本章中找到有用的信息。
- en: 2.1 Annotating Effectively
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.1 有效注释
- en: Problem
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Annotating types is cumbersome and boring.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 注释类型是繁琐且无聊的。
- en: Solution
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Annotate only when you want your types checked.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当你希望检查类型时才添加注释。
- en: Discussion
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'A type annotation is a way to explicitly tell which types to expect. You know,
    the prominent stuff in other programming languages, where the verbosity of `StringBuilder
    stringBuilder = new StringBuilder()` makes sure that you’re really, really dealing
    with a `StringBuilder`. The opposite is type inference, where TypeScript tries
    to figure out the type for you:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 类型注释是一种明确告知期望的类型的方式。你知道，在其他编程语言中，`StringBuilder stringBuilder = new StringBuilder()`
    的冗长确保你确实在处理一个 `StringBuilder`。相反的是类型推断，其中 TypeScript 尝试为你推断类型：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Type annotations are also the most obvious and visible syntax difference between
    TypeScript and JavaScript.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 类型注释也是 TypeScript 和 JavaScript 之间最显而易见的语法差异。
- en: When you start learning TypeScript, you might want to annotate everything to
    express the types you’d expect. This might feel like the obvious choice, but you
    can also use annotations sparingly and let TypeScript figure out types for you.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始学习 TypeScript 时，你可能希望注释所有内容以表达你期望的类型。这可能会感觉是显而易见的选择，但你也可以节省地使用注释，让 TypeScript
    为你推断类型。
- en: 'A type annotation is a way for you to express where contracts have to be checked.
    If you add a type annotation to a variable declaration, you tell the compiler
    to check if types match during the assignment:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 类型注释是你表达需要检查契约的地方。如果你在变量声明中添加类型注释，你告诉编译器在赋值过程中检查类型是否匹配：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If `createPerson` returns something that isn’t compatible with `Person`, TypeScript
    will throw an error. Do this if you really want to be sure you’re dealing with
    the right type.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `createPerson` 返回的东西与 `Person` 不兼容，TypeScript 将抛出错误。如果你确实希望确保处理正确类型，请这样做。
- en: Also, from this moment on, `me` is of type `Person`, and TypeScript will treat
    it as a `Person`. If there are more properties in `me`—for example, a `profession`—TypeScript
    won’t allow you to access them. It’s not defined in `Person`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一刻起，`me` 是 `Person` 类型，并且 TypeScript 将其视为 `Person`。如果 `me` 还有更多属性——例如 `profession`——TypeScript
    将不允许你访问它们。这在 `Person` 中未定义。
- en: 'If you add a type annotation to a function signature’s return value, you tell
    the compiler to check if types match the moment you return that value:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在函数签名的返回值中添加类型注释，你告诉编译器在返回该值的时候检查类型是否匹配：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you return something that doesn’t match `Person`, TypeScript will throw an
    error. Do this if you want to be completely sure that you return the correct type.
    This especially comes in handy if you are working with functions that construct
    big objects from various sources.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果返回的内容与 `Person` 不匹配，TypeScript 将抛出错误。如果你想完全确保返回正确的类型，可以这样做。特别是在处理从各种来源构建大对象的函数时，这非常方便。
- en: 'If you add a type annotation to a function signature’s parameters, you tell
    the compiler to check if types match the moment you pass along arguments:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你给函数签名的参数添加类型注解，你告诉编译器在传递参数时检查类型是否匹配：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In my opinion this is the most important and unavoidable type annotation. Everything
    else can be inferred:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，这是最重要且不可避免的类型注解。其他一切都可以推断：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can use inferred object types where you expect an annotation because TypeScript
    has a *structural type system*. In a structural type system, the compiler will
    only take into account the members (properties) of a type, not the actual name.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当你期望一个注解而使用推断的对象类型时，你可以使用 TypeScript 的 *结构类型系统*。在结构类型系统中，编译器只会考虑类型的成员（属性），而不是实际的名称。
- en: 'Types are compatible if all members of the type to check against are available
    in the type of the value. We also say that the *shape* or *structure* of a type
    has to match:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要检查的类型的所有成员在值的类型中都可用，则这些类型是兼容的。我们也说类型的 *形状* 或 *结构* 必须匹配：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`User` has more properties than `Person`, but all properties that are in `Person`
    are also in `User`, and they have the same type. This is why it’s possible to
    pass `User` objects to `printPerson`, even though the types don’t have any explicit
    connection.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`User` 拥有比 `Person` 更多的属性，但是所有 `Person` 中的属性也都在 `User` 中，并且类型相同。这就是为什么可以将 `User`
    对象传递给 `printPerson`，即使这些类型没有显式的连接。'
- en: 'However, if you pass a literal, TypeScript will complain that there are excess
    properties that should not be there:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你传递一个文字量，TypeScript 将抱怨存在不应该存在的多余属性：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This makes sure that you didn’t expect properties to be present in this type
    and then wonder why changing them has no effect.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了你不会期望这种类型存在某些属性，然后惊讶地发现更改它们没有效果。
- en: 'With a structural type system, you can create interesting patterns with carrier
    variables with the type inferred, and you can reuse the same variable in different
    parts of your software, with no similar connection to each other:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用结构类型系统，你可以创建具有推断类型的承载变量的有趣模式，并且可以在软件的不同部分重复使用相同的变量，而彼此之间没有类似的连接：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`Student`, `Person`, and `Studying` have some overlap but are unrelated to
    each other. `createPerson` returns something that is compatible with all three
    types. If you have annotated too much, you would need to create a lot more types
    and a lot more checks than necessary, without any benefit.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`Student`、`Person` 和 `Studying` 有一些重叠，但彼此无关。`createPerson` 返回与这三种类型兼容的内容。如果你注释过多，你需要创建比必要更多的类型和检查，而且没有任何好处。'
- en: So annotate wherever you want to have your types checked, at least for function
    arguments.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，无论在哪里，你都应该对函数参数进行注解以便进行类型检查。
- en: 2.2 Working with any and unknown
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.2 使用 `any` 和 `unknown`
- en: Problem
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: There are two top types in TypeScript, `any` and `unknown`. Which one should
    you use?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 中有两个顶级类型，`any` 和 `unknown`。你应该使用哪一个？
- en: Solution
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `any` if you effectively want to deactivate typing; use `unknown` when you
    need to be cautious.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望有效地取消类型检查，请使用 `any`；当你需要谨慎处理时，请使用 `unknown`。
- en: Discussion
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Both `any` and `unknown` are top types, which means that every value is compatible
    with `any` or `unknown`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`any` 和 `unknown` 都是顶级类型，这意味着每个值都兼容于 `any` 或 `unknown`：'
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Since `any` is a type every value is compatible with, you can access any property
    without restriction:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `any` 是一种每个值都兼容的类型，你可以无限制地访问任何属性：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`any` is also compatible with every subtype, except `never`. This means you
    can narrow the set of possible values by assigning a new type:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`any` 也与每个子类型兼容，除了 `never`。这意味着你可以通过分配新类型来缩小可能值的集合：'
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Being so permissive, `any` can be a constant source of potential errors and
    pitfalls since you effectively deactivate type-checking.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `any` 非常宽容，它可能是潜在错误和陷阱的不断源头，因为你实际上是取消了类型检查。
- en: 'While everybody seems to agree that you shouldn’t use `any` in your codebases,
    there are some situations where `any` is really useful:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大家似乎都同意你不应该在代码库中使用 `any`，但在某些情况下，`any`确实非常有用：
- en: Migration
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移
- en: When you go from JavaScript to TypeScript, chances are that you already have
    a large codebase with a lot of implicit information on how your data structures
    and objects work. It might be a chore to get everything spelled out in one go.
    `any` can help you migrate to a safer codebase incrementally.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从JavaScript迁移到TypeScript时，你可能已经有一个大型的代码库，其中包含大量关于数据结构和对象如何工作的隐含信息。一次性将所有内容明确化可能有些麻烦。`any`可以帮助你逐步迁移到更安全的代码库。
- en: Untyped third-party dependencies
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 未类型化的第三方依赖项
- en: 'You might have a JavaScript dependency that still refuses to use TypeScript
    (or something similar). Or even worse: there are no up-to-date types for it. Definitely
    Typed is a great resource, but it’s also maintained by volunteers. It’s a formalization
    of something that exists in JavaScript but is not directly derived from it. There
    might be errors (even in such popular type definitions like React’s), or they
    just might not be up to date!'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能有一个JavaScript依赖项，仍然拒绝使用TypeScript（或类似的东西）。甚至更糟糕的是：没有最新的类型定义。Definitely Typed是一个很好的资源，但它也是由志愿者维护的。它是JavaScript中存在的东西的形式化，但并非直接从JavaScript派生而来。可能存在错误（甚至在像React这样的流行类型定义中），或者它们可能只是不是最新的！
- en: This is where `any` can help you. When you know how the library works, if the
    documentation is good enough to get you going, and if you use it sparingly, `any`
    can be an option instead of fighting types.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`any`可以帮助你的地方。当你了解库的工作原理，如果文档足够好以帮助你入门，并且你使用它不多时，`any`可以是一个选择，而不是与类型作斗争的选项。
- en: JavaScript prototyping
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript原型
- en: 'TypeScript works a bit differently from JavaScript and needs to make a lot
    of trade-offs to ensure that you don’t run into edge cases. This also means that
    if you write certain things that would work in JavaScript, you’d get errors in
    TypeScript:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript的工作方式与JavaScript有所不同，并需要做出许多权衡以确保你不会遇到边缘情况。这也意味着，如果你写的某些东西在JavaScript中可以工作，但在TypeScript中会出错：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Find out why this is an error in [Recipe 9.1](ch09.html#ch09_working_with_object_keys).
    In cases like this, `any` can help you to switch off type-checking for a moment
    because you know what you’re doing. And since you can go from every type to `any`,
    but also back to every other type, you have little, explicit unsafe blocks throughout
    your code where you are in charge of what’s happening:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 查找在[Recipe 9.1](ch09.html#ch09_working_with_object_keys)中为什么这是一个错误。在这种情况下，`any`可以帮助你暂时关闭类型检查，因为你知道你在做什么。而且由于你可以从任何类型转换到`any`，但也可以返回到任何其他类型，所以在你的代码中有少量明确的不安全块，你可以控制发生的事情：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once you know this part of your code works, you can start adding the right
    types, work around TypeScript’s restrictions, and type assertions:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你知道代码的这部分工作正常，你可以开始添加正确的类型，绕过TypeScript的限制，并进行类型断言：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Whenever you use `any`, make sure you activate the `noImplicitAny` flag in your
    *tsconfig.json*; it is activated by default in `strict` mode. TypeScript needs
    you to explicitly annotate `any` when you don’t have a type through inference
    or annotation. This helps find potentially problematic situations later on.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 每当使用`any`时，请确保在*tsconfig.json*中激活`noImplicitAny`标志；在`strict`模式下，默认已激活。TypeScript需要你在通过推断或注释没有类型时显式注释`any`，这有助于在后续找到潜在的问题情况。
- en: 'An alternative to `any` is `unknown`. It allows for the same values, but the
    things you can do with it are very different. Where `any` allows you to do everything,
    `unknown` allows you to do nothing. All you can do is pass values around; the
    moment you want to call a function or make the type more specific, you first need
    to do type-checks:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`any`的一种替代方案是`unknown`。它允许使用相同的值，但你可以做的事情完全不同。`any`允许你做任何事情，而`unknown`则不允许你做任何事情。你只能传递值；当你想要调用函数或使类型更具体时，首先需要进行类型检查：'
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Type-checks and control flow analysis help you do more with `unknown`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 类型检查和控制流分析帮助你更多地使用`unknown`：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If your apps work with a lot of different types, `unknown` is great for making
    sure that you can carry values throughout your code but don’t run into any safety
    problems because of `any`’s permissiveness.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序涉及大量不同类型，`unknown`非常适合确保你可以在整个代码中传递值，但不会因为`any`的宽松性而遇到安全问题。
- en: 2.3 Choosing the Right Object Type
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.3 选择正确的对象类型
- en: Problem
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: 'You want to allow for values that are JavaScript objects, but there are three
    different object types: `object`, `Object`, and `{}`. Which one should you use?'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望允许JavaScript对象的值，但有三种不同的对象类型：`object`、`Object`和`{}`。你应该使用哪一个？
- en: Solution
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `object` for compound types like objects, functions, and arrays. Use `{}`
    for everything that has a value.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于对象、函数和数组等复合类型，请使用 `object`。对于所有具有值的情况，请使用 `{}`。
- en: Discussion
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: TypeScript divides its types into two branches. The first branch, *primitive
    types*, includes `number`, `boolean`, `string`, `symbol`, `bigint`, and some subtypes.
    The second branch, *compound types*, includes everything that is a subtype of
    an object and is ultimately composed of other compound types or primitive types.
    [Figure 2-1](#img-type-hierarchy) provides an overview.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 将其类型分为两个分支。第一个分支，*原始类型*，包括 `number`、`boolean`、`string`、`symbol`、`bigint`
    和一些子类型。第二个分支，*复合类型*，包括所有对象的子类型，最终由其他复合类型或原始类型组成。[图 2-1](#img-type-hierarchy) 提供了一个概述。
- en: '![tscb 0201](assets/tscb_0201.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![tscb 0201](assets/tscb_0201.png)'
- en: Figure 2-1\. The type hierarchy in TypeScript
  id: totrans-76
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-1\. TypeScript 中的类型层次结构
- en: 'In some situations you want to target values that are *compound types*, either
    because you want to modify certain properties or because you just want to be safe
    that you don’t pass any primitive values. For example `Object.create` creates
    a new object and takes its prototype as the first argument. This can only be a
    *compound type*; otherwise, your runtime JavaScript code would crash:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你希望针对*复合类型*的值，无论是因为你想修改某些属性还是因为你只是想确保不传递任何原始值。例如 `Object.create` 创建一个新对象，并将其原型作为第一个参数。这只能是一个*复合类型*；否则，你的运行时
    JavaScript 代码将崩溃：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In TypeScript, three types seem to do the same thing: The empty object type
    `{}`, the uppercase O `Object` interface, and the lowercase O `object` type. Which
    one do you use for compound types?'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 中，似乎有三种类型可以做同样的事情：空对象类型 `{}`，大写 `Object` 接口和小写 `object` 类型。你会选择哪一个用于复合类型？
- en: '`{}` and `Object` allow for roughly the same values, which are everything but
    `null` or `undefined` (given that `strict` mode or `strictNullChecks` is activated):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`{}` 和 `Object` 允许大致相同的值，即除了 `null` 或 `undefined` 外的所有内容（假设激活了 `strict` 模式或
    `strictNullChecks`）：'
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `Object` interface is compatible with all values that have the `Object`
    prototype, which is every value from every primitive and compound type.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object` 接口与所有具有 `Object` 原型的值兼容，这些值来自每种原始和复合类型。'
- en: 'However, `Object` is a defined interface in TypeScript, and it has some requirements
    for certain functions. For example, the `toString` method, which is `toString()
    => string` and part of any non-nullish value, is part of the `Object` prototype.
    If you assign a value with a different `tostring` method, TypeScript will error:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 TypeScript 中，`Object` 是一个定义好的接口，并且对某些函数有一些要求。例如，`toString` 方法是 `toString()
    => string`，并且是任何非空值的一部分，它是 `Object` 原型的一部分。如果你分配一个具有不同 `tostring` 方法的值，TypeScript
    将会报错：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`Object` can cause some confusion due to this behavior, so in most cases, you’re
    good with `{}`.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此行为，`Object` 可能会导致一些混淆，因此在大多数情况下，你可以使用 `{}`。
- en: 'TypeScript also has a *lowercase* `object` type. This is more the type you’re
    looking for, as it allows for any compound type but no primitive types:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 还有一个*小写* `object` 类型。这更接近你要找的类型，因为它允许任何复合类型，但不允许原始类型：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you want a type that excludes functions, regexes, arrays, and the like, see
    [Chapter 5](ch05.html#ch05), where we create one on our own.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要一个排除函数、正则表达式、数组等的类型，请参阅[第 5 章](ch05.html#ch05)，我们在那里自己创建一个。
- en: 2.4 Working with Tuple Types
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.4 使用元组类型
- en: Problem
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You are using JavaScript arrays to organize your data. The order is important,
    and so are the types at each position. But TypeScript’s type inference makes it
    really cumbersome to work with.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在使用 JavaScript 数组来组织你的数据。顺序很重要，每个位置的类型也很重要。但是 TypeScript 的类型推断使得处理起来非常繁琐。
- en: Solution
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Annotate with tuple types.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 用元组类型进行注释。
- en: Discussion
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Like objects, JavaScript arrays are a popular way to organize data in a complex
    object. Instead of writing a typical `Person` object as we did in other recipes,
    you can store entries element by element:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 像对象一样，JavaScript 数组是组织复杂对象数据的一种流行方式。与我们在其他示例中所做的典型 `Person` 对象不同，你可以逐个元素地存储条目：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The benefit of using arrays over objects is that array elements don’t have
    property names. When you assign each element to variables using destructuring,
    it becomes really easy to assign custom names:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数组而不是对象的好处在于，数组元素没有属性名称。当你使用解构分配每个元素到变量时，可以很容易地分配自定义名称：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: For APIs where you need to assign new names constantly, using arrays is very
    comfortable, as explained in [Chapter 10](ch10.html#ch10).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要不断分配新名称的 API，使用数组非常方便，正如在[第 10 章](ch10.html#ch10)中所解释的那样。
- en: 'When using TypeScript and relying on type inference, however, this pattern
    can cause some issues. By default, TypeScript infers the array type from an assignment.
    Arrays are open-ended collections with the same element in each position:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在使用 TypeScript 并依赖类型推断时，这种模式可能会导致一些问题。默认情况下，TypeScript 从赋值推断数组类型。数组是具有相同元素在每个位置的开放集合：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'So TypeScript thinks that `person` is an array, where each element can be either
    a string or a number, and it allows for plenty of elements after the original
    two. This means when you’re destructuring, each element is also of type `string`
    or `number`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，TypeScript 认为 `person` 是一个数组，其中每个元素可以是字符串或数字，并允许在原始两个元素之后有大量元素。这意味着在解构时，每个元素也是`string`或`number`类型：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: That makes a comfortable pattern in JavaScript really cumbersome in Typescript.
    You would need to do control flow checks to narrow the type to the actual one,
    where it should be clear from the assignment that this is not necessary.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得 JavaScript 中的一个舒适模式在 TypeScript 中变得非常繁琐。您需要进行控制流检查以缩小到实际类型，而实际上从赋值中应该明确这是不必要的。
- en: Whenever you think you need to do extra work in JavaScript just to satisfy TypeScript,
    there’s usually a better way. In that case, you can use tuple types to be more
    specific about how your array should be interpreted.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您认为在 JavaScript 中需要额外工作仅仅是为了满足 TypeScript 时，通常都有更好的方法。在这种情况下，您可以使用元组类型来更具体地指定数组应如何解释。
- en: Tuple types are a sibling of array types that work on a different semantic.
    While arrays can be potentially endless in size and each element is of the same
    type (no matter how broad), tuple types have a fixed size, and each element has
    a distinct type.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 元组类型是数组类型的一个类似物，但其语义不同。虽然数组可能大小无限，并且每个元素都是相同类型的（无论多宽泛），元组类型具有固定的大小，并且每个元素具有不同的类型。
- en: 'All you need to do to get tuple types is to explicitly annotate:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取元组类型，您只需显式注释：
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Fantastic! Tuple types have a fixed length; this means the length is also encoded
    in the type. So assignments that go out of bounds are not possible; TypeScript
    will throw an error:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！元组类型具有固定的长度；这意味着长度也编码在类型中。因此，不可能出现越界的赋值；TypeScript 将抛出错误：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'TypeScript also allows you to add labels to tuple types. This is just metainformation
    for editors and compiler feedback, but it allows you to be clearer about what
    to expect from each element:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 还允许您向元组类型添加标签。这只是编辑器和编译器反馈的元信息，但它允许您更清楚地了解每个元素的期望值：
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This will help you and your colleagues to understand what to expect, just like
    with object types.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这将帮助您和您的同事理解期望值，就像对象类型一样。
- en: 'Tuple types can also be used to annotate function arguments. This function:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 元组类型还可以用于注释函数参数。这个函数：
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'can also be written with tuple types:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用元组类型编写：
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And you can be very flexible in defining it:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 而且您可以非常灵活地定义它：
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'These are also known as *rest* elements, something that we have in JavaScript
    that allow you to define functions with an almost limitless argument list; when
    it is the last element, the *rest* element sucks all excess arguments in. When
    you need to collect arguments in your code, you can use a tuple before you apply
    them to your function:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这些也被称为*剩余*元素，在 JavaScript 中我们有这样的功能，允许您定义几乎无限的参数列表；当它是最后一个元素时，*剩余*元素会吸收所有多余的参数。当您需要在代码中收集参数时，可以在将它们应用到函数之前使用一个元组：
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Tuple types are useful for many scenarios. For more information about tuple
    types, see Chapters [7](ch07.html#ch07) and [10](ch10.html#ch10).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 元组类型在许多场景中非常有用。有关元组类型的更多信息，请参见第 [7](ch07.html#ch07) 章和第 [10](ch10.html#ch10)
    章。
- en: 2.5 Understanding Interfaces Versus Type Aliases
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.5 理解接口与类型别名之间的区别
- en: Problem
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: 'TypeScript declares object types in two ways: interfaces and type aliases.
    Which one should you use?'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 以两种方式声明对象类型：接口和类型别名。您应该使用哪一种？
- en: Solution
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use type aliases for types within your project’s boundary, and use interfaces
    for contracts that are meant to be consumed by others.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目边界内部使用类型别名，对于供他人使用的合同，请使用接口。
- en: Discussion
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Both approaches to defining object types have been the subject of many blog
    articles over the years. And all of them became outdated over time. As of this
    writing there is little difference between type aliases and interfaces. And everything
    that *was* different has been gradually aligned.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，关于定义对象类型的两种方法的许多博客文章都涉及到这两种方法。但它们随时间变得过时。截至本文撰写时，类型别名和接口之间几乎没有区别。所有*以前*的差异已逐渐对齐。
- en: 'Syntactically, the difference between interfaces and type aliases is nuanced:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 从语法上看，接口和类型别名之间的区别是微妙的：
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can use interfaces and type aliases for the same things, in the same scenarios:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在相同的场景中，为相同的事物使用接口和类型别名：
- en: In an implements declaration for classes
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类的实现声明中
- en: As a type annotation for object literals
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为对象字面量的类型注解
- en: For recursive type structures
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于递归类型结构
- en: 'However, there is one important difference that can cause side effects you
    usually don’t want to deal with: interfaces allow for declaration merging, but
    type aliases don’t. Declaration merging allows for adding properties to an interface
    even after it has been declared:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个重要的区别可能会引起通常不想处理的副作用：接口允许声明合并，但类型别名不允许。声明合并允许在接口已声明之后添加属性：
- en: '[PRE32]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'TypeScript often uses this technique in *lib.d.ts* files, making it possible
    to just add deltas of new JavaScript APIs based on ECMAScript versions. This is
    a great feature if you want to extend, for example, `Window`, but it can backfire
    in other scenarios, for example:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript经常在*lib.d.ts*文件中使用这种技术，这样只需添加基于ECMAScript版本的新JavaScript API的增量。例如，如果你想扩展`Window`，这是一个很好的特性，但在其他情况下可能会适得其反：
- en: '[PRE33]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: So, where does the `entries()` method come from? It’s a DOM API! `FormData`
    is one of the interfaces provided by browser APIs, and there are a lot of them.
    They are globally available, and nothing keeps you from extending those interfaces.
    And you get no notification if you do.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，`entries()`方法是从哪里来的呢？这是一个DOM API！`FormData`是浏览器API提供的接口之一，而且还有很多类似的接口。它们是全局可用的，如果你扩展这些接口，是不会收到任何通知的。
- en: You can of course argue about proper naming, but the problem persists for all
    interfaces that you make available globally, maybe from some dependency where
    you aren’t even aware they add an interface to the global space.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以争论正确的命名，但这个问题会影响你所提供的所有全局接口，甚至是一些依赖项中的接口，你甚至可能不知道它们向全局空间添加了一个接口。
- en: 'Changing this interface to a type alias immediately makes you aware of this
    problem:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个接口更改为类型别名会立即让你意识到这个问题：
- en: '[PRE34]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Declaration merging is a fantastic feature if you are creating a library that
    is consumed by other parts in your project, maybe even other projects written
    entirely by other teams. It allows you to define an interface that describes your
    application but allows your users to adapt it to reality. Think of a plug-in system,
    where loading new modules enhances functionality: declaration merging is a feature
    that you do not want to miss.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在创建一个被项目中其他部分消费的库，甚至是完全由其他团队编写的其他项目，声明合并是一个非常棒的特性。它允许你定义一个描述你的应用程序的接口，但允许用户根据实际情况进行调整。想象一个插件系统，加载新模块增强功能：声明合并是一个你不想错过的特性。
- en: Within your module’s boundaries, however, using type aliases prevents you from
    accidentally reusing or extending already declared types. Use type aliases when
    you don’t expect others to consume them.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在你模块的边界内，使用类型别名可以防止你意外重用或扩展已声明的类型。当你不希望其他人使用它们时，请使用类型别名。
- en: Performance
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 性能
- en: Using type aliases over interfaces has sparked some discussion, as interfaces
    have been considered much more performant in their evaluation than type aliases,
    even resulting in a performance recommendation on the official [TypeScript wiki](https://oreil.ly/8Y0hP).
    This recommendation should be taken with a grain of salt.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在接口的评估中，使用类型别名而不是接口引发了一些讨论，因为接口在其评估中被认为更为高效，甚至在官方[TypeScript wiki](https://oreil.ly/8Y0hP)上也有性能建议。这些建议应该持保留态度。
- en: 'On creation, simple type aliases may perform faster than interfaces because
    interfaces are never closed and might be merged with other declarations. But interfaces
    may perform faster in other places because they’re known ahead of time to be object
    types. Ryan Canavaugh from the TypeScript team expects performance differences
    to be measurable with an extraordinary number of interfaces or type aliases to
    be declared: around five thousand according to [this tweet](https://oreil.ly/Y_2oS).'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建时，简单的类型别名可能比接口执行更快，因为接口永远不会关闭，并且可能与其他声明合并。但是，接口在其他地方可能执行得更快，因为它们在预先知道要成为对象类型。来自
    TypeScript 团队的 Ryan Canavaugh 预计在声明了非常多的接口或类型别名时，性能差异将是可测量的：大约在[这条推文](https://oreil.ly/Y_2oS)中说明了这一点。
- en: If your TypeScript code base doesn’t perform well, it’s not because you declared
    too many type aliases instead of interfaces, or vice versa.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 TypeScript 代码库性能不佳，这并不是因为你声明了太多类型别名而不是接口，或者反之。
- en: 2.6 Defining Function Overloads
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.6 定义函数重载
- en: Problem
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Your function’s API is very flexible and allows for arguments of various types,
    where context is important. This is hard to type in just a single function signature.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你的函数 API 非常灵活，允许不同类型的参数，其中上下文非常重要。这在单个函数签名中很难类型化。
- en: Solution
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use function overloads.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数重载。
- en: Discussion
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: JavaScript is very flexible when it comes to function arguments. You can pass
    basically any parameters, of any length. As long as the function body treats the
    input correctly, you’re good. This allows for very ergonomic APIs, but it’s also
    very tough to type.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 在处理函数参数时非常灵活。你可以传递基本上任何长度的任何参数。只要函数体正确处理输入，你就没问题。这使得 API 非常符合人体工程学，但同时也非常难以类型化。
- en: 'Think of a conceptual task runner. With a `task` function you define new tasks
    by name and either pass a callback or pass a list of other tasks to be executed.
    Or both—a list of tasks that needs to be executed *before* the callback runs:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个概念上的任务运行器。通过 `task` 函数，你可以按名称定义新任务，然后传递回调函数或传递要执行的其他任务列表。或者两者兼有——在回调运行*之前*，需要执行的任务列表：
- en: '[PRE35]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If you’re thinking, “this looks a lot like Gulp six years ago,” you’re right.
    Its flexible API where you couldn’t do much wrong was also one of the reasons
    Gulp was so popular.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得，“这看起来很像六年前的 Gulp”，你是对的。它的灵活 API 允许你几乎无所不能，这也是 Gulp 如此流行的原因之一。
- en: Typing functions like this can be a nightmare. Optional arguments, different
    types at the same position—this is tough to do even if you use union types:^([1](ch02.html#id500))
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 类型函数的编写可能会是一场噩梦。可选参数，相同位置的不同类型——即使使用联合类型也很难处理：^([1](ch02.html#id500))
- en: '[PRE36]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This catches all variations from the preceding example, but it’s also wrong,
    as it allows for combinations that don’t make any sense:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这会捕捉到前面示例的所有变化，但它也是错误的，因为它允许不合理的组合：
- en: '[PRE37]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Thankfully, TypeScript has a way to solve problems like this: function overloads.
    Its name hints at similar concepts from other programming languages: the same
    defintion but with different behavior. The biggest difference in TypeScript, as
    opposed to other programming languages, is that function overloads work only on
    a type system level and have no effect on the actual implementation.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，TypeScript 有一种方法可以解决这类问题：函数重载。它的名字暗示了与其他编程语言相似的概念：相同的定义但具有不同的行为。与其他编程语言相比，TypeScript
    最大的不同在于函数重载仅在类型系统层级上工作，并不影响实际实现。
- en: 'The idea is that you define every possible scenario as its own function signature.
    The last function signature is the actual implementation:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 思路是你将每种可能的情况定义为其自己的函数签名。最后一个函数签名是实际的实现：
- en: '[PRE38]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: A couple of things are important to note here.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几件重要的事情需要注意。
- en: First, TypeScript only picks up the declarations before the actual implementation
    as possible types. If the actual implementation signature is also relevant, duplicate
    it.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，TypeScript 只会选取实际实现之前的声明作为可能的类型。如果实际实现的签名也相关，则会重复声明。
- en: Also, the actual implementation function signature can’t be anything. TypeScript
    checks if the overloads can be implemented with the implementation signature.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，实际的实现函数签名不能是任何东西。TypeScript 检查重载是否可以使用实现签名实现。
- en: 'If you have different return types, it is your responsibility to make sure
    that inputs and outputs match:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有不同的返回类型，你有责任确保输入和输出匹配：
- en: '[PRE39]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The implementation signature usually works with a very broad type, which means
    you have to do a lot of checks that you would need to do in JavaScript anyway.
    This is good as it urges you to be extra careful.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 实现签名通常与非常广泛的类型一起工作，这意味着您必须进行许多在JavaScript中无论如何都需要做的检查。这是件好事，因为它促使您格外小心。
- en: 'If you need overloaded functions as their own type, to use them in annotations
    and assign multiple implementations, you can always create a type alias:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要将重载函数作为它们自己的类型使用，以便在注释中使用并分配多个实现，您总是可以创建一个类型别名：
- en: '[PRE40]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As you can see, you only need the type system overloads, not the actual implementation
    definition.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，您只需要类型系统的重载，而不是实际的实现定义。
- en: 2.7 Defining this Parameter Types
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.7 定义此参数类型
- en: Problem
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You are writing callback functions that make assumptions about `this`, but you
    don’t know how to define `this` when writing the function standalone.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您正在编写对`this` 做出假设的回调函数，但在编写函数独立时不知道如何定义`this`。
- en: Solution
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Define a `this` parameter type at the beginning of a function signature.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数签名的开头定义一个`this` 参数类型。
- en: Discussion
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'One source of confusion for aspiring JavaScript developers is the ever-changing
    nature of the `this` object pointer:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于渴望成为JavaScript开发者的人来说，一个困惑的来源是`this` 对象指针的不断变化性质：
- en: Sometimes when writing JavaScript, I want to shout, “This is ridiculous!” But
    then I never know what *this* refers to.
  id: totrans-183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有时在编写JavaScript时，我想大声说：“这太荒谬了！”但我从来不知道* this * 指的是什么。
- en: ''
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Unknown JavaScript developer
  id: totrans-185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 未知的JavaScript开发者
- en: The preceding statement is true especially if your background is a class-based
    object-oriented programming language, where `this` always refers to an instance
    of a class. `this` in JavaScript is entirely different but not necessarily harder
    to understand. What’s more, TypeScript can greatly help get more closure about
    `this` in usage.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 前述声明尤其适用于您的背景是基于类的面向对象编程语言的情况，其中`this` 总是指向类的实例。JavaScript中的`this` 完全不同，但并不一定更难理解。更重要的是，TypeScript可以在使用中极大地帮助理解`this`。
- en: '`this` lives within the scope of a function, and that points to an object or
    value bound to that function. In regular objects, `this` is pretty straightforward:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`this` 存在于函数的作用域中，并且指向绑定到该函数的对象或值。在常规对象中，`this` 是非常简单明了的：'
- en: '[PRE41]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'But functions are values in JavaScript, and they can be bound to a different
    context, effectively changing the value of `this`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在JavaScript中，函数是值，它们可以绑定到不同的上下文，从而有效地改变`this` 的值：
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'It doesn’t help that the semantics of `this` change again if you use arrow
    functions instead of regular functions:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用箭头函数而不是常规函数，则`this` 的语义再次改变也没有帮助：
- en: '[PRE43]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: With TypeScript, we can get more information on what `this` is and, more importantly,
    what it’s supposed to be through `this` parameter types.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TypeScript，我们可以通过`this` 参数类型获得关于`this` 是什么以及更重要的是应该是什么的更多信息。
- en: 'Take a look at the following example. We access a button element via DOM APIs
    and bind an event listener to it. Within the callback function, `this` is of type
    `HT⁠ML⁠Bu⁠tt⁠on​El⁠em⁠ent⁠`, which means you can access properties like `classList`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的例子。我们通过DOM API访问按钮元素并将事件侦听器绑定到它。在回调函数中，`this` 的类型是`HT⁠ML⁠Bu⁠tt⁠on​El⁠em⁠ent⁠`，这意味着您可以访问`classList`
    等属性：
- en: '[PRE44]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The information on `this` is provided by the `addEventListener` function. If
    you extract your function in a refactoring step, you retain the functionality,
    but TypeScript will error, as it loses context for `this`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`addEventListener` 函数提供关于`this` 的信息。如果您在重构步骤中提取函数，则保留功能，但TypeScript将出错，因为它失去了`this`
    的上下文：'
- en: '[PRE45]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The trick is to tell TypeScript that `this` is supposed to be a specific type.
    You can do this by adding a parameter at the very first position in your function
    signature named `this`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 诀窍在于告诉TypeScript `this` 应该是特定类型。您可以通过在函数签名的第一个位置添加名为`this` 的参数来做到这一点：
- en: '[PRE46]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This argument gets removed once compiled. TypeScript now has all the information
    it needs to make sure `this` needs to be of type `HTMLButtonElement`, which also
    means that you get errors once you use `handleToggle` in a different context:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦编译，此参数将被移除。TypeScript 现在具有确保`this` 必须是`HTMLButtonElement` 类型的所有信息，这也意味着一旦您在不同上下文中使用`handleToggle`，您会收到错误：
- en: '[PRE47]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You can make `handleToggle` even more useful if you define `this` to be `HTMLElement`,
    a supertype of `HTMLButtonElement`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您定义`this` 为`HTMLElement`，它比`HTMLButtonElement` 的超类型更有用，您可以使`handleToggle`
    更加实用：
- en: '[PRE48]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'When working with `this` parameter types, you might want to use two helper
    types that can either extract or remove `this` parameters from your function type:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理 `this` 参数类型时，您可能希望使用两个辅助类型，可以从函数类型中提取或删除 `this` 参数。
- en: '[PRE49]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: There are more helper types for `this` in classes and objects. See more in Recipes
    [4.8](ch04.html#ch04_this_type) and [11.8](ch11.html#ch11_this_return).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 类和对象中还有更多关于 `this` 的辅助类型。在《食谱》[4.8](ch04.html#ch04_this_type) 和 [11.8](ch11.html#ch11_this_return)
    中查看更多内容。
- en: 2.8 Working with Symbols
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.8 使用符号工作
- en: Problem
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You see the type `symbol` popping up in some error messages, but you don’t know
    what symbols mean or how you can use them.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到类型 `symbol` 在某些错误消息中弹出，但您不知道符号的含义或如何使用它们。
- en: Solution
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Create symbols for object properties you want to be unique and not iterable.
    They’re great for storing and accessing sensitive information.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为您希望是唯一且不可迭代的对象属性创建符号。它们非常适合存储和访问敏感信息。
- en: Discussion
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: '`symbol` is a primitive data type in JavaScript and TypeScript, which, among
    other things, can be used for object properties. Compared to `number` and `string`,
    symbols have some unique features.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`symbol` 是 JavaScript 和 TypeScript 中的原始数据类型，除其他用途外，还可用于对象属性。与 `number` 和 `string`
    相比，符号具有一些独特的特性。'
- en: 'Symbols can be created using the `Symbol()` factory function:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `Symbol()` 工厂函数创建符号：
- en: '[PRE50]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '`Symbol` has no constructor function. The parameter is an optional description.
    By calling the factory function, `TITLE` is assigned the unique value of this
    freshly created symbol. This symbol is now unique and distinguishable from all
    other symbols, and it doesn’t clash with any other symbols that have the same
    description:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`Symbol` 没有构造函数。参数是可选的描述。通过调用工厂函数，`TITLE` 被分配了这个新创建符号的唯一值。此符号现在是唯一的，与所有其他具有相同描述的符号不同，并且不会与任何其他具有相同描述的符号冲突：'
- en: '[PRE51]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The description helps you to get info on the symbol during development time:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 描述在开发时帮助您获取符号信息：
- en: '[PRE52]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Symbols are great if you want to have comparable values that are exclusive
    and unique. For runtime switches or mode comparisons:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想拥有可比较且独特的值进行运行时切换或模式比较，则符号非常适合：
- en: '[PRE53]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Symbols also work as property keys but are not iterable, which is great for
    serialization:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 符号也可以作为属性键，但不可迭代，这对于序列化非常有用：
- en: '[PRE54]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'A global symbols registry allows you to access tokens across your whole application:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 全局符号注册表允许您跨整个应用程序访问令牌：
- en: '[PRE55]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The first call to `Symbol.for` creates a symbol, and the second call uses the
    same symbol. If you store the symbol value in a variable and want to know the
    key, you can use `Symbol.keyFor()`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用 `Symbol.for` 创建一个符号，第二次调用使用相同的符号。如果您将符号值存储在变量中并想知道键，您可以使用 `Symbol.keyFor()`：
- en: '[PRE56]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Nifty!
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 很巧妙！
- en: 'TypeScript has full support for symbols, and they are prime citizens in the
    type system. `symbol` itself is a data type annotation for all possible symbols.
    See the `ex⁠ten⁠d​Ob⁠je⁠ct` function in the preceding code block. To allow for
    all symbols to extend our object, we can use the `symbol` type:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 对符号提供了全面的支持，它们是类型系统中的主要成员。`symbol` 本身是所有可能符号的数据类型注解。请参见上述代码块中的 `ex⁠ten⁠d​Ob⁠je⁠ct`
    函数。为了允许所有符号扩展我们的对象，我们可以使用 `symbol` 类型：
- en: '[PRE57]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: There’s also the subtype `unique symbol`. A `unique symbol` is closely tied
    to the declaration, allowed only in `const` declarations, and referencing this
    exact symbol and nothing else.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 还有子类型 `unique symbol`。`unique symbol` 与声明紧密相关，仅允许在 `const` 声明中使用，并引用这个确切的符号，而不是其他任何符号。
- en: You can think of a nominal type in TypeScript for a very nominal value in JavaScript.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将 TypeScript 中的名义类型视为 JavaScript 中非常名义化的值。
- en: 'To get to the type of `unique symbol`, you need to use the `typeof` operator:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 `unique symbol` 的类型，您需要使用 `typeof` 运算符：
- en: '[PRE58]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: At the time of writing, the only possible nominal type is TypeScript’s structural
    type system.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，唯一可能的名义类型是 TypeScript 的结构类型系统。
- en: Symbols stand at the intersection between nominal and opaque types in TypeScript
    and JavaScript. They are the closest things we get to nominal type-checks at runtime.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 符号位于 TypeScript 和 JavaScript 中名义类型与不透明类型的交集。它们是我们在运行时最接近名义类型检查的东西。
- en: 2.9 Understanding Value and Type Namespaces
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.9 理解值和类型命名空间
- en: Problem
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: It’s confusing that you can use certain names as type annotations and not others.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 令人困惑的是，您可以将某些名称用作类型注解，而不能用作其他名称。
- en: Solution
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Learn about type and value namespaces, and which names contribute to what.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 了解类型和值命名空间，以及哪些名称对应于什么。
- en: Discussion
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: TypeScript is a superset of JavaScript, which means it adds more things to an
    already existing and defined language. Over time you learn to spot which parts
    are JavaScript and which parts are TypeScript.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 是 JavaScript 的超集，这意味着它在已有的、已定义的语言基础上添加了更多内容。随着时间的推移，你会学会辨别哪些部分是 JavaScript，哪些部分是
    TypeScript。
- en: It really helps to see TypeScript as this additional layer of types upon regular
    JavaScript, a thin layer of metainformation that will be peeled off before your
    JavaScript code runs in one of the available runtimes. Some people even speak
    about TypeScript code “erasing to JavaScript” once compiled.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 真的很有帮助将 TypeScript 视为常规 JavaScript 上的这一额外类型层，一层薄薄的元信息，在 JavaScript 代码在可用的运行时之一运行之前会被剥离。一些人甚至谈论
    TypeScript 代码一旦编译后“擦除到 JavaScript”。
- en: 'TypeScript being this layer on top of JavaScript also means that different
    syntax contributes to different layers. While a `function` or `const` creates
    a name in the JavaScript part, a `type` declaration or an `interface` contributes
    a name in the TypeScript layer:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 作为 JavaScript 顶层的这一层还意味着不同的语法贡献给不同的层。虽然`function`或`const`在 JavaScript
    部分创建了一个名称，但`type`声明或`interface`贡献了 TypeScript 层的名称：
- en: '[PRE59]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We also say that declarations contribute a name to either the *type namespace*
    or the *value namespace*. Since the type layer is on top of the value layer, it’s
    possible to consume values in the type layer, but not vice versa. We also have
    explicit keywords for that:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还说声明会向*类型命名空间*或*值命名空间*贡献名称。由于类型层位于值层之上，可以在类型层消费值，但反之则不行。我们还有专门的关键字用于此目的：
- en: '[PRE60]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '`typeof` creates a name available in the type layer from the value layer below.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`typeof`从下面的值层创建一个在类型层可用的名称。'
- en: 'It gets irritating when there are declaration types that create both types
    and values. Classes, for instance, can be used in the TypeScript layer as a type
    as well as in JavaScript as a value:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当存在既创建类型又创建值的声明类型时，会变得很恼人。例如，类可以在 TypeScript 层作为类型使用，也可以在 JavaScript 中作为值使用：
- en: '[PRE61]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: And naming conventions can trick you. Usually, we define classes, types, interfaces,
    enums, and so on with a capital first letter. And even if they may contribute
    values, they for sure contribute types. Well, until you write uppercase functions
    for your React app, as the convention dictates.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 命名约定可能会让你困惑。通常，我们用大写字母开头定义类、类型、接口、枚举等。即使它们可能贡献值，它们肯定也贡献了类型。嗯，直到你为 React 应用程序编写大写函数，因为惯例要求如此。
- en: 'If you’re used to using names as types and values, you’re going to scratch
    your head if you suddenly get a good old “TS2749: *YourType* refers to a value,
    but is being used as a type” error:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你习惯于将名称用作类型和值，突然遇到旧有的“TS2749: *YourType* 指的是一个值，但却被用作类型”错误会让你摸不着头脑：'
- en: '[PRE62]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This is where TypeScript can get really confusing. What is a type, what is a
    value, why do we need to separate them, and why doesn’t this work like in other
    programming languages? Suddenly, you are confronted with `typeof` calls or even
    the `InstanceType` helper type, because you realize that classes actually contribute
    two types (see [Chapter 11](ch11.html#ch11)).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 TypeScript 可以变得非常令人困惑的地方。什么是类型，什么是值，为什么我们需要将它们分开，为什么这不像其他编程语言那样工作？突然之间，你遇到了`typeof`调用或者甚至是`InstanceType`辅助类型，因为你意识到类实际上贡献了两种类型（见[第
    11 章](ch11.html#ch11)）。
- en: 'Classes contribute a name to the type namespace, and since TypeScript is a
    structural type system, they allow values that have the same shape as an instance
    of a certain class. So this is allowed:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 类在类型命名空间中贡献名称，并且由于 TypeScript 是一个结构类型系统，它们允许具有与某个类实例相同形状的值。因此这是允许的：
- en: '[PRE63]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'However, `instanceof` checks, which are working entirely in the value namespace
    and just have implications in the type namespace, would fail, as objects with
    the same shape may have the same properties but are not an actual *instance* of
    a class:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，完全在值命名空间中工作并且仅在类型命名空间中产生影响的`instanceof`检查将失败，因为具有相同形状的对象可能具有相同的属性，但不是类的实际*实例*：
- en: '[PRE64]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: So it’s useful to understand what contributes types and what contributes value.
    [Table 2-1](#table2_1), adapted from the TypeScript docs, sums it up nicely.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，了解是什么贡献类型，什么贡献值是很有用的。来自 TypeScript 文档修改的[表 2-1](#table2_1)，概括得很好。
- en: Table 2-1\. Type and value namespaces
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-1\. 类型和值命名空间
- en: '| Declaration type | Type | Value |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| 声明类型 | 类型 | 值 |'
- en: '| --- | --- | --- |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Class | X | X |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| 类 | X | X |'
- en: '| Enum | X | X |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| 枚举 | X | X |'
- en: '| Interface | X |  |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| 接口 | X |  |'
- en: '| Type Alias | X |  |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| 类型别名 | X |  |'
- en: '| Function |  | X |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| 函数 |  | X |'
- en: '| Variable |  | X |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| 变量 |  | X |'
- en: If you stick with functions, interfaces (or type aliases, see [Recipe 2.5](#ch02_item_interfaces_vs_types)),
    and variables at the beginning, you will get a feel for what you can use where.
    If you work with classes, think about the implications a bit longer.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你坚持使用函数、接口（或类型别名，请参见[Recipe 2.5](#ch02_item_interfaces_vs_types)）和变量开始学习，你会对在何处可以使用它们有所感觉。如果你使用类，考虑其影响可能需要更长时间。
- en: ^([1](ch02.html#id500-marker)) Union types are a way to combine two different
    types into one (see more in [Chapter 3](ch03.html#ch03)).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch02.html#id500-marker)) 联合类型是将两种不同类型组合成一种的一种方法（详见[第三章](ch03.html#ch03)）。
