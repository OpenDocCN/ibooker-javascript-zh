- en: Chapter 10\. React Alternatives
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第十章 React 的替代方案
- en: In the previous chapter, we covered the emerging topic of React Server Components
    (RSCs) in depth. We explored how they work, when to use them, and why they require
    powerful tools such as next-generation bundlers, routers, and more. We further
    differentiated between server components and server rendering, and even implemented
    a bare-bones RSCs renderer from scratch in order to understand the underlying
    mechanism for ourselves.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们深入讨论了 React 服务器组件（RSCs）的新兴主题。我们探讨了它们的工作原理、使用时机以及为什么它们需要像下一代捆绑器、路由器等强大的工具。我们进一步区分了服务器组件和服务器渲染，并甚至从头开始实现了一个简单的
    RSC 渲染器，以便理解其底层机制。
- en: As we transition into exploring alternatives to React, this understanding of
    the role and function of frameworks and server components will provide valuable
    context. Each library we’ll discuss in this chapter also ships with its associated
    frameworks, and many of the principles and trade-offs we’ve covered in React will
    apply to these ecosystems as well.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们开始探索 React 的替代方案，对框架和服务器组件的角色和功能的理解将提供宝贵的背景信息。本章中讨论的每个库都附带其关联的框架，并且我们在 React
    中涵盖的原则和权衡将同样适用于这些生态系统。
- en: 'As we pivot our attention from React and its ecosystem, let’s delve into some
    popular alternatives in the frontend development ecosystem: Vue.js, Angular, Svelte,
    Solid, and Qwik. Each library and framework introduces its own reactivity model
    and ways of thinking about UI development. Understanding these different models
    can broaden our perspective and give us more tools to solve problems in our projects.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将注意力从 React 及其生态系统转向时，让我们深入了解前端开发生态系统中的一些流行替代品：Vue.js、Angular、Svelte、Solid
    和 Qwik。每个库和框架都介绍了其自己的响应性模型和UI开发思路。了解这些不同的模型可以拓宽我们的视野，并为解决项目中的问题提供更多工具。
- en: Vue.js
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue.js
- en: Vue.js is a popular JavaScript framework for building user interfaces. Developed
    by Evan You, an ex-Google engineer who worked on AngularJS projects, Vue.js seeks
    to extract the good parts of Angular, but in a lighter, more maintainable, and
    less opinionated package.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js 是一个流行的用于构建用户界面的 JavaScript 框架。由 Evan You 开发，他是一位曾在 AngularJS 项目上工作的前
    Google 工程师。Vue.js 旨在提取 Angular 的优点，但在更轻量、更易维护和少观点化的包中实现。
- en: One of Vue’s most distinctive features is the unobtrusive reactivity system.
    Component state consists of reactive JavaScript objects. When you modify them,
    the view updates. It makes state management simple and intuitive, but it’s also
    important to understand how it works to avoid some common gotchas.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Vue 的一个最显著特点是非侵入式的响应式系统。组件状态由响应式 JavaScript 对象组成。当您修改它们时，视图会更新。它使状态管理简单直观，但理解其工作原理也很重要，以避免一些常见的陷阱。
- en: 'In Vue’s reactivity model, it intercepts the reading and writing of object
    properties. Vue 2 used getter/setters exclusively due to browser support limitations,
    but in Vue 3, proxies are used for reactive objects and getter/setters are used
    for refs. From the Vue docs, here’s some pseudocode that illustrates how they
    work:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vue 的响应性模型中，它拦截对象属性的读取和写入。Vue 2 由于浏览器支持的限制，仅使用 getter/setter，但在 Vue 3 中，响应式对象使用代理，而
    ref 使用 getter/setter。从 Vue 文档中，以下是一些伪代码，说明了它们的工作原理：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is somewhat oversimplified, but here we demonstrate a simplistic reactive
    system utilizing proxies. The `reactive` function takes an object and returns
    a proxy of that object, which intercepts `get` and `set` operations. On a `get`
    operation, it calls the `track` function and returns the requested property. On
    a `set` operation, it updates the value and calls the `trigger` function.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点过于简化，但在这里我们演示了一个简单的响应式系统，利用代理实现。`reactive` 函数接受一个对象并返回该对象的代理，拦截 `get` 和 `set`
    操作。在 `get` 操作时，它调用 `track` 函数并返回请求的属性。在 `set` 操作时，它更新值并调用 `trigger` 函数。
- en: The `ref` function, on the other hand, encapsulates a value within an object
    and provides reactive `get` and `set` operations for that value, similar to the
    proxy but with a different structure, ensuring that the `track` and `trigger`
    functions are called appropriately during access or modification.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`ref` 函数将一个值封装在对象中，并为该值提供响应式的 `get` 和 `set` 操作，类似于代理，但具有不同的结构，确保在访问或修改期间适当地调用
    `track` 和 `trigger` 函数。
- en: 'This is a very simple example of a reactive system, but it demonstrates the
    basic principles of Vue’s reactivity model. This reactivity model can even be
    used to update the DOM. We can implement simple “reactive rendering” like this:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的反应性系统示例，但它展示了 Vue 响应性模型的基本原则。这种响应性模型甚至可以用于更新 DOM。我们可以实现简单的“反应式渲染”如下：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In fact, this is pretty close to how a Vue component keeps the state and the
    DOM in sync—each component instance creates a reactive effect to render and update
    the DOM. Of course, Vue components use much more efficient ways to update the
    DOM than `innerHTML`, but this should be enough to give you a basic idea of how
    it works.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这与 Vue 组件保持状态和 DOM 同步的方式非常接近——每个组件实例创建一个反应性效果来渲染和更新 DOM。当然，Vue 组件使用比`innerHTML`更高效的方法来更新
    DOM，但这应该足以让你对它的工作原理有一个基本的了解。
- en: The `ref()`, `computed()`, and `watchEffect()` APIs are all part of Vue’s Composition
    API.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`ref()`、`computed()` 和 `watchEffect()` API 都是 Vue Composition API 的一部分。'
- en: Signals
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信号
- en: Quite a few other frameworks have introduced reactivity primitives similar to
    `refs` from Vue’s Composition API, under the term “signals” that we’ll discuss
    in this chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他框架引入了类似 Vue Composition API 中`refs`的响应性原语，称之为“信号”，我们将在本章讨论。
- en: 'Fundamentally, signals are the same kind of reactivity primitive as Vue `refs`.
    It’s a value container that provides dependency tracking on access, and side-effect
    triggering on mutation. This reactivity-primitive-based paradigm isn’t a particularly
    new concept in the frontend world: it dates back to implementations like Knockout
    observables and Meteor Tracker from more than a decade ago. Vue Options API and
    the React state management library MobX are also based on the same principles
    but hide the primitives behind object properties.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从根本上说，信号与 Vue 的`refs`是同一种响应性原语。它是一个值容器，提供访问时的依赖跟踪，以及在变异时触发副作用。这种基于响应性原语的范式在前端世界并不新鲜：它可以追溯到十多年前的
    Knockout observables 和 Meteor Tracker 的实现。Vue Options API 和 React 状态管理库 MobX 也是基于相同原理，但是隐藏在对象属性背后。
- en: Although not a necessary trait for something to qualify as signals, today the
    concept is often discussed alongside the rendering model where updates are performed
    through fine-grained subscriptions. Due to the use of virtual DOM, Vue currently
    relies on compilers to achieve similar optimizations. However, Vue is also exploring
    a new Solid-inspired compilation strategy (Vapor Mode) that does not rely on virtual
    DOM and takes more advantage of Vue’s built-in reactivity system.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管信号并非作为某种东西的必要特征，但今天这个概念经常与渲染模型一起讨论，其中更新通过精细的订阅进行。由于使用虚拟 DOM，Vue 目前依赖编译器来实现类似的优化。然而，Vue
    还在探索一种新的受 Solid 启发的编译策略（Vapor Mode），不依赖于虚拟 DOM，并更充分利用 Vue 内置的响应性系统。
- en: Simplicity
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单性
- en: 'Vue’s biggest strength is its simplicity. It’s incredibly easy to get started
    with Vue: you can simply include the Vue library in your HTML file in a `<script>`
    tag and start writing Vue components. Vue also provides a CLI tool for scaffolding
    new projects, which can be a great way to get started with a more complex application.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Vue 最大的优势在于它的简单性。使用 Vue 很容易入门：你可以简单地在 HTML 文件中使用`<script>`标签引入 Vue 库，然后开始编写
    Vue 组件。Vue 还提供了一个 CLI 工具来搭建新项目，这可以是开始更复杂应用的好方法。
- en: While we’ve only scratched the surface of Vue.js here, it’s clear that Vue’s
    combination of a powerful reactivity system, a template-based syntax, and a well-structured
    component model make it a compelling option for many developers.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在这里只是浅尝辄止 Vue.js，但很明显，Vue 强大的响应性系统、基于模板的语法和良好结构的组件模型使它成为许多开发者的一个吸引人的选择。
- en: Angular
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular
- en: Angular, developed and maintained by Google, is another well-known player in
    the world of JavaScript frameworks. Angular is a complete, opinionated framework,
    providing its own solutions for a wide range of frontend concerns, from rendering
    and state management to routing and form handling.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Angular，由 Google 开发和维护，是 JavaScript 框架领域中另一个著名的参与者。Angular 是一个完整且具有主见的框架，为前端各种问题提供了自己的解决方案，从渲染和状态管理到路由和表单处理。
- en: Angular introduces a different reactivity model than React. Instead of a virtual
    DOM diffing and reconciliation process, Angular uses a system known as change
    detection.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 引入了与 React 不同的响应性模型。Angular 不使用虚拟 DOM 的差异化和调和过程，而是使用称为变更检测的系统。
- en: In Angular, every component gets a change detector responsible for checking
    the component’s view for changes using a library called Zone.js. Before we proceed,
    let’s talk about this in a little bit more detail.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 中，每个组件都有一个变更检测器，使用一个名为 Zone.js 的库来检查组件视图中的变更。在我们继续之前，让我们稍微详细讨论一下这个。
- en: Change Detection
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变更检测
- en: Change detection is the process through which Angular checks to see whether
    your application state has changed, and if any DOM needs to be updated. At a high
    level, Angular walks your components from top to bottom, looking for changes.
    Angular runs its change detection mechanism periodically so that changes to the
    data model are reflected in an application’s view. Change detection can be triggered
    either manually or through an asynchronous event.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 变更检测是 Angular 用来检查应用程序状态是否已更改以及是否需要更新任何 DOM 的过程。在高层次上，Angular 从上到下遍历组件，寻找变更。Angular
    定期运行其变更检测机制，以便将数据模型的更改反映在应用程序的视图中。变更检测可以通过手动触发或通过异步事件触发。
- en: Change detection is highly optimized and performant, but it can still cause
    slowdowns if the application runs it too frequently. This change detection system
    is a powerful and flexible tool, and Angular provides several strategies out of
    the box for fine-tuning its behavior to optimize performance for different scenarios.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 变更检测高度优化和高性能，但如果应用程序频繁运行变更检测，仍可能导致减速。这种变更检测系统是一个强大且灵活的工具，Angular 提供了几种策略来优化其行为，以适应不同场景的性能需求。
- en: Angular also uses a template syntax, like Vue, but it provides even more powerful
    directives and constructs for manipulating the DOM, such as `*ngIf` for conditionally
    rendering elements and `*ngFor` for rendering lists. This is different from React,
    which uses JSX with in-place JavaScript expressions to render dynamic data.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 也使用模板语法，类似于 Vue，但它提供了更强大的指令和结构来操作 DOM，比如 `*ngIf` 条件性地渲染元素和 `*ngFor`
    渲染列表。这与使用 JSX 的 React 不同，后者使用内置 JavaScript 表达式来渲染动态数据。
- en: Signals
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信号
- en: 'Angular is undergoing some fundamental changes by foregoing dirty-checking
    and introducing its own implementation of a reactivity primitive. The Angular
    Signal API looks like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 正在进行一些根本性的变更，放弃脏检查，并引入自己的响应性原语实现。Angular 信号 API 如下所示：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Compared to Vue refs, Angular’s getter-based API style provides some interesting
    trade-offs when used in Vue components:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Vue 的引用不同，Angular 的基于 getter 的 API 风格在 Vue 组件中使用时提供了一些有趣的权衡。
- en: '`()` is slightly less verbose than `.value`, but updating the value is more
    verbose.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`()` 比 `.value` 略少冗长，但更新值更为冗长。'
- en: 'There is no ref-unwrapping: accessing values always requires `()`. This makes
    value access consistent everywhere. This also means you can pass raw signals down
    as component props.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无需解包引用：访问值始终需要 `()`。这样可以确保在任何地方访问值的一致性。这也意味着可以将原始信号传递为组件的属性。
- en: Angular is something of a Swiss Army knife, providing a wide range of tools
    for building complex applications. Its opinionated nature can be both a strength,
    in terms of the consistency and structure it brings to a codebase, and a limitation,
    in terms of flexibility and the learning curve for developers new to the framework.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 是一种类似瑞士军刀的工具，提供了广泛的工具来构建复杂的应用程序。它的固执己见既是其代码库一致性和结构的优点，也是新开发人员面临的学习曲线和灵活性的限制。
- en: Svelte
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Svelte
- en: Svelte is a radical new approach to building user interfaces. Unlike traditional
    frameworks, Svelte is a compiler that transforms your declarative components into
    efficient imperative code that surgically updates the DOM. As a result, you’re
    able to write high-performance, reactive web applications with less code.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Svelte 是构建用户界面的一种激进新方法。与传统框架不同，Svelte 是一个编译器，将您的声明式组件转换为高效的命令式代码，精确地更新 DOM。因此，您可以用更少的代码编写高性能、响应式的
    Web 应用程序。
- en: 'Svelte’s reactivity model is incredibly simple, yet powerful. Reactive statements
    in Svelte are written with a simple syntax that’s reminiscent of spreadsheet formulas.
    Here’s a basic Svelte component:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Svelte 的响应模型非常简单但功能强大。在 Svelte 中，响应式语句使用简单的语法编写，这让人想起电子表格公式。这里是一个基本的 Svelte
    组件：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this example, the `{count}` syntax in the markup will automatically update
    whenever the `count` variable changes. This is similar to React’s JSX, but with
    one key difference: in Svelte, this reactivity is automatic. You don’t need to
    call a setter function or use any special API to update the DOM; you just assign
    to the variable, and Svelte takes care of the rest.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，标记中的`{count}`语法将在`count`变量更改时自动更新。这类似于 React 的 JSX，但有一个关键的区别：在 Svelte
    中，这种响应性是自动的。您不需要调用设置函数或使用任何特殊的 API 来更新 DOM；您只需分配给变量，Svelte 就会处理其余的工作。
- en: 'Svelte also offers a reactive statement syntax that allows you to compute values
    based on your reactive data:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Svelte 还提供了一种响应式语句语法，允许您根据您的响应式数据计算值：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, `doubleCount` will automatically be updated whenever `count`
    changes. This is reminiscent of computed properties in Vue, but with an arguably
    simpler syntax.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当`count`变化时，`doubleCount`会自动更新。这类似于 Vue 中的计算属性，但语法可能更简单。
- en: The compiler approach taken by Svelte has several advantages. It typically results
    in faster runtime performance because there’s no virtual DOM diffing and patching
    step. Instead, Svelte generates code that updates the DOM directly.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Svelte 采用的编译器方法具有几个优势。通常情况下，这会导致更快的运行时性能，因为没有虚拟 DOM 的差异和修补步骤。相反，Svelte 生成直接更新
    DOM 的代码。
- en: However, this approach also comes with trade-offs. The compiler-centric nature
    of Svelte means that some dynamic capabilities offered by virtual DOM-based frameworks,
    like dynamic component types, can be more cumbersome or verbose to express. Also,
    because the Svelte ecosystem is smaller and younger than those of React, Vue,
    and Angular, there may be fewer resources, libraries, and community solutions
    available.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法也存在一些权衡。Svelte 的编译器中心性意味着一些基于虚拟 DOM 的框架提供的动态能力（如动态组件类型）可能更加笨拙或冗长地表达出来。此外，由于
    Svelte 生态系统比 React、Vue 和 Angular 更小且更年轻，因此可用的资源、库和社区解决方案可能较少。
- en: Runes
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 符文
- en: Runes are symbols that influence the Svelte compiler. Whereas Svelte today uses
    `let`, `=`, the `export` keyword, and the `$:` label to mean specific things,
    runes use *function syntax* to achieve the same things and more.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 符文是影响 Svelte 编译器的符号。虽然今天 Svelte 使用`let`、`= `、`export`关键字和`$:`标签来指代特定事物，符文则使用*函数语法*来实现相同的功能，甚至更多。
- en: 'For example, to declare a piece of reactive state, we can use the `$state`
    rune:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要声明一个响应式状态片段，我们可以使用`$state`符文：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As applications grow in complexity, figuring out which values are reactive and
    which aren’t can get tricky. And the current heuristic only works for `let` declarations
    at the top level of a component, which can cause confusion. Having code behave
    one way inside *.svelte* files and another way inside *.js* can make it hard to
    refactor code, for example, if you need to turn something into a store so that
    you can use it in multiple places.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序复杂度的增加，弄清哪些值是响应式的，哪些不是，可能会变得棘手。当前的启发式方法仅适用于组件顶层的`let`声明，这可能会引起混淆。例如，如果您需要将某些内容转换为存储以便在多个位置使用，则在*.svelte*文件内部和*.js*文件内部的代码行为不一致可能会使重构代码变得困难。
- en: 'With runes, reactivity extends beyond the boundaries of your *.svelte* files.
    Suppose we wanted to encapsulate our counter logic in a way that could be reused
    between components. Today, you would use a custom store in a *.js* or *.ts* file:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有了符文，响应性不再局限于您的*.svelte*文件的边界之内。假设我们想要封装计数器逻辑，以便在组件之间重复使用。今天，您可以在*.js*或*.ts*文件中使用自定义存储：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Because this implements the *store contract*—the returned value has a `subscribe`
    method—we can reference the store value by prefixing the store name with `$`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这实现了*存储契约*——返回值具有`subscribe`方法——我们可以通过在存储名称前加`$`来引用存储值：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This works, but it’s pretty weird! The store API can get rather unwieldy when
    you start doing more complex things. With runes, things get much simpler:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做虽然有效，但感觉有点奇怪！当你开始做更复杂的事情时，存储 API 可能会变得非常难以管理。而有了符文，一切变得简单得多：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that we’re using a `get` property in the returned object, so that `counter.count`
    always refers to the current value rather than the value at the time the function
    was called.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在返回对象中使用了`get`属性，以便`counter.count`始终指向当前值，而不是函数被调用时的值。
- en: Runtime reactivity
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行时响应性
- en: 'Today, Svelte uses *compile-time reactivity*. This means that if you have some
    code that uses the `$:` label to rerun automatically when dependencies change,
    those dependencies are determined when Svelte compiles your component:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，Svelte使用*编译时响应性*。这意味着，如果你有一些使用`$:`标签的代码，以便在依赖项更改时自动重新运行，这些依赖项在Svelte编译组件时确定：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This works well…until it doesn’t. Suppose we refactored the code as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这运作良好……直到它不工作。假设我们将代码重构如下：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Because the `$: area = ...` declaration can only see `width`, it won’t be recalculated
    when `height` changes. As a result, code is hard to refactor, and understanding
    the intricacies of when Svelte chooses to update which values can become rather
    tricky beyond a certain level of complexity.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '因为`$: area = ...`声明只能看到`width`，所以当`height`变化时不会重新计算。因此，代码很难重构，理解Svelte何时选择更新哪些值在一定复杂程度之后可能变得相当棘手。'
- en: 'Svelte 5 introduces the `$derived` and `$effect` runes, which instead determine
    the dependencies of their expressions when they are evaluated:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Svelte 5引入了`$derived`和`$effect`符文，它们在评估表达式时确定其依赖关系：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As with `$state`, `$derived` and `$effect` can also be used in your *.js* and
    *.ts* files.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 与`$state`、`$derived`和`$effect`类似，您也可以在*.js*和*.ts*文件中使用它们。
- en: Signal boost
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 信号放大
- en: Like every other framework, Svelte has come to the realization that Knockout
    was right all along.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他框架一样，Svelte也意识到Knockout一直是正确的。
- en: Svelte 5’s reactivity is powered by *signals*, which are essentially what Knockout
    was doing in 2010\. More recently, signals have been popularized by Solid (more
    on this later) and adopted by a multitude of other frameworks. In Svelte 5, signals
    are an under-the-hood implementation detail rather than something you interact
    with directly.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Svelte 5的响应性由*信号*驱动，这本质上是Knockout在2010年所做的。最近，信号已经被Solid（稍后详细介绍）推广，并被多个其他框架采纳。在Svelte
    5中，信号是一个底层实现细节，而不是直接与之交互的内容。
- en: Solid
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Solid
- en: Solid is a declarative JavaScript library for building user interfaces. It’s
    similar to React in that it provides a component model base, but Solid is based
    on reactive primitives. Instead of using a virtual DOM, Solid uses a fine-grained
    reactivity system to automatically track dependencies and update the DOM directly,
    which can result in more efficient updates.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Solid是一个用于构建用户界面的声明性JavaScript库。它类似于React，提供了一个组件模型基础，但Solid基于响应式原语。Solid不使用虚拟DOM，而是使用细粒度的响应性系统来自动跟踪依赖关系并直接更新DOM，这可能会导致更有效的更新。
- en: 'Here’s an example of a simple Solid component:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的Solid组件示例：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this example, `createSignal` creates a reactive primitive, similar to `useState`
    in React. The key difference is that `count` is a function that returns the current
    value and implicitly registers the dependency for the reactive context. When `setCount`
    is called, it triggers an update for any part of the UI that depends on `count`
    without reinvoking the function components.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`createSignal`创建了一个响应式原语，类似于React中的`useState`。关键区别在于`count`是一个返回当前值并隐式注册依赖关系的函数。当调用`setCount`时，它会触发依赖于`count`的任何UI部分的更新，而不重新调用函数组件。
- en: To contrast this with React, in React the component, `Component` in this case,
    would be reinvoked, including all of the logic inside its block. Thus, the `count`
    value itself is not reactive. In Solid, the `Component` function is never reinvoked,
    but the `count` value itself is reactive and changes whenever `setCount` is called.
    This is called fine-grained reactivity, and it is directly opposite to React’s
    coarse-grained reactivity.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要与React对比，在React中，组件（在这种情况下是`Component`）会被重新调用，包括其块内的所有逻辑。因此，`count`值本身不是响应式的。在Solid中，`Component`函数永远不会被重新调用，但`count`值本身是响应式的，并在调用`setCount`时变化。这被称为细粒度响应性，与React的粗粒度响应性完全相反。
- en: Solid’s fine-grained reactivity system means that it can minimize unnecessary
    updates and avoid the need for a diffing step, resulting in very high performance.
    However, because it’s a relatively new and less widely used library, it may not
    have as many resources and community solutions available as some of the more established
    options.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Solid的细粒度响应性系统意味着它可以最小化不必要的更新，并避免需要差异化步骤，从而实现非常高的性能。然而，由于它是一个相对较新且使用较少的库，可能没有像一些更成熟选项那样多的资源和社区解决方案。
- en: 'Solid’s `createSignal()` API design emphasizes read/write segregation. Signals
    are exposed as a read-only getter and a separate setter:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Solid的`createSignal()` API设计强调了读/写分离。信号作为只读getter和单独的setter公开：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice how the `count` signal can be passed down without the setter. This ensures
    that the state can never be mutated unless the setter is also explicitly exposed.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `count` 信号如何在不使用 setter 的情况下传递。这确保状态除非显式公开 setter，否则不能被修改。
- en: Solid reinvigorated the discussion around signals, and the concept has been
    adopted by many other frameworks and libraries as we’ve seen previously. Everything
    we’ve previously mentioned about signals comes from the work of Ryan Carniato,
    the author of Solid, who somehow single-handedly managed to change the entire
    frontend ecosystem by bringing back a concept from 2010.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Solid 重新点燃了关于信号的讨论，并且这个概念已被许多其他框架和库采纳，正如我们之前看到的。关于信号的所有前述内容都来自于 Solid 的作者 Ryan
    Carniato 的工作，他以某种方式凭借 2010 年的概念单枪匹马地改变了整个前端生态系统。
- en: Qwik
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qwik
- en: Qwik is a unique framework designed to optimize the loading of web pages and
    prioritize user interaction and responsiveness. Unlike traditional frameworks,
    it views web pages as a collection of components that can be independently loaded
    over the network and interacted with on demand. This approach significantly reduces
    the initial load time of the page, enhancing the overall user experience.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Qwik 是一个独特的框架，旨在优化 Web 页面的加载，并优先考虑用户交互和响应能力。与传统框架不同，它将 Web 页面视为可以独立通过网络加载并按需交互的组件集合。这种方法显著减少了页面的初始加载时间，提升了整体用户体验。
- en: Web applications and sites built with Qwik ship with exceedingly small and constant
    initial amounts of JavaScript (~1 kB). The amount of initial JavaScript loaded
    by a Qwik site is constant, as it is the Qwik loader. This is why Qwik is known
    in some circles as “the O(1) framework,” meaning it has a constant load time regardless
    of the size of the application.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Qwik 构建的 Web 应用和站点带有极小且恒定的初始 JavaScript（~1 kB）。Qwik 站点加载的初始 JavaScript 量是恒定的，因为它是
    Qwik 加载器。这就是为什么在某些圈子中称 Qwik 为“O(1) 框架”的原因，意味着无论应用程序大小如何，它的加载时间都是恒定的。
- en: Initially, Qwik loads a bare minimum amount of JavaScript, but then loads components
    and other behaviors as they are needed. This approach allows Qwik to prioritize
    the loading of the most important components first, resulting in a faster initial
    load time and a more responsive user experience.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，Qwik 只加载最少量的 JavaScript，然后根据需要加载组件和其他行为。这种方法使得 Qwik 能够优先加载最重要的组件，从而实现更快的初始加载时间和更响应的用户体验。
- en: 'An essential feature of Qwik is resumability. We covered resumability crudely
    in our chapter on server-side React ([Chapter 6](ch06.html#ch06)), but to recap:
    resumability is a process through which a server rendered snapshot of the initial
    state of the page is sent to the client. As the user opens the page, they interact
    with this static snapshot until they need more interactivity. Then, various behaviors
    load on demand as users continue. This mechanism provides an instant interaction
    opportunity for the user, a characteristic that is not prevalent in many other
    frameworks.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Qwik 的一个重要特性是可恢复性。我们在服务器端 React 的章节中粗略地介绍了可恢复性（[第 6 章](ch06.html#ch06)），但回顾一下：可恢复性是通过将页面的初始状态的服务器渲染快照发送到客户端来实现的。当用户打开页面时，他们与这个静态快照进行交互，直到他们需要更多的互动为止。然后，随着用户继续操作，各种行为按需加载。这种机制为用户提供了即时的交互机会，这是许多其他框架中不多见的特性。
- en: Resumability is far superior to hydration (also covered in [Chapter 6](ch06.html#ch06))
    because it does not require rendering components twice. It also avoids the “uncanny
    valley” of user interfaces where a website is not interactive for a period of
    time after the initial server rendered markup has made it to the browser and before
    the JavaScript has loaded and hydrated the page. Qwik is instant on.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 可恢复性远远优于水合（也在[第 6 章](ch06.html#ch06)中讨论），因为它不需要两次渲染组件。它还避免了用户界面的“奇异谷”，即在初始服务器渲染标记到达浏览器并且
    JavaScript 加载并水合页面之前的一段时间内，网站不具有交互性。Qwik 立即启动。
- en: When comparing Qwik to other popular frameworks such as React, Vue, Svelte,
    or Solid, several differences emerge. While React and Vue also adopt a component-based
    approach, if we’re not careful and intentional about code splitting, we can send
    the entire JavaScript bundle for the application to the client up front, sometimes
    getting into the megabyte zone. This process can lead to longer initial load times,
    especially for large applications. On the other hand, Qwik only loads the components
    and event handlers as they are needed, resulting in faster initial load times
    and a more responsive user experience. Qwik is also clever about prefetching,
    and does so for lazy-loaded elements such that everything is prefetched on initial
    load but only parsed and executed on demand.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在将 Qwik 与其他流行的框架如 React、Vue、Svelte 或 Solid 进行比较时，会发现几个区别。虽然 React 和 Vue 也采用了基于组件的方法，但如果我们在代码拆分方面不小心或不有意识地进行处理，有时可能会一次性向客户端发送整个
    JavaScript 捆绑包，有时会达到几兆字节。这个过程可能导致更长的初始加载时间，特别是对于大型应用程序而言。另一方面，Qwik 只在需要时加载组件和事件处理程序，从而实现更快的初始加载时间和更响应迅速的用户体验。Qwik
    还精于预取，对于延迟加载的元素进行预取，使得所有内容在初始加载时都被预取，但只有在需求时才进行解析和执行。
- en: Qwik, like Svelte and Solid, focuses on performance, but achieves this in different
    ways. Svelte compiles the components to highly efficient imperative code that
    manipulates the DOM directly, while Solid uses a reactive fine-grained reactivity
    model for its components. While also using reactive primitives, Qwik focuses on
    optimizing component loading and making sure the most important ones are available
    as soon as possible.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Qwik，像 Svelte 和 Solid 一样，专注于性能，但通过不同的方式实现这一目标。Svelte 将组件编译为高效的命令式代码，直接操作 DOM，而
    Solid 则使用响应式细粒度的响应模型来处理其组件。Qwik 使用响应式原语，专注于优化组件加载，确保尽快提供最重要的组件。
- en: In terms of developer experience, Qwik offers a simple and intuitive API that
    makes it easy to define and work with components. Qwik components are nearly identical
    to React components in terms of syntax and structure, since they are also expressed
    with JSX (or TSX). This similarity makes it easy for developers to get started
    with Qwik, especially if they’re already familiar with React.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发者体验方面，Qwik 提供了一个简单直观的 API，使得定义和使用组件变得非常容易。Qwik 组件在语法和结构上几乎与 React 组件相同，因为它们也是使用
    JSX（或 TSX）表示的。这种相似性使得开发者可以轻松开始使用 Qwik，特别是如果他们已经熟悉 React 的话。
- en: Moreover, Qwik has interoperability with React, allowing developers to use React
    components in Qwik applications via a `qwikify` utility. This interoperability
    is a significant advantage for developers who want to use Qwik but also want to
    take advantage of the rich ecosystem of React libraries and tools.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Qwik 与 React 具有互操作性，允许开发者通过 `qwikify` 实用程序在 Qwik 应用程序中使用 React 组件。这种互操作性对于希望使用
    Qwik 但也想利用丰富的 React 库和工具生态系统的开发者来说是一个重大优势。
- en: Qwik presents a novel approach to modern web development with its component-based
    and event-driven architecture. Its focus on resumability and prioritized loading
    sets it apart from other frameworks like React, Vue, Svelte, and Solid. While
    each of these tools has its strengths and use cases, Qwik’s unique features make
    it an exciting addition to the landscape of web development frameworks. It could
    be the right choice for developers and teams looking for a performant, user-centric,
    and efficient way to build their web applications.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Qwik 通过其基于组件和事件驱动的架构提出了现代 Web 开发的新方法。它的重点在于可恢复性和优先加载，使其在与 React、Vue、Svelte 和
    Solid 等其他框架相比显得与众不同。虽然每个工具都有其优势和使用案例，但 Qwik 的独特特性使其成为 Web 开发框架领域中令人兴奋的新选择。对于寻求高性能、以用户为中心和高效构建
    Web 应用程序的开发者和团队来说，Qwik 可能是一个正确的选择。
- en: The only drawback of Qwik is that it is still fairly new and does not have quite
    as mature of an ecosystem as React, Vue, or Angular. However, it is gaining traction
    and has a growing community of developers and contributors. As Qwik continues
    to evolve, it will be interesting to see how it compares to other frameworks and
    how it can be used to build even more powerful applications.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Qwik 唯一的缺点是它仍然相对较新，并且没有像 React、Vue 或 Angular 那样成熟的生态系统。但是，它正在获得关注，并且拥有一个不断增长的开发者和贡献者社区。随着
    Qwik 的持续发展，看到它与其他框架的比较及如何用于构建更强大的应用程序将是非常有趣的。
- en: Common Patterns
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见模式
- en: All of these technologies—React, Angular, Qwik, Solid, and Svelte—are solutions
    for creating rich, interactive user interfaces for the web. Though they vary in
    their philosophies, methodologies, and implementation details, they share several
    commonalities that reflect their shared purpose.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些技术——React、Angular、Qwik、Solid 和 Svelte——都是用于为 Web 创建丰富、交互式用户界面的解决方案。尽管它们在哲学、方法论和实现细节上各有不同，但它们共享几个反映它们共同目标的共同点。
- en: Component-Based Architecture
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于组件的架构
- en: One of the primary commonalities among these frameworks and libraries is the
    adoption of a component-based architecture. In a component-based architecture,
    UIs are broken down into individual pieces, or components, each of which is responsible
    for a specific part of the user interface.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些框架和库之间的一个主要共同点是采用组件化架构。在组件化架构中，UI 被拆分成独立的组件，每个组件负责用户界面的特定部分。
- en: Components encapsulate their own state and logic, and they can be composed together
    to build complex UIs. This modularity promotes code reuse, separation of concerns,
    and improved maintainability. In each of these frameworks, components can be functional,
    and they can often be composed, extended, or decorated to create more complex
    components.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 组件封装了自己的状态和逻辑，并可以组合在一起构建复杂的 UI。这种模块化促进了代码重用、关注点分离和提高了可维护性。在这些框架中，组件可以是函数式的，并且通常可以组合、扩展或装饰以创建更复杂的组件。
- en: Declarative Syntax
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明式语法
- en: React, Angular, Qwik, Solid, and Svelte all employ a declarative syntax for
    defining UIs. In a declarative approach, developers specify what the UI should
    look like for a given state, and the framework takes care of updating the UI to
    match that state. This abstracts away the imperative DOM manipulations that can
    make UI development tedious and error prone.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: React、Angular、Qwik、Solid 和 Svelte 都使用声明式语法来定义 UI。在声明式方法中，开发者指定了给定状态下 UI 的外观，框架负责更新
    UI 以匹配该状态。这抽象了繁琐且容易出错的命令式 DOM 操作。
- en: All these technologies provide their own flavor of a templating language for
    writing declarative UIs. React, Qwik, and Solid use JSX; Angular uses its own
    HTML-based template syntax; and Svelte has its HTML-inspired language.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些技术都提供了自己的模板语言来编写声明式 UI。React、Qwik 和 Solid 使用 JSX；Angular 使用其自己的基于 HTML 的模板语法；而
    Svelte 则有其受 HTML 启发的语言。
- en: Updates
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新
- en: All these libraries and frameworks provide a mechanism to respond to updates
    in the application state and alter the UI accordingly. React and Vue use a virtual
    DOM diffing algorithm to make these updates. Svelte, on the other hand, compiles
    components to imperative code that updates the DOM directly. Angular uses a change
    detection mechanism based on Zones and observables.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些库和框架都提供了一种机制来响应应用程序状态的更新，并相应地更改 UI。React 和 Vue 使用虚拟 DOM 差异算法来进行这些更新。而 Svelte
    则将组件编译为直接更新 DOM 的命令式代码。Angular 使用基于 Zones 和可观察对象的变更检测机制。
- en: Soon, it’ll pretty much be React using vDOM and everyone else using some variety
    of signals.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 不久之后，几乎所有人都将使用 vDOM，而其他人将使用各种信号。
- en: 'Despite the different methods, the goal is the same: to efficiently update
    the UI in response to state changes, abstracting away the complex DOM manipulation
    and allowing developers to focus on the application logic.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管方法不同，目标是相同的：在响应状态变化时有效地更新 UI，抽象出复杂的 DOM 操作，使开发者能够专注于应用程序逻辑。
- en: Lifecycle Methods
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生命周期方法
- en: React, Angular, Solid, and Svelte provide lifecycle methods or hooks, which
    are functions that get called at different stages in a component’s life, such
    as when it’s first created, when it’s updated, and when it’s about to be removed
    from the DOM. Developers can use these methods to run side effects, clean up resources,
    or make updates based on changes in props.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: React、Angular、Solid 和 Svelte 提供了生命周期方法或钩子，这些方法在组件生命周期的不同阶段调用，比如组件首次创建、更新和即将从
    DOM 中移除时。开发者可以利用这些方法来运行副作用、清理资源或根据 props 的变化进行更新。
- en: Ecosystem and Tooling
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生态系统与工具
- en: Each of these frameworks and libraries is supported by a rich ecosystem of tools,
    libraries, and resources. They all have support for modern JavaScript features
    and tooling, including ES6 syntax, modules, and build tools like Webpack and Babel.
    They also have excellent TypeScript support, allowing developers to write type-safe
    code and take advantage of TypeScript’s powerful features.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这些框架和库都由丰富的工具、库和资源支持。它们都支持现代JavaScript特性和工具，包括ES6语法、模块以及Webpack和Babel等构建工具。它们还具有出色的TypeScript支持，允许开发者编写类型安全的代码并利用TypeScript强大的功能。
- en: Most of these technologies also come with or have available sophisticated developer
    tools that can aid in debugging and application profiling. React’s and Angular’s
    developer tools extensions for popular browsers are excellent examples of such
    tooling.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数这些技术还配备或可用复杂的开发者工具，可以帮助调试和应用程序分析。React和Angular的开发者工具扩展是这类工具的绝佳例子。
- en: 'While React, Angular, Qwik, Solid, and Svelte have their unique strengths and
    philosophies, they share these common goals: providing a component-based architecture,
    enabling the creation of declarative UIs, offering reactivity to state changes,
    simplifying event handling, providing lifecycle methods or similar concepts, and
    supporting a rich ecosystem and modern JavaScript tooling. This shared set of
    features and concepts is a testament to the evolution of web development toward
    more modular, declarative, and reactive paradigms.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然React、Angular、Qwik、Solid和Svelte各自有其独特的优势和理念，但它们都分享以下共同目标：提供基于组件的架构，实现声明式UI的创建，为状态变化提供响应性，简化事件处理，提供生命周期方法或类似概念，并支持丰富的生态系统和现代JavaScript工具链。这些共同的特性和概念体现了Web开发朝向更模块化、声明式和响应式范式的演变。
- en: React Is Not Reactive
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React不是响应式
- en: The term “reactive” has been used to describe many things in the world of programming,
    but it’s often used to describe systems that automatically update in response
    to changes in data. The paradigm of reactive programming is fundamentally about
    building systems that respond to changes, and automatically propagating those
    changes through the system. This is why frameworks like Vue.js and Svelte are
    often described as being reactive. However, React does not follow the traditional
    model of reactivity, and its approach is distinctly different.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: “响应式”这个术语被用来描述编程世界中的许多事物，但通常用来描述自动根据数据变化更新的系统。响应式编程范式基本上是构建能响应变化并自动传播这些变化的系统。这就是为什么像Vue.js和Svelte这样的框架经常被描述为具有响应性。然而，React并不遵循传统的响应式模型，它的方法是完全不同的。
- en: React was introduced as a library for building user interfaces in a declarative
    way—*declarative* meaning that those of us writing React merely describe *what*
    we want, and React deals with the *how*. It allows developers to describe the
    UI based on the current application state, and React takes care of updating the
    UI whenever the state changes. This description might sound like React is reactive,
    but when you delve deeper into the implementation details, it becomes apparent
    that React’s model is quite distinct from the traditional reactive programming
    model.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: React是一个以声明方式构建用户界面的库——*声明式*意味着我们编写React的人只描述我们想要的*是什么*，React处理*如何*。它允许开发者根据当前应用状态描述UI，React会在状态变化时更新UI。这种描述听起来像React是响应式的，但当你深入了解其实现细节时，就会发现React的模型与传统的响应式编程模型有很大不同。
- en: To understand why React isn’t reactive in the traditional sense, let’s first
    look at what traditional reactivity looks like in a system. In a traditional reactive
    system, dependencies between computations are automatically tracked as your code
    runs. When a reactive dependency changes, all computations that depend on it are
    automatically rerun to reflect this change. This is typically done using techniques
    such as data-binding, observables, or signals and slots.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么React在传统意义上不是响应式的，让我们首先看看系统中传统响应式看起来如何。在传统的响应式系统中，依赖关系在代码运行时会自动跟踪。当一个响应式依赖发生变化时，所有依赖于它的计算都会自动重新运行以反映这一变化。通常使用数据绑定、可观察对象或信号与插槽等技术来实现这一点。
- en: 'Signals for example, are a reactive primitive that can be used to create reactive
    values: on read, the reader of the signal subscribes to it, and on write, all
    subscribers are notified. This is reactivity 101.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，信号是一种可以用来创建响应式值的响应式原语：在读取时，信号的读取者订阅它，在写入时，所有订阅者都会收到通知。这就是响应式编程的基础。
- en: React uses a different approach to manage state and its updates. Instead of
    automatically tracking dependencies and propagating changes, React introduces
    a more explicit mechanism for updating the state—the `useState` hook. When state
    changes, instead of immediately rendering updates, React schedules a rerender,
    and during that rerender, the entire component function is run again with the
    new state.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: React 使用了一种不同的方法来管理状态及其更新。它不会自动追踪依赖关系和传播更改，而是引入了一种更明确的机制来更新状态——`useState` 钩子。当状态发生变化时，React
    不会立即进行渲染更新，而是安排重新渲染，在重新渲染期间，整个组件函数将会以新状态再次运行。
- en: 'What that means is in the case of this counter:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在这个计数器的情况下：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When `setCount` is called, the `Counter` function is reinvoked, including the
    `useState` hook. This is different from the traditional reactive model, where
    instead of reinvoking the entire function, only the reactive portions of the UI
    would be updated, in this case, the `{count}` inside of `<p>`. This is called
    coarse-grained reactivity, and it is directly opposed to the fine-grained reactivity
    model of signals.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `setCount` 时，将重新调用 `Counter` 函数，包括 `useState` 钩子。这与传统的响应式模型不同，传统模型中只会更新
    UI 的响应部分，而在这种情况下，更新的是 `<p>` 中的 `{count}`。这称为粗粒度的响应性，与信号的细粒度响应模型形成鲜明对比。
- en: 'React is often identified with the following equation:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: React 经常被认为符合以下等式：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'That is, the view is equal to a function of its state. This equation itself
    describes React’s nonreactive nature: the view is a function of the state, but
    it’s not automatically updated when the state changes. Instead, the view is updated
    when the function is re-executed with the new state.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，视图等于其状态的函数。这个等式本身描述了 React 的非反应性本质：视图是状态的函数，但状态变化时不会自动更新视图。相反，只有当函数重新执行时，视图才会使用新状态更新。
- en: This is where React’s virtual DOM diffing and reconciliation process comes in.
    When a component’s state or props change, React rerenders the component, creating
    a new virtual DOM subtree. It then diffs this new subtree with the old one, computes
    the minimal set of actual DOM mutations needed, and applies those mutations to
    the DOM.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 React 的虚拟 DOM 差异化和协调过程的关键所在。当组件的状态或属性发生变化时，React 会重新渲染组件，创建一个新的虚拟 DOM 子树。然后，它会将这个新子树与旧子树进行比较，计算出需要的最小的实际
    DOM 变化，并将这些变化应用到 DOM 上。
- en: 'This model of explicitly setting state and rerendering, as opposed to automatic
    reactive propagation of changes, allows for more predictability: React, if anthropomorphized,
    would say, “Tell me your state expectations and I’ll take care of it.” It enables
    features like batching of state updates and makes it easier to reason about the
    state of the application at any point in time because the state update and the
    resulting UI update are linked in a single, atomic operation.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 明确设置状态并重新渲染的这种模式，与自动的反应性变化传播相对，使得更加可预测：如果把 React 拟人化，它会说，“告诉我你对状态的期望，我会照顾好它。”
    它支持批量状态更新等特性，并且使得在任何时刻都更容易推理应用程序的状态，因为状态更新和结果 UI 更新是一个单一的、原子性操作。
- en: However, this also means that React components are less reactive in the traditional
    sense. They don’t automatically react to changes in data. Instead, they explicitly
    describe what the UI should look like for a given state, and it’s up to React
    to apply any necessary updates when the state changes through re-executing functions
    instead of the appropriate values just updating in place.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这也意味着 React 组件在传统意义上不那么具有反应性。它们不会自动响应数据的变化。相反，它们明确描述了在给定状态下 UI 应该如何看起来，而
    React 负责在状态变化时重新执行函数并应用任何必要的更新，而不是直接在原地更新相应的值。
- en: While React’s approach is not reactive in the sense of automatically tracking
    and propagating changes, it still provides a highly effective mechanism for building
    dynamic, interactive user interfaces. The use of state and props to control rendering
    provides a clear and predictable model for understanding how changes propagate
    through the application, and the virtual DOM system efficiently manages updates
    to the actual DOM.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 React 的方法不是指自动跟踪和传播变化，但它仍然提供了一种高效的机制来构建动态、交互式的用户界面。使用状态和属性来控制渲染提供了一个清晰且可预测的模型，帮助理解变化如何在应用程序中传播，而虚拟
    DOM 系统有效地管理更新到实际 DOM。
- en: In the end, whether or not React’s approach is considered reactive comes down
    to semantics. If you define reactivity as the automatic propagation of changes
    through a system, then no, React is not reactive. But if you define reactivity
    as the ability of a system to respond to changes in state in a predictable and
    controlled manner, then yes, React can certainly be considered reactive.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，无论React的方法是否被认为是响应式，最终都归结为语义。如果你定义响应性为系统中变化的自动传播，那么不，React不是响应式的。但如果你定义响应性为系统能够以可预测和受控的方式响应状态变化，那么是的，React确实可以被认为是响应式的。
- en: Looking at React and other frameworks/libraries, it’s clear that there isn’t
    a one-size-fits-all approach to managing state and reactivity in UI development.
    Each tool has its strengths and trade-offs and is suited to different use cases.
    Understanding these differences is crucial when choosing the right tool for the
    job and can also help in writing more effective and efficient code, regardless
    of the framework or library you’re using.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 查看React和其他框架/库，很明显，在UI开发中，没有一种大小合适的方法来管理状态和响应性。每种工具都有其优势和权衡，并适用于不同的用例。了解这些差异在选择合适的工具时至关重要，也可以帮助编写更有效和高效的代码，无论你使用的是哪种框架或库。
- en: React’s model of handling state and updates provides an excellent balance between
    control and convenience. The explicit state update mechanism allows developers
    to reason about their application state more easily, while the reconciliation
    and diffing algorithm efficiently applies updates to the DOM. Despite not being
    traditionally “reactive,” React’s approach has proven to be incredibly effective
    for building complex user interfaces.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: React处理状态和更新的模型提供了控制和便利的极好平衡。显式状态更新机制使开发人员能更轻松地推理他们的应用状态，而协调和差异算法则高效地将更新应用到DOM中。尽管不是传统意义上的“响应式”，React的方法已被证明在构建复杂用户界面时非常有效。
- en: There’s no denying that reactive programming models offer some compelling benefits,
    particularly when it comes to automatically managing dependencies and updates.
    But as we’ve seen, React’s approach offers its own set of advantages, providing
    a high degree of control and predictability.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 不可否认的是，响应式编程模型在自动管理依赖和更新方面提供了一些引人注目的好处。但正如我们所见，React的方法提供了自己一套优势，提供了高度的控制和可预测性。
- en: 'For completionists, we’ll now look at how the same counter would look in Solid,
    a framework that uses a reactive model:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于完美主义者来说，现在我们将看一下在Solid中，一个使用响应式模型的框架中相同计数器是如何表现的：
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this example, `count` is a reactive property of the component’s data. When
    we first read `count` by calling `count()` in place inside our `<p>` elements,
    we implicitly subscribe that portion of our JSX to the reactive value of `count`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`count`是组件数据的一个响应式属性。当我们通过在我们的`<p>`元素内部调用`count()`来首次读取`count`时，我们隐式订阅了`count`的响应式值的那部分JSX。
- en: Then, when we call `increment()` later, which then calls `setCount`, `setCount`
    updates the value and notifies all subscribers that the value changed, prompting
    them to update. This is a bit analogous to the pub/sub pattern, where a subscriber
    subscribes to a publisher, and the publisher notifies all subscribers.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当我们稍后调用`increment()`时，这将调用`setCount`，`setCount`更新值并通知所有订阅者值已更改，促使它们进行更新。这有点类似于发布/订阅模式，其中订阅者订阅发布者，发布者通知所有订阅者。
- en: 'The result is fine-grained reactivity: that is, the function component itself,
    `Counter`, is never called more than once, but the fine-grained, small reactive
    values are.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是细粒度的响应性：即，函数组件本身`Counter`从未被调用超过一次，但是细粒度、小型的响应式值会被调用。
- en: 'Example 2: Dependent Values'
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例2：依赖值
- en: 'Consider a component that displays a list of items and the count of those items.
    In a reactive system like Svelte, the count would automatically update whenever
    the list changes:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个显示项目列表和项目计数的组件。在像Svelte这样的响应式系统中，每当列表变化时，计数会自动更新：
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here, `$: count = items.length;` declares a reactive statement. Whenever `items`
    changes, the `count` is automatically recalculated.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，`$: count = items.length;` 声明了一个响应式语句。每当 `items` 发生变化时，`count` 会自动重新计算。'
- en: 'In React, this looks a bit different:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中，这看起来有些不同：
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this React component, `count` is not a reactive value that automatically
    updates when `items` changes. Instead, it’s a value derived from the current state
    during the render phase. When `items` changes, we need to call `setItems` to update
    the state and cause a rerender, at which point `count` is recalculated not because
    `count` is reactive, but because the `ItemList` function component is reinvoked.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 React 组件中，`count` 不是一个在`items`改变时自动更新的响应式值。相反，它是在渲染阶段从当前状态派生出来的值。当`items`改变时，我们需要调用`setItems`来更新状态并引起重新渲染，在这个时候`count`被重新计算，不是因为`count`是响应式的，而是因为`ItemList`函数组件被重新调用。
- en: The Future of React
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React 的未来
- en: Given the widespread adoption of reactive primitives like signals across the
    entire frontend ecosystem, some would presume that React would eventually adopt
    a similar approach. However, the React team has expressed that they are “not excited”
    about signals and opt for an alternative approach to arrive at similar performance
    benefits that signals provide.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于像信号这样的响应式原语在整个前端生态系统中的广泛采用，一些人可能会认为 React 最终会采纳类似的方法。然而，React 团队表示他们对信号“不感兴趣”，并选择了另一种方法来实现信号提供的类似性能优势。
- en: 'To understand this a little better, let’s recap some of the things we’ve learned
    about React through an example. Consider this component:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一点，让我们通过一个例子回顾一些我们通过 React 学到的东西。考虑这个组件：
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this very, very contrived example, we have a component that contains state
    called `Counter` with some children:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个非常，非常构造的例子中，我们有一个包含名为`Counter`状态的组件，带有一些子元素：
- en: A `<p>` element that displays the current count
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `<p>` 元素，显示当前计数
- en: A `<button>` element that increments the count
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `<button>` 元素，用来增加计数
- en: A `<ComponentWithExpensiveChildren>` component that renders some expensive children
    with a lot of computation
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `<ComponentWithExpensiveChildren>` 组件，渲染一些计算量大的昂贵子元素
- en: 'Now, let’s say we click the button to increment the count. What happens? The
    `Counter` function is called/reinvoked/rerendered along with all its children.
    This is React’s default behavior. This means that the `<ComponentWithExpensiveChildren>`
    component is rerendered even though it doesn’t need to be: its props or state
    hasn’t changed!'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们点击按钮增加计数。会发生什么？`Counter`函数会被调用/重新调用/重新渲染以及其所有的子元素。这是 React 的默认行为。这意味着即使其
    props 或状态没有改变，`<ComponentWithExpensiveChildren>`组件也会重新渲染！
- en: 'This coarse-grained reactivity makes React less performant than it could be.
    However, this is quite an easy fix: we just include `memo` at the right time and
    in the right place:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这种粗粒度的响应性使得 React 的性能比可能的更低。然而，这是一个相当容易的修复：我们只需在正确的时间和地点包含`memo`：
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This works, as long as we remember to use `memo` everywhere we need to. Indeed,
    this provides the same fine-grained reactivity as signals. However, it’s not as
    convenient as signals, because we have to remember to use `memo` everywhere we
    need to.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们记得在需要的地方使用`memo`，这就能正常工作。实际上，这提供了与信号相同的细粒度响应性。但它不像信号那样方便，因为我们必须记得在需要的地方使用`memo`。
- en: 'Many of us at this point may be thinking that signals could easily solve this
    problem, but the React team at Meta believes that signals, like `memo`, may be
    an implementation detail that everyday developers who use React ought not have
    to think about. They hearken back to the initial value proposition of React: “declaratively
    describe your UI, let React do the rest.” The React team believes that the superior
    way is where developers don’t concern ourselves with signals, `memo`, or any details,
    but that React should be able to figure out the optimal way to render the UI.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们中的许多人可能认为，信号很容易解决这个问题，但 Meta 的 React 团队认为信号和`memo`可能是日常使用 React 的开发人员不必考虑的实现细节。他们回顾了
    React 的最初价值主张：“声明性地描述你的 UI，让 React 去处理剩下的事情。” React 团队认为，更优越的方式是开发者不需要关心信号、`memo`或任何细节，而是让
    React 能够找出渲染 UI 的最佳方式。
- en: 'To this end, the team is working on a new piece of software to do just that:
    React Forget.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，团队正在开发一个新的软件来做到这一点：React Forget。
- en: React Forget
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React Forget
- en: 'Forget is a toolchain for React similar to a linter that has its `--fix` flag
    enabled: it enforces the rules of React and then automatically transforms React
    code to be optimal through intelligently memoizing values that will not change
    throughout the lifecycle of an application—like `ComponentWithExpensiveChildren`.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Forget 是一个针对 React 的工具链，类似于启用了其`--fix`标志的代码检查工具：它强制执行 React 的规则，然后通过智能记忆那些在应用程序生命周期中不会改变的值来自动优化
    React 代码，例如`ComponentWithExpensiveChildren`。
- en: Because of the rules of React, the Forget compiler can predict these values
    and memoize them for us. This is a similar approach to what Svelte does, but instead
    of compiling to imperative code, Forget compiles to more performant React code.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 React 的这些规则，Forget 编译器可以预测这些值并为我们进行记忆化。这与 Svelte 的做法类似，但 Forget 编译的是更高性能的
    React 代码，而不是编译为命令式代码。
- en: 'What are these rules of React? Let’s recap:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 React 的规则是什么？让我们回顾一下：
- en: React components are expected to be pure functions.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React 组件应该是纯函数。
- en: Some hooks and custom event handlers are not required to be pure.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一些钩子和自定义事件处理程序不需要是纯函数。
- en: 'Forbidden actions within pure functions include:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 纯函数中禁止的操作包括：
- en: Mutating variables/objects not newly created within the function
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数内部禁止变异变量/对象而不是新创建的。
- en: Reading properties that may change
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取可能会改变的属性。
- en: 'Allowed actions include:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许的操作包括：
- en: Reading props or state
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取 props 或 state
- en: Throwing errors
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抛出错误
- en: Mutating newly created objects/bindings
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变异新创建的对象/绑定。
- en: Lazy initialization is an exception allowing mutation for the purpose of initialization.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 惰性初始化是一个例外，允许为初始化目的进行变异。
- en: Objects or closures created during render should not be mutated after render
    completes, except mutable objects stored in state.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染期间创建的对象或闭包在渲染完成后不应变异，除了存储在状态中的可变对象。
- en: Because of these rules, the Forget compiler can predict which values will not
    change throughout the lifecycle of an application and memoize them for us. The
    result? Highly optimized, highly performant React code that rivals the performance
    of other libraries that use signals.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 正是由于这些 React 的规则，Forget 编译器可以预测应用程序生命周期中不会改变的值，并为我们进行记忆化。结果是？高度优化、性能卓越的 React
    代码，可以与使用信号的其他库的性能相媲美。
- en: At the time of writing, Forget is in evaluation at Meta and exceeding expectations
    in use on Instagram and WhatsApp. It is not yet open source, but the React team
    is considering releasing it as open source software in the near future.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Forget 在 Meta 公司正在评估中，并且在 Instagram 和 WhatsApp 上的使用超出了预期。它尚未开源，但 React
    团队正在考虑在不久的将来发布它作为开源软件。
- en: Forget versus signals
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Forget 与信号的对比
- en: Because Forget isn’t yet open source, it’s somewhat challenging to comment on
    its trade-offs with any amount of authority. However, we can posit that if Forget
    indeed memoizes everything that doesn’t change, fine-grained reactivity from signals
    may still be superior to coarse-grained reactivity with React Forget, because
    signals live in a parallel universe outside of the component hierarchy.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Forget 尚未开源，所以很难以权威的方式评论它的权衡。然而，我们可以推测，如果 Forget 确实对所有不会改变的内容进行了记忆化，那么信号的细粒度反应性可能仍然优于
    React Forget 的粗粒度反应性，因为信号存在于组件层次结构之外的平行宇宙。
- en: Thus, when an update happens, React will still have to walk the entire component
    tree and compare the new and old values of each component’s props to determine
    which components need to be rerendered. This is not the case with signals, where
    only the reactive portions of the UI are updated without needing to walk a tree.
    This preliminary data does suggest that even with Forget, React may still be slower
    than libraries where signals are the default, but it is too early to tell.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当更新发生时，React 仍然需要遍历整个组件树，并比较每个组件的 props 的新旧值，以确定哪些组件需要重新渲染。这在信号中并非如此，其中仅更新
    UI 的响应部分而无需遍历树。初步数据表明，即使使用了 Forget，React 仍可能比默认使用信号的库慢，但现在还为时过早。
- en: Chapter Review
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节回顾
- en: This chapter began with a recap of [Chapter 9](ch09.html#ch09), where we covered
    the use of RSCs in detail. We then delved into the vast landscape of JavaScript
    frameworks beyond React, including Angular, Vue, Svelte, Solid, and Qwik, aiming
    to understand the differences and similarities among these libraries and frameworks.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 本章开始时回顾了[第 9 章](ch09.html#ch09)，我们详细讨论了 RSCs 的使用。然后我们深入探讨了 JavaScript 框架的广阔领域，超越了
    React，包括 Angular、Vue、Svelte、Solid 和 Qwik，旨在理解这些库和框架之间的差异和相似之处。
- en: We started with a look at Vue.js, and explored how it uses a declarative approach
    for building UIs and promotes a strong separation of concerns through its component-based
    architecture.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 Vue.js 入手，探讨了它如何采用声明式方法构建 UI，并通过其基于组件的架构促进了关注点的强分离。
- en: Next, we took a dive into Angular, Svelte, Solid, and Qwik, exploring their
    unique features and philosophies. We looked at how they use reactive primitives
    to automatically update the UI in response to changes in data, and how they differ
    from React in this regard.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们深入研究了 Angular、Svelte、Solid 和 Qwik，探讨它们的独特特性和理念。我们看了它们如何使用响应式基元自动更新 UI，以响应数据变化，并探讨了它们在这方面与
    React 的不同之处。
- en: After the individual examinations, we drew comparisons among these UI libraries,
    underlining their strengths, weaknesses, and overlaps. We looked at their reactivity
    models, architectural choices, development experience, and performance characteristics.
    Through code examples, we showed the unique qualities of each, helping us to understand
    their differences better.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在个别考察之后，我们对这些 UI 库进行了比较，突出它们的优势、劣势和重叠之处。我们关注它们的响应模型、架构选择、开发体验和性能特征。通过代码示例，我们展示了每个库的独特特性，帮助我们更好地理解它们的差异。
- en: We also examined the concept of reactivity and how it is implemented differently
    across various libraries. Interestingly, we discussed how React is not reactive
    in the traditional sense, as it follows a coarser approach where a change in state
    leads to a rerender, unlike the fine-grained reactivity model found in libraries
    like Vue or Svelte.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了响应性的概念以及在不同库中如何实现不同。有趣的是，我们讨论了 React 不同于传统意义上的响应式，因为它遵循一种更粗粒度的方法，其中状态变化会导致重新渲染，而不是像
    Vue 或 Svelte 这样的库中的细粒度响应模型。
- en: Finally, we looked at the future of React and how it might evolve in the coming
    years. We discussed the React team’s approach to reactivity and how it differs
    from the traditional reactive programming model. We also looked at the Forget
    compiler, a toolchain for React that automatically optimizes React code by memoizing
    values that don’t change throughout the lifecycle of an application.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看了一眼 React 未来的发展方向以及它未来几年可能的演变。我们讨论了 React 团队对响应性的方法，以及它与传统响应式编程模型的不同之处。我们还看了一下
    Forget 编译器，这是一个用于 React 的工具链，通过记忆那些在应用程序生命周期中不变的值来自动优化 React 代码。
- en: Let’s finally land the plane.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们把飞机安全降落。
- en: Review Questions
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复习问题
- en: Here is a list of questions to help you track your understanding of the concepts
    covered in this chapter. If you can answer all of them confidently, great! That’s
    a sign you’re learning from this book. If you cannot, it might be worth rereading
    this chapter.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些问题列表，帮助您跟踪本章讨论的概念理解程度。如果您能自信地回答所有问题，那很好！这表明您正在从这本书中学到东西。如果不能，可能值得重新阅读本章。
- en: How does the reactivity model differ among React, Vue, Svelte, Solid, and Angular?
    What are the implications of these differences on the performance and development
    experience of these libraries/frameworks?
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React、Vue、Svelte、Solid 和 Angular 之间的响应模型有何不同？这些差异对这些库/框架的性能和开发体验有何影响？
- en: Discuss the unique approach of Qwik in maximizing performance. How does this
    differ from the approach of other UI libraries/frameworks we’ve discussed?
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 讨论 Qwik 在最大化性能方面的独特方法。这与我们讨论过的其他 UI 库/框架的方法有何不同？
- en: What are the core strengths and weaknesses of each UI library/framework discussed
    in this chapter? How might these strengths and weaknesses influence the choice
    of library/framework for a particular project?
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本章讨论的每个 UI 库/框架中，它们各自的核心优势和劣势是什么？这些优势和劣势如何影响选择某个项目的库/框架？
- en: React is not reactive in the traditional sense. Explain this statement in detail,
    comparing it with the “push-based” reactivity model found in libraries like Vue
    or Svelte.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React 在传统意义上并非是响应式的。详细解释这个说法，并与像 Vue 或 Svelte 这样的“推送型”响应模型进行比较。
- en: What’s React Forget? How does it work? How does it compare to signals?
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 React Forget？它如何工作？它与信号（signals）相比如何？
- en: Up Next
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来
- en: As we draw closer to the conclusion of this comprehensive journey through the
    world of React and its ecosystem, we’re preparing to synthesize all that we’ve
    learned. In the next and final chapter, we’ll be stepping back and reflecting
    on the whole landscape.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们接近总结对 React 及其生态系统的全面探索时，我们准备综合我们所学的一切。在下一章，也是最后一章中，我们将退后一步，反思整个局势。
- en: We’ll be wrapping up this book and providing a holistic view of where we stand
    today and what we can anticipate tomorrow. In doing so, we’ll be drawing on all
    the technical knowledge and insights that we’ve gathered throughout the course
    of this book.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将总结本书内容，全面展示我们今天的进展及明日的预期。在此过程中，我们将汲取本书中积累的所有技术知识和见解。
- en: From understanding the inner workings of React’s reconciler and diving into
    asynchrony, to tackling server components and understanding various React frameworks,
    to comparing React with its peers—all this was done with a purpose. Now, we’re
    ready to connect the dots, to see the bigger picture, and to chart the path forward.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 从理解 React 协调器的内部工作方式和深入异步性，到处理服务器组件和理解各种 React 框架，再到与同行比较 React —— 所有这些都有其目的。现在，我们准备好串联各点，看到更大的画面，并规划前进的道路。
- en: So, are you ready to take a leap into the future of React and frontend development?
    Stay tuned for the grand finale!
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你准备好迈入 React 和前端开发的未来了吗？敬请期待壮丽的结局！
