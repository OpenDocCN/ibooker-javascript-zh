- en: Chapter 1\. Project Setup
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章 项目设置
- en: 'You want to get started with TypeScript, fantastic! The big question is: how
    do you start? You can integrate TypeScript into your projects in many ways, and
    all are slightly different depending on your project’s needs. Just as JavaScript
    runs on many runtimes, there are plenty of ways to configure TypeScript so it
    meets your target’s needs.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你想开始使用 TypeScript，太棒了！关键问题是：你如何开始呢？你可以用多种方式将 TypeScript 集成到你的项目中，每种方式根据项目需求略有不同。就像
    JavaScript 在多个运行时上运行一样，有很多方法可以配置 TypeScript，使其符合你的目标需求。
- en: This chapter covers all the possibilities of introducing TypeScript to your
    project, as an extension next to JavaScript that gives you basic autocompletion
    and error indication, up to full-fledged setups for full-stack applications on
    Node.js and the browser.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了向你的项目引入 TypeScript 的所有可能性，作为 JavaScript 的扩展，为你提供基本的自动完成和错误指示，直至为 Node.js
    和浏览器上的全栈应用程序设置完整的配置。
- en: Since JavaScript tooling is a field with endless possibilities—​some say that
    a new JavaScript build chain is released every week, almost as much as new frameworks—​this
    chapter focuses more on what you can do with the TypeScript compiler alone, without
    any extra tool.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 JavaScript 工具链是一个拥有无限可能性的领域——有人说几乎每周都会发布新的 JavaScript 构建链，几乎与新框架一样多——本章更侧重于你可以单独使用
    TypeScript 编译器完成的工作，不需要任何额外工具。
- en: TypeScript offers everything you need for your transpilation needs, except the
    ability to create minified and optimized bundles for web distribution. Bundlers
    like [ESBuild](https://esbuild.github.io) or [Webpack](https://webpack.js.org)
    take care of this task. Also, there are setups that include other transpilers
    like [Babel.js](https://babeljs.io) that can play nicely with TypeScript.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 提供了你所有转译需求所需的一切，除了创建针对 Web 分发的压缩和优化的包的能力。像 [ESBuild](https://esbuild.github.io)
    或 [Webpack](https://webpack.js.org) 这样的捆绑工具会处理这项任务。此外，还有一些设置包含其他与 TypeScript 良好兼容的转译器，如
    [Babel.js](https://babeljs.io)。
- en: Bundlers and other transpilers are not within the scope of this chapter. Refer
    to their documentation for the inclusion of TypeScript and use the knowledge in
    this chapter to get the right configuration setup.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 捆绑工具和其他转译器不在本章的范围之内。请参考它们的文档，了解如何包含 TypeScript，并使用本章中的知识来获取正确的配置设置。
- en: TypeScript being a project with more than a decade of history, it carries some
    remains from older times that, for the sake of compatibility, TypeScript can’t
    just get rid of. Therefore, this chapter will spotlight modern JavaScript syntax
    and recent developments in web standards.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 作为一个拥有十多年历史的项目，保留了一些来自早期的遗留物，为了兼容性考虑，TypeScript 不能轻易摆脱它们。因此，本章将重点介绍现代
    JavaScript 语法和Web标准的最新发展。
- en: 'If you still need to target Internet Explorer 8 or Node.js 10, first: I’m sorry,
    these platforms are really hard to develop for. However, second: you will be able
    to put together the pieces for older platforms with the knowledge from this chapter
    and the [official TypeScript documentation](https://typescriptlang.org).'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然需要支持 Internet Explorer 8 或 Node.js 10，首先：抱歉，这些平台确实很难开发。但是，第二：通过本章和 [官方
    TypeScript 文档](https://typescriptlang.org)，你将能够为旧平台整合知识。
- en: 1.1 Type-Checking JavaScript
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.1 JavaScript 的类型检查
- en: Problem
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to get basic type-checking for JavaScript with the least amount of
    effort possible.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望尽可能少的工作量获取 JavaScript 的基本类型检查。
- en: Solution
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Add a single-line comment with `@ts-check` at the beginning of every JavaScript
    file you want to type-check. With the right editors, you already get red squiggly
    lines whenever TypeScript encounters things that don’t quite add up.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在你想要类型检查的每个 JavaScript 文件开头添加一个带有 `@ts-check` 的单行注释。对于合适的编辑器，当 TypeScript 遇到不太匹配的事物时，你会立即看到红色波浪线。
- en: Discussion
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: TypeScript has been designed as a superset of JavaScript, and every valid JavaScript
    is also valid TypeScript. This means TypeScript is also really good at figuring
    out potential errors in regular JavaScript code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 被设计为 JavaScript 的超集，每个有效的 JavaScript 代码也是有效的 TypeScript 代码。这意味着 TypeScript
    也非常擅长发现常规 JavaScript 代码中的潜在错误。
- en: We can use this if we don’t want a full-blown TypeScript setup but want some
    basic hints and type-checks to ease our development workflow.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不想要一个完整的 TypeScript 设置，但想要一些基本的提示和类型检查来简化我们的开发工作流程，我们可以使用这个。
- en: A good prerequisite if you only want to type-check JavaScript is a good editor
    or IDE. An editor that goes really well with TypeScript is [Visual Studio Code](https://code.visualstudio.com).
    Visual Studio Code—or VSCode for short—was the first major project to utilize
    TypeScript, even before TypeScript’s release.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想对 JavaScript 进行类型检查，一个很好的前提条件是一个功能强大的编辑器或 IDE。一个非常适合 TypeScript 的编辑器是 [Visual
    Studio Code](https://code.visualstudio.com)。Visual Studio Code，或简称 VSCode，在 TypeScript
    发布之前就是第一个主要使用 TypeScript 的项目。
- en: A lot of people recommend VSCode if you want to write JavaScript or TypeScript.
    But really, every editor is great as long as it features TypeScript support. And
    nowadays most of them do.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想编写 JavaScript 或 TypeScript，很多人推荐使用 VSCode。但实际上，只要支持 TypeScript 的编辑器都是很棒的。现在大多数编辑器都支持
    TypeScript。
- en: 'With Visual Studio Code we get one very important thing for type-checking JavaScript:
    red squiggly lines when something doesn’t quite add up, as you can see in [Figure 1-1](#img-vscode-error).
    This is the lowest barrier to entry. TypeScript’s type system has different levels
    of strictness when working with a codebase.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Visual Studio Code 进行 JavaScript 的类型检查非常重要的一点是：当代码中有什么不对劲时，我们会看到红色波浪线，如您在
    [图 1-1](#img-vscode-error) 中所见。这是最低的入门障碍。TypeScript 的类型系统在处理代码库时有不同的严格级别。
- en: '![tscb 0101](assets/tscb_0101.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![tscb 0101](assets/tscb_0101.png)'
- en: 'Figure 1-1\. Red squiggly lines in code editors: first-level feedback if something
    in your code doesn’t add up'
  id: totrans-20
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-1\. 代码编辑器中的红色波浪线：如果代码中有什么不对劲，它将会给予第一级反馈
- en: 'First, the type system will try to *infer* types from JavaScript code through
    usage. If you have a line like this in your code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，类型系统会通过使用情况从 JavaScript 代码中 *推断* 类型。如果您的代码中有这样一行：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: TypeScript will correctly infer `number` as the type of `a_number`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 将会正确推断 `a_number` 的类型为 `number`。
- en: 'One difficulty with JavaScript is that types are dynamic. Bindings via `let`,
    `var`, or `const` can change type based on usage.^([1](ch01.html#id393)) Take
    a look at the following example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的一个难点在于其类型是动态的。通过 `let`、`var` 或 `const` 进行绑定可以根据使用情况改变类型。^([1](ch01.html#id393))
    请看下面的例子：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We assign a number to `a_number` and change the binding to a `string` if the
    condition in the next line evaluates to true. This wouldn’t be much of a problem
    if we didn’t try to multiply `a_number` on the last line. In approximately 50%
    of all cases, this example will produce unwanted behavior.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果条件在下一行评估为真时，我们将一个数字赋给 `a_number` 并将绑定更改为一个 `string`。如果我们在最后一行试图对 `a_number`
    进行乘法运算，这将会是一个问题。在大约 50% 的情况下，这个例子会产生意料之外的行为。
- en: 'TypeScript can help here. With the addition of a single-line comment with `@ts-check`
    at the very top of our JavaScript file, TypeScript activates the next strictness
    level: type-checking JavaScript files based on the type information available
    in the JavaScript file.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 可以在这里提供帮助。通过在我们的 JavaScript 文件的顶部添加一行单行注释 `@ts-check`，TypeScript
    将激活下一个严格级别：根据 JavaScript 文件中可用的类型信息对 JavaScript 文件进行类型检查。
- en: 'In our example, TypeScript will figure out that we tried to assign a string
    to a binding that TypeScript has inferred to be a number. We will get an error
    in our editor:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，TypeScript 将会发现我们试图将一个字符串分配给一个 TypeScript 推断为数字的绑定。我们在编辑器中会收到一个错误：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now we can start to fix our code, and TypeScript will guide us.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始修复我们的代码，TypeScript 将会指导我们。
- en: 'Type inference for JavaScript goes a long way. In the following example, TypeScript
    infers types by looking at operations like multiplication and addition as well
    as default values:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的类型推断可以在很大程度上帮助。在下面的例子中，TypeScript 通过乘法和加法操作以及默认值推断类型：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The function `addVat` takes two arguments. The second argument is optional,
    as it has been set to a default value of `0.2`. TypeScript will alert you if you
    try to pass a value that doesn’t work:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `addVat` 接受两个参数。第二个参数是可选的，因为它已经被设置为默认值 `0.2`。如果您试图传递一个不起作用的值，TypeScript 将会警告您：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Also, since we use multiplication and addition operations within the function
    body, TypeScript understands that we will return a number from this function:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，由于我们在函数体内使用了乘法和加法操作，TypeScript 理解我们将会从这个函数返回一个数字：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In some situations you need more than type inference. In JavaScript files,
    you can annotate function arguments and bindings through JSDoc type annotations.
    [JSDoc](https://jsdoc.app) is a comment convention that allows you to describe
    your variables and function interfaces in a way that’s not only readable for humans
    but also interpretable by machines. TypeScript will pick up your annotations and
    use them as types for the type system:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你需要更多的类型推断。在 JavaScript 文件中，你可以通过 JSDoc 类型注释来注释函数参数和绑定。[JSDoc](https://jsdoc.app)
    是一种注释约定，允许你以一种不仅对人类可读而且对机器可解释的方式描述你的变量和函数接口。TypeScript 将获取你的注释并将其用作类型系统的类型：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'JSDoc also allows you to define new, complex types for objects:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: JSDoc 还允许你为对象定义新的复杂类型：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The syntax might feel a bit clunky, though; we will find better ways to annotate
    objects in [Recipe 1.3](#ch01_item_types_on_the_side).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管语法可能有点笨拙，但我们将在 [Recipe 1.3](#ch01_item_types_on_the_side) 中找到更好的方法来注释对象。
- en: Given that you have a JavaScript codebase that is well documented via JSDoc,
    adding a single line on top of your files will give you a really good understanding
    if something goes wrong in your code.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个通过 JSDoc 很好文档化的 JavaScript 代码库，只需在文件顶部添加一行就可以在代码出现问题时获得很好的理解。
- en: 1.2 Installing TypeScript
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.2 安装 TypeScript
- en: Problem
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: 'Red squigglies in the editor are not enough: you want command-line feedback,
    status codes, configuration, and options to type-check JavaScript and compile
    TypeScript.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑器中的红色波浪线并不足够：你希望获得命令行反馈、状态码、配置和选项来检查 JavaScript 并编译 TypeScript。
- en: Solution
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Install TypeScript via Node’s primary package registry: [NPM](https://npmjs.com).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 Node 的主要包注册表安装 TypeScript：[NPM](https://npmjs.com)。
- en: Discussion
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: TypeScript is written in TypeScript, compiled to JavaScript, and uses the [Node.js
    JavaScript runtime](https://nodejs.org) as its primary execution environment.^([2](ch01.html#id406))
    Even if you’re not writing a Node.js app, the tooling for your JavaScript applications
    will run on Node. So, make sure you get Node.js from [the official website](https://nodejs.org)
    and get familiar with its command-line tools.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 是用 TypeScript 编写的，编译为 JavaScript，并使用 [Node.js JavaScript 运行时](https://nodejs.org)
    作为其主要执行环境。^([2](ch01.html#id406)) 即使你不是在编写一个 Node.js 应用程序，你的 JavaScript 应用程序的工具将在
    Node 上运行。因此，请确保从 [官方网站](https://nodejs.org) 获取 Node.js，并熟悉其命令行工具。
- en: 'For a new project, make sure you initialize your project’s folder with a fresh
    *package.json*. This file contains all the information for Node and its package
    manager NPM to figure out your project’s contents. Generate a new *package.json*
    file with default contents in your project’s folder with the NPM command-line
    tool:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个新项目，请确保用一个新的 *package.json* 初始化你的项目文件夹。这个文件包含了 Node 及其包管理器 NPM 理解你的项目内容的所有信息。使用
    NPM 命令行工具在你项目文件夹中生成一个带有默认内容的新 *package.json* 文件：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-52
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Throughout this book, you will see commands that should be executed in your
    terminal. For convenience, we show these commands as they would appear on BASH
    or similar shells available for Linux, macOS, or the Windows subsystem for Linux.
    The leading `$` sign is a convention to indicate a command, but it is not meant
    to be written by you. Note that all commands also work on the regular Windows
    command-line interface as well as PowerShell.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，你会看到应在你的终端执行的命令。为方便起见，我们展示这些命令，如它们将出现在 Linux、macOS 或 Windows 子系统可用的 BASH
    或类似的 shell 中。前导的 `$` 符号是一种指示命令的约定，但你不应该自己输入它。注意，所有命令也适用于常规的 Windows 命令行界面以及 PowerShell。
- en: 'NPM is Node’s package manager. It comes with a CLI, a registry, and other tools
    that allow you to install dependencies. Once you initialize your *package.json*,
    install TypeScript from NPM. We install it as a development dependency, meaning
    that TypeScript won’t be included if you intend to publish your project as a library
    to NPM itself:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: NPM 是 Node 的包管理器。它带有一个 CLI、一个注册表以及其他工具，允许你安装依赖项。一旦你初始化了你的 *package.json*，从 NPM
    安装 TypeScript。我们将其安装为开发依赖项，这意味着如果你打算将你的项目作为库发布到 NPM 自身，TypeScript 将不会包含在内：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can globally install TypeScript so you have the TypeScript compiler available
    everywhere, but I strongly suggest installing TypeScript separately per project.
    Depending on how frequently you visit your projects, you will end up with different
    TypeScript versions that are in sync with your project’s code. Installing (and
    updating) TypeScript globally might break projects you haven’t touched in a while.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以全局安装 TypeScript，这样你就可以在任何地方使用 TypeScript 编译器，但我强烈建议每个项目单独安装 TypeScript。根据你访问项目的频率不同，你会得到与项目代码同步的不同
    TypeScript 版本。全局安装（和更新）TypeScript 可能会破坏你长时间没有碰过的项目。
- en: Note
  id: totrans-57
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you install frontend dependencies via NPM, you will need an additional tool
    to make sure that your code also runs in your browser: a bundler. TypeScript doesn’t
    include a bundler that works with the supported module systems, so you need to
    set up the proper tooling. Tools like [Webpack](https://webpack.js.org) are common,
    and so is [ESBuild](https://esbuild.github.io). All tools are designed to execute
    TypeScript as well. Or you can go full native, as described in [Recipe 1.8](#ch01_item_es_modules).'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过 NPM 安装前端依赖项，你将需要额外的工具来确保你的代码在浏览器中运行：一个捆绑工具。TypeScript 不包含与支持的模块系统一起工作的捆绑工具，因此你需要设置适当的工具。像
    [Webpack](https://webpack.js.org) 这样的工具很常见，[ESBuild](https://esbuild.github.io)
    也是如此。所有这些工具都设计用于执行 TypeScript。或者你可以完全使用原生支持，如[第 1.8 节](#ch01_item_es_modules)所述。
- en: 'Now that TypeScript is installed, initialize a new TypeScript project. Use
    NPX for that: it allows you to execute a command-line utility that you installed
    relative to your project.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 TypeScript 已经安装好了，初始化一个新的 TypeScript 项目。使用 NPX 来执行：它允许你执行一个与项目相关联的命令行实用程序。
- en: 'With:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: you can run your project’s local version of the TypeScript compiler and pass
    the `init` flag to create a new *tsconfig.json*.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以运行项目的本地 TypeScript 编译器，并传递 `init` 标志来创建一个新的 *tsconfig.json*。
- en: The *tsconfig.json* is the main configuration file for your TypeScript project.
    It contains all the configuration needed so that TypeScript understands how to
    interpret your code, how to make types available for dependencies, and if you
    need to turn certain features on or off.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*tsconfig.json* 是你的 TypeScript 项目的主要配置文件。它包含了所有配置信息，以便 TypeScript 理解如何解释你的代码，如何为依赖项提供类型，并且如果需要打开或关闭某些功能。'
- en: 'Per default, TypeScript sets these options for you:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，TypeScript 为你设置了这些选项：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let’s look at them in detail.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看它们。
- en: '`target` is `es2016`, which means that if you run the TypeScript compiler,
    it will compile your TypeScript files to an ECMAScript 2016 compatible syntax.
    Depending on your supported browsers or environments, you can set that either
    to something more recent (ECMAScript versions are named after the year of release)
    or to something older such as `es5` for people who have to support very old Internet
    Explorer versions. Of course, I hope you don’t have to.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`target` 是 `es2016`，这意味着如果你运行 TypeScript 编译器，它将把你的 TypeScript 文件编译成 ECMAScript
    2016 兼容的语法。根据你支持的浏览器或环境，你可以将其设置为更近期的版本（ECMAScript 版本以发布年份命名），或者像 `es5` 这样更旧的版本，适合需要支持非常旧的
    Internet Explorer 版本的人。当然，我希望你不必这么做。'
- en: '`module` is `commonjs`. This allows you to write ECMAScript module syntax,
    but instead of carrying this syntax over to the output, TypeScript will compile
    it to the CommonJS format. This means that:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`module` 是 `commonjs`。这允许你使用 ECMAScript 模块语法，但 TypeScript 会将其编译为 CommonJS 格式的输出。这意味着：'
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'becomes:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 变成：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: once you compile. CommonJS was the module system for Node.js and has become
    very common because of Node’s popularity. Node.js has since adopted ECMAScript
    modules as well, something we’ll tackle in [Recipe 1.9](#ch01_item_modules).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦编译完成。CommonJS 是 Node.js 的模块系统，并因为 Node 的流行而变得非常普遍。Node.js 后来也采用了 ECMAScript
    模块，我们将在[第 1.9 节](#ch01_item_modules)中处理这个问题。
- en: '`esModuleInterop` ensures modules that aren’t ECMAScript modules are aligned
    to the standard once imported. `forceConsistentCasingInFileNames` helps people
    using case-sensitive file systems cooperate with folks who use case-insensitive
    file systems. And `skipLibCheck` assumes that your installed type definition files
    (more on that later) have no errors. So your compiler won’t check them and will
    become a little faster.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`esModuleInterop` 确保了非 ECMAScript 模块的模块在导入后与标准对齐。`forceConsistentCasingInFileNames`
    帮助使用区分大小写文件系统的人与使用不区分大小写文件系统的人协作。而 `skipLibCheck` 假设你安装的类型定义文件（稍后会详述）没有错误。因此，编译器不会检查它们，编译速度会略微加快。'
- en: One of the most interesting features is TypeScript’s strict mode. If set to
    `true`, TypeScript will behave differently in certain areas. It’s a way for the
    TypeScript team to define their view on how the type system should behave.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 最有趣的特性之一是严格模式。如果设置为 `true`，TypeScript 在某些领域的行为将有所不同。这是 TypeScript
    团队定义类型系统行为方式的一种方式。
- en: If TypeScript introduces a breaking change because the view on the type system
    changes, it will get incorporated in strict mode. This ultimately means that your
    code might break if you update TypeScript and always run in strict mode.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 TypeScript 引入了破坏性变更，因为对类型系统的看法变化，它将在严格模式下被整合。这最终意味着，如果你更新 TypeScript 并且始终运行在严格模式下，你的代码可能会出现问题。
- en: To give you time to adapt to changes, TypeScript also allows you to turn certain
    strict mode features on or off, feature by feature.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给你适应变化的时间，TypeScript 还允许你逐个功能地启用或禁用某些严格模式特性。
- en: 'In addition to the default settings, I strongly recommend two more:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 除了默认设置，我强烈推荐另外两个：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This tells TypeScript to pick up source files from a *src* folder and put the
    compiled files into a *dist* folder. This setup allows you to separate your built
    files from the ones you author. You will have to create the *src* folder, of course;
    the *dist* folder will be created after you compile.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉 TypeScript 从 *src* 文件夹中获取源文件，并将编译后的文件放入 *dist* 文件夹。这种设置允许你将构建文件与你编写的文件分开。当然，你需要创建
    *src* 文件夹；*dist* 文件夹将在编译后创建。
- en: 'Oh, compilation. Once you have your project set up, create an *index.ts* file
    in `src`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Oh, compilation. 项目设置完成后，需在 `src` 文件夹中创建一个 *index.ts* 文件：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The *.ts* extension indicates it’s a TypeScript file. Now run:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展名 *.ts* 表明这是一个 TypeScript 文件。现在运行：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: in your command line and see the compiler at work.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行中查看编译器的工作。
- en: 1.3 Keeping Types on the Side
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.3 保持侧边类型
- en: Problem
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to write regular JavaScript with no extra build step but still get
    some editor support and proper type information for your functions. However, you
    don’t want to define your complex object types with JSDoc as shown in [Recipe
    1.1](#ch01_item_type-checking-javascript).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你想写普通的 JavaScript 而不需要额外的构建步骤，但仍然希望获得一些编辑器支持和函数的正确类型信息。然而，你不想像 [Recipe 1.1](#ch01_item_type-checking-javascript)
    中展示的那样使用 JSDoc 定义复杂的对象类型。
- en: Solution
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Keep type definition files “on the side” and run the TypeScript compiler in
    the “check JavaScript” mode.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 将类型定义文件放在“侧边”，并在 TypeScript 编译器中以“检查 JavaScript”模式运行。
- en: Discussion
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Gradual adoption has always been a dedicated goal for TypeScript. With this
    technique, which I dubbed “types on the side,” you can write TypeScript syntax
    for object types and advanced features like generics and conditional types (see
    [Chapter 5](ch05.html#ch05)) instead of clunky JSDoc comments, but you still write
    JavaScript for your actual app.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 渐进采用一直是 TypeScript 的一个专注目标。通过这种称为“侧边类型”的技术，你可以为对象类型和高级特性如泛型和条件类型编写 TypeScript
    语法（参见 [第5章](ch05.html#ch05)），而不是笨重的 JSDoc 注释，但你仍然为你的实际应用编写 JavaScript。
- en: Somewhere in your project, maybe in a *@types* folder, create a type definition
    file. Its ending is *.d.ts*, and as opposed to regular *.ts* files, its purpose
    is to hold declarations but no actual code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的某个地方，也许在 *@types* 文件夹中，创建一个类型定义文件。它的扩展名是 *.d.ts*，与常规的 *.ts* 文件相反，它的目的是保存声明而不是实际代码。
- en: 'This is where you can write your interfaces, type aliases, and complex types:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这里可以编写接口、类型别名和复杂类型：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Note that you export the interfaces from the declaration files. This is so
    you can import them in your JavaScript files:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你要从声明文件中导出接口。这样你就可以在 JavaScript 文件中导入它们：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The comment on the first line tells TypeScript to import the `Person` type from
    *@types/person* and make it available under the name `Person`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行的注释告诉 TypeScript 从 *@types/person* 导入 `Person` 类型，并使其在名称 `Person` 下可用。
- en: 'Now you can use this identifier to annotate function parameters or objects
    just like you would with primitive types like `string`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以使用这个标识符来注释函数参数或对象，就像你对基本类型如 `string` 所做的那样：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: To make sure that you get editor feedback, you still need to set `@ts-check`
    at the beginning of your JavaScript files as described in [Recipe 1.1](#ch01_item_type-checking-javascript).
    Or, you can configure your project to always check JavaScript.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保获得编辑器反馈，你仍然需要在 JavaScript 文件的开头设置 `@ts-check`，如 [Recipe 1.1](#ch01_item_type-checking-javascript)
    中描述。或者，你可以配置项目始终检查 JavaScript。
- en: Open *tsconfig.json* and set the `checkJs` flag to `true`. This will pick up
    all the JavaScript files from your *src* folder and give you constant feedback
    on type errors in your editor. You also can run `npx tsc` to see if you have errors
    in your command line.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 *tsconfig.json* 并将 `checkJs` 标志设置为 `true`。这将从你的 *src* 文件夹中获取所有 JavaScript
    文件，并在编辑器中持续反馈类型错误。你也可以在命令行中运行 `npx tsc` 来查看是否有错误。
- en: 'If you don’t want TypeScript to transpile your JavaScript files to older versions
    of JavaScript, make sure you set `noEmit` to `true`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不希望 TypeScript 将你的 JavaScript 文件转译为较旧版本的 JavaScript，请确保将 `noEmit` 设置为 `true`：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: With that, TypeScript will look at your source files and will give you all the
    type information you need, but it won’t touch your code.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，TypeScript 将检查你的源文件，并为你提供所需的所有类型信息，但不会修改你的代码。
- en: This technique is also known to scale. Prominent JavaScript libraries like [Preact](https://preactjs.org)
    work like this and provide fantastic tooling for their users as well as their
    contributors.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术也被称为可扩展。像 [Preact](https://preactjs.org) 这样的知名 JavaScript 库就是这样运作的，并为他们的用户以及贡献者提供了出色的工具支持。
- en: 1.4 Migrating a Project to TypeScript
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.4 将项目迁移到 TypeScript
- en: Problem
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to get the full benefits of TypeScript for your project, but you need
    to migrate an entire codebase.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望为项目获得 TypeScript 的全部好处，但需要迁移整个代码库。
- en: Solution
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Rename your modules file by file from *.js* to *.ts*. Use several compiler options
    and features that help you iron out errors.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的模块文件从 *.js* 逐个重命名为 *.ts*。使用多个编译器选项和功能来帮助你消除错误。
- en: Discussion
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The benefit of having TypeScript files instead of JavaScript files with types
    is that your types and implementations are in one file, which gives you better
    editor support and access to more TypeScript features, and increases compatibility
    with other tools.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 TypeScript 文件而不是带有类型的 JavaScript 文件的好处在于，你的类型和实现都在一个文件中，这为编辑器提供了更好的支持和更多的
    TypeScript 功能，并增加了与其他工具的兼容性。
- en: However, just renaming all files from *.js* to *.ts* most likely will result
    in tons of errors. This is why you should go file by file and gradually increase
    type safety as you go along.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，仅仅将所有文件从 *.js* 重命名为 *.ts* 很可能会导致大量的错误。因此，你应该逐个文件地操作，并逐步增加类型安全性。
- en: The biggest problem when migrating is that you’re suddenly dealing with a TypeScript
    project, not with JavaScript. Still, lots of your modules will be JavaScript and,
    with no type information, they will fail the type-checking step.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在迁移时最大的问题是，你突然要处理的是一个 TypeScript 项目，而不是 JavaScript 项目。然而，你的许多模块仍然是 JavaScript，并且没有类型信息，它们将无法通过类型检查步骤。
- en: 'Make it easier for yourself and for TypeScript by turning off type-checking
    for JavaScript, but allow TypeScript modules to load and refer to JavaScript files:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 TypeScript 和自己更轻松，关闭 JavaScript 的类型检查，但允许 TypeScript 模块加载和引用 JavaScript
    文件：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Should you run `npx tsc` now, you will see that TypeScript picks up all JavaScript
    and TypeScript files in your source folder and creates respective JavaScript files
    in your destination folder. TypeScript will also transpile your code to be compatible
    with the specified target version.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行 `npx tsc`，你会看到 TypeScript 会在源文件夹中检索所有 JavaScript 和 TypeScript 文件，并在目标文件夹中创建相应的
    JavaScript 文件。TypeScript 还会将你的代码转译为与指定目标版本兼容的代码。
- en: 'If you are working with dependencies, you will see that some of them don’t
    come with type information. This will also produce TypeScript errors:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在处理依赖项，你会发现其中一些依赖项没有类型信息。这也会导致 TypeScript 错误：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Install third-party type definitions to get rid of this error. See [Recipe 1.5](#ch01_item_definitely_typed).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 安装第三方类型定义以消除此错误。参见 [Recipe 1.5](#ch01_item_definitely_typed)。
- en: Once you migrate file by file, you might realize that you won’t be able to get
    all typings for one file in one go. There are dependencies, and you will quickly
    go down the rabbit hole of having too many files to adjust before you can tackle
    the one that you actually need.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 逐个文件迁移后，你可能会意识到你无法一次性获得一个文件的所有类型定义。存在依赖关系，你很快就会陷入调整过多文件的困境，而你实际需要解决的只是其中一个文件。
- en: 'You can always decide just to live with the error. By default, TypeScript sets
    the compiler option `noEmitOnError` to `false`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择接受错误。默认情况下，TypeScript 将编译器选项 `noEmitOnError` 设置为 `false`：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This means that no matter how many errors you have in your project, TypeScript
    will generate result files, trying not to block you. This might be a setting you
    want to turn on after you finish migrating.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着无论你的项目有多少错误，TypeScript 都会生成结果文件，尽量不阻止你。这可能是你在完成迁移后希望打开的一个设置。
- en: 'In strict mode, TypeScript’s feature flag `noImplicitAny` is set to `true`.
    This flag will make sure that you don’t forget to assign a type to a variable,
    constant, or function parameter. Even if it’s just `any`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在严格模式下，TypeScript 的特性标志 `noImplicitAny` 被设置为 `true`。这个标志将确保你不会忘记为变量、常量或函数参数分配类型，即使它只是
    `any`：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`any` is the catchall type in TypeScript. Every value is compatible with `any`,
    and `any` allows you to access every property or call every method. `any` effectively
    turns off type-checking, giving you some room to breathe during your migration
    process.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`any` 是 TypeScript 中的万能类型。每个值都兼容于 `any`，而且 `any` 允许你访问每个属性或调用每个方法。`any` 有效地关闭了类型检查，在迁移过程中给你一些喘息的空间。'
- en: Alternatively, you can annotate your parameters with `unknown`. This also allows
    you to pass everything to a function but won’t allow you to do anything with it
    until you know more about the type.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以用 `unknown` 注释你的参数。这也允许你将一切传递给函数，但在了解更多类型信息之前不允许对其进行任何操作。
- en: You can also decide to ignore errors by adding a `@ts-ignore` comment before
    the line you want to exclude from type-checking. A `@ts-nocheck` comment at the
    beginning of your file turns off type-checking entirely for this particular module.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以决定通过在要排除在类型检查之外的行之前添加 `@ts-ignore` 注释来忽略错误。在文件开头添加 `@ts-nocheck` 注释可以完全关闭该模块的类型检查。
- en: A comment directive that is fantastic for migration is `@ts-expect-error`. It
    works like `@ts-ignore` as it will swallow errors from the type-checking progress
    but will produce red squiggly lines if no type error is found.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对迁移非常棒的注释指令是 `@ts-expect-error`。它像 `@ts-ignore` 一样，可以吞噬类型检查过程中的错误，但如果没有类型错误，则会产生红色波浪线。
- en: 'When migrating, this helps you find the spots that you successfully moved to
    TypeScript. When there are no `@ts-expect-error` directives left, you’re done:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在迁移过程中，这有助于你找出成功迁移到 TypeScript 的地方。当没有剩余的 `@ts-expect-error` 指令时，你就完成了：
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The great thing about this technique is that you flip responsibilities. Usually,
    you have to make sure that you pass in the right values to a function; now you
    can make sure that the function is able to handle the right input.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术的好处在于你可以颠倒责任。通常，你需要确保将正确的值传递给函数；现在你可以确保函数能够处理正确的输入。
- en: 'All possibilities for getting rid of errors throughout your migration process
    have one thing in common: they’re explicit. You need to explicitly set `@ts-expect-error`
    comments, annotate function parameters as `any`, or ignore files entirely from
    type-checking. With that, you can always search for those escape hatches during
    the migration process and make sure that, over time, you got rid of them all.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 消除迁移过程中所有错误的所有可能性都有一个共同点：它们都是显式的。你需要显式地设置 `@ts-expect-error` 注释、将函数参数注释为 `any`，或完全忽略文件的类型检查。通过这样做，你可以始终搜索这些逃逸通道，以确保随着时间的推移，你完全消除了它们。
- en: 1.5 Loading Types from Definitely Typed
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.5 从 Definitely Typed 加载类型
- en: Problem
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You rely on a dependency that hasn’t been written in TypeScript and therefore
    lacks typings.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你依赖于一个尚未用 TypeScript 编写并因此缺少类型定义的依赖项。
- en: Solution
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: From [Definitely Typed](https://oreil.ly/nZ4xZ), install community-maintained
    type definitions.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [Definitely Typed](https://oreil.ly/nZ4xZ) 获取并安装由社区维护的类型定义。
- en: Discussion
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Definitely Typed is one of the biggest and most active repositories on GitHub
    and collects high-quality TypeScript type definitions developed and maintained
    by the community.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Definitely Typed 是 GitHub 上最大、最活跃的仓库之一，收集由社区开发和维护的高质量 TypeScript 类型定义。
- en: The number of maintained type definitions is close to 10,000, and there is rarely
    a JavaScript library not available.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 维护的类型定义数量接近 10,000，并且几乎没有 JavaScript 库不可用。
- en: All type definitions are linted, checked, and deployed to the Node.js package
    registry NPM under the `@types` namespace. NPM has an indicator on each package’s
    information site that shows if Definitely Typed type definitions are available,
    as you can see in [Figure 1-2](#img-npm-react).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 所有类型定义都经过了代码检查和部署到 Node.js 包注册表 NPM 的 `@types` 命名空间下。NPM 在每个包的信息页面上都有一个指示器，显示是否有
    Definitely Typed 的类型定义，正如你可以在 [Figure 1-2](#img-npm-react) 中看到的那样。
- en: '![tscb 0102](assets/tscb_0102.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![tscb 0102](assets/tscb_0102.png)'
- en: Figure 1-2\. The NPM site for React shows a DT logo next to the package name;
    this indicates available type definitions from Definitely Typed
  id: totrans-145
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-2\. React的NPM站点显示了一个DT标志，这表示来自Definitely Typed的可用类型定义。
- en: Clicking on this logo leads you to the actual site for type definitions. If
    a package has first-party type definitions already available, it shows a small
    TS logo next to the package name, as shown in [Figure 1-3](#img-npm-types-react).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 点击此标志将您引导到实际的类型定义站点。如果一个包已经有第一方的类型定义可用，它会在包名旁边显示一个小的TS标志，就像在[Figure 1-3](#img-npm-types-react)中显示的那样。
- en: '![tscb 0103](assets/tscb_0103.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![tscb 0103](assets/tscb_0103.png)'
- en: Figure 1-3\. Type definitions for React from Definitely Typed
  id: totrans-148
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-3\. 来自Definitely Typed的React类型定义
- en: 'To install, for example, typings for the popular JavaScript framework React,
    you install the `@types/react` package to your local dependencies:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要安装流行的JavaScript框架React的类型，您需要将`@types/react`包安装到您的本地依赖项中：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-151
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In this example we install types to development dependencies, since we consume
    them while developing the application, and the compiled result has no use of the
    types anyway.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们安装类型到开发依赖项，因为在开发应用程序时我们会使用它们，而编译后的结果对类型没有任何用处。
- en: By default, TypeScript will pick up type definitions it can find that are in
    visible *@types* folders relative to your project’s root folder. It will also
    pick up all type definitions from *node_modules/@types*; note that this is where
    NPM installs, for example, `@types/react`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，TypeScript会捕捉到可以在项目根文件夹相对可见的*@types*文件夹中找到的类型定义。它还会从*node_modules/@types*中捕捉到所有类型定义；例如，这就是NPM安装`@types/react`的位置。
- en: 'We do this because the `typeRoots` compiler option in *tsconfig.json* is set
    to `@types` and `./node_modules/@types`. Should you need to override this setting,
    make sure to include the original folders if you want to pick up type definitions
    from Definitely Typed:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做是因为在*tsconfig.json*中的`typeRoots`编译器选项设置为`@types`和`./node_modules/@types`。如果需要覆盖此设置，请确保包括原始文件夹，以便从Definitely
    Typed中获取类型定义：
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that just by installing type definitions into *node_modules/@types*, TypeScript
    will load them during compilation. This means that if some types declare globals,
    TypeScript will pick them up.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，只需将类型定义安装到*node_modules/@types*中，TypeScript就会在编译时加载它们。这意味着如果某些类型声明了全局变量，TypeScript将会捕捉到它们。
- en: 'You might want to explicitly state which packages should be allowed to contribute
    to the global scope by specifying them in the `types` setting in your compiler
    options:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想要明确指定哪些包可以通过在编译器选项的`types`设置中指定它们来贡献到全局作用域：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Note that this setting will only affect the contributions to the global scope.
    If you load node modules via import statements, TypeScript still will pick up
    the correct types from *@types*:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此设置仅影响对全局作用域的贡献。如果通过import语句加载Node模块，则TypeScript仍将从*@types*中获取正确的类型：
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We will revisit this setting in [Recipe 1.7](#ch01_item_testing).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[Recipe 1.7](#ch01_item_testing)中重新讨论这个设置。
- en: 1.6 Setting Up a Full-Stack Project
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.6 设置一个全栈项目
- en: Problem
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to write a full-stack application targeting Node.js and the browser,
    with shared dependencies.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要编写一个针对Node.js和浏览器的全栈应用程序，并且共享依赖项。
- en: Solution
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Create two *tsconfig* files for each frontend and backend, and load shared dependencies
    as composites.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个前端和后端创建两个*tsconfig*文件，并将共享依赖项加载为组合。
- en: Discussion
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Node.js and the browser both run JavaScript, but they have a very different
    understanding of what developers should do with the environment. Node.js is meant
    for servers, command-line tools, and everything that runs without a UI—*headless*.
    It has its own set of APIs and standard library. This little script starts an
    HTTP server:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js和浏览器都运行JavaScript，但它们对开发者应该如何使用环境有着非常不同的理解。Node.js用于服务器、命令行工具以及所有在没有UI界面的情况下运行的内容——*无头*。它有自己的一套API和标准库。这段小脚本启动了一个HTTP服务器：
- en: '[PRE30]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'While it’s without a doubt JavaScript, some things are unique to Node.js:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它毫无疑问是JavaScript，但有些东西是Node.js特有的：
- en: '[![1](assets/1.png)](#co_project_setup_CO1-1)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_project_setup_CO1-1)'
- en: '`"http"` is a built-in Node.js module for everything related to HTTP. It is
    loaded via `require`, which is an indicator for Node’s module system called *CommonJS*.
    There are other ways to load modules in Node.js as we see in [Recipe 1.9](#ch01_item_modules),
    but recently CommonJS has been the most common.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`"http"`是一个内置的Node.js模块，用于处理与HTTP相关的所有事务。它通过`require`加载，这是Node的模块系统CommonJS的一个指示器。在Node.js中，加载模块还有其他方法，我们将在[Recipe
    1.9](#ch01_item_modules)中看到，但最常见的是使用CommonJS。'
- en: '[![2](assets/2.png)](#co_project_setup_CO1-2)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_project_setup_CO1-2)'
- en: The `process` object is a global object containing information on environment
    variables and the current Node.js process in general. This is also unique to Node.js.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`process` 对象是一个全局对象，包含有关环境变量和当前 Node.js 进程的信息。这也是 Node.js 独有的。'
- en: '[![3](assets/3.png)](#co_project_setup_CO1-3)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_project_setup_CO1-3)'
- en: The `console` and its functions are available in almost every JavaScript runtime,
    but what it does in Node is different from what it does in the browser. In Node,
    it prints on STDOUT; in the browser, it will print a line to the development tools.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`console` 及其函数几乎在每个 JavaScript 运行时中都可用，但在 Node 中它的作用与在浏览器中的不同。在 Node 中，它打印到标准输出；在浏览器中，它将在开发工具中打印一行。'
- en: 'There are of course many more unique APIs for Node.js. But the same goes for
    JavaScript in the browser:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Node.js 还有许多独特的 API。但是同样的情况也适用于浏览器中的 JavaScript：
- en: '[PRE31]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[![1](assets/1.png)](#co_project_setup_CO2-1)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_project_setup_CO2-1)'
- en: After years without a way to load modules, ECMAScript modules have found their
    way into JavaScript and the browsers. This line loads an object from another JavaScript
    module. This runs in the browser natively and is a second module system for Node.js
    (see [Recipe 1.9](#ch01_item_modules)).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，没有一种加载模块的方式，ECMAScript 模块已经进入了 JavaScript 和浏览器。此行从另一个 JavaScript 模块中加载对象。这在浏览器中可以原生运行，并且是
    Node.js 的第二个模块系统（参见 [Recipe 1.9](#ch01_item_modules)）。
- en: '[![2](assets/2.png)](#co_project_setup_CO2-2)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_project_setup_CO2-2)'
- en: JavaScript in the browser is meant to interact with UI events. The `document`
    object and the idea of a `querySelector` that points to elements in the *Document
    Object Model (DOM)* are unique to the browser. So is adding an event listener
    and listening on “click” events. You don’t have this in Node.js.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器中的 JavaScript 用于与 UI 事件交互。`document` 对象以及指向 *文档对象模型 (DOM)* 中元素的 `querySelector`
    概念是浏览器独有的。添加事件侦听器并监听“click”事件也是如此。在 Node.js 中是没有这些的。
- en: '[![3](assets/3.png)](#co_project_setup_CO2-3)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_project_setup_CO2-3)'
- en: And again, `console`. It has the same API as in Node.js, but the result is a
    bit different.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提到 `console`。它与 Node.js 中的 API 相同，但结果略有不同。
- en: The differences are so big, it’s hard to create one TypeScript project that
    handles both. If you are writing a full-stack application, you need to create
    two TypeScript configuration files that deal with each part of your stack.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这些差异如此之大，很难创建一个处理两者的 TypeScript 项目。如果您要编写一个全栈应用程序，您需要创建两个 TypeScript 配置文件，分别处理每个部分。
- en: 'Let’s work on the backend first. Let’s assume you want to write an Express.js
    server in Node.js (Express is a popular server framework for Node). First, you
    create a new NPM project as shown in [Recipe 1.1](#ch01_item_type-checking-javascript).
    Then, install Express as a dependency:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们先处理后端。假设您想在 Node.js 中编写一个 Express.js 服务器（Express 是 Node 的流行服务器框架）。首先，按照
    [Recipe 1.1](#ch01_item_type-checking-javascript) 中的示例创建一个新的 NPM 项目。然后，将 Express
    安装为依赖项：
- en: '[PRE32]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'And install type definitions for Node.js and Express from Definitely Typed:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 并从 Definitely Typed 安装 Node.js 和 Express 的类型定义：
- en: '[PRE33]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Create a new folder called *server*. This is where your Node.js code goes.
    Instead of creating a new *tsconfig.json* via `tsc`, create a new *tsconfig.json*
    in your project’s *server* folder. Here are the contents:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 *server* 的新文件夹。这是您的 Node.js 代码所在之处。而不是通过 `tsc` 创建新的 *tsconfig.json*，在您项目的
    *server* 文件夹中创建一个新的 *tsconfig.json*。以下是其内容：
- en: '[PRE34]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You should already know a lot of this, but a few things stand out:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经对此有所了解，但有一些事情尤为突出：
- en: The `module` property is set to `commonjs`, the original Node.js module system.
    All `import` and `export` statements will be transpiled to their CommonJS counterpart.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`module` 属性设置为 `commonjs`，这是原始的 Node.js 模块系统。所有 `import` 和 `export` 语句将被转译为它们的
    CommonJS 对应语句。'
- en: The `types` property is set to `["node"]`. This property includes all the libraries
    you want to have globally available. If `"node"` is in the global scope, you will
    get type information for `require`, `process`, and other Node.js specifics that
    are in the global space.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`types` 属性设置为 `["node"]`。此属性包含您希望在全局范围内可用的所有库。如果全局范围中有 `"node"`，则将获得 `require`、`process`
    和其他 Node.js 特定的类型信息。'
- en: 'To compile your server-side code, run:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译您的服务器端代码，请运行：
- en: '[PRE35]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now for the client:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看客户端：
- en: '[PRE36]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'There are some similarities, but again, a few things stand out:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 有些相似之处，但同样有一些事情尤为突出：
- en: You add `DOM` to the `lib` property. This gives you type definitions for everything
    related to the browser. Where you needed to install Node.js typings via Definitely
    Typed, TypeScript ships the most recent type definitions for the browser with
    the compiler.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`DOM`添加到`lib`属性中。这将为与浏览器相关的所有内容提供类型定义。在以前需要通过Definitely Typed安装Node.js类型定义时，TypeScript现在将最新的浏览器类型定义与编译器一起发布。
- en: The `types` array is empty. This will *remove* `"node"` from our global typings.
    Since you only can install type definitions per *package.json*, the `"node"` type
    definitions we installed earlier would be available in the entire code base. For
    the `client` part, however, you want to get rid of them.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`types`数组为空。这将从全局类型定义中*移除*`"node"`。由于您只能按照*package.json*安装类型定义，我们之前安装的`"node"`类型定义将在整个代码库中可用。但是，对于*client*部分，您希望摆脱它们。'
- en: 'To compile your frontend code, run:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译前端代码，请运行：
- en: '[PRE37]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Please note that you configured two distinct *tsconfig.json* files. Editors
    like Visual Studio Code pick up configuration information only for *tsconfig.json*
    files per folder. You could as well name them *tsconfig.server.json* and *tsconfig.client.json*
    and have them in your project’s root folder (and adjust all directory properties).
    `tsc` will use the correct configurations and throw errors if it finds any, but
    the editor will mostly stay silent or work with a default configuration.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您配置了两个不同的*tsconfig.json*文件。像Visual Studio Code这样的编辑器仅在每个文件夹的*tsconfig.json*文件中获取配置信息。您也可以将它们命名为*tsconfig.server.json*和*tsconfig.client.json*，并将它们放在项目的根文件夹中（并调整所有目录属性）。`tsc`将使用正确的配置，并在发现错误时抛出错误，但编辑器通常会保持沉默或使用默认配置。
- en: Things get a bit hairier if you want to have shared dependencies. One way to
    achieve shared dependencies is to use project references and composite projects.
    This means that you extract your shared code in its own folder, but tell TypeScript
    that this is meant to be a dependency project of another one.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要共享依赖关系，情况会变得有些复杂。实现共享依赖关系的一种方法是使用项目引用和组合项目。这意味着您将共享的代码提取到其自己的文件夹中，并告诉TypeScript这是另一个项目的依赖项目。
- en: 'Create a *shared* folder on the same level as *client* and *server*. Create
    a *tsconfig.json* in *shared* with these contents:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在与*client*和*server*同级的位置创建一个*shared*文件夹。在*shared*文件夹中创建一个*tsconfig.json*文件，并填入以下内容：
- en: '[PRE38]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Two things stand out again:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这里再次有两件事情需要注意：
- en: The flag `composite` is set to `true`. This allows other projects to reference
    this one.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`composite`标志设置为`true`。这允许其他项目引用这个项目。'
- en: The `declaration` flag is also set to `true`. This will generate *d.ts* files
    from your code so other projects can consume type information.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`declaration`标志也设置为`true`。这将从您的代码生成*d.ts*文件，以便其他项目可以使用类型信息。'
- en: 'To include them in your client and server code, add this line to *client/tsconfig.json*
    and *server/tsconfig.json*:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要将它们包含在客户端和服务器代码中，请将此行添加到*client/tsconfig.json*和*server/tsconfig.json*：
- en: '[PRE39]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: And you are all set. You can write shared dependencies and include them in your
    client and server code.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经准备好了。您可以编写共享的依赖项，并将它们包含在客户端和服务器代码中。
- en: There is a caveat, however. This works great if you share, for example, only
    models and type information, but the moment you share actual functionality, you
    will see that the two different module systems (CommonJS in Node, ECMAScript modules
    in the browser) can’t be unified in one compiled file. You either create an ESNext
    module and can’t import it in CommonJS code or create CommonJS code and can’t
    import it in the browser.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里有一个注意事项。如果您只共享模型和类型信息，那么这将非常有效，但是一旦您共享实际功能，您会发现两个不同的模块系统（Node中的CommonJS和浏览器中的ECMAScript模块）无法统一到一个编译文件中。您要么创建一个ESNext模块，无法在CommonJS代码中导入它，要么创建CommonJS代码，无法在浏览器中导入它。
- en: 'There are two things you can do:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 有两件事情您可以做：
- en: Compile to CommonJS and let a bundler take care of the module resolution work
    for the browser.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译为CommonJS，并让捆绑器处理浏览器的模块解析工作。
- en: Compile to ECMAScript modules and write modern Node.js applications based on
    ECMAScript modules. See [Recipe 1.9](#ch01_item_modules) for more information.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译为ECMAScript模块，并编写基于ECMAScript模块的现代Node.js应用程序。有关更多信息，请参见[Recipe 1.9](#ch01_item_modules)。
- en: Since you are starting out new, I strongly recommend the second option.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 因为您是新手，我强烈建议选择第二个选项。
- en: 1.7 Setting Up Tests
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.7 设置测试环境
- en: Problem
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to write tests, but the globals for testing frameworks interfere with
    your production code.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您想编写测试代码，但测试框架的全局变量会干扰您的生产代码。
- en: Solution
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Create a separate *tsconfig* for development and build, and exclude all test
    files in the latter one.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为开发和构建创建单独的*tsconfig*，在后者中排除所有测试文件。
- en: Discussion
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: In the JavaScript and Node.js ecosystem, there are a lot of unit testing frameworks
    and test runners. They vary in detail, have different opinions, or are tailored
    for certain needs. Some of them might just be prettier than others.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 和 Node.js 生态系统中，有许多单元测试框架和测试运行器。它们在细节上有所不同，有不同的观点，或者是为特定需求定制的。有些可能只是比其他框架更漂亮。
- en: 'While test runners like [Ava](https://oreil.ly/R6xFr) rely on importing modules
    to get the framework into scope, others provide a set of globals. Take [Mocha](https://mochajs.org),
    for example:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 就像[Ava](https://oreil.ly/R6xFr)这样的测试运行器依赖于导入模块来引入框架范围内，其他一些则提供一组全局对象。例如，[Mocha](https://mochajs.org)：
- en: '[PRE40]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`assert` comes from the Node.js built-in assertion library, but `describe`,
    `it`, and many more are globals provided by Mocha. They also only exist when the
    Mocha CLI is running.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert`来自于 Node.js 内置的断言库，但`describe`、`it`等是 Mocha 提供的全局对象。它们也只存在于 Mocha CLI
    运行时。'
- en: This provides a bit of a challenge for your type setup, as those functions are
    necessary to write tests but aren’t available when you execute your actual application.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这对你的类型设置提出了一些挑战，因为这些函数在编写测试时是必需的，但在执行实际应用程序时却不可用。
- en: 'The solution is to create two different configuration files: a regular *tsconfig.json*
    for development that your editor can pick up (remember [Recipe 1.6](#ch01_item_fullstack))
    and a separate *tsconfig.build.json* that you use when you want to compile your
    application.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是创建两个不同的配置文件：一个是常规的*tsconfig.json*用于开发（你的编辑器可以识别，记得[配方 1.6](#ch01_item_fullstack)），另一个是*tsconfig.build.json*，用于编译应用程序时使用。
- en: The first one includes all the globals you need, including types for Mocha;
    the latter makes sure no test file is included within your compilation.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个包含所有你需要的全局对象，包括 Mocha 的类型；而后者则确保在编译中不包含任何测试文件。
- en: Let’s go through this step by step. We look at Mocha as an example, but other
    test runners that provide globals like [Jest](https://jestjs.io) work just the
    same way.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步进行。我们以 Mocha 为例，但其他提供类似全局对象的测试运行器，比如[Jest](https://jestjs.io)，也可以按照相同的方式工作。
- en: 'First, install Mocha and its types:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，安装 Mocha 及其类型：
- en: '[PRE41]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Create a new *tsconfig.base.json*. Since the only differences between development
    and build are the set of files to be included and the libraries activated, you
    want to have all the other compiler settings located in one file you can reuse
    for both. An example file for a Node.js application would look like this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的*tsconfig.base.json*。由于开发和构建之间唯一的区别是要包含的文件集和激活的库，因此你希望将所有其他编译器设置放在一个可以重用的文件中。一个用于
    Node.js 应用程序的示例文件如下：
- en: '[PRE42]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The source files should be located in *src*; test files should be located in
    an adjacent folder *test*. The setup you create in this recipe will also allow
    you to create files ending with *.test.ts* anywhere in your project.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 源文件应位于*src*；测试文件应位于相邻的*test*文件夹中。在此配方中创建的设置还允许你在项目的任何地方创建以*.test.ts*结尾的文件。
- en: 'Create a new *tsconfig.json* with your base development configuration. This
    one is used for editor feedback and for running tests with Mocha. You extend the
    basic settings from *tsconfig.base.json* and inform TypeScript which folders to
    pick up for compilation:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的*tsconfig.json*，包含你的基本开发配置。这个配置用于编辑器反馈和在 Mocha 中运行测试。你可以从*tsconfig.base.json*继承基本设置，并告诉
    TypeScript 哪些文件夹用于编译：
- en: '[PRE43]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note that you add `types` for Node and Mocha. The `types` property defines which
    globals are available and, in the development setting, you have both.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你需要为 Node 和 Mocha 添加`types`。`types`属性定义了可用的全局对象，在开发环境中你需要这两者。
- en: 'Additionally, you might find that compiling your tests before executing them
    is cumbersome. There are shortcuts to help you. For example, `ts-node` runs your
    local installation of Node.js and does an in-memory TypeScript compilation first:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可能会发现在执行测试之前编译它们很麻烦。有一些快捷方式可以帮助你。例如，`ts-node`首先运行你本地安装的 Node.js，并进行内存中的
    TypeScript 编译：
- en: '[PRE44]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'With the development environment set up, it’s time for the build environment.
    Create a *tsconfig.build.json*. It looks similar to *tsconfig.json*, but you will
    spot the difference right away:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置开发环境后，是构建环境的时候了。创建一个*tsconfig.build.json*。它看起来与*tsconfig.json*类似，但你会立即发现其中的区别：
- en: '[PRE45]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In addition to changing `types` and `rootDirs`, you define which files to exclude
    from type-checking and compilation. You use wild-card patterns that exclude all
    files ending with *.test.ts* that are located in test folders. Depending on your
    taste, you can also add *.spec.ts* or *spec* folders to this array.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更改`types`和`rootDirs`外，您还可以定义要从类型检查和编译中排除的文件。您可以使用通配符模式来排除所有位于测试文件夹中且以*.test.ts*结尾的文件。根据您的喜好，您还可以将*.spec.ts*或*spec*文件夹添加到此数组中。
- en: 'Compile your project by referring to the right JSON file:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引用正确的JSON文件来编译您的项目：
- en: '[PRE46]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You will see that in the result files (located in `dist`), you won’t see any
    test file. Also, while you still can access `describe` and `it` when editing your
    source files, you will get an error if you try to compile:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到在结果文件（位于`dist`中）中，不会看到任何测试文件。此外，虽然在编辑源文件时仍然可以访问`describe`和`it`，但如果尝试编译，则会收到错误消息：
- en: '[PRE47]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: If you don’t like polluting your globals during development mode, you can choose
    a similar setup as in [Recipe 1.6](#ch01_item_fullstack), but it won’t allow you
    to write tests adjacent to your source files.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不喜欢在开发模式中污染全局命名空间，可以选择与[Recipe 1.6](#ch01_item_fullstack)类似的设置，但它不允许您在源文件旁边编写测试。
- en: Finally, you can always opt for a test runner that prefers the module system.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您始终可以选择偏向模块系统的测试运行器。
- en: 1.8 Typing ECMAScript Modules from URLs
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.8 从URL中输入ECMAScript模块类型
- en: Problem
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to work without bundlers and use the browser’s module-loading capabilities
    for your app, yet you still want to have all the type information.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望在不使用捆绑工具的情况下使用浏览器的模块加载功能来处理您的应用程序，但仍希望获得所有类型信息。
- en: Solution
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Set `target` and `module` in your *tsconfig*’s compiler options to `esnext`
    and point to your modules with a *.js* extension. In addition, install types to
    dependencies via NPM, and use the `path` property in your *tsconfig* to tell TypeScript
    where to look for types:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的*tsconfig*的编译器选项中设置`target`和`module`为`esnext`，并使用*.js*扩展名指向您的模块。此外，通过NPM安装依赖项的类型，并在*tsconfig*中使用`path`属性告诉TypeScript在哪里查找类型：
- en: '[PRE48]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Discussion
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Modern browsers support module loading out of the box. Instead of bundling your
    app into a smaller set of files, you can use the raw JavaScript files directly.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现代浏览器原生支持模块加载。您可以直接使用原始JavaScript文件，而不是将应用程序捆绑成较小的一组文件。
- en: Content Delivery Networks (CDNs) like [esm.sh](https://esm.sh), [unpkg](https://unpkg.com),
    and others are designed to distribute node modules and JavaScript dependencies
    as URLs, consumable by native ECMAScript module loading.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 内容传递网络（CDN）如[esm.sh](https://esm.sh)，[unpkg](https://unpkg.com)等旨在以URL形式分发节点模块和JavaScript依赖项，以供本地ECMAScript模块加载使用。
- en: With proper caching and state-of-the-art HTTP, ECMAScript modules become a real
    alternative for apps.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 使用适当的缓存和最先进的HTTP，ECMAScript模块成为应用程序的真正替代品。
- en: TypeScript does not include a modern bundler, so you would need to install an
    extra tool anyway. But if you decide to go module first, there are a few things
    to consider when working with TypeScript.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript不包括现代捆绑工具，因此您无论如何都需要安装额外的工具。但是，如果决定采用模块优先方式，使用TypeScript时需要考虑几个因素。
- en: 'What you want to achieve is to write `import` and `export` statements in TypeScript
    but preserve the module-loading syntax and let the browser handle module resolution:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 您要达到的目标是在TypeScript中编写`import`和`export`语句，但保留模块加载语法，并让浏览器处理模块解析：
- en: '[PRE49]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To achieve this, tell TypeScript to:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，请告诉TypeScript：
- en: Compile to an ECMAScript version that understands modules
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译到理解模块的ECMAScript版本
- en: Use the ECMAScript module syntax for module code generation
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用ECMAScript模块语法进行模块代码生成
- en: 'Update two properties in your *tsconfig.json*:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的*tsconfig.json*中更新两个属性：
- en: '[PRE50]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '`module` tells TypeScript how to transform import and export statements. The
    default converts module loading to CommonJS, as seen in [Recipe 1.2](#ch01_item_installing).
    Setting `module` to `esnext` will use ECMAScript module loading and thus preserve
    the syntax.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`module`告诉TypeScript如何转换导入和导出语句。默认情况下，它将模块加载转换为CommonJS格式，如[Recipe 1.2](#ch01_item_installing)中所示。将`module`设置为`esnext`将使用ECMAScript模块加载，从而保留语法。'
- en: '`target` tells TypeScript the ECMAScript version you want to transpile your
    code to. Once a year, there’s a new ECMAScript release with new features. Setting
    `target` to `esnext` will always target the latest ECMAScript version.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`target`告诉TypeScript您要将代码转换为的ECMAScript版本。每年都会发布新的ECMAScript版本，具有新功能。将`target`设置为`esnext`将始终针对最新的ECMAScript版本。'
- en: Depending on your compatibility goals, you might want to set this property to
    the ECMAScript version compatible with the browsers you want to support. This
    is usually a version with a year (e.g. `es2015`, `es2016`, `es2017`, etc). ECMAScript
    modules work with every version from `es2015` on. If you go for an older version,
    you won’t be able to load ECMAScript modules natively in the browser.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的兼容性目标，你可能希望将这个属性设置为与你想要支持的浏览器兼容的 ECMAScript 版本。通常是年份形式的版本（例如 `es2015`、`es2016`、`es2017`
    等）。ECMAScript 模块从 `es2015` 版本开始支持。如果选择较旧的版本，你将无法在浏览器中原生加载 ECMAScript 模块。
- en: 'Changing these compiler options already does one important thing: it leaves
    the syntax intact. A problem occurs once you want to run your code.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 改变这些编译器选项已经做了一件重要的事情：保持语法不变。但是一旦你想要运行你的代码，问题就会出现。
- en: Usually, import statements in TypeScript point to files without an extension.
    You write `import { obj } from "./module"`, leaving out *.ts*. Once you compile,
    this extension is still missing. But the browser needs an extension to actually
    point to the respective JavaScript file.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在 TypeScript 中，导入语句指向没有扩展名的文件。你可以写 `import { obj } from "./module"`，省略 *.ts*
    扩展名。但是一旦编译，这个扩展名仍然缺失。但浏览器需要扩展名来实际指向相应的 JavaScript 文件。
- en: 'The solution: Add a *.js* extension, even though you are pointing to a *.ts*
    file when you develop. TypeScript is smart enough to pick that up:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案：即使在开发时指向 *.ts* 文件，也要添加 *.js* 扩展名。TypeScript 能够智能地识别到这一点：
- en: '[PRE51]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: For your project’s modules, that’s all you need!
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 对于项目的模块来说，这就是你所需的一切！
- en: 'It gets a lot more interesting when you want to use dependencies. If you go
    native, you might want to load modules from a CDN, like [esm.sh](https://esm.sh):'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要使用依赖项时，情况就变得更加有趣了。如果你选择原生方式，可能会希望从 CDN 加载模块，比如 [esm.sh](https://esm.sh)：
- en: '[PRE52]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'TypeScript will error with the following message: “Cannot find module *…​*
    or its corresponding type declarations. (2307)”'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 将会报错，错误信息如下：“无法找到模块 *...* 或其相应的类型声明。(2307)”
- en: TypeScript’s module resolution works when files are on your disk, not on a server
    via HTTP. To get the info we need, we have to provide TypeScript with a resolution
    of our own.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 的模块解析在文件位于你的硬盘上时有效，而不是通过 HTTP 在服务器上时有效。为了获得我们所需的信息，我们必须为 TypeScript
    提供自己的解析方式。
- en: 'Even though we are loading dependencies from URLs, the type information for
    these dependencies lives with NPM. For `lodash`, you can install type information
    from Definitely Typed:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们从 URL 加载依赖项，这些依赖项的类型信息仍然驻留在 NPM 中。对于 `lodash`，你可以从 Definitely Typed 安装类型信息。
- en: '[PRE53]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'For dependencies that come with their own types, you can install the dependencies
    directly:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 对于自带类型声明的依赖项，你可以直接安装这些依赖项：
- en: '[PRE54]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Once the types are installed, use the `path` property in your compiler options
    to tell TypeScript how to resolve your URL:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了类型声明，使用编译器选项中的 `path` 属性告诉 TypeScript 如何解析你的 URL：
- en: '[PRE55]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Be sure to point to the right file!
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 确保指向正确的文件！
- en: 'There’s also an escape hatch if you don’t want to use typings, or if you just
    can’t find typings. Within TypeScript, we can use `any` to intentionally disable
    type-checking. For modules, we can do something very similar—ignore the TypeScript
    error:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想使用类型声明或者找不到类型声明，还有一种应急方法。在 TypeScript 中，我们可以使用 `any` 来有意地禁用类型检查。对于模块，我们可以做类似的事情——忽略
    TypeScript 的错误：
- en: '[PRE56]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`ts-ignore` removes the *next* line from type-checking and can be used everywhere
    you want to ignore type errors (see [Recipe 1.4](#ch01_item_migrating)). This
    effectively means that you won’t get any type information for your dependencies
    and you might run into errors, but it might be the ultimate solution for unmaintained,
    old dependencies that you just need but won’t find any types for.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`ts-ignore` 从类型检查中移除 *下一行* ，可以在任何你想忽略类型错误的地方使用（见 [Recipe 1.4](#ch01_item_migrating)）。这实际上意味着你不会得到任何依赖项的类型信息，可能会遇到错误，但对于那些未维护的旧依赖项，这可能是最终的解决方案。'
- en: 1.9 Loading Different Module Types in Node
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.9 在 Node 中加载不同的模块类型
- en: Problem
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to use ECMAScript modules in Node.js and the CommonJS interoperability
    feature for libraries.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 你想在 Node.js 中使用 ECMAScript 模块，并为库使用 CommonJS 互操作性特性。
- en: Solution
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Set TypeScript’s module resolution to `"nodeNext"` and name your files *.mts*
    or *.cts*.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 将 TypeScript 的模块解析设置为 `"nodeNext"`，并命名你的文件为 *.mts* 或 *.cts*。
- en: Discussion
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: With the advent of Node.js, the CommonJS module system has become one of the
    most popular module systems in the JavaScript ecosystem.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 Node.js 的出现，CommonJS 模块系统已经成为 JavaScript 生态系统中最流行的模块系统之一。
- en: 'The idea is simple and effective: define exports in one module and require
    them in another:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法简单而有效：在一个模块中定义导出，然后在另一个模块中引用它们：
- en: '[PRE57]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This system has been a huge influence on ECMAScript modules and also has been
    the default for TypeScript’s module resolution and transpiler. If you look at
    the ECMAScript modules syntax in [Example 1-1](#listing_cts), you can see that
    the keywords allow for different transpilations. This means that with the `commonjs`
    module setting, your `import` and `export` statements are transpiled to `require`
    and `exports`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统对 ECMAScript 模块产生了巨大影响，也已成为 TypeScript 模块解析和转译的默认方式。如果你查看 [Example 1-1](#listing_cts)
    中的 ECMAScript 模块语法，你可以看到这些关键字允许不同的转译。这意味着在 `commonjs` 模块设置下，你的 `import` 和 `export`
    语句将被转译为 `require` 和 `exports`。
- en: Example 1-1\. Using the ECMAScript module system
  id: totrans-302
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-1\. 使用 ECMAScript 模块系统
- en: '[PRE58]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: With ECMAScript modules stabilizing, Node.js has also started to adopt them.
    Even though the basics of both module systems seem to be very similar, there are
    some differences in the details, such as handling default exports or loading ECMAScript
    modules asynchronously.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 ECMAScript 模块稳定下来，Node.js 也开始采用它们。尽管两种模块系统的基础看起来非常相似，但在细节处理上存在一些差异，例如处理默认导出或异步加载
    ECMAScript 模块。
- en: As there is no way to treat both module systems the same but with different
    syntax, the Node.js maintainers decided to give both systems room and assigned
    different file endings to indicate the preferred module type. [Table 1-1](#table_mjs_cjs_js)
    shows the different endings, how they’re named in TypeScript, what TypeScript
    compiles them to, and what they can import. Thanks to the CommonJS interoperability,
    it’s fine to import CommonJS modules from ECMAScript modules, but not the other
    way around.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 由于无法使用不同的语法对待两种模块系统，Node.js 的维护者决定为它们留出空间，并为首选模块类型分配不同的文件结尾。[表 1-1](#table_mjs_cjs_js)
    显示了不同的结尾，它们在 TypeScript 中的命名，TypeScript 将它们编译成什么，以及它们可以导入什么。由于 CommonJS 的互操作性，从
    ECMAScript 模块中导入 CommonJS 模块是可以的，但反之则不行。
- en: Table 1-1\. Module endings and what they import
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1-1\. 模块结尾及其导入内容
- en: '| Ending | TypeScript | Compiles to | Can import |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| 结尾 | TypeScript | 编译为 | 可导入 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| *.js* | *.ts* | CommonJS | *.js*, *.cjs* |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| *.js* | *.ts* | CommonJS | *.js*, *.cjs* |'
- en: '| *.cjs* | *.cts* | CommonJS | *.js*, *.cjs* |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| *.cjs* | *.cts* | CommonJS | *.js*, *.cjs* |'
- en: '| *.mjs* | *.mts* | ES Modules | *.js*, *.cjs*, *.mjs* |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| *.mjs* | *.mts* | ES Modules | *.js*, *.cjs*, *.mjs* |'
- en: 'Library developers who publish on NPM get extra information in their *package.json*
    file to indicate the main type of a package (`module` or `commonjs`), and to point
    to a list of main files or fallbacks so module loaders can pick up the right file:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在 NPM 上发布库的库开发者可以在他们的 *package.json* 文件中获取额外的信息，以指示包的主要类型（`module` 或 `commonjs`），并指向一系列主要文件或回退，以便模块加载器能够选择正确的文件：
- en: '[PRE59]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In TypeScript, you write mainly ECMAScript module syntax and let the compiler
    decide which module format to create in the end. Now there are possibly two: CommonJS
    and ECMAScript modules.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 中，主要采用 ECMAScript 模块语法，并由编译器决定最终创建哪种模块格式。现在可能有两种格式：CommonJS 和 ECMAScript
    模块。
- en: 'To allow for both, you can set module resolution in your *tsconfig.json* to
    `NodeNext`:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许两者，你可以在 *tsconfig.json* 中设置模块解析为 `NodeNext`：
- en: '[PRE60]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: With that flag, TypeScript will pick up the right modules as described in your
    dependencies *package.json*, will recognize *.mts* and *.cts* endings, and will
    follow [Table 1-1](#table_mjs_cjs_js) for module imports.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个标志，TypeScript 将根据你的依赖关系 *package.json* 中描述的正确模块来选择，将识别 *.mts* 和 *.cts* 结尾，并且将遵循
    [表 1-1](#table_mjs_cjs_js) 中的模块导入。
- en: For you as a developer, there are differences in importing files. Since CommonJS
    didn’t require endings when importing, TypeScript still supports imports without
    endings. The example in [Example 1-1](#listing_cts) still works, if all you use
    is CommonJS.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发者来说，导入文件时存在差异。由于在导入时 CommonJS 不需要结尾，TypeScript 仍支持无结尾导入。例如，在 [Example 1-1](#listing_cts)
    中的示例仍然有效，如果你只使用的是 CommonJS。
- en: 'Importing with file endings, just like in [Recipe 1.8](#ch01_item_es_modules),
    allows modules to be imported in both ECMAScript modules and CommonJS modules:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 使用文件结尾进行导入，就像在 [Recipe 1.8](#ch01_item_es_modules) 中一样，允许模块在 ECMAScript 模块和
    CommonJS 模块中导入：
- en: '[PRE61]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Should CommonJS interoperability not work, you can always fall back on a `require`
    statement. Add `"node"` as global types to your compiler options:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 CommonJS 互操作性不起作用，你可以始终退回到 `require` 语句。将 `"node"` 添加为全局类型到你的编译选项中：
- en: '[PRE62]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Then, import with this TypeScript-specific syntax:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用这种特定于 TypeScript 的语法进行导入：
- en: '[PRE63]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In a CommonJS module, this will be just another `require` call; in ECMAScript
    modules, this will include Node.js helper functions:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在CommonJS模块中，这将只是另一个`require`调用；在ECMAScript模块中，这将包括Node.js的辅助函数：
- en: '[PRE64]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Note that this will reduce compatibility with non-Node.js environments like
    the browser, but it might eventually fix interoperability issues.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这将降低与非Node.js环境（如浏览器）的兼容性，但最终可能会修复互操作性问题。
- en: 1.10 Working with Deno and Dependencies
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.10 使用Deno和依赖项
- en: Problem
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to use TypeScript with Deno, a modern JavaScript runtime for applications
    outside the browser.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望在Deno中使用TypeScript，这是一个面向非浏览器应用程序的现代JavaScript运行时。
- en: Solution
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: That’s easy; TypeScript is built in.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易；TypeScript已经内置。
- en: Discussion
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Deno is a modern JavaScript runtime created by the same people who developed
    Node.js. Deno is similar to Node.js in many ways, but with significant differences:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: Deno是由开发Node.js的同一团队创建的现代JavaScript运行时。Deno在很多方面类似于Node.js，但也有显著的区别：
- en: Deno adopts web platform standards for their main APIs, meaning that you will
    find it easier to port code from the browser to the server.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Deno采用Web平台标准作为其主要API，这意味着你可以更轻松地将代码从浏览器移植到服务器。
- en: It allows file system or network access only if you explicitly activate it.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它只允许在显式激活时访问文件系统或网络。
- en: It doesn’t handle dependencies via a centralized registry, but—again adopting
    browser features—via URLs.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不通过集中式注册表处理依赖关系，而是——再次采用浏览器特性——通过URL处理。
- en: Oh, and it comes with built-in development tooling and TypeScript!
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 噢，它还带有内置的开发工具和TypeScript！
- en: 'Deno is the tool with the lowest barrier if you want to try TypeScript. No
    need to download any other tool (the `tsc` compiler is already built in), no need
    for TypeScript configurations. You write *.ts* files, and Deno handles the rest:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想尝试TypeScript，Deno是最低门槛的工具。无需下载任何其他工具（`tsc`编译器已经内置），也不需要TypeScript配置。您只需编写*.ts*文件，Deno会处理其余：
- en: '[PRE65]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Deno’s TypeScript can do everything `tsc` can do, and it is updated with every
    Deno update. However, there are some differences when you want to configure it.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: Deno的TypeScript可以做任何`tsc`能做的事情，并且随着每次Deno更新而更新。然而，在你想要配置它时，有一些不同之处。
- en: First, the default configuration has differences in its default settings as
    opposed to the default configuration issued by `tsc --init`. Strict mode feature
    flags are set differently, and it includes support for React (on the server side!).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，默认配置在其默认设置中与通过`tsc --init`发行的默认配置有所不同。严格模式功能标志设置不同，并包括对React（在服务器端！）的支持。
- en: 'To make changes to the configuration, you should create a *deno.json* file
    in your root folder. Deno will automatically pick this up, unless you tell it
    not to. *deno.json* includes several configurations for the Deno runtime, including
    TypeScript compiler options:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 要对配置进行更改，你应该在根文件夹中创建一个*deno.json*文件。除非告诉它不要，否则Deno会自动加载此文件。*deno.json*包含用于Deno运行时的多个配置，包括TypeScript编译器选项：
- en: '[PRE67]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: You can see more possibilities on the [Deno website](https://oreil.ly/zGA--).
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[Deno网站](https://oreil.ly/zGA--)上看到更多可能性。
- en: The default libraries are different as well. Even though Deno supports web platform
    standards and has browser-compatible APIs, it needs to make some cuts because
    there is no graphical user interface. That’s why some types—for example, the DOM
    library—clash with what Deno provides.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 默认库也有所不同。尽管Deno支持Web平台标准并具有与浏览器兼容的API，但它需要做一些裁剪，因为没有图形用户界面。这就是为什么某些类型（例如DOM库）与Deno提供的内容冲突。
- en: 'Some libraries of interest are:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 一些有趣的库有：
- en: '*deno.ns*, the default Deno namespace'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*deno.ns*，默认的Deno命名空间'
- en: '*deno.window*, the global object for Deno'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*deno.window*，Deno的全局对象'
- en: '*deno.worker*, the equivalent for Web Workers in the Deno runtime'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*deno.worker*，Deno运行时中Web Workers的等效物'
- en: 'DOM and subsets are included in Deno, but they are not switched on by default.
    If your application targets both the browser and Deno, configure Deno to include
    all browser and Deno libraries:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: Deno包含DOM和其子集，但默认情况下不会开启。如果您的应用程序同时面向浏览器和Deno，请配置Deno以包含所有浏览器和Deno库：
- en: '[PRE68]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[Aleph.js](https://alephjs.org) is an example of a framework that targets both
    Deno and the browser.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '[Aleph.js](https://alephjs.org)是一个旨在同时面向Deno和浏览器的框架的示例。'
- en: Also different with Deno is how type information for dependencies is distributed.
    External dependencies in Deno are loaded via URLs from a CDN. Deno itself hosts
    its standard library at [*https://deno.land/std*](https://deno.land/std).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 与Deno不同的是，外部依赖项的类型信息是如何分布的。在Deno中，外部依赖项通过CDN的URL加载。Deno本身将其标准库托管在[*https://deno.land/std*](https://deno.land/std)。
- en: But you can also use CDNs like [esm.sh](https://esm.sh) or [unpkg](https://unpkg.com),
    like in [Recipe 1.8](#ch01_item_es_modules). These CDNs distribute types by sending
    an `X-TypeScript-Types` header with the HTTP request, showing Deno was to load
    type declarations. This also goes for dependencies that don’t have first-party
    type declarations but rely on Definitely Typed.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 但您也可以像在[Recipe 1.8](#ch01_item_es_modules)中那样使用CDN，例如[esm.sh](https://esm.sh)或[unpkg](https://unpkg.com)。这些CDN通过在HTTP请求中发送`X-TypeScript-Types`头部来分发类型，显示Deno将加载类型声明。这也适用于没有官方类型声明但依赖于Definitely
    Typed的依赖项。
- en: So the moment you install your dependency, Deno will fetch not only the source
    files but also all the type information.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一旦安装了依赖项，Deno 将获取源文件以及所有类型信息。
- en: 'If you don’t load a dependency from a CDN but rather have it locally, you can
    point to a type declaration file the moment you import the dependency:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不从CDN加载依赖项，而是在本地拥有它，您可以在导入依赖项的时候指向类型声明文件：
- en: '[PRE69]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'or include a reference to the typings in the library itself:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 或者在库本身中包含对类型的引用：
- en: '[PRE70]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This reference is also called a *triple-slash directive* and is a TypeScript
    feature, not a Deno feature. There are various triple-slash directives, mostly
    used for pre-ECMAScript module dependency systems. The [documentation](https://oreil.ly/EvUWm)
    gives a really good overview. If you stick with ECMAScript modules, you most likely
    won’t use triple-slash directives, though.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 此引用也称为*三斜线指令*，是TypeScript的一个特性，而不是Deno的特性。有各种三斜线指令，主要用于前ECMAScript模块依赖系统。[文档](https://oreil.ly/EvUWm)
    提供了非常好的概述。如果您坚持使用ECMAScript模块，您很可能不会使用三斜线指令。
- en: 1.11 Using Predefined Configurations
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.11 使用预定义配置
- en: Problem
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to use TypeScript for a certain framework or platform but don’t know
    where to start with your configuration.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要为某个框架或平台使用TypeScript，但不知道如何开始配置。
- en: Solution
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use a predefined configuration from [*tsconfig/bases*](https://oreil.ly/ljsVT)
    and extend from there.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[*tsconfig/bases*](https://oreil.ly/ljsVT)中的预定义配置，并在此基础上进行扩展。
- en: Discussion
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Just like Definitely Typed hosts community-maintained type definitions for popular
    libraries, *tsconfig/bases* hosts a set of community-maintained recommendations
    for TypeScript configurations you can use as a starting point for your own project.
    This includes frameworks like Ember.js, Svelte, or Next.js as well as JavaScript
    runtimes like Node.js and Deno.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Definitely Typed为流行库提供社区维护的类型定义一样，*tsconfig/bases*提供了一组社区维护的推荐TypeScript配置，可以作为项目的起点。这包括像Ember.js、Svelte或Next.js这样的框架，以及像Node.js和Deno这样的JavaScript运行时。
- en: The configuration files are reduced to a minimum, dealing mostly with recommended
    libraries, modules, and target settings, and a bunch of strict mode flags that
    make sense for the respective environment.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件被简化到最低限度，主要处理推荐的库、模块和目标设置，以及一堆对相应环境有意义的严格模式标志。
- en: 'For example, this is the recommended configuration for Node.js 18, with a recommended
    strict mode setting and with ECMAScript modules:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是Node.js 18的推荐配置，带有推荐的严格模式设置和ECMAScript模块：
- en: '[PRE71]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'To use this configuration, install it via NPM:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此配置，请通过NPM安装：
- en: '[PRE72]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'and wire it up in your own TypeScript configuration:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 并将其与您自己的TypeScript配置连接起来：
- en: '[PRE73]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This will pick up all the settings from the predefined configuration. You can
    now start setting your own properties, for example, root and out directories.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从预定义配置中获取所有设置。现在您可以开始设置自己的属性，例如根目录和输出目录。
- en: ^([1](ch01.html#id393-marker)) Objects assigned to a `const` binding can still
    change values and properties, and thus change their types.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch01.html#id393-marker)) 分配给`const`绑定的对象仍然可以更改值和属性，从而改变它们的类型。
- en: ^([2](ch01.html#id406-marker)) TypeScript also works in other JavaScript runtimes,
    such as Deno and the browser, but they are not intended as main targets.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch01.html#id406-marker)) TypeScript还可以在其他JavaScript运行时环境中工作，比如Deno和浏览器，但它们并不是主要的目标。
