- en: Chapter 9\. Frontend and Backend Frameworks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章。前端和后端框架
- en: While you could build every part of your application yourself from the ground
    up—the networking and database layers on the server, a user interface framework
    and state management solution on the frontend—you probably shouldn’t. It’s hard
    to get the details right, and luckily for us, lots of these hard problems on the
    frontend and backend have already been solved by other engineers. By taking advantage
    of existing tools, libraries, and frameworks to build things both on the frontend
    and the backend, we can iterate quickly and on stable ground when building our
    own applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以从头开始构建应用程序的每个部分——在服务器上的网络和数据库层，前端的用户界面框架和状态管理解决方案——但你可能不应该这样做。很难把细节做好，幸运的是，许多这些前端和后端的难题已经被其他工程师解决了。通过利用现有的工具、库和框架来构建前端和后端的东西，我们可以在构建自己的应用程序时快速迭代并站在稳定的基础上。
- en: In this chapter, we’ll go through some of the most popular tools and frameworks
    that solve common problems on both the client and the server. We’ll talk about
    what you might use each framework for, and how to safely integrate it into your
    TypeScript application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍一些在客户端和服务器上解决常见问题的最流行的工具和框架。我们将讨论您可能会使用每个框架以及如何安全地将其集成到您的 TypeScript
    应用程序中。
- en: Frontend Frameworks
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前端框架
- en: TypeScript is a natural fit for the world of frontend applications. With its
    rich support for JSX and its ability to safely model mutability, TypeScript lends
    structure and safety to your application and makes it easier to write correct,
    maintainable code in the fast-paced environment that is frontend development.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 自然适合于前端应用程序的世界。凭借其对 JSX 的丰富支持以及安全建模可变性的能力，TypeScript 为您的应用程序提供结构和安全性，并使得在快节奏的前端开发环境中编写正确、可维护的代码变得更加容易。
- en: 'Of course, all of the built-in DOM APIs are typesafe. To use them from TypeScript,
    just include their type declarations in your project’s *tsconfig.json*:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，所有内置的 DOM API 都是类型安全的。要从 TypeScript 中使用它们，只需在项目的 *tsconfig.json* 中包含它们的类型声明：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: That will tell TypeScript to include *lib.dom.d.ts*—its built-in browser and
    DOM type declarations—when typechecking your code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这将告诉 TypeScript 在检查代码时包含*lib.dom.d.ts*——其内置的浏览器和 DOM 类型声明。
- en: Note
  id: totrans-8
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `lib` *tsconfig.json* option just tells TypeScript to include a set of specific
    type declarations when processing the code in your project; it won’t emit any
    extra code, or generate any JavaScript that will exist at runtime. It won’t, for
    example, make the DOM magically work in a NodeJS environment (your code will compile,
    but it will fail at runtime)—it’s on you to make sure that your type declarations
    match up to what your JavaScript environment actually supports at runtime. Jump
    ahead to [“Building Your TypeScript Project”](ch12.html#building) to learn more.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`lib` *tsconfig.json* 选项只是告诉 TypeScript 在处理项目中的代码时包含一组特定的类型声明；它不会生成任何额外的代码，或者生成任何在运行时存在的
    JavaScript。例如，它不会让 DOM 在 NodeJS 环境中奇迹般地工作（您的代码会编译，但在运行时会失败）——您需要确保您的类型声明与您的 JavaScript
    环境在运行时实际支持的内容匹配。跳到 [“构建您的 TypeScript 项目”](ch12.html#building) 了解更多信息。'
- en: 'With DOM type declarations enabled, you’ll be able to safely consume DOM and
    browser APIs to do things like:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 启用 DOM 类型声明后，您可以安全地使用 DOM 和浏览器 API 来执行诸如以下操作：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Of course, all of that code is typechecked and comes with the normal goodies
    like in-editor autocompletion. For example, consider something like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，所有这些代码都经过类型检查，并且具有像编辑器中的自动完成之类的常规好处。例如，考虑类似于这样的内容：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: TypeScript will throw an error because the return type of `querySelector` is
    nullable.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 将抛出一个错误，因为`querySelector`的返回类型是可空的。
- en: While for simple frontend applications these low-level DOM APIs are enough and
    will give you what you need to do safe, type-guided programming for the browser,
    most real-world frontend applications use a framework to abstract away how DOM
    rendering and rerendering, data binding, and events work. The following sections
    will give some pointers on how to effectively use TypeScript with a few of the
    most popular browser frameworks.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的前端应用程序，这些低级 DOM API 已经足够，并且将为您提供所需的内容，以便在浏览器中进行安全的、类型引导的编程。大多数真实世界的前端应用程序使用框架来抽象掉
    DOM 渲染和重新渲染、数据绑定和事件处理的工作方式。以下部分将为您提供如何有效地使用 TypeScript 与一些最流行的浏览器框架的一些指针。
- en: React
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React
- en: React is among the most popular frontend frameworks today, and is a great choice
    when it comes to type safety.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: React 是当今最受欢迎的前端框架之一，在类型安全方面非常出色。
- en: The reason React is so safe is because React components—the basic building blocks
    of React applications—are both defined and consumed in TypeScript. This property
    is hard to find among frontend frameworks, and means that both component definitions
    and consumers are typechecked. You can use types to say things like “this component
    takes a user ID and a color” or “this component can only have list items as children.”
    These constraints are then enforced by TypeScript, verifying that your components
    do what they say they do.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: React如此安全的原因在于React组件——React应用程序的基本构建块——在TypeScript中既定义又消费。这种属性在前端框架中很难找到，意味着组件定义和消费者都经过了类型检查。您可以使用类型来表达诸如“此组件接受用户ID和颜色”或“此组件只能具有列表项作为子元素”的内容。然后，TypeScript会强制执行这些约束，验证您的组件是否按照其所说的方式运行。
- en: This safety around component definitions and consumers—the *view layer* of a
    frontend application—is killer. The view is traditionally the place where typos,
    missed attributes, mistyped parameters, and improperly nested elements cause programmers
    to collectively spend thousands of hours tearing their hair out and indignantly
    refreshing their browsers. The day you start typing your views with TypeScript
    and React is the day you double your and your team’s productivity on the frontend.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在前端应用程序的*视图层*中，关于组件定义和消费者的这种安全性是致命的。传统上，视图是程序员们花费数千小时挠头并愤怒地刷新浏览器的地方，因为错别字、遗漏的属性、错误输入的参数和不正确的嵌套元素。当您开始使用TypeScript和React编写视图时，您和您的团队在前端的生产力将翻倍。
- en: A JSX primer
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JSX入门指南
- en: When using React, you define your views using a special DSL called *JavaScript
    XML* (JSX) that you embed straight into your JavaScript code. It sort of looks
    like HTML in your JavaScript. You then run your JavaScript through a JSX compiler
    that rewrites that funky JSX syntax into regular JavaScript function calls.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用React时，您可以使用称为*JavaScript XML*（JSX）的特殊DSL来定义视图，直接嵌入到JavaScript代码中。它在您的JavaScript中看起来像HTML。然后，您可以运行您的JavaScript通过JSX编译器，将那些奇特的JSX语法重写为常规的JavaScript函数调用。
- en: 'The process looks something like this. Say you’re building a menu app for your
    friend’s restaurant, and you list out a few items on the brunch menu with the
    following JSX:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程看起来像这样。假设您正在为朋友的餐厅构建一个菜单应用程序，并列出早午餐菜单上的一些项目，使用以下JSX：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After running that code through a JSX compiler like Babel’s [`transform-react-jsx`
    plugin](http://bit.ly/2uENY4M), you’ll get the following output:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在像Babel的[`transform-react-jsx`插件](http://bit.ly/2uENY4M)这样的JSX编译器中运行该代码后，您将得到以下输出：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'TSC Flag: esModuleInterop'
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TSC标志：esModuleInterop
- en: 'Because JSX compiles to a call to `React.createElement`, be sure to import
    the React library into each file where you use JSX so that you have a variable
    named `React` in scope:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因为JSX编译为对`React.createElement`的调用，请确保在每个使用JSX的文件中导入React库，以便在作用域中有名为`React`的变量：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Don’t worry—if you forget, TypeScript will warn you:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 别担心——如果您忘记了，TypeScript会提醒您：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Also note that I’ve set `{"esModuleInterop": true}` in my *tsconfig.json* to
    support importing `React` without a wildcard (`*`) import. If you’re following
    along, either enable `esModuleInterop` in your own *tsconfig.json*, or use a wildcard
    import instead:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '还请注意，我已在我的*tsconfig.json*中设置了`{"esModuleInterop": true}`以支持导入`React`而无需通配符（`*`）导入。如果您在跟进，请在您自己的*tsconfig.json*中启用`esModuleInterop`，或者改用通配符导入：'
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The nice thing about JSX is you can write what looks a lot like normal HTML,
    then compile it automatically to a JavaScript engine–friendly format. As an engineer
    you only use a familiar, high-level, declarative DSL, and you don’t have to deal
    with the implementation details.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: JSX的好处在于，您可以编写看起来非常像普通HTML的内容，然后自动将其编译为友好于JavaScript引擎的格式。作为一名工程师，您只需使用一种熟悉的、高级的、声明性的DSL，而无需处理实现细节。
- en: You don’t need JSX to work with React (you can write that compiled code directly
    and it’ll work fine), and you can use JSX without React (the specific function
    call that JSX tags compile to—`React.createElement` in the previous example—is
    configurable), but the combination of React with JSX is magical, and makes writing
    views really fun, and really, really safe.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要JSX来使用React（您可以直接编写已编译的代码，它也能正常工作），并且您可以在没有React的情况下使用JSX（JSX标签编译为的特定函数调用——在前面的示例中是`React.createElement`——是可以配置的），但是React与JSX的组合是神奇的，让编写视图非常有趣，也非常安全。
- en: TSX = JSX + TypeScript
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TSX = JSX + TypeScript
- en: 'Files that contain JSX use the file extension *.jsx*. And TypeScript files
    that contain JSX use the *.tsx* extension. TSX is to JSX what TypeScript is to
    JavaScript—a compile-time safety and assistance layer to help you be more productive
    and produce code with fewer mistakes. To enable TSX support for your project,
    add the following line to your *tsconfig.json*:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 包含 JSX 的文件使用扩展名 *.jsx*。而包含 JSX 的 TypeScript 文件使用扩展名 *.tsx*。TSX 对 JSX 就像 TypeScript
    对 JavaScript 一样—是一个编译时的安全和辅助层，帮助你更高效地生产代码，减少错误。要为你的项目启用 TSX 支持，请在你的 *tsconfig.json*
    文件中添加以下行：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `jsx` directive has three modes at the time of writing:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`jsx` 指令在撰写时有三种模式：'
- en: '`react`'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`react`'
- en: Compile JSX to a *.js* file using the JSX pragma (by default, `React.createElement`).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JSX pragma 编译 JSX 到一个扩展名为 *.js* 的文件（默认为 `React.createElement`）。
- en: '`react-native`'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`react-native`'
- en: Preserve JSX without compiling it, but do emit a file with a *.js* extension.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 不编译 JSX，但生成一个扩展名为 *.js* 的文件。
- en: '`preserve`'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`preserve`'
- en: Typecheck JSX but don’t compile it away, and emit a file with a *.jsx* extension.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对 JSX 进行类型检查，但不要将其编译掉，并生成一个扩展名为 *.jsx* 的文件。
- en: Under the hood, TypeScript exposes a few hooks for typing TSX in a pluggable
    way. These are special types on the `global.JSX` namespace that TypeScript looks
    at as the source of truth for TSX types throughout your program. If you’re just
    using React, you don’t need to go that low-level; but if you’re building your
    own TypeScript library that uses TSX (and doesn’t use React)—or if you’re curious
    how the React type declarations do it—head over to [Appendix G](app07.html#tsx-reference).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，TypeScript 以一种可插拔的方式暴露了几个用于 TSX 类型的钩子。这些是 `global.JSX` 命名空间上的特殊类型，TypeScript
    在整个程序中查看它们作为 TSX 类型的真实来源。如果你只是使用 React，你不需要深入到这个低级别；但是如果你正在构建自己的 TypeScript 库，该库使用
    TSX（而不是 React）—或者如果你好奇 React 类型声明是如何做到的—可以查看 [附录 G](app07.html#tsx-reference)。
- en: Using TSX with React
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 TSX 与 React
- en: 'React lets us declare two kinds of components: function components and class
    components. Both kinds of components take some properties and render some TSX.
    From a consumer’s point of view, they are identical.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: React 允许我们声明两种类型的组件：函数组件和类组件。无论是哪种类型的组件，都需要一些属性并渲染一些 TSX。从消费者的角度来看，它们是相同的。
- en: 'Declaring and rendering a function component looks like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 声明和渲染一个函数组件看起来像这样：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[![1](assets/1.png)](#co_frontend_and_backend_frameworks_CO1-1)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_frontend_and_backend_frameworks_CO1-1)'
- en: We have to bring the `React` variable into the current scope in order to use
    TSX with React. Since TSX is compiled to `React.createElement` function calls,
    that means we need to import `React` so that it’s defined at runtime.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在使用 React 和 TSX 时进行类型检查，我们必须将 `React` 变量引入当前作用域。由于 TSX 被编译为 `React.createElement`
    函数调用，这意味着我们需要导入 `React`，以便在运行时定义它。
- en: '[![2](assets/2.png)](#co_frontend_and_backend_frameworks_CO1-2)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_frontend_and_backend_frameworks_CO1-2)'
- en: We start by declaring the specific set of props we can pass to our `FancyButton`
    component. `Props` is always an object type, and is named `Props` by convention.
    For our `FancyButton` component, `isDisabled` is optional, while the rest of our
    props are required.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先声明可以传递给我们的 `FancyButton` 组件的具体 props 集合。按照约定，`Props` 总是一个对象类型，并且名为 `Props`。对于我们的
    `FancyButton` 组件，`isDisabled` 是可选的，而其余的 props 都是必需的。
- en: '[![3](assets/3.png)](#co_frontend_and_backend_frameworks_CO1-3)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_frontend_and_backend_frameworks_CO1-3)'
- en: React has its own set of wrapper types for DOM events. When using React events,
    be sure to use React’s event types rather than regular DOM event types.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 React 事件时，React 有自己的一套包装器类型用于 DOM 事件。请确保使用 React 的事件类型，而不是常规的 DOM 事件类型。
- en: '[![4](assets/4.png)](#co_frontend_and_backend_frameworks_CO1-4)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_frontend_and_backend_frameworks_CO1-4)'
- en: 'A function component is just a regular function that has up to one parameter
    (the `props` object) and returns a React-renderable type. React is permissive
    and can render a wide range of types: TSX, strings, numbers, booleans, `null`,
    and `undefined`.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 函数组件只是一个普通函数，最多有一个参数（`props` 对象），并返回一个可以被 React 渲染的类型。React 是宽松的，可以渲染多种类型：TSX、字符串、数字、布尔值、`null`
    和 `undefined`。
- en: '[![5](assets/5.png)](#co_frontend_and_backend_frameworks_CO1-5)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_frontend_and_backend_frameworks_CO1-5)'
- en: We use React’s `useState` hook to declare local state for a function component.
    `useState` is one of a handful of hooks available in React, which you can combine
    to create your own custom hooks. Note that because we passed the initial value
    `false` to `useState`, TypeScript was able to infer that the piece of state is
    a `boolean`; if we’d instead used a type that TypeScript wasn’t able to infer—for
    example, an array—we would have bound the type explicitly (e.g., with useState<number[]>;([])).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用React的`useState`钩子来为函数组件声明本地状态。`useState`是React中可用的几个钩子之一，您可以组合它们来创建自己的自定义钩子。请注意，因为我们将初始值`false`传递给`useState`，TypeScript能够推断出该状态片段是一个`boolean`；如果我们使用了TypeScript无法推断的类型，例如数组，我们将需要显式地绑定类型（例如，使用useState<number[]>;([])）。
- en: '[![6](assets/6.png)](#co_frontend_and_backend_frameworks_CO1-6)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_frontend_and_backend_frameworks_CO1-6)'
- en: We use TSX syntax to create an instance of `FancyButton`. The `<FancyButton
    />` syntax is almost identical to calling `FancyButton`, but it lets React manage
    the lifecycle of `FancyButton` for us.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用TSX语法来创建`FancyButton`的实例。`<FancyButton />`语法与调用`FancyButton`几乎相同，但它让React来管理`FancyButton`的生命周期。
- en: 'That’s it. TypeScript enforces that:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。TypeScript强制执行以下规则：
- en: JSX is well formed. Tags are closed and properly nested, and tag names aren’t
    misspelled.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSX格式良好。标签已关闭且嵌套正确，标签名称没有拼写错误。
- en: When we instantiate a `<FancyButton />` we pass all required—plus any optional—props
    to `FancyButton` (`size`, `text`, and `onClick`), and that the props are all correctly
    typed.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们实例化一个`<FancyButton />`时，我们将所有必需的——以及任何可选的——props传递给`FancyButton`（`size`，`text`和`onClick`），并确保props的类型是正确的。
- en: We don’t pass any extraneous props to `FancyButton`, just the ones that are
    required.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不会向`FancyButton`传递任何多余的props，只传递必需的props。
- en: 'A class component is similar:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 类组件类似：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![1](assets/1.png)](#co_frontend_and_backend_frameworks_CO2-1)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_frontend_and_backend_frameworks_CO2-1)'
- en: Like before, we import `React` to bring it into scope.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，我们导入`React`以将其引入作用域。
- en: '[![2](assets/2.png)](#co_frontend_and_backend_frameworks_CO2-2)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_frontend_and_backend_frameworks_CO2-2)'
- en: Like before, we declare a `Props` type to define what data we need to pass in
    when creating an instance of `<SignupForm />`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于之前，我们声明一个`Props`类型来定义在创建`<SignupForm />`实例时需要传递的数据。
- en: '[![3](assets/3.png)](#co_frontend_and_backend_frameworks_CO2-3)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_frontend_and_backend_frameworks_CO2-3)'
- en: We declare a `State` type to model our component’s local state.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明一个`State`类型来模拟组件的本地状态。
- en: '[![4](assets/4.png)](#co_frontend_and_backend_frameworks_CO2-4)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_frontend_and_backend_frameworks_CO2-4)'
- en: To declare a class component, we extend the `React.Component` base class.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个类组件，我们需要扩展`React.Component`基类。
- en: '[![5](assets/5.png)](#co_frontend_and_backend_frameworks_CO2-5)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_frontend_and_backend_frameworks_CO2-5)'
- en: We use a property initializer to declare default values for local state.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用属性初始化器来为本地状态声明默认值。
- en: '[![6](assets/6.png)](#co_frontend_and_backend_frameworks_CO2-6)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_frontend_and_backend_frameworks_CO2-6)'
- en: 'Like with function components, a class component’s `render` method returns
    something renderable by React: TSX, a string, a number, a boolean, `null`, or
    undefined.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于函数组件，类组件的`render`方法返回可以由React渲染的内容：TSX，字符串，数字，布尔值，`null`或`undefined`。
- en: '[![7](assets/7.png)](#co_frontend_and_backend_frameworks_CO2-7)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_frontend_and_backend_frameworks_CO2-7)'
- en: TSX supports fragments using the special `<>...</>` syntax. A fragment is a
    nameless TSX element that wraps other TSX, and is a way to avoid rendering extra
    DOM elements in places where you need to return a single TSX element. For example,
    a React component’s `render` method needs to return a single TSX element; to do
    that, we could have wrapped our code with a `<div>` or any other element, but
    that would have incurred unnecessary overhead during rendering.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: TSX支持使用特殊的`<>...</>`语法来进行片段处理。片段是一个无名称的TSX元素，用于包装其他TSX元素，可以避免在需要返回单个TSX元素的地方渲染额外的DOM元素。例如，React组件的`render`方法需要返回单个TSX元素；为此，我们可以使用`<div>`或任何其他元素来包装我们的代码，但这样做会在渲染时产生不必要的开销。
- en: '[![8](assets/8.png)](#co_frontend_and_backend_frameworks_CO2-8)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_frontend_and_backend_frameworks_CO2-8)'
- en: We define `signUp` using an arrow function, to make sure that `this` in the
    function doesn’t get re-bound.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用箭头函数定义`signUp`，以确保函数中的`this`不会被重新绑定。
- en: '[![9](assets/9.png)](#co_frontend_and_backend_frameworks_CO2-9)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[![9](assets/9.png)](#co_frontend_and_backend_frameworks_CO2-9)'
- en: 'Finally, we instantiate our `SignupForm`. Like when instantiating function
    components, we could have directly `new`-ed it with `new SignupForm({firstName:
    ''Albert'', userId: ''13ab9g3''})` instead, but that would mean that React couldn’t
    manage the `SignupForm` instance’s lifecycle for us.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，我们实例化我们的 `SignupForm`。就像实例化函数组件一样，我们也可以直接用 `new SignupForm({firstName: ''Albert'',
    userId: ''13ab9g3''})` 来实例化它，但这意味着 React 无法为我们管理 `SignupForm` 实例的生命周期。'
- en: 'Notice how we mix and match value-based (`FancyButton`, `SignupForm`) and intrinsic
    (`section`, `h2`) components in this example. We put TypeScript to work to verify
    things like:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在这个例子中我们如何混合匹配基于值的（`FancyButton`，`SignupForm`）和内置的（`section`，`h2`）组件。我们让 TypeScript
    工作来验证以下几点：
- en: That all required state fields were defined either in the `state` initializer,
    or in the constructor
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有必需的状态字段都在 `state` 初始化器或构造函数中定义了。
- en: That whatever we access on `props` and `state` actually exists, and is of the
    type we think it is
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在 `props` 和 `state` 上访问的任何内容都确实存在，并且是我们认为的类型。
- en: That we don’t write to `this.state` directly, because in React, state updates
    have to go through the `setState` API
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 React 中，我们不直接写入 `this.state`，因为状态更新必须通过 `setState` API 进行。
- en: That calling `render` really returns some JSX
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 `render` 确实返回一些 JSX。
- en: With TypeScript you can make your React code safer, and become a better, happier
    person as a result.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 TypeScript，您可以使您的 React 代码更安全，从而成为一个更好、更快乐的人。
- en: Note
  id: totrans-92
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: We didn’t use React’s `PropTypes` feature, which is a way to declare and check
    props’ types at runtime. Since TypeScript is already checking types for us at
    compile time, we don’t need to do it again.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有使用 React 的 `PropTypes` 特性，这是一种在运行时声明和检查 props 类型的方式。因为 TypeScript 已经在编译时为我们检查了类型，所以我们不需要再次检查。
- en: Angular 6/7
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular 6/7
- en: Contributed by Shyam Seshadri
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由 Shyam Seshadri 贡献
- en: Angular is a more fully featured frontend framework than React, and comes with
    support not just for rendering views but also for sending and managing network
    requests, routing, and dependency injection. It’s built from the ground up to
    work with TypeScript (in fact, the framework itself is written in TypeScript!).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 是一个比 React 更全面的前端框架，不仅支持渲染视图，还支持发送和管理网络请求、路由和依赖注入。它从头开始与 TypeScript
    协作（事实上，框架本身就是用 TypeScript 编写的！）。
- en: Central to the way Angular works is the Ahead-of-Time (AoT) compiler built into
    Angular CLI, Angular’s command-line utility, that grabs the type information you
    gave it with your TypeScript annotations and uses that information to compile
    your code down to regular JavaScript. Instead of calling TypeScript directly,
    Angular applies a whole bunch of optimizations and transformations to your code
    before ultimately delegating to TypeScript and compiling it down to JavaScript.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 的核心工作方式是 Angular CLI 中内置的 Ahead-of-Time（AoT）编译器，这是 Angular 命令行实用程序，它获取您用
    TypeScript 注解提供的类型信息，并使用该信息将您的代码编译为常规 JavaScript。Angular 不直接调用 TypeScript，而是在最终委托给
    TypeScript 之前对您的代码应用一系列优化和转换。
- en: Let’s see how Angular uses TypeScript and its AoT compiler to make writing frontend
    applications safe.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Angular 如何使用 TypeScript 及其 AoT 编译器来确保编写前端应用的安全性。
- en: Scaffolding
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 脚手架
- en: 'To initialize a new Angular project, start by globally installing Angular CLI
    using NPM:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要初始化一个新的 Angular 项目，首先使用 NPM 全局安装 Angular CLI：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, use Angular CLI to initialize a new Angular application:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用 Angular CLI 初始化一个新的 Angular 应用程序：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Follow the prompts, and Angular CLI will set up a bare-bones Angular application
    for you.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 按照提示操作，Angular CLI 将为您设置一个简易的 Angular 应用程序。
- en: In this book we won’t go into depth on how an Angular application is structured,
    or how to configure and run it. For detailed information, head over to the [official
    Angular documentation](https://angular.io/docs).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们不会深入讲解 Angular 应用程序的结构，或者如何配置和运行它。有关详细信息，请参阅[官方 Angular 文档](https://angular.io/docs)。
- en: Components
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组件
- en: 'Let’s build an Angular component. Angular components are like React components,
    and include a way to describe a component’s DOM structure, styling, and controller.
    With Angular, you generate component boilerplate with Angular CLI, then fill in
    the details by hand. An Angular component consists of a few different files:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个 Angular 组件。Angular 组件类似于 React 组件，并包括一种描述组件 DOM 结构、样式和控制器的方法。使用 Angular，您可以使用
    Angular CLI 生成组件样板，然后手动填写详细信息。Angular 组件包含几个不同的文件：
- en: A template, which describes the DOM a component renders
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述组件渲染的 DOM 的模板
- en: A set of CSS styles
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组 CSS 样式
- en: A component class, which is a TypeScript class that dictates your components’
    business logic
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件类，这是一个 TypeScript 类，用于定义你的组件业务逻辑。
- en: 'Let’s start with the component class:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从组件类开始：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For the most part, this is a pretty standard TypeScript class, with just a
    few differences that bring out how Angular leverages TypeScript. Namely:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这是一个相当标准的 TypeScript 类，只是有几个不同点展示了 Angular 如何利用 TypeScript。具体来说：
- en: Angular’s lifecycle hooks are available as TypeScript interfaces—just declare
    which ones you `implement` (`ngOnChanges`, `ngOnInit`, etc.). TypeScript then
    enforces that you implement methods that comply with the lifecycle hooks you want.
    In this example we implemented the `OnInit` interface, which requires that we
    implement the `ngOnInit` method.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 的生命周期钩子作为 TypeScript 接口可用——只需声明你要 `implement` 的哪些接口（`ngOnChanges`、`ngOnInit`
    等）。然后 TypeScript 强制要求你实现符合所需生命周期钩子的方法。在本例中，我们实现了 `OnInit` 接口，这要求我们实现 `ngOnInit`
    方法。
- en: Angular makes heavy use of TypeScript decorators (see [“Decorators”](ch05.html#decorators))
    to declare metadata related to your Angular components, services, and modules.
    In this example, we used a `selector` to declare how people can consume our component,
    and we used `templateUrls` and `styleUrl` to link an HTML template and CSS stylesheet
    to our component.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 大量使用 TypeScript 装饰器（见 [“装饰器”](ch05.html#decorators)）来声明与 Angular 组件、服务和模块相关的元数据。在这个例子中，我们使用了
    `selector` 来声明如何消费我们的组件，并使用了 `templateUrls` 和 `styleUrl` 来链接 HTML 模板和 CSS 样式表到我们的组件。
- en: 'TSC Flag: fullTemplateTypeCheck'
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TSC 标志：fullTemplateTypeCheck
- en: 'To enable typechecking for your Angular templates (you should!), be sure to
    enable `fullTemplateTypeCheck` in your *tsconfig.json*:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要为您的 Angular 模板启用类型检查（您应该！），请确保在您的 *tsconfig.json* 中启用 `fullTemplateTypeCheck`：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that `angularCompilerOptions` isn’t specifying options for TSC. Rather,
    it defines compiler flags specific to Angular’s AoT compiler.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `angularCompilerOptions` 并非指定 TSC 的选项。相反，它定义了特定于 Angular 的 AoT 编译器的编译器标志。
- en: Services
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务
- en: Angular comes with a built-in dependency injector (DI), which is a way for the
    framework to take care of instantiating services and passing them in as arguments
    to components and services that depend on them. This can make it easier to instantiate
    and test services and components.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 自带内置的依赖注入器（DI），这是框架实例化服务并将它们作为参数传递给依赖于它们的组件和服务的一种方式。这可以使得实例化和测试服务和组件更加容易。
- en: 'Let’s update `SimpleMessageComponent` to inject a dependency, `MessageService`,
    responsible for fetching messages from the server:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新 `SimpleMessageComponent` 来注入一个依赖项 `MessageService`，负责从服务器获取消息：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Angular’s AoT compiler looks at the parameters that your component’s `constructor`
    takes, plucks out their types (e.g., `MessageService`), and searches the relevant
    dependency injector’s dependency map for a dependency of that specific type. It
    then instantiates that dependency (`new`-ing it) if it hasn’t been instantiated
    yet, and passes it into the `SimpleMessageComponent` instance’s constructor. All
    of this DI stuff is pretty complicated, but it can be convenient as your application
    grows and you have multiple dependencies you might use depending on how the app
    is configured (e.g., `ProductionAPIService` versus `DevelopmentAPIService`) or
    when testing it (`MockAPIService`).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 的 AoT 编译器查看您的组件 `constructor` 接受的参数，提取它们的类型（例如 `MessageService`），并搜索相关的依赖注入器的依赖映射以查找该特定类型的依赖项。如果尚未实例化该依赖项，则实例化它（使用
    `new`），并将其传递给 `SimpleMessageComponent` 实例的构造函数。所有这些依赖注入的内容相当复杂，但随着应用程序的增长以及根据应用程序配置（例如
    `ProductionAPIService` 与 `DevelopmentAPIService`）或测试时使用的依赖项（`MockAPIService`）的不同，它可能非常方便。
- en: 'Now let’s take a quick look at how to define a service:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们快速看一下如何定义一个服务：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Whenever we create a service in Angular, we again use TypeScript decorators
    to register it as something that is `Injectable`, and we define whether it is
    provided at the root level of the application or in a submodule. Here, we registered
    the service `MessageService`, allowing us to inject it anywhere in our application.
    In the constructor of any component or service, we can just ask for a `MessageService`
    and Angular will magically take care of passing it in.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们在 Angular 中创建一个服务时，我们都会再次使用 TypeScript 装饰器将其注册为可注入的东西，并定义它是在应用程序的根级别提供还是在子模块中提供。在这里，我们注册了服务
    `MessageService`，允许我们在应用程序的任何地方注入它。在任何组件或服务的构造函数中，我们只需请求一个 `MessageService`，Angular
    将神奇地负责传递它。
- en: With how to safely use these two popular frontend frameworks out of the way,
    let’s move on to typing the interface between your frontend and your backend.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了如何安全地使用这两种流行的前端框架，现在让我们转向定义前端和后端之间的接口类型。
- en: Typesafe APIs
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型安全的 API
- en: Contributed by Nick Nance
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由 Nick Nance 贡献
- en: Regardless of which frontend and backend frameworks you decide to use, you’ll
    want a way to safely communicate across machines—from client to server, server
    to client, server to server, and client to client.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 不论你决定使用哪种前端和后端框架，你都需要一种安全的跨机器通信方式——从客户端到服务器、服务器到客户端、服务器到服务器，以及客户端到客户端。
- en: There are a few competing tools and standards in this space. But before we explore
    what they are and how they work, let’s think about how we might build our own
    solution, and what benefits and drawbacks it might have (we are engineers, after
    all).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个领域有几种竞争的工具和标准。但在我们探讨它们及其工作原理之前，让我们考虑一下如何构建我们自己的解决方案，以及它可能具有的优缺点（毕竟我们是工程师）。
- en: 'The problem we want to solve is this: though our clients and servers might
    be 100% typesafe—bastions of safety—at some point they’ll need to talk to each
    other over untyped network protocols like HTTP, TCP, or some other socket-based
    protocols. How might we make this communication typesafe?'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要解决的问题是：尽管我们的客户端和服务器可能是100%类型安全的——安全的堡垒——但它们在某个时候需要通过未经类型化的网络协议如 HTTP、TCP
    或其他基于套接字的协议进行通信。我们如何使这种通信类型安全？
- en: 'A good starting point could be a typesafe protocol like the one we developed
    in [“Typesafe protocols”](ch08.html#typesafe-protocols). It might look something
    like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一个良好的起点可能是像我们在[“类型安全协议”](ch08.html#typesafe-protocols)中开发的类型安全协议。它可能看起来像这样：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You could build corresponding `post` and `put` functions to write back to your
    REST API, and add a type for each entity your server supports. On the backend,
    you’d then implement a corresponding set of handlers for each type of entity,
    reading from your database to return to the client whatever entity it asked for.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以构建对应的 `post` 和 `put` 函数来写回到你的 REST API，并为服务器支持的每种实体添加一个类型。在后端，你将为每种实体类型实现一组相应的处理程序，从数据库读取并返回客户端请求的实体。
- en: But what happens if your server isn’t written in TypeScript, or if you aren’t
    able to share your `Request` type between the client and server (leading to the
    two getting out of sync over time), or if you don’t use REST (maybe you use GraphQL
    instead)? Or what if you have other clients to support, like Swift clients on
    iOS or Java clients on Android?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你的服务器不是用 TypeScript 编写的，或者你不能在客户端和服务器之间共享你的 `Request` 类型（导致它们随时间脱节），或者你不使用
    REST（也许你使用的是 GraphQL）？或者如果你需要支持其他客户端，比如 iOS 上的 Swift 客户端或 Android 上的 Java 客户端？
- en: 'That’s where typed, code-generated APIs come in. They come in a lot of flavors,
    each with libraries available in a bunch of languages (including TypeScript)—for
    example:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是类型化、代码生成的 API 所能解决的问题。它们有许多不同的变体，每种都有库可以在许多语言中使用（包括 TypeScript）——例如：
- en: '[Swagger](https://github.com/swagger-api/swagger-codegen) for RESTful APIs'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Swagger](https://github.com/swagger-api/swagger-codegen) 用于 RESTful APIs'
- en: '[Apollo](https://www.npmjs.com/package/apollo) and [Relay](https://facebook.github.io/relay/)
    for GraphQL'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Apollo](https://www.npmjs.com/package/apollo) 和 [Relay](https://facebook.github.io/relay/)
    用于 GraphQL'
- en: '[gRPC](https://grpc.io/) and [Apache Thrift](https://thrift.apache.org/) for
    RPC'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[gRPC](https://grpc.io/) 和 [Apache Thrift](https://thrift.apache.org/) 用于 RPC'
- en: These tools rely on a common source of truth for both server and clients—data
    models for Swagger, GraphQL schemas for Apollo, Protocol Buffers for gRPC—which
    are then compiled into language-specific bindings for whatever language you might
    be using (in our case, that’s TypeScript).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具依赖于一个共同的真实数据来源，用于服务器和客户端——Swagger 的数据模型、Apollo 的 GraphQL schema、gRPC 的 Protocol
    Buffers——然后将其编译成特定语言的绑定（在我们的案例中是 TypeScript）。
- en: This code generation is what prevents your client and server (or multiple clients)
    from getting out of sync with each other; since every platform shares a common
    schema, you won’t run into the case where you updated your iOS app to support
    a field, but forgot to press Merge on your pull request to add server support
    for it.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这种代码生成能防止你的客户端和服务器（或多个客户端）在互相不同步；因为每个平台共享一个公共模式，你不会遇到这样的情况，即你更新了 iOS 应用以支持一个字段，但忘记在你的拉取请求上按下合并以添加服务器对其的支持。
- en: Diving into the details of each framework is out of scope for this book. Pick
    one for your project, and head over to its documentation to learn more.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 本书不涵盖每种框架的详细细节。为你的项目选择一个框架，然后转到其文档了解更多信息。
- en: Backend Frameworks
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 后端框架
- en: 'When you build an application that interacts with a database, you might start
    with raw SQL or API calls, which are inherently untyped:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当你构建一个与数据库交互的应用程序时，你可能从原始 SQL 或 API 调用开始，这些本质上是无类型的：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With a bit of manual typing you can make these APIs safer and get rid of most
    of your `any`s:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一点手工输入，你可以使这些 API 更安全，并摆脱大部分的`any`：
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: However, raw SQL APIs are still fairly low-level, and it’s still easy to use
    the wrong type, or forget a type and accidentally end up with `any`s.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，原始 SQL API 仍然相对较低级，并且很容易使用错误的类型，或者忘记类型而意外地得到 `any`。
- en: That’s where *object-relational mappers* (ORMs) come in. ORMs generate code
    from your database schema, giving you high-level APIs to express queries, updates,
    deletions, and so on. In statically typed languages, these APIs are typesafe,
    so you don’t have to worry about typing things correctly and manually binding
    generic type parameters.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 *对象关系映射*（ORM）的用武之地。ORM 从你的数据库架构生成代码，为你提供高级 API 来表达查询、更新、删除等操作。在静态类型语言中，这些
    API 是类型安全的，因此你不必担心正确地输入类型和手动绑定泛型类型参数。
- en: 'When accessing your database from TypeScript, consider using an ORM. At the
    time of writing, Umed Khudoiberdiev’s excellent [TypeORM](https://www.npmjs.com/package/typeorm)
    is the most complete ORM for TypeScript, and supports MySQL, PostgreSQL, Microsoft
    SQL Server, Oracle, and even MongoDB. Using TypeORM, your query to get a user’s
    first name might look like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 中访问数据库时，考虑使用 ORM。在撰写本文时，Umed Khudoiberdiev 的优秀 [TypeORM](https://www.npmjs.com/package/typeorm)
    是 TypeScript 最完整的 ORM，支持 MySQL、PostgreSQL、Microsoft SQL Server、Oracle 甚至 MongoDB。使用
    TypeORM，获取用户名字的查询可能像这样：
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice the high-level API, which is both safe (in that it prevents things like
    SQL injection attacks) and typesafe by default (in that we know what type `findOne`
    returns without having to manually annotate it). Always use an ORM when working
    with databases—it’s more convenient, and it will save you from getting woken up
    at four in the morning because the `saleAmount` field is `null` because you updated
    it to `orderAmount` the night before and your coworker decided to run your database
    migration for you in anticipation of your pull request landing while you were
    out, but then around midnight your pull request failed even though the migration
    succeeded, and your sales team in New York woke up to realize that all your clients’
    orders were for exactly `null` dollars (this happened to… a friend).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注意高级 API，它既安全（防止诸如 SQL 注入攻击之类的问题），默认情况下也是类型安全的（我们知道 `findOne` 返回的类型，而不必手动注释）。在处理数据库时，始终使用
    ORM——这更方便，可以避免你因为在凌晨四点更新 `saleAmount` 字段为 `orderAmount` 而被叫醒，而你的同事决定在你不在时为你运行数据库迁移，但是半夜你的拉取请求失败了，即使迁移成功，你的纽约销售团队也意识到所有客户的订单金额都为
    `null` 美元（这发生在... 朋友身上）。
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter we’ve covered a lot: directly manipulating the DOM; using React
    and Angular; adding type safety to your APIs with tools like Swagger, gRPC, and
    GraphQL; and using TypeORM to safely interact with your database.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了很多内容：直接操作 DOM；使用 React 和 Angular；使用类似 Swagger、gRPC 和 GraphQL 的工具为你的
    API 添加类型安全性；以及使用 TypeORM 安全地与数据库交互。
- en: JavaScript frameworks change at a rapid pace, and by the time you read this,
    the specific APIs and frameworks described here may be on their way to becoming
    museum exhibits. Use your newfound intuition for *what problems typesafe frameworks
    solve* to identify places where you can take advantage of someone else’s work
    to make your code safer, more abstract, and more modular. The big idea to take
    away from this chapter isn’t what the best framework to use in the year 2019 is,
    but what sorts of problems can be better solved with frameworks.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 框架变化迅速，当你阅读本文时，这里描述的具体 API 和框架可能已经成为博物馆展品。利用你新获得的直觉来*解决类型安全框架解决的问题*，找出可以利用他人工作的地方，使你的代码更安全、更抽象、更模块化。从本章中带走的重要思想不是在
    2019 年使用最佳框架是什么，而是什么样的问题可以通过框架更好地解决。
- en: With the combination of typesafe UI code, a typed API layer, and a typesafe
    backend, you can eliminate entire classes of bugs from your application, and sleep
    better at night as a result.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 结合类型安全的 UI 代码、带类型的 API 层和类型安全的后端，你可以从应用程序中消除整类错误，结果是你可以晚上睡得更安稳。
