- en: Chapter 6\. Server-Side React
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章\. 服务器端的 React
- en: React has evolved considerably since its inception. Although it started as a
    client-side library, the demand for server-side rendering (SSR) has grown over
    time for reasons we will come to understand in this chapter. Together, we will
    explore server-side React and understand how it differs from client-only React,
    and how it can be used to level up our React applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: React 自其创立以来发生了很大的变化。尽管它起初是一个客户端库，但随着时间的推移，基于服务器端的渲染（SSR）的需求因我们将在本章中了解的原因而不断增长。我们将一起探索服务器端的
    React，并理解它与仅客户端 React 的区别，以及如何利用它来提升我们的 React 应用程序。
- en: As we’ve discussed in earlier chapters, React was initially developed by Meta
    to address the need for efficient and scalable UIs. In [Chapter 3](ch03.html#ch03)
    we looked at how it does this through the virtual DOM, which enables developers
    to create and manage UI components with ease. React’s client-side approach unlocked
    fast, responsive user experiences across the web. However, as the web continued
    to evolve, the limitations of client-side rendering became more apparent.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在早期章节中讨论的那样，React 最初由 Meta 开发，以满足高效和可扩展用户界面的需求。在[第三章](ch03.html#ch03)中，我们看到它通过虚拟
    DOM 实现这一点，这使得开发人员能够轻松地创建和管理 UI 组件。React 的客户端方法解锁了全网快速响应的用户体验。然而，随着 Web 的不断发展，客户端渲染的局限性变得越来越明显。
- en: Limitations of Client-Side Rendering
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端渲染的局限性
- en: user interfaces with React since it was first released as open source software
    in 2013. Eventually, a number of limitations with this approach started to appear.
    These limitations eventually led to us moving more and more concerns to the server
    side.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 自2013年首次作为开源软件发布以来，使用 React 构建用户界面。最终，这种方法的一些局限性开始显现。这些局限性最终导致我们将更多的关注点转移到服务器端。
- en: SEO
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SEO
- en: One of the significant limitations of client-side rendering is that search engine
    crawlers may not correctly index the content, as some of them do not execute JavaScript,
    or those that do execute JavaScript may not execute it as we expect.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端渲染的一个显著局限性是，搜索引擎爬虫可能无法正确索引内容，因为其中一些不执行 JavaScript，或者那些执行 JavaScript 的爬虫可能不会按照我们的预期执行。
- en: Given the wide variety of search engine crawler implementations, along with
    the fact that a lot of them are proprietary and unknowable to the public, this
    makes client-only rendering somewhat questionable with regard to the reach of
    a given website or application.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到各种搜索引擎爬虫的多样实现，以及许多爬虫是专有且对公众不可知的，这使得仅客户端渲染在特定网站或应用程序的覆盖范围方面显得有些值得怀疑。
- en: 'That said, an article from [Search Engine Land in 2015](https://oreil.ly/r5hF2)
    described some experiments to test how various search engines work with client-only
    applications, and this is what they mentioned:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，2015年的一篇文章（[来自 Search Engine Land](https://oreil.ly/r5hF2)）描述了一些测试，以测试各种搜索引擎如何处理仅客户端应用程序，以下是它们提到的内容：
- en: We ran a series of tests that verified Google is able to execute and index JavaScript
    with a multitude of implementations. We also confirmed Google is able to render
    the entire page and read the DOM, thereby indexing dynamically generated content.
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们进行了一系列测试，验证了 Google 能够执行和索引多种实现的 JavaScript。我们还确认了 Google 能够渲染整个页面并读取 DOM，从而索引动态生成的内容。
- en: This article found that at the time of writing, Google and Bing were advanced
    enough to index client-only websites, but ultimately this is just one research
    project in an otherwise vast and unknowable proprietary ocean.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本文发现，截至撰写本文时，Google 和 Bing 已经足够先进，能够索引仅客户端的网站，但最终这只是一个研究项目，在一个广阔而不可知的专有海洋中仅仅是一个研究项目。
- en: Thus, while client-only applications may work well with modern search engines,
    there is an inherent risk in not having a server-based counterpart. In traditional
    web applications, when a user or a search engine crawler requests a page, the
    server renders the HTML for the page and sends it back. The HTML contains all
    the content, links, and data, making it easy for search engine crawlers to read
    and index the content for search engine results since all the content of the page
    is nothing more than text, i.e., markup.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管仅客户端应用程序在现代搜索引擎中可能表现良好，但没有基于服务器的对应方案存在固有风险。在传统的 Web 应用程序中，当用户或搜索引擎爬虫请求页面时，服务器会渲染页面的
    HTML 并将其返回。HTML 包含所有内容、链接和数据，使得搜索引擎爬虫可以轻松读取和索引内容，用于搜索引擎结果，因为页面的所有内容仅仅是文本，即标记。
- en: 'However, in a client-side rendered application, often built with libraries
    or frameworks like React, the server sends back a near-empty HTML file whose sole
    job is to load JavaScript from a separate JavaScript file on the same or an alternate
    server. The JavaScript file then downloads and executes in the browser, rendering
    the page content dynamically. This approach provides a smooth user experience,
    resembling that of a native application, but it has a downside when it comes to
    search engine optimization (SEO) and performance: we don’t download anything useful
    for human readers on the first request, but instead have to do another request
    immediately after the page loads for the JavaScript that will power the entire
    site. This is known as a network waterfall.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在使用像 React 这样的库或框架构建的客户端渲染应用程序中，服务器返回一个几乎为空的 HTML 文件，其唯一任务是从同一服务器或备用服务器上的单独
    JavaScript 文件中加载 JavaScript。然后，JavaScript 文件在浏览器中下载和执行，动态渲染页面内容。这种方法提供了流畅的用户体验，类似于本地应用程序，但在搜索引擎优化（SEO）和性能方面存在缺点：在第一次请求时，我们没有下载任何有用的东西给人类读者，而是必须在页面加载后立即进行另一个请求，获取将为整个站点提供动力的
    JavaScript。这被称为网络瀑布效应。
- en: Thus, another downside of client-only rendering is performance. Let’s talk about
    that.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，客户端仅渲染的另一个缺点是性能问题。让我们来谈谈这个问题。
- en: Performance
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能
- en: Client-side rendered applications may suffer from performance issues, especially
    on slow networks or less powerful devices. The need to download, parse, and execute
    JavaScript before rendering the content can lead to significant delays in content
    rendering. This “time to interactive” is a crucial metric as it directly impacts
    user engagement and bounce rates (bounce as in the rate at which users abandon
    a page). Users might leave a page if it takes too long to load, and this behavior
    can further negatively impact the SEO ranking of the page.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端渲染的应用程序可能会因性能问题而受到影响，特别是在网络较慢或设备性能较弱的情况下。在渲染内容之前需要下载、解析和执行 JavaScript，这可能导致内容渲染的显著延迟。这个“交互时间”是一个关键指标，直接影响用户参与度和跳出率（用户放弃页面的速率）。如果加载时间过长，用户可能会离开页面，这种行为进一步会对页面的
    SEO 排名产生负面影响。
- en: Additionally, if a device is low-powered with minimal CPU availability, client-only
    rendering also creates a poor user experience. This is because the device may
    not have enough processing power to execute the JavaScript quickly, resulting
    in a slow and unresponsive application. This can lead to frustrated users and
    a poor user experience. If we executed this JavaScript on the server and sent
    minimal data or markup to the client, low-power clients don’t have to do much
    work and thus the user experience is better.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果设备性能低，CPU 可用性较少，仅客户端渲染还会导致糟糕的用户体验。这是因为设备可能没有足够的处理能力来快速执行 JavaScript，导致应用程序运行缓慢且响应迟钝。这可能会导致用户感到沮丧和不良的用户体验。如果我们在服务器上执行这些
    JavaScript，并向客户端发送最少的数据或标记，那么低功率客户端不需要做太多工作，因此用户体验会更好。
- en: On a broader spectrum, the issues of SEO and performance in client-side rendered
    applications highlight the importance of adhering to web standards and best practices.
    They also underline the need for server-side rendering or static site generation
    as more reliable alternatives for delivering content in a performant and accessible
    manner, especially for content-heavy sites or applications.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从更广泛的角度来看，客户端渲染应用程序中的 SEO 和性能问题突显了遵循 web 标准和最佳实践的重要性。它们也强调了服务器端渲染或静态网站生成作为提供内容的可靠替代方案的需求，尤其是对于内容丰富的站点或应用程序而言。
- en: The principle of progressive enhancement, where basic content and functionality
    are delivered to all browsers, while advanced features are considered as an enhancement,
    aligns well with these alternatives. By rendering the core content server-side,
    you ensure that all users and search engines have access to the fundamental content
    and functionality, regardless of JavaScript execution. Then, client-side JavaScript
    can enhance the user experience by adding interactivity, richer animations, and
    other advanced features for the browsers and devices that can support them. It
    does not make any sense to have *the entire experience* be client-side JavaScript
    only, as this is not the original design of the web. JavaScript’s role is to *enhance*
    a web page, not *be* a web page.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 渐进增强原则，即向所有浏览器传递基本内容和功能，而将高级特性作为增强功能，与这些选择非常契合。通过在服务器端渲染核心内容，确保所有用户和搜索引擎都可以访问基本内容和功能，而不受
    JavaScript 执行的影响。然后，客户端 JavaScript 可以通过增加交互性、更丰富的动画和其他高级功能，增强用户体验。仅将整个体验设计为仅基于客户端
    JavaScript 是没有意义的，因为这不是 Web 的原始设计。JavaScript 的角色是*增强*网页，而不是*成为*网页。
- en: 'Consider the following example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下例子：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, we are fetching data from an API and rendering it on the client
    side. We can tell it’s the client side because we are using the `useEffect` hook
    to fetch the data, and the `useState` hook to store the data in state. The `useEffect`
    hook executes inside a browser (a client) only.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们从一个 API 获取数据，并在客户端上渲染它。我们可以通过使用`useEffect`钩子来获取数据，并使用`useState`钩子将数据存储在状态中，来判断这是客户端操作。`useEffect`钩子仅在浏览器（客户端）中执行。
- en: A serious limitation with this is that some search engine crawlers may not be
    able to see this content unless we implement server-side rendering. Instead, there
    is a risk that they see a blank screen or a fallback message, which can result
    in poor SEO.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一个严重的限制是，一些搜索引擎爬虫可能无法看到这些内容，除非我们实现服务器端渲染。否则，他们可能会看到一个空白屏幕或回退信息，这可能会导致较差的 SEO。
- en: Another common problem with client-only applications is network waterfalls,
    wherein the initial page load is blocked by the amount of JavaScript that needs
    to be downloaded, parsed, and executed by the browser before the website or web
    app becomes visible. In cases where network connectivity is a limited resource,
    this would render a website or application completely unresponsive for significant
    amounts of time.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端应用程序仅仅是网络瀑布的另一个常见问题，即在初始页面加载时，需要下载、解析和执行大量 JavaScript，导致网站或 Web 应用在相当长时间内不可响应，尤其是在网络连接受限的情况下。
- en: In the example, we’re initiating a data fetch request to an external API endpoint
    (`https://api.example.com/data`) to retrieve some data. This fetch happens *after*
    our initial JavaScript bundle is downloaded, parsed, and executed, and that happens
    only *after* the initial HTML loads. This is a network waterfall and leads to
    less-than-optimal performance. If we visualize it, it would look like [Figure 6-1](#figure6-1).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在向外部 API 端点（`https://api.example.com/data`）发起数据获取请求以检索一些数据。这种获取发生在我们的初始
    JavaScript 包被下载、解析和执行之后，而这只会发生在初始 HTML 加载之后。这是一个网络瀑布，导致性能不佳。如果我们可视化它，看起来会像是[图
    6-1](#figure6-1)。
- en: '![frea 0601](assets/frea_0601.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![frea 0601](assets/frea_0601.png)'
- en: Figure 6-1\. Data fetch request
  id: totrans-26
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-1\. 数据获取请求
- en: 'Yuck. With server-side rendering, we can do better and enable our users to
    see useful content immediately, altering the diagram to look like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 真是糟糕。使用服务器端渲染，我们可以做得更好，使用户能够立即看到有用的内容，从而修改图表如下所示：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Indeed, the first load is already packed with information that is useful to
    the user because we fetched our data and rendered our component on the server.
    There is no waterfall here, and the user gets all their information immediately.
    This is the value of server-side rendering.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，首次加载已经包含了对用户有用的信息，因为我们在服务器上获取了数据并渲染了我们的组件。这里没有瀑布效应，用户立即获得所有信息。这就是服务器端渲染的价值所在。
- en: As of React 18, the bundle sizes of React and React DOM are 6.4 kB and 130.2
    kB, respectively. These sizes are for the latest version of React at the time
    of writing and may vary depending on the version and configuration of React that
    you are using today. This means that even in production environments, our users
    have to download around 136 kB of JavaScript just for React alone (i.e., React
    + React DOM), before downloading, parsing, and executing the rest of our application’s
    code. This can result in a slower initial page load, especially on slower devices
    and networks, and potentially frustrated users. Moreover, because React essentially
    owns the DOM and we have no user interface without React in client-only applications,
    our users have no choice but to wait for React and React DOM to load *first* before
    the rest of our application does.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 截至React 18版本，React和React DOM的捆绑大小分别为6.4 kB和130.2 kB。这些大小是在撰写本文时的最新React版本，实际使用中可能因React的版本和配置而有所不同。这意味着即使在生产环境中，我们的用户也必须单独下载约136
    kB的JavaScript仅用于React（即React + React DOM），然后才能下载、解析和执行我们应用程序其余的代码。这可能导致初始页面加载较慢，尤其是在较慢的设备和网络上，可能会让用户感到沮丧。此外，因为React基本上控制了DOM，在仅客户端应用程序中没有React，我们的用户没有选择，只能等待React和React
    DOM首先加载，然后才加载应用程序的其余部分。
- en: In contrast, a server rendered application would stream rendered HTML to the
    client before any JavaScript downloads, enabling users to get meaningful content
    immediately. It would then load relevant JavaScript after the initial page renders,
    probably while the user is still orienting themselves with a user interface through
    a process called “hydration.” More on this in the coming sections.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，服务器呈现的应用程序将在任何JavaScript下载之前向客户端流式传输呈现的HTML，使用户可以立即获取有意义的内容。然后，在初始页面呈现后，可能在用户还在通过称为“hydration”过程的用户界面定位自己时，加载相关的JavaScript。接下来的部分将更详细讨论这一点。
- en: 'Initially streaming rendered HTML and then hydrating the DOM with JavaScript
    allows users to interact with the application sooner, resulting in a better user
    experience: it is immediately available to the user without them having to wait
    for any extras—that they may or may not even need—to load.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最初通过流式呈现的HTML，然后通过JavaScript注入DOM，使用户能够更早地与应用程序进行交互，从而获得更好的用户体验：用户可以立即使用，而无需等待可能甚至不需要加载的任何额外内容。
- en: Security
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全性
- en: Client-only rendering can also have security issues, especially when dealing
    with sensitive data. This is because all of the application’s code is downloaded
    to the client’s browser, making it vulnerable to attacks such as cross-site request
    forgery (CSRF).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 仅客户端渲染也可能存在安全问题，特别是在处理敏感数据时。这是因为应用程序的所有代码都会下载到客户端的浏览器中，使其容易受到跨站请求伪造（CSRF）等攻击的影响。
- en: Without getting too much into the weeds about CSRF, a common way to mitigate
    against it is to have control of the server that serves the website or web app
    to your users. If we have control of this server, we can send appropriate anti-CSRF
    tokens from the server as a trusted source to the client, and then the client
    submits the tokens via a form or similar back to the server, which can verify
    that the request is coming from the correct client. This is a common way to mitigate
    against CSRF.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到CSRF，一种常见的减少其影响的方法是控制向用户提供网站或Web应用程序的服务器。如果我们控制了这个服务器，我们可以从服务器发送适当的反CSRF令牌作为可信来源到客户端，然后客户端通过表单或类似方式提交令牌回服务器，服务器可以验证请求来自正确的客户端。这是一种常见的减少CSRF攻击的方式。
- en: While it is technically possible to serve client-only applications from a static
    site server we control, and mitigate against CSRF that way, it’s still not the
    best way to serve a website in general because of the other trade-offs we’ve discussed
    so far. If we do have control of a server, then why not add SSR to it from there?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管从我们控制的静态站点服务器上提供仅客户端应用程序并以此方式减少CSRF攻击是技术上可行的，但总体上并不是最佳的网站服务方式，因为我们到目前为止讨论的其他权衡。如果我们确实控制了服务器，那么为什么不从那里添加SSR呢？
- en: 'Ultimately, here’s what we’re saying:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，这就是我们要说的：
- en: If we don’t have access to the server side but work in a team where it’s just
    `git push` frontend client-only code and then it’s magically deployed somewhere,
    there are inherent CSRF risks here.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们没有访问服务器端的权限，但在一个团队中工作，只需要`git push`前端客户端代码，然后它就会神奇地部署到某个地方，这里存在固有的CSRF风险。
- en: If we have access to the server side and if our website or web app is still
    client only, we can mitigate against CSRF quite well already and the security
    risks around it go away.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们可以访问服务器端，并且我们的网站或 Web 应用仍然仅限于客户端，我们已经可以相当好地缓解 CSRF，并且其周围的安全风险也随之消失。
- en: If we have access to the server side and if our website or web app is still
    client only, there’s a strong argument to be made to add server-side rendering
    to it, since we have access to the server, enabling the other benefits around
    SEO and performance that we’ve already covered.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们可以访问服务器端，并且我们的网站或 Web 应用仍然仅限于客户端，那么我们有充分理由为其添加服务器端渲染，因为我们可以访问服务器，从而实现我们已经涵盖的关于
    SEO 和性能的其他好处。
- en: 'Let’s get a little bit practical and consider the following example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们变得更加实际，考虑以下示例：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this code, `handleWithdrawal` sends a `POST` request to a hypothetical server-side
    endpoint `/withdraw` to process the withdrawal. A CSRF risk could occur if this
    endpoint does not properly validate the origin of the request and doesn’t require
    any form of anti-CSRF token.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，`handleWithdrawal` 发送 `POST` 请求到一个假设的服务器端点 `/withdraw` 处理提款。如果此端点未正确验证请求的来源并且不需要任何形式的反
    CSRF 令牌，则可能存在 CSRF 风险。
- en: An attacker could create a malicious webpage that tricks a user into clicking
    a button, which then sends a `POST` request to the `/withdraw` endpoint on the
    user’s behalf, possibly leading to unauthorized withdrawals from the user’s account.
    This is because the browser automatically includes cookies in the request, which
    the server uses to authenticate the user. If the server does not validate the
    origin of the request, it could be tricked into processing the request and sending
    the funds to the attacker’s account.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可以创建一个恶意网页，欺骗用户点击按钮，然后代表用户向 `/withdraw` 端点发送 `POST` 请求，可能导致从用户账户未经授权地提取资金。这是因为浏览器会自动在请求中包含
    cookie，服务器使用这些 cookie 来验证用户身份。如果服务器不验证请求的来源，可能会被欺骗处理请求并将资金发送到攻击者的账户。
- en: If this component is rendered on the client side, it could be vulnerable to
    CSRF attacks because the server and client do not have a shared common secret
    or contract between them. To speak poetically, the client and server don’t know
    each other. This could allow an attacker to steal funds or manipulate the application’s
    data.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此组件在客户端渲染，则可能会容易受到 CSRF 攻击的影响，因为服务器和客户端之间没有共享的公共秘密或契约。用诗意的语言来说，客户端和服务器彼此不认识。这可能允许攻击者窃取资金或操纵应用程序的数据。
- en: If we used server rendering, we could mitigate these security issues by rendering
    the component on the server with a special secret token generated by the server,
    and then sending HTML containing the secret token to the client. The client would
    then send this token back to the server that issued it, establishing a secure
    bidirectional contract. This would allow the server to verify that the request
    is coming from the correct client that it has preauthorized and not an unknown
    one, which could possibly be a malicious attacker.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们采用服务器端渲染，我们可以通过在服务器上使用特殊生成的秘密令牌来渲染组件，然后将包含秘密令牌的 HTML 发送给客户端，来缓解这些安全问题。客户端随后将此令牌发送回发出令牌的服务器，建立一个安全的双向契约。这样服务器就可以验证请求来自于预授权的正确客户端，而不是一个可能是恶意攻击者的未知客户端。
- en: The Rise of Server Rendering
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端渲染的兴起
- en: For these reasons, server-side rendering has emerged as an arguably superior
    technique for improving the performance and user experience of web applications.
    With server rendering, applications can be optimized for speed and accessibility,
    resulting in faster load times, better SEO, and improved user engagement.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 出于这些原因，服务器端渲染已经成为提高 Web 应用性能和用户体验的一种可以说是更优越的技术。通过服务器渲染，应用程序可以针对速度和可访问性进行优化，从而实现更快的加载时间、更好的
    SEO 和提高的用户参与度。
- en: Benefits of Server Rendering
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器端渲染的好处
- en: 'Let’s dive deeper into the benefits of server rendering. These should become
    immediately clear as we further understand the limitations of client-only rendering:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地探讨服务器端渲染的好处。当我们进一步理解仅客户端渲染的局限性时，这些好处应该会立即显现：
- en: The time to first meaningful paint is faster with server rendering.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用服务器端渲染的首次有意义绘制时间更快。
- en: This is because the server can render the initial HTML markup and send it to
    the client, which can then be displayed immediately. This is in contrast to client-only
    rendering, where the client must wait for the JavaScript to be downloaded, parsed,
    and executed before the application can be rendered.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为服务器可以渲染初始的 HTML 标记并将其发送到客户端，客户端可以立即显示。这与仅在客户端渲染不同，后者必须等待 JavaScript 被下载、解析和执行后才能渲染应用程序。
- en: Server rendering improves the accessibility of web applications.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器渲染改善了 Web 应用程序的可访问性。
- en: Users with slow internet connections or low-power devices may have a better
    experience if they receive fully rendered HTML instead of waiting for client-side
    JavaScript to load and render the page.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 网速慢或设备性能低的用户，如果收到完全渲染的 HTML 而不是等待客户端 JavaScript 加载和渲染页面，可能会有更好的体验。
- en: Server rendering can improve the SEO of web applications.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器渲染可以提升 Web 应用程序的 SEO。
- en: When search engine crawlers index your site, they can see the fully rendered
    HTML, making it easier for them to understand the content and structure of your
    site.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当搜索引擎爬虫索引您的站点时，它们可以看到完全渲染的 HTML，这样更容易理解您站点的内容和结构。
- en: Server rendering can also improve the security of web applications.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器渲染还可以提升 Web 应用程序的安全性。
- en: By rendering the core content server-side, you ensure that all users and search
    engines have access to the fundamental content and functionality, regardless of
    JavaScript execution. Then, client-side JavaScript can enhance the user experience
    by adding interactivity, richer animations, and other advanced features for the
    browsers and devices that can support them.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在服务器端渲染核心内容，可以确保所有用户和搜索引擎都可以访问基本内容和功能，而不受 JavaScript 执行的影响。然后，客户端 JavaScript
    可以通过为支持它们的浏览器和设备添加互动性、更丰富的动画和其他高级功能，来增强用户体验。
- en: However, server rendered HTML is static and lacks interactivity as it does not
    have any JavaScript initially loaded. It includes no event listeners or other
    dynamic functionality attached. To enable user interactions and other dynamic
    features, the static HTML must be “hydrated” with the necessary JavaScript code.
    Let’s understand the concept of hydration a little better.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，服务器渲染的 HTML 是静态的，缺乏初始加载时的互动性。它不包含任何事件监听器或其他动态功能。要启用用户交互和其他动态功能，必须使用必要的 JavaScript
    代码“hydrate”静态 HTML。让我们更好地理解 hydration 的概念。
- en: Hydration
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hydration
- en: '*Hydration* is a term used to describe the process of attaching event listeners
    and other JavaScript functionality to static HTML that is generated on the server
    and sent to the client. The goal of hydration is to enable a server rendered application
    to become fully interactive after being loaded in the browser, providing users
    with a fast and smooth experience.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**Hydration** 是一个术语，用于描述将事件监听器和其他 JavaScript 功能附加到在服务器上生成并发送到客户端的静态 HTML 的过程。hydration
    的目标是使服务器渲染的应用程序在加载到浏览器后变得完全交互，从而为用户提供快速流畅的体验。'
- en: 'In a React application, hydration happens after a client downloads a server
    rendered React application. Then, the following steps occur:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个 React 应用程序中，**hydration** 是指在客户端下载了服务器渲染的 React 应用程序之后发生的过程。
- en: Loading the client bundle
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 加载客户端 bundle
- en: While the browser is rendering the static HTML, it also downloads and parses
    the JavaScript bundle that contains the application’s code. This bundle includes
    the React components and any other code that is necessary for the application’s
    functionality.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器渲染静态 HTML 时，它也会下载并解析包含应用程序代码的 JavaScript bundle。该 bundle 包括 React 组件和其他必要的应用程序功能代码。
- en: Attaching event listener
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 附加事件监听器
- en: Once the JavaScript bundle is loaded, React “hydrates” the static HTML by attaching
    event listeners and other dynamic functionality to the DOM elements. This is typically
    done using the `hydrateRoot` function from `react-dom`, which takes the root React
    component and the DOM container as arguments. Hydration essentially transforms
    the static HTML into a fully interactive React application.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦加载了 JavaScript bundle，React 通过将事件监听器和其他动态功能附加到 DOM 元素来“hydrate”静态 HTML。通常使用
    `react-dom` 中的 `hydrateRoot` 函数来完成此操作，该函数接受根 React 组件和 DOM 容器作为参数。hydration 本质上将静态
    HTML 转换为完全交互式的 React 应用程序。
- en: After the hydration process is complete, the application is fully interactive
    and can respond to user input, fetch data, and update the DOM, as necessary.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 完成 hydration 过程后，应用程序变得完全可交互，可以响应用户输入，获取数据，并在必要时更新 DOM。
- en: During hydration, React matches the structure of the DOM elements in the static
    HTML to the structure defined by the React components via JSX. It is crucial that
    the structure generated by the React components matches the structure of the static
    HTML. If there is a mismatch, React will not be able to correctly attach event
    listeners and will not be aware of what React element directly maps to what DOM
    element, which results in the application not behaving as expected.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在水合作用期间，React将静态HTML中的DOM元素结构与通过JSX定义的React组件结构进行匹配。关键是React组件生成的结构必须与静态HTML的结构匹配。如果不匹配，React将无法正确附加事件监听器，并且不会意识到哪个React元素直接映射到哪个DOM元素，导致应用程序的行为不符预期。
- en: By combining server-side rendering and hydration, developers can create web
    applications that load quickly and provide a smooth, interactive user experience.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合服务器端渲染和水合作用，开发者可以创建加载快速、提供平滑交互用户体验的Web应用程序。
- en: Hydration Considered Harmful
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 水合作用有害
- en: While hydration is a great way to take server rendered HTML and make it interactive,
    some criticize hydration for being slower than necessary, often citing resumability
    as a superior alternative (see [Figure 6-2](#figure6-2)). Let’s explore this a
    little bit.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在水合作用是将服务器渲染的HTML变为交互式的一种绝佳方式，但也有人批评它的速度慢于必要，通常提到可恢复性作为一个更优的替代方案（见[图 6-2](#figure6-2)）。让我们稍微探讨一下这个问题。
- en: '![Hydration](assets/frea_0602.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![水合作用](assets/frea_0602.png)'
- en: Figure 6-2\. Hydration
  id: totrans-73
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-2\. 水合作用
- en: With hydration, we render a React application on the server and then pass the
    rendered output to a client. However, at this point in time, nothing is interactive.
    From here, our browser needs to download the client bundle, attach event listeners,
    and effectively “rerender” the client. This is a lot of work, and sometimes presents
    a delay between when content appears to a user and when the user can actually
    use the site.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在水合作用中，我们在服务器上渲染React应用程序，然后将渲染输出传递给客户端。但是，在这个时间点上，什么都不是交互式的。从这里开始，浏览器需要下载客户端捆绑包，附加事件监听器，并有效地“重新渲染”客户端。这是一项繁重的工作，有时会导致内容出现在用户面前与用户实际可以使用站点之间存在延迟。
- en: Alternatively, resumability works slightly differently, as shown in [Figure 6-3](#figure6-3).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可恢复性的工作方式略有不同，如[图 6-3](#figure6-3)所示。
- en: '![Resumability](assets/frea_0603.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![可恢复性](assets/frea_0603.png)'
- en: Figure 6-3\. Resumability
  id: totrans-77
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-3\. 可恢复性
- en: With resumability, the entire application is rendered on the server and streamed
    to a browser. Along with the initial markup, all interactive behavior is serialized
    and also sent to the client. From there, the client already has all the information
    on how to become interactive on demand and thus *resume* where the server left
    off. It does not need to hydrate (that is, attach event listeners and render the
    page on the client side), but instead can deserialize the stuff the server gave
    it and react accordingly. Skipping the hydration step can result in a faster time
    to interactive (TTI) and a better user experience.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可恢复性，整个应用程序在服务器上进行渲染并流式传输到浏览器。除了初始标记外，所有交互行为都被序列化并发送到客户端。从那时起，客户端已经获得了关于如何根据需要进行交互的所有信息，因此可以在服务器离开的地方*继续*。它不需要水合（即，在客户端附加事件监听器和渲染页面），而是可以反序列化服务器提供的内容并相应地做出反应。跳过水合步骤可以导致更快的交互时间（TTI）和更好的用户体验。
- en: 'While there is measurable benefit to resumability, the engineering community
    questions whether the complexity of implementing it is worth the benefit. Indeed,
    it is a more complex approach than hydration, and it is not yet clear whether
    the benefits outweigh the costs: yes, time to interactive is faster by a few milliseconds,
    but is it worth the complexity of implementing resumability? This is a question
    that is still being debated in the React community.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可恢复性有明显的好处，工程社区对于实施复杂性是否值得这个好处存在疑问。确实，这比水合作用更复杂，目前尚不清楚好处是否超过成本：是的，交互时间会快几毫秒，但实施可恢复性的复杂性是否值得？这是React社区仍在辩论的问题。
- en: Creating Server Rendering
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建服务器渲染
- en: If you have an existing client-only React app, you may be wondering how to add
    server rendering to it. Fortunately, it’s relatively straightforward to add server
    rendering to an existing React app. One approach is to use a server rendering
    framework, such as Next.js or Remix. While these frameworks are indeed the best
    way to server rendered React applications, abstractions like this can leave the
    more curious of us hungry to understand the underlying mechanisms used to accomplish
    this.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有现有的客户端 React 应用程序，您可能想知道如何将服务器渲染添加到其中。幸运的是，向现有的 React 应用程序添加服务器渲染相对简单。一种方法是使用服务器渲染框架，如
    Next.js 或 Remix。虽然这些框架确实是提供服务器渲染 React 应用程序的最佳方式，但这种抽象可能会让我们中更好奇的人渴望理解用于实现此目标的基本机制。
- en: If you’re a curious person and are interested in how you would add server rendering
    to a client-only React app manually, or if you’re interested in how frameworks
    do it, read on. Once again, this is stuff you’d probably not use in production,
    but is more for educational purposes for the curious.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是一个好奇的人，并且有兴趣了解如何手动将服务器渲染添加到客户端 React 应用程序中，或者对框架如何实现它感兴趣，请继续阅读。再次强调，这些内容可能不适合在生产中使用，而更适合于好奇心的教育目的。
- en: Manually Adding Server Rendering to a Client-Only React App
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将客户端 React 应用程序手动添加到服务器渲染
- en: 'If you’ve got a client-only application, this is how you’d add server rendering
    to it. First, you’d create a *server.js* file in the root of your project. This
    file will contain the code for your server:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个客户端应用程序，这是如何向其添加服务器渲染的方式。首先，在项目的根目录中创建一个*server.js*文件。此文件将包含您的服务器代码：
- en: '[PRE3]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, we’re using Express to create a server that serves static files
    from the *./build* directory and then renders our React app on the server. We’re
    also using `ReactDOMServer` to render our React app to an HTML string and then
    inject it into the response sent to the client.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们使用 Express 创建一个服务器，该服务器从*./build*目录中提供静态文件，然后在服务器上渲染我们的 React 应用程序。我们还使用`ReactDOMServer`将我们的
    React 应用程序渲染为 HTML 字符串，然后将其注入到发送给客户端的响应中。
- en: 'In this scenario, we’re assuming our client-only React app has some type of
    `build` script that would output a client-only JavaScript bundle into a directory
    called *build* that we reference in the snippet. This is important for hydration.
    With all these pieces in order, let’s go ahead and start our server:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们假设我们的客户端 React 应用程序有某种类型的`build`脚本，该脚本将客户端 JavaScript 捆绑包输出到名为*build*的目录中，我们在代码片段中引用该目录。这对于水合作用很重要。所有这些部分都准备就绪后，让我们继续启动我们的服务器：
- en: '[PRE4]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Running this command should start our server on port 3000 and should output
    `Server listening on port 3000`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令应该会在端口3000上启动我们的服务器，并输出`Server listening on port 3000`。
- en: With these steps, we now have a server rendered React app. By taking this “peek
    under the hood” approach to server rendering, we gain a deeper understanding of
    how server rendering works and how it can benefit our React applications.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些步骤，我们现在拥有了一个服务器渲染的 React 应用程序。通过这种“窥探内部”的方法来进行服务器渲染，我们可以更深入地了解服务器渲染的工作原理，以及它如何使我们的
    React 应用程序受益。
- en: If we open a browser and visit *[*http://localhost:3000*](http://localhost:3000)*,
    we should see a server rendered application. We can confirm that it is in fact
    server rendered by viewing the source code of this page, which should reveal actual
    HTML markup instead of a blank document.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打开浏览器并访问[*http://localhost:3000*](http://localhost:3000)，我们应该看到一个服务器渲染的应用程序。我们可以通过查看页面的源代码来确认它确实是服务器渲染的，这应该显示实际的
    HTML 标记，而不是空白文档。
- en: 'For the sake of completion, this is what the HTML markup should look like:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整起见，这就是 HTML 标记的样子：
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is the HTML markup that is sent to the client. It contains the fully rendered
    HTML for our React app, which can be indexed by search engines and more efficiently
    accessed by users with slow or unreliable internet connections. This can result
    in better SEO and improved accessibility for our React app.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是发送到客户端的 HTML 标记。它包含我们的 React 应用程序的完全渲染的 HTML，可以被搜索引擎索引，并且可以更有效地由网络连接较慢或不可靠的用户访问。这可以为我们的
    React 应用程序带来更好的 SEO 和改进的可访问性。
- en: Hydrating
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 水合作用
- en: With server rendered output making it to users, hydration happens when we load
    our client bundle with the `<script>` tag toward the end of the file. As discussed,
    hydration is the process of attaching event listeners and other JavaScript functionality
    to static HTML that is generated on the server and sent to the client. The goal
    of hydration is to enable a server rendered application to become fully interactive
    after being loaded in the browser.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器渲染的输出到达用户端时，我们通过将 `<script>` 标签加载到文件末尾来进行 hydration。正如讨论的那样，hydration 是将事件监听器和其他
    JavaScript 功能附加到在服务器上生成并发送到客户端的静态 HTML 上的过程。hydration 的目标是使服务器渲染的应用程序在加载到浏览器后能够完全交互。
- en: 'If we want to explore the hydration step of the client-side bundle of our app,
    it would look like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要探索应用程序客户端端 bundle 的 hydration 步骤，它将如下所示：
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With server rendering and client hydration, our app is fully interactive and
    can respond to user input, fetch data, and update the DOM, as necessary.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通过服务器渲染和客户端 hydration，我们的应用程序完全交互，可以响应用户输入、获取数据并根据需要更新 DOM。
- en: Server Rendering APIs in React
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React 中的服务器渲染 API
- en: In the previous section, we manually added server rendering to a client-only
    React app using Express and `ReactDOMServer`. Specifically, we used `ReactDOMServer.renderToString()`
    to render our React app to an HTML string. This is the most basic way to add server
    rendering to a React app. However, there are other ways to add server rendering
    to React apps. Let’s take a deeper look at server rendering APIs exposed by React
    and understand when and how to use them.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们通过 Express 和 `ReactDOMServer` 手动向客户端 React 应用程序添加了服务器渲染。具体来说，我们使用了 `ReactDOMServer.renderToString()`
    将我们的 React 应用程序渲染为 HTML 字符串。这是向 React 应用程序添加服务器渲染的最基本方法。然而，还有其他向 React 应用程序添加服务器渲染的方法。让我们深入了解
    React 暴露的服务器渲染 API，并了解何时以及如何使用它们。
- en: 'Let’s consider the `renderToString` API in detail, exploring its usage, advantages,
    disadvantages, and when it is appropriate to use it in a React application. Specifically,
    let’s look into:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细考虑 `renderToString` API，探讨其使用、优势、劣势以及在何时适合在 React 应用程序中使用它。
- en: What it is
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是什么
- en: How it works
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作原理
- en: How it fits into our everyday usage of React
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它如何适应我们对 React 的日常使用
- en: To start with this, let’s talk about what it is.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们谈谈它是什么。
- en: renderToString
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`renderToString`'
- en: '`renderToString` is a server-side rendering API provided by React that enables
    you to render a React component into an HTML string on the server. This API is
    synchronous and returns a fully rendered HTML string, which can then be sent to
    the client as a response. `renderToString` is commonly used in server rendered
    React applications to improve performance, SEO, and accessibility.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`renderToString` 是 React 提供的一种服务端渲染 API，允许你在服务器上将一个 React 组件渲染成 HTML 字符串。该
    API 是同步的，并返回一个完全渲染的 HTML 字符串，随后可以作为响应发送到客户端。`renderToString` 在服务器渲染的 React 应用中常用于提升性能、SEO
    和可访问性。'
- en: Usage
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用方式
- en: 'To use `renderToString`, you’d need to import the `renderToString` function
    from the `react-dom/server` package. Then, you can call the function with a React
    component as its argument. It will then return the fully rendered HTML as a string.
    Here’s an example of using `renderToString` to render a simple React component:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `renderToString`，您需要从 `react-dom/server` 包中导入 `renderToString` 函数。然后，您可以使用一个
    React 组件作为其参数调用该函数。然后它将作为一个字符串返回完全渲染的 HTML。以下是使用 `renderToString` 渲染简单 React 组件的示例：
- en: '[PRE7]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, we create a simple App component and call `renderToString`
    with the component as its argument. The function returns the fully rendered HTML,
    which can be sent to the client.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们创建一个简单的 App 组件，并使用组件作为参数调用 `renderToString`。该函数返回完全渲染的 HTML，可以发送到客户端。
- en: How it works
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工作原理
- en: This function traverses the tree of React elements, converts them to a string
    representation of real DOM elements, and finally outputs a string.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数遍历 React 元素树，将它们转换为真实 DOM 元素的字符串表示，最终输出一个字符串。
- en: 'It’s worth recalling here that in React, `<div>` is converted to:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里值得提醒的是，在 React 中，`<div>` 被转换为：
- en: '[PRE8]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'whose output is:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 输出为：
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We’ve covered this in prior chapters, but it’s worth recalling here for the
    discussion we’re about to have. Fundamentally, JSX turns into HTML with the following
    flow:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前几章已经涵盖了这一点，但对于我们即将进行的讨论，这里值得回顾一下。从根本上讲，JSX 转换为 HTML 的流程如下：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`renderToString` as an API is synchronous and blocking, meaning it cannot be
    interrupted or paused. If a component tree from the root is many levels deep,
    it can require quite a bit of processing. Since a server typically services multiple
    clients, `renderToString` could be called for each client unless there’s some
    type of cache preventing this, and quickly block the event loop and overload the
    system.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`renderToString`作为一个API是同步和阻塞的，意味着它不能被中断或暂停。如果从根部开始的组件树很深，它可能需要相当多的处理。由于服务器通常为多个客户端提供服务，除非有某种缓存阻止这种情况发生，否则可能为每个客户端调用`renderToString`，并迅速阻塞事件循环并使系统超载。'
- en: 'In terms of code, `renderToString` converts this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码角度来看，`renderToString`将这个：
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'to this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为这个：
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Because React is declarative and React elements are declarative abstractions,
    a tree of them can be turned into a tree of anything else—in this case, a tree
    of React elements is turned into a string-representation of a tree of HTML elements.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因为React是声明式的，React元素是声明式的抽象，它们的树可以转换为任何其他东西的树——在这种情况下，React元素的树被转换为HTML元素树的字符串表示。
- en: Disadvantages
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缺点
- en: 'While `renderToString` offers several advantages, it also has some downsides:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`renderToString`提供了几个优点，但它也有一些缺点：
- en: Performance
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 性能
- en: One of the main disadvantages of `renderToString` is that it can be slow for
    large React applications. Because it is synchronous, it can block the event loop
    and make the server unresponsive. This can be especially problematic if you have
    a high-traffic application with many concurrent users.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`renderToString`的主要缺点之一是对于大型React应用程序来说可能会很慢。因为它是同步的，它可能会阻塞事件循环并使服务器无响应。如果您有许多并发用户的高流量应用程序，这可能会特别成问题。'
- en: Moreover, `renderToString` returns a fully rendered HTML string, which can be
    memory intensive for large applications. This can lead to increased memory usage
    on your server and potentially slower response times, or a panic that kills the
    server process under heavy load.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`renderToString`返回一个完全渲染的HTML字符串，对于大型应用程序来说可能会占用大量内存。这可能导致服务器的内存使用增加，响应时间变慢，或者在高负载下导致服务器进程崩溃。
- en: Lack of streaming support
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 缺乏流支持
- en: '`renderToString` does not support streaming, which means that the entire HTML
    string must be generated before it can be sent to the client. This can result
    in a slower time to first byte (TTFB) and a longer time for the client to start
    receiving the HTML. This limitation can be particularly problematic for large
    applications with lots of content, as the client must wait for the entire HTML
    string to be generated before any content can be displayed.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`renderToString`不支持流，这意味着整个HTML字符串必须在发送到客户端之前生成。这可能导致首字节时间（TTFB）较慢，客户端开始接收HTML的时间较长。这种限制对于内容较多的大型应用程序尤其有问题，因为客户端必须等待整个HTML字符串生成后才能显示任何内容。'
- en: For larger applications or situations where the downsides of `renderToString`
    become problematic, React offers alternative APIs for server-side rendering, such
    as `renderToPipeableStream` and `renderToReadableStream`. These APIs return a
    Node.js stream and a browser stream, respectively, instead of a fully rendered
    HTML string, which can provide better performance and support for streaming. We
    will cover these more in the next section.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更大的应用程序或`renderToString`的缺点变得问题严重的情况，React提供了替代的服务器端渲染API，如`renderToPipeableStream`和`renderToReadableStream`。这些API分别返回一个Node.js流和一个浏览器流，而不是完全渲染的HTML字符串，这可以提供更好的性能和对流的支持。我们将在下一节中更详细地介绍这些内容。
- en: renderToPipeableStream
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: renderToPipeableStream
- en: '`renderToPipeableStream` is a server-side rendering API introduced in React
    18\. It provides a more efficient and flexible way to render large React applications
    to a Node.js stream. It returns a stream that can be piped to a response object.
    `renderTo​Pi⁠peableStream` provides more control over how the HTML is rendered
    and allows for better integration with other Node.js streams.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`renderToPipeableStream`是在React 18中引入的一个服务器端渲染API。它提供了一种更高效和灵活的方式来将大型React应用程序渲染到Node.js流。它返回一个可以传输到响应对象的流。`renderToPipeableStream`提供了更多控制HTML如何渲染的方式，并允许更好地与其他Node.js流集成。'
- en: In addition, it fully supports React’s concurrent features, including Suspense,
    which unlocks better handling of asynchronous data fetching during server-side
    rendering. Because it is a stream, it is also streamable over the network, where
    chunks of HTML can be asynchronously and cumulatively sent to clients over the
    network without blocking. This leads to faster TTFB measures and generally better
    performance.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它完全支持 React 的并发特性，包括 Suspense，这在服务器端渲染期间解锁了更好的异步数据获取处理。由于它是一个流，因此可以通过网络进行流式传输，可以将
    HTML 块异步地累积地发送到客户端，而不会阻塞。这导致更快的 TTFB 以及通常更好的性能。
- en: 'To rewrite our earlier server using `renderToPipeableStream`, we’d do the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `renderToPipeableStream` 重写我们之前的服务器，我们将执行以下操作：
- en: '[PRE13]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Let’s dive deep into `renderToPipeableStream`, discussing its features, advantages,
    and use cases. We’ll also provide code snippets and examples to help you better
    understand how to implement this API in your React applications.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨 `renderToPipeableStream`，讨论其特性、优势和用例。我们还将提供代码片段和示例，帮助您更好地了解如何在 React
    应用程序中实现此 API。
- en: How it works
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何运作
- en: Similar to `renderToString`, `renderToPipeableStream` takes a declaratively
    described tree of React elements and, instead of turning them into a string of
    HTML, turns the tree into a Node.js stream. A Node.js stream is a fundamental
    concept in the Node.js runtime environment that enables efficient data processing
    and manipulation. Streams provide a way to handle data incrementally in chunks,
    rather than loading the entire data set into memory at once. This approach is
    particularly useful when dealing with large strings or data streams that cannot
    fit entirely in memory or over the network.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 `renderToString`，`renderToPipeableStream` 接受一个声明式描述的 React 元素树，并将其转换为 Node.js
    流，而不是将其转换为 HTML 字符串。Node.js 流是 Node.js 运行环境中的一个基本概念，它能够实现高效的数据处理和操作。流提供了一种处理数据的方式，逐块递增地处理数据，而不是一次性地将整个数据集加载到内存中。这种方法在处理无法完全加载到内存或网络上的大字符串或数据流时特别有用。
- en: Node.js streams
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Node.js 流
- en: At its core, a Node.js stream represents a flow of data between a source and
    a destination. It can be thought of as a pipeline through which data flows, with
    various operations applied to transform or process the data along the way.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，Node.js 流表示源和目标之间的数据流动。它可以被视为一个管道，通过这个管道数据流动，并且可以应用各种操作来转换或处理数据。
- en: 'Node.js streams are categorized into four types based on their nature and direction
    of data flow:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 流根据其数据流动的性质和方向分为四种类型：
- en: Readable streams
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 可读流
- en: A readable stream represents a source of data from which you can read. It emits
    events like `data`, `end`, and `error`. Examples of readable streams include reading
    data from a file, receiving data from an HTTP request, or generating data using
    a custom generator.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 可读流（readable stream）代表可以从中读取数据的数据源。它会发出诸如 `data`、`end` 和 `error` 等事件。可读流的示例包括从文件中读取数据、从
    HTTP 请求接收数据或使用自定义生成器生成数据。
- en: React’s `renderToPipeableStream` function returns a readable stream where you
    can read a stream of HTML and output it to a writable stream like the `res` response
    object from Express.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: React 的 `renderToPipeableStream` 函数返回一个可读流，你可以从中读取 HTML 流，并将其输出到 Express 的 `res`
    响应对象等可写流。
- en: Writable streams
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 可写流
- en: A writable stream represents a destination where you can write data. It provides
    methods like `write()` and `end()` to send data into the stream. Writable streams
    emit events like `drain` when the destination can handle more data, and `error`
    when an error occurs during writing. Examples of writable streams include the
    Express `res` response object.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 可写流（writable stream）代表可以写入数据的目标位置。它提供了诸如 `write()` 和 `end()` 等方法来向流中发送数据。可写流会发出事件，如在目标可以处理更多数据时的
    `drain` 事件，以及在写入过程中发生错误时的 `error` 事件。可写流的示例包括 Express 的 `res` 响应对象。
- en: Duplex streams
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 双工流
- en: A duplex stream represents both a readable and writable stream simultaneously.
    It allows bidirectional data flow, meaning you can both read from and write to
    the stream. Duplex streams are commonly used for network sockets or communication
    channels where data needs to flow in both directions.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 双工流（duplex stream）同时代表可读和可写的流。它允许双向数据流动，意味着你既可以从流中读取数据，也可以向流中写入数据。双工流通常用于网络套接字或需要双向数据流动的通信通道。
- en: Transform streams
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 转换流
- en: A transform stream is a special type of duplex stream that performs data transformations
    while data flows through it. It reads input data, processes it, and provides the
    processed data as output. Transform streams can be used to perform tasks such
    as compression, encryption, decompression, or data parsing.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 转换流是一种特殊的双工流，它在数据流经过时执行数据转换。它读取输入数据，处理它，并将处理后的数据作为输出提供。转换流可用于执行诸如压缩、加密、解压缩或数据解析等任务。
- en: One of the powerful features of Node.js streams is the ability to pipe data
    between streams. Piping allows you to connect the output of a readable stream
    directly to the input of a writable stream, creating a seamless flow of data.
    This greatly simplifies the process of handling data and reduces memory usage.
    Indeed, this is how streaming server-side rendering in React works.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 流的一个强大特性是能够在流之间传输数据。管道操作允许直接连接可读流的输出到可写流的输入，从而创建数据的无缝流动。这极大地简化了数据处理过程并减少了内存使用。确实，这就是
    React 中流式服务器端渲染的工作原理。
- en: Streams in Node.js also support backpressure handling. Backpressure is a problem
    that occurs during data handling and describes a buildup of data behind a buffer
    during data transfer. When the writable stream is unable to handle data quickly
    enough, the readable stream will pause emitting `data` events, preventing data
    loss. Once the writable stream is ready to consume more data, it emits a `drain`
    event, signaling the readable stream to resume emitting data.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 中的流还支持背压处理。背压是在数据处理过程中发生的问题，描述了在数据传输期间缓冲区后面的数据堆积。当可写流无法及时处理数据时，可读流会暂停发出
    `data` 事件，防止数据丢失。一旦可写流准备好消费更多数据，它会发出 `drain` 事件，提示可读流继续发出数据。
- en: Without diving too deep and digressing too much here, Node.js streams are a
    powerful abstraction for handling data in a scalable and memory-efficient manner.
    By breaking data into manageable chunks and allowing incremental processing, streams
    enable efficient handling of large data sets, file I/O operations, network communication,
    and much more.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里不深入探讨和偏离主题，Node.js 流是一种处理数据的强大抽象，能够以可扩展且高效的方式处理数据。通过将数据分解为可管理的块并允许增量处理，流使得大数据集、文件
    I/O 操作、网络通信等的处理更加高效。
- en: React’s renderToPipeableStream
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: React 的 `renderToPipeableStream`
- en: In React, the purpose of streaming React components to a writable stream is
    to enhance the TTFB performance of server rendered applications. Instead of waiting
    for the entire HTML markup to be generated before sending it to the client, these
    methods enable the server to start sending chunks of the HTML response as they
    are ready, thus reducing the overall latency.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 中，将 React 组件流式传输到可写流的目的是提升服务器渲染应用程序的 TTFB 性能。而不是等待整个 HTML 标记生成完毕后再发送到客户端，这些方法允许服务器在准备就绪时开始发送
    HTML 响应的分块，从而降低总体延迟。
- en: The `renderToPipeableStream` function is a part of React’s server renderer,
    which is designed to support streaming rendering of a React application to a Node.js
    stream. It’s a part of the server renderer architecture called “Fizz.”
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`renderToPipeableStream` 函数是 React 服务器渲染器的一部分，旨在支持将 React 应用程序流式渲染到 Node.js
    流。它是称为 "Fizz" 的服务器渲染器架构的一部分。'
- en: Note
  id: totrans-161
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: We’re about to dive super deep into React implementation details that are prone
    to change over time. Once again, this is for educational purposes and to satisfy
    the curiosity of the reader. It may not perfectly match the implementation details
    of React at the time of reading, but it’s close enough to get a good idea of how
    this works at the time of writing. This stuff is probably not something you’d
    use in production and is nonessential to knowing how to use React, but is just
    for education and curiosity.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将深入探讨 React 实现细节，这些细节可能随时间变化而变化。再次强调，此内容仅供教育和满足读者好奇心使用。它可能并不完全匹配阅读时的 React
    实现细节，但足以了解写作时的运行方式。这些内容可能不适合在生产中使用，而且并非掌握 React 使用技巧所必需，仅供教育和好奇心之用。
- en: 'Without distracting from our context of server rendering too much, here’s a
    simplified explanation of the flow of how server rendering works:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 不要让我们从服务器渲染的上下文分散太多注意力，这里是服务器渲染工作流的简化解释：
- en: Creating a request
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 创建请求
- en: The function `renderToPipeableStream` takes as input the React elements to be
    rendered and an optional options object. It then creates a request object using
    a `createRequestImpl` function. This request object encapsulates the React elements,
    resources, response state, and format context.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `renderToPipeableStream` 接受要渲染的 React 元素和一个可选的选项对象作为输入。然后使用 `createRequestImpl`
    函数创建一个请求对象。此请求对象封装了 React 元素、资源、响应状态和格式上下文。
- en: Starting the work
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 开始工作
- en: After creating the request, the `startWork` function is called with the request
    as an argument. This function initiates the rendering process. The rendering process
    is asynchronous and can be paused and resumed as needed, which is where React
    Suspense comes in. If a component is wrapped in a Suspense boundary and it initiates
    some asynchronous operation (like data fetching), the rendering of that component
    (and possibly its siblings) can be “suspended” until the operation finishes.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 创建请求后，使用请求作为参数调用 `startWork` 函数。此函数启动渲染过程。渲染过程是异步的，并且可以根据需要暂停和恢复，这就是 React Suspense
    的作用所在。如果组件被包裹在 Suspense 边界中，并且它启动了一些异步操作（如数据获取），则该组件（及可能的兄弟组件）的渲染可以被“挂起”，直到操作完成。
- en: While a component is suspended, it can be rendered in a “fallback” state, which
    is typically a loading indicator or a placeholder. Once the operation finishes,
    the component is “resumed” and rendered in its final state. Suspense is a powerful
    feature that enables React to handle asynchronous data fetching and lazy loading
    more effectively during server-side rendering.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件被挂起时，它可以以“fallback”状态呈现，通常是加载指示器或占位符。操作完成后，组件“恢复”并以其最终状态呈现。Suspense 是一个强大的功能，使
    React 能够在服务器端渲染期间更有效地处理异步数据获取和延迟加载。
- en: The benefits are that we are able to serve the user a meaningful page immediately,
    and then progressively enhance it with more data as it becomes available. This
    is a powerful technique that can be used to improve the user experience of React
    applications.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 优点在于我们能够立即向用户提供有意义的页面，并随着更多数据的可用性逐步增强它。这是一种强大的技术，可用于改善 React 应用程序的用户体验。
- en: Returning a pipeable stream
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 返回可管道流
- en: '`renderToPipeableStream` then returns an object that includes a `pipe` method
    and an `abort` method. The `pipe` method is used to pipe the rendered output to
    a writable stream (like an HTTP response object in Node.js). The `abort` method
    can be used to cancel any pending I/O and put anything remaining into client-rendered
    mode.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`renderToPipeableStream` 然后返回一个对象，其中包括一个 `pipe` 方法和一个 `abort` 方法。 `pipe` 方法用于将渲染输出导入可写流（例如
    Node.js 中的 HTTP 响应对象）。 `abort` 方法可用于取消任何待处理的 I/O 并将剩余内容放入客户端渲染模式。'
- en: Piping to a destination
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 导入到目标的流
- en: When the `pipe` method is called with a destination stream, it checks if the
    data has already started flowing. If not, it sets `hasStartedFlowing` to `true`
    and calls the `startFlowing` function with the request and the destination. It
    also sets up handlers for the `drain`, `error`, and `close` events of the destination
    stream.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `pipe` 方法与目标流一起调用时，它会检查数据是否已开始流动。如果没有，则设置 `hasStartedFlowing` 为 `true`，并使用请求和目标调用
    `startFlowing` 函数。还为目标流的 `drain`、`error` 和 `close` 事件设置处理程序。
- en: Handling stream events
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 处理流事件
- en: The `drain` event handler calls `startFlowing` again to resume the flow of data
    when the destination stream is ready to receive more data. The `error` and `close`
    event handlers call the `abort` function to stop the rendering process if an error
    occurs in the destination stream or if the stream is closed prematurely.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`drain` 事件处理程序在目标流准备好接收更多数据时再次调用 `startFlowing` 以恢复数据流。`error` 和 `close` 事件处理程序在目标流发生错误或流被提前关闭时调用
    `abort` 函数以停止渲染过程。'
- en: Aborting the rendering
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 中止渲染
- en: The `abort` method on the returned object can be called with a reason to stop
    the rendering process. It calls the `abort` function from the `react-server` module
    with the request and the reason.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的对象上的 `abort` 方法可用于以原因停止渲染过程。它使用来自 `react-server` 模块的请求和原因调用 `abort` 函数。
- en: The actual implementation of these functions involves more complex logic to
    handle things like progressive rendering, error handling, and integration with
    the rest of the React server renderer. The code for these functions can be found
    in the `react-server` and `react-dom` packages of the React source code.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的实际实现涉及处理更复杂的逻辑，例如渐进式渲染、错误处理以及与React服务器渲染器的其他部分集成。这些函数的代码可以在React源代码的`react-server`和`react-dom`包中找到。
- en: Features of renderToPipeableStream
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`renderToPipeableStream`的特性'
- en: '`renderToPipeableStream` features include:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`renderToPipeableStream`的功能包括：'
- en: Streaming
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 流式传输
- en: '`renderToPipeableStream` returns a pipeable Node.js stream, which can be piped
    to a response object. This allows the server to start sending the HTML to the
    client before the entire page is rendered, providing a faster user experience
    and better performance for large applications.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`renderToPipeableStream`返回一个可管道化的Node.js流，可以传送到响应对象。这允许服务器在整个页面渲染完成之前开始向客户端发送HTML，为大型应用程序提供更快的用户体验和更好的性能。'
- en: Flexibility
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 灵活性
- en: '`renderToPipeableStream` offers more control over how the HTML is rendered.
    It can be easily integrated with other Node.js streams, allowing developers to
    customize the rendering pipeline and create more efficient server-side rendering
    solutions.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`renderToPipeableStream`提供了更多控制HTML渲染方式的方法。它可以轻松与其他Node.js流集成，允许开发人员定制渲染流水线，并创建更高效的服务器端渲染解决方案。'
- en: Suspense support
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Suspense支持
- en: '`renderToPipeableStream` fully supports React’s concurrent features, including
    Suspense. This allows developers to manage asynchronous data fetching and lazy
    loading more effectively during server-side rendering, ensuring that data-dependent
    components are only rendered once the necessary data is available.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`renderToPipeableStream`完全支持React的并发特性，包括Suspense。这允许开发人员在服务器端渲染期间更有效地管理异步数据获取和延迟加载，确保只有在必要数据可用时才渲染依赖于数据的组件。'
- en: How it fits
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何适配
- en: 'Let’s take a look at some code that illustrates the benefits of this API. We
    have an application that displays a list of dog breeds. The list is populated
    by fetching data from an API endpoint. The application is rendered on the server
    using `renderTo​Pi⁠peableStream` and then sent to the client. Let’s start by looking
    at our dog list component:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些代码，展示这个API的好处。我们有一个显示狗品种列表的应用程序。该列表通过从API端点获取数据来填充。应用程序在服务器上使用`renderTo​Pi⁠peableStream`进行渲染，然后发送到客户端。让我们先看看我们的狗列表组件：
- en: '[PRE14]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, let’s look at our overall `App` that contains the `DogBreeds` component:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看包含`DogBreeds`组件的整体`App`：
- en: '[PRE15]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Notice, we’re using `React.lazy` here as mentioned in prior chapters, just
    so we have another Suspense boundary to demonstrate how `renderToPipeableStream`
    handles Suspense. OK, let’s tie this all together with an Express server:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这里我们使用了`React.lazy`，正如前几章提到的，这是为了展示`renderToPipeableStream`如何处理Suspense。好的，让我们通过一个Express服务器将所有这些联系起来：
- en: '[PRE16]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: What we’re doing in this code snippet is responding to a request with a stream
    of HTML. We’re using `renderToPipeableStream` to render our `App` component to
    a stream, and then piping that stream to our response object. We’re also using
    the `onShellReady` option to pipe the stream to the response object once the shell
    is ready. The shell is the HTML that is rendered before the React application
    is hydrated, and before data dependencies wrapped in Suspense boundaries are resolved.
    In our case, the shell is the HTML that is rendered before the dog breeds are
    fetched from the API. Let’s take a look at what happens when we run this code.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中，我们正在使用流式HTML响应请求。我们使用`renderToPipeableStream`将我们的`App`组件渲染为一个流，然后将该流导入响应对象。我们还使用`onShellReady`选项，在壳准备就绪后将流导入响应对象。壳是在React应用程序被水合之前以及在解析包含Suspense边界的数据依赖之前渲染的HTML。在我们的情况下，壳是在从API获取狗品种之前渲染的HTML。让我们看看运行此代码时会发生什么。
- en: If we visit *[*http://localhost:3000*](http://localhost:3000)*, we get a page
    with a heading “Dog Breeds,” and our Suspense fallback “Loading Dog Breeds….”
    This is the shell that is rendered before the dog breeds are fetched from the
    API. The really cool thing is that even if we don’t include React on the client
    side in our HTML and hydrate the page, the Suspense fallback is replaced with
    the actual dog breeds once they are fetched from the API. This swapping of DOM
    when data becomes available happens entirely from the server side, without client-side
    React!
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们访问[*http://localhost:3000*](http://localhost:3000)，我们会得到一个带有标题“狗品种”的页面，以及我们的悬挂状态“加载狗品种….”。这是在从
    API 获取狗品种之前呈现的外壳。非常酷的是，即使我们在 HTML 中不包含客户端 React 并且给页面加水，一旦从 API 获取到狗品种，悬挂状态就会被实际的狗品种替换掉。这种在数据可用时从服务器端完全交换
    DOM 的操作，而无需客户端 React 参与！
- en: Let’s understand how this works in a bit more detail.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地了解这是如何工作的。
- en: Note
  id: totrans-197
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Once again, we are about to dive deep into React implementation details here
    that are quite likely to change over time. The point of this exercise (and this
    book) is not to obsess over single implementation details, but instead to understand
    the underlying mechanism so we can learn and reason about React better. This isn’t
    required to *use* React, but understanding the mechanism can give us hints and
    practical tools to use in our day-to-day working with React. With that, let’s
    move forward.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将深入探讨这里的 React 实现细节，这些内容很可能随时间而改变。这个练习（和这本书）的重点不是着迷于单个实现细节，而是理解底层机制，这样我们可以更好地学习和推理关于
    React 的内容。这不是 *使用* React 的必要条件，但理解这种机制可以给我们提供提示和实用工具，以便我们在日常工作中更好地使用 React。有了这个，让我们继续前进。
- en: 'When we visit *[*http://localhost:3000*](http://localhost:3000)*, the server
    responds with the HTML shell, which includes the heading “Dog Breeds” and the
    Suspense fallback “Loading Dog Breeds….” This HTML looks like this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们访问[*http://localhost:3000*](http://localhost:3000)时，服务器会响应带有 HTML 外壳的内容，其中包括标题“狗品种”和悬挂状态的“加载狗品种….”。这个
    HTML 看起来像这样：
- en: '[PRE17]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: What we see here is quite interesting. There’s a `<template>` element with a
    generated ID (`B:0` in this case), and some HTML comments. The HTML comments are
    used to mark the start and end of the shell. These are markers or “holes” where
    resolved data will go once Suspense is resolved. `<template>` elements in HTML
    provide a way to construct document subtrees and hold nodes without introducing
    an additional wrapping level of the DOM hierarchy. They serve as lightweight containers
    for managing groups of nodes, improving performance by reducing the amount of
    work done during DOM manipulation.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到的很有趣。有一个 `<template>` 元素带有一个生成的 ID（在本例中是 `B:0`），还有一些 HTML 注释。HTML 注释用于标记外壳的开始和结束。这些标记或“洞”在
    Suspense 解析后将被解决的数据填入。HTML 中的 `<template>` 元素提供了一种构建文档子树和保持节点的方式，而不引入 DOM 层次结构的额外包装级别。它们作为轻量级容器，用于管理节点组，通过减少
    DOM 操作期间的工作量来提高性能。
- en: 'There’s also a `<script>` element. This `<script>` tag contains a function
    called `$RC` that is used to replace the shell with the actual content. The `$RC`
    function takes two arguments: the ID of the `<template>` element that contains
    the marker, and the ID of the `<div>` element that contains the fallback. The
    function then fills the marker with rendered UI after data is available, while
    removing the fallback.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个 `<script>` 元素。这个 `<script>` 标签包含一个名为 `$RC` 的函数，用于用实际内容替换外壳。`$RC` 函数接受两个参数：包含标记的
    `<template>` 元素的 ID 和包含悬挂状态的 `<div>` 元素的 ID。然后函数在数据可用后填充标记的渲染 UI，同时移除悬挂状态。
- en: 'It’s pretty unfortunate that this function is minified, but let’s try to unminify
    it and understand what it does. If we do, this is what we observe:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这个函数是被压缩过的，但让我们试着解压它并理解它的作用。如果我们这样做，我们会观察到：
- en: '[PRE18]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Let’s break this down further.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步分解。
- en: 'The function takes two arguments: `reactMarkerId` and `siblingId`. Effectively,
    the marker is a hole where rendered components will go once they’re available,
    and the sibling is the Suspense fallback.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 函数接受两个参数：`reactMarkerId` 和 `siblingId`。实际上，标记是一个洞，一旦渲染组件可用，渲染组件将放入其中，而兄弟节点则是悬挂状态。
- en: The function then removes the sibling element (the fallback) from the DOM using
    the `removeChild` method on its parent node when data is available.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然后函数使用 `removeChild` 方法从其父节点上移除了兄弟元素（即悬挂状态），当数据可用时。
- en: If the `reactMarker` element exists, the function runs. It sets the `reactMarker`
    variable to the previous sibling of the current `reactMarker` element. The function
    also initializes the variables `parentNode`, `nextSibling`, and `nestedLevel`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`reactMarker`元素存在，则运行该函数。它将`reactMarker`变量设置为当前`reactMarker`元素的前一个兄弟元素。函数还初始化了`parentNode`、`nextSibling`和`nestedLevel`这些变量。
- en: 'A `do...while` loop is used to traverse the DOM tree, starting with the `nextSibling`
    element. The loop continues as long as the `nextSibling` element exists. Inside
    the loop, the function checks whether the `nextSibling` element is a comment node
    (indicated by a `nodeType` value of `8`):'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`do...while`循环来遍历DOM树，从`nextSibling`元素开始。只要`nextSibling`元素存在，循环就会继续。在循环内部，函数检查`nextSibling`元素是否为注释节点（通过`nodeType`值为`8`来表示）：
- en: If the `nextSibling` element is a comment node, the function inspects its data
    (i.e., the text content of the comment). It checks whether the data is equal to
    `"/$"`, which signifies the end of a nested structure. If the `nestedLevel` value
    is `0`, the loop breaks, indicating that the desired end of the structure has
    been reached. If the `nestedLevel` value is not `0`, it means that the current
    `"/$"` comment node is part of a nested structure, and the `nestedLevel` value
    is decremented.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`nextSibling`元素是一个注释节点，函数会检查其数据（即注释的文本内容）。它检查数据是否等于`"/$"`, 这表示嵌套结构的结束。如果`nestedLevel`值为`0`，则循环中断，表示已达到所需的结构结束。如果`nestedLevel`值不为`0`，则意味着当前的`"/$"`注释节点是嵌套结构的一部分，并且`nestedLevel`值递减。
- en: If the comment node data is not equal to `"/$"`, the function checks whether
    it is equal to `"$"`, `"$?"`, or `"$!"`. These values indicate the beginning of
    a new nested structure. If any of these values are encountered, the `nestedLevel`
    value is incremented.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果评论节点的数据不等于`"/$"`, 函数将检查它是否等于`"$"`, `"$?"`或`"$!"`。这些值表示新的嵌套结构的开始。如果遇到任何这些值，`nestedLevel`值将被递增。
- en: During each iteration of the loop, the `nextSibling` element (that is, the Suspense
    boundary) is removed from the DOM using the `removeChild` method on its parent
    node. The loop continues with the next sibling element in the DOM tree.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环的每次迭代中，使用父节点上的`removeChild`方法从DOM中移除`nextSibling`元素（即Suspense边界）。循环继续处理DOM树中的下一个兄弟元素。
- en: Once the loop has completed, the function moves all child elements of the sibling
    element to the location immediately before the `nextSibling` element in the DOM
    tree using the `insertBefore` method. This process effectively restructures the
    DOM around the `reactMarker` element and replaces a Suspense fallback with the
    component it wraps.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦循环完成，函数使用`insertBefore`方法将兄弟元素的所有子元素移动到DOM树中`nextSibling`元素的位置之前。这个过程有效地重组了围绕`reactMarker`元素的DOM，并用它包裹的组件替换了Suspense回退。
- en: The function then sets the data of the `reactMarker` element to `"$"`, which
    is likely used to mark the component for future processing or reference. If a
    `reactRetry` property exists on the `reactMarker` element and it is a function,
    the function invokes this method.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，函数将`reactMarker`元素的数据设置为`"$"`，这可能用于标记将来处理或引用的组件。如果`reactMarker`元素上存在`reactRetry`属性且它是一个函数，则调用该方法。
- en: 'If some of this was difficult to follow, don’t worry about it. We can summarize
    all of this here: essentially, this function waits for data-dependent React components
    to be ready, and when they are, swaps out Suspense fallbacks for the server rendered
    components. It uses comment nodes with specific data values to determine the structure
    of the components, and manipulates the DOM accordingly. Since this is inlined
    in our HTML from the server, we can stream data like this using `renderToPipeableStream`
    and have the browser render the UI as it becomes available without even including
    React in the browser bundle or hydrating.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有些内容难以理解，不用担心。我们可以在这里总结一切：本质上，该函数等待数据依赖的React组件准备就绪，然后用服务器渲染的组件替换掉Suspense回退。它使用具有特定数据值的注释节点来确定组件的结构，并相应地操作DOM。由于这是内联在我们的HTML中从服务器端传输的，我们可以使用`renderToPipeableStream`这样的方式流式传输数据，并使浏览器在可用时渲染UI，甚至不包括React在浏览器捆绑包中或进行水合处理。
- en: Thus, `renderToPipeableStream` gives us quite a bit more control and power compared
    to `renderToString` when server rendering.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，与`renderToString`相比，`renderToPipeableStream`在服务器渲染时给了我们更多的控制和能力。
- en: renderToReadableStream
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: renderToReadableStream
- en: The previous API we covered, `renderToPipeableStream`, makes use of Node.js
    streams under the hood. However, browsers also have support for streams and browser
    streams slightly differ from Node.js streams. Node.js streams are primarily designed
    to operate in a server-side environment, where they deal with file I/O, network
    I/O, or any kind of end-to-end streaming. They follow a custom API defined by
    the Node.js environment and have been a core part of Node.js for a long time.
    Node.js streams have distinct classes for readable, writable, duplex, and transform
    streams, and utilize events like `data`, `end`, and `error` to manage stream flow
    and handle data.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前介绍的 `renderToPipeableStream` API 在底层使用了 Node.js 流。然而，浏览器也支持流，并且浏览器流与 Node.js
    流略有不同。Node.js 流主要设计用于在服务器端环境中运行，在这些环境中处理文件 I/O、网络 I/O 或任何端到端流式处理。它们遵循 Node.js
    环境定义的自定义 API，并且长期以来一直是 Node.js 的核心组成部分。Node.js 流具有可读、可写、双工和转换流的不同类，并利用 `data`、`end`
    和 `error` 等事件来管理流程和处理数据。
- en: 'Browser streams are designed to operate in a client-side environment within
    web browsers. They often deal with streaming data from network requests, media
    streaming, or other data-processing tasks in the browser. Browser streams follow
    the Streams standard defined by the WHATWG (Web Hypertext Application Technology
    Working Group), aiming to standardize APIs across the web. Unlike Node.js streams,
    browser streams use methods like `read()`, `write()`, and `pipeThrough()` to control
    the flow of data and then process that streamed data. They provide a more standardized
    and promise-based API. Here is an example of a readable stream in a browser environment:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器流设计用于在 Web 浏览器中的客户端环境中运行。它们通常处理来自网络请求、媒体流或浏览器中的其他数据处理任务的流数据。浏览器流遵循由 WHATWG（Web
    Hypertext Application Technology Working Group）定义的流标准，旨在标准化 Web 上的 API。与 Node.js
    流不同，浏览器流使用诸如 `read()`、`write()` 和 `pipeThrough()` 等方法来控制数据流的流动并处理流数据。它们提供了更标准化和基于
    Promise 的 API。以下是浏览器环境中可读流的示例：
- en: '[PRE19]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: While both Node.js streams and browser streams serve the purpose of handling
    streaming data, they operate in different environments with slightly different
    APIs and standards. Node.js streams are event driven and are well suited for server-side
    operations, whereas browser streams are promise based, aligning with modern web
    standards, and are tailored for client-side operations.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Node.js 流和浏览器流都用于处理流数据，但它们在不同的环境中运行，具有略有不同的 API 和标准。Node.js 流是事件驱动的，非常适合服务器端操作，而浏览器流基于
    Promise，符合现代 Web 标准，专为客户端操作定制。
- en: To support both environments, React has `renderToPipeableStream` for Node.js
    streams, and `renderToReadableStream` for browser streams. The `renderToReadableStream`
    API is similar to `renderToPipeableStream`, but it returns a readable stream for
    the browser instead of a Node.js-native stream.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这两个环境，React 提供了 `renderToPipeableStream` 用于 Node.js 流，以及 `renderToReadableStream`
    用于浏览器流。`renderToReadableStream` API 类似于 `renderToPipeableStream`，但它返回的是适合浏览器的可读流，而不是
    Node.js 本地流。
- en: When to Use What
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用什么
- en: '`renderToString` isn’t ideal because it is synchronous. This is quite problematic
    for a number of reasons:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`renderToString` 不是理想的选择，因为它是同步的。这在许多方面都是问题：'
- en: Network I/O is asynchronous.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 网络 I/O 是异步的。
- en: 'Any data fetching we do depends on retrieving data from somewhere: a database,
    a web service, the filesystem, etc. These operations are often asynchronous: meaning
    that they start and end at discrete points in time, not at the same time. Because
    `renderToString` is synchronous, it cannot wait for asynchronous requests to complete
    and *must* send a string instantly to the browser. This means that the server
    cannot complete things, the client gets a shell before any data has loaded, and
    the client ideally picks up where the server left off after hydration. This presents
    performance problems by way of network waterfalls.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的任何数据获取取决于从某处检索数据：数据库、Web 服务、文件系统等。这些操作通常是异步的：意味着它们在离散的时间点开始和结束，而不是同时进行。由于
    `renderToString` 是同步的，它无法等待异步请求完成，*必须*立即将字符串发送到浏览器。这意味着服务器无法完成事情，客户端在加载任何数据之前就收到一个空壳，而客户端理想情况下在水合之后继续执行服务器留下的工作。这导致通过网络瀑布出现性能问题。
- en: Servers serve multiple clients.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器为多个客户端提供服务。
- en: If your server that calls `renderToString` is busy rendering to a string and
    30 clients have sent new requests to it, those new clients will have to wait for
    it to finish its current work. Because `renderToString` is synchronous, it blocks
    until it’s done. In the one-to-many relationship between servers and clients,
    blocking means your clients wait longer than they should.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的服务器正在忙于将`renderToString`渲染为字符串，并且有30个客户端发送了新请求到服务器，那些新的客户端将不得不等待服务器完成当前的工作。因为`renderToString`是同步的，它会一直阻塞直到完成。在服务器和客户端之间的一对多关系中，阻塞意味着你的客户端等待的时间比他们本应该等待的时间长。
- en: Newer alternatives like `renderToPipeableStream` and `renderToReadableStream`
    are asynchronous stream-based approaches that solve for both of these problems,
    with `renderToReadableStream` being browser native and `renderToPipeableStream`
    being server native. Thus, if the question is “what’s the best API to use on the
    server?” the answer is clearly either `renderToPipeableStream` or `renderToReadableStream`,
    depending on the environment.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 新的选择，如`renderToPipeableStream`和`renderToReadableStream`，是解决这些问题的异步基于流的方法，其中`renderToReadableStream`是浏览器本地的，而`renderToPipeableStream`是服务器本地的。因此，如果问题是“在服务器上使用什么API最好？”，答案显然是`renderToPipeableStream`或`renderToReadableStream`，具体取决于环境。
- en: That said, while `renderTo*Stream` appears to be a superior set of APIs, there
    is currently no “full user story” around these APIs at the time of writing. Many
    third-party libraries that are currently around will not work with them, especially
    considering data fetching or CSS libraries. This is because they conceptually
    need a “full run” on the server, then need to create data, and then rerender the
    application with that data to actually stream from the server. They don’t support
    scenarios where an app hasn’t finished rendering on the server yet, but needs
    to start partially hydrating in the browser.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，虽然`renderTo*Stream`似乎是一组更优秀的API，但在写作时，这些API仍然没有完整的用户故事。目前许多第三方库无法与它们一起使用，特别是考虑到数据获取或CSS库的情况。这是因为它们概念上需要在服务器上进行“完整运行”，然后需要创建数据，并使用该数据重新渲染应用程序以实际从服务器流式传输。它们不支持应用程序在服务器上尚未完成渲染但需要开始部分水化到浏览器的情况。
- en: 'This is a React problem: there are no APIs in React 18 (the latest release
    at the time of writing) that would allow for support of any kind of streaming
    or partial rehydration of third-party data. The React team has recently added
    a bunch of new APIs to `react-dom`, like `prefetchDNS`, `preconnect`, `preload`,
    etc., to address that, but those will only ship with React 19\. Even with these
    APIs, there are still a few important APIs missing to make `renderToPipeableStream`
    a viable option.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个React的问题：在写作时的最新版本React 18中，没有任何API支持任何类型的流式传输或第三方数据的部分重新注水。React团队最近在`react-dom`中添加了一堆新的API，比如`prefetchDNS`，`preconnect`，`preload`等等，以解决这个问题，但这些功能将只在React
    19中发布。即使有了这些API，仍然缺少一些重要的API来使`renderToPipeableStream`成为可行的选择。
- en: The only really viable option to use `renderToPipeableStream` right now would
    be to prefetch all required data (or in the case of a CSS library, render the
    full application with `renderToString` to “prerecord” all classes that need rendering)
    before calling `renderToPipeableStream` in the first place—which would pretty
    much eliminate most of its benefits over `renderToString`, essentially making
    it a synchronous API again.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 目前唯一真正可行的选择是在调用`renderToPipeableStream`之前预取所有必需的数据（或在CSS库的情况下，使用`renderToString`渲染整个应用程序以“预记录”所有需要渲染的类），这样做基本上会消除`renderToString`的大部分优势，从而再次使其成为同步API。
- en: All things considered, these are complex topics that require a good amount of
    forethought, careful planning, and further consideration around which APIs to
    use that equally depend on your current projects and use cases. Thus, the answer
    is once again “it depends,” or “just use a framework” and defer the decision to
    the broader community.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这些都是复杂的主题，需要充分考虑，仔细规划，并进一步考虑使用哪些API，这些选择同样取决于你当前的项目和使用场景。因此，答案再次是“这要看情况”，或者“只需使用一个框架”，并将决策推迟到更广泛的社区中。
- en: Don’t Roll Your Own
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要自己造轮子
- en: 'Creating a custom server rendering implementation for a React application can
    be a challenging and time-consuming task. While React does provide some APIs for
    server rendering, building a custom solution from scratch can lead to various
    issues and inefficiencies. In this section, we’ll explore the reasons why it’s
    better to rely on established frameworks like Next.js and Remix, rather than building
    your own server rendering solution:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为React应用程序创建自定义服务器渲染实现可能是一项具有挑战性且耗时的任务。虽然React提供了一些用于服务器渲染的API，但从头开始构建自定义解决方案可能会导致各种问题和低效率。在本节中，我们将探讨依赖于像Next.js和Remix这样的成熟框架而不是构建自己的服务器渲染解决方案的原因：
- en: Handling edge cases and complexities
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 处理边缘情况和复杂性
- en: React applications can become quite complex, and implementing server rendering
    requires addressing various edge cases and complexities. These can include handling
    asynchronous data fetching, code splitting, and managing various React lifecycle
    events. By using a framework like Next.js or Remix, you can avoid the need to
    handle these complexities yourself, as these frameworks have built-in solutions
    for many common edge cases.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: React应用程序可能变得非常复杂，实施服务器渲染需要解决各种边缘情况和复杂性。这些问题包括处理异步数据获取、代码分割以及管理各种React生命周期事件。通过使用像Next.js或Remix这样的框架，您可以避免自己处理这些复杂性的需要，因为这些框架已经为许多常见的边缘情况内置了解决方案。
- en: One such edge case is security. As the server processes numerous client requests,
    it’s crucial to ensure that sensitive data from one client doesn’t inadvertently
    leak to another. This is where frameworks like Next.js, Remix, and Gatsby can
    provide invaluable assistance in handling these concerns. Imagine a scenario where
    client A accesses the server, and their data is cached by the server. If the server
    accidentally serves this cached data to client B, sensitive information could
    be exposed.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一种边缘情况是安全性。由于服务器处理大量客户端请求，确保不会意外地将一个客户端的敏感数据泄露给另一个客户端至关重要。这就是像Next.js、Remix和Gatsby这样的框架在处理这些问题方面提供宝贵帮助的地方。想象一种情况，客户端A访问服务器并且他们的数据被服务器缓存。如果服务器意外地将此缓存数据提供给客户端B，可能会暴露敏感信息。
- en: 'Consider the following example:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE20]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the given code, `cachedUserData` is intended to cache the user data, but
    it’s shared across all requests regardless of the `userId`. Every time a request
    is made to `/user/:userId`, the server checks `cachedUserData` to see if there’s
    cached data. If there is, it returns the cached data regardless of whether the
    `userId` matches the `userId` of the cached data. If there isn’t, it fetches the
    data, caches it, and returns it. This means that if two requests are made in sequence
    to `/user/1` and `/user/2`, the second request would receive the data of the first
    user, which is a significant security issue.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定的代码中，`cachedUserData`旨在缓存用户数据，但不管`userId`是否匹配，它都在所有请求中共享。每当对`/user/:userId`进行请求时，服务器检查`cachedUserData`是否有缓存数据。如果有，则返回缓存数据，而不管缓存数据的`userId`是否与请求的`userId`匹配。如果没有，则获取数据、缓存数据并返回。这意味着如果连续进行两个请求到`/user/1`和`/user/2`，第二个请求将收到第一个用户的数据，这是一个重大的安全问题。
- en: A more secure caching strategy would be to cache the data in a way that’s associated
    with the `userId` so that each user has their own cache. One way to do this would
    be to use an object to hold the cached data, with the `userId` as the key.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 更安全的缓存策略是将数据缓存在与`userId`相关联的方式中，以便每个用户都有自己的缓存。一种方法是使用对象来保存缓存数据，以`userId`作为键。
- en: If we roll our own, the risk of human error is ever present. If we lean on frameworks
    built by large communities, this risk is mitigated. These frameworks are designed
    with security in mind and ensure that sensitive data is handled properly. They
    prevent potential data leakage scenarios by using secure and isolated data-fetching
    methods.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们自己动手，人为错误的风险始终存在。如果依赖于大型社区构建的框架，可以减轻这种风险。这些框架是以安全性为设计核心，并确保敏感数据得到正确处理。它们通过使用安全和隔离的数据获取方法，防止潜在的数据泄露场景。
- en: Performance optimizations
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 性能优化
- en: Frameworks come with numerous performance optimizations out of the box. These
    optimizations can include automatic code splitting, server rendering, and caching.
    Building a custom server rendering solution might not include these optimizations
    by default, and implementing them can be a challenging and time-consuming task.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 框架自带了许多性能优化功能。这些优化包括自动代码分割、服务器渲染和缓存。构建自定义服务器渲染解决方案可能默认不包括这些优化，并且实施它们可能是一个具有挑战性且耗时的任务。
- en: One such optimization Next.js makes, for example, is route-based code splitting
    for the pages router that was the default for Next.js 13 and earlier. Each page
    in this case is automatically code split into its own bundle, which is then loaded
    only when the page is requested. This can significantly improve performance by
    reducing the initial bundle size and improving the TTFB.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Next.js 进行的一种优化是基于路由的页面代码拆分，这在 Next.js 13 及更早版本中是默认的。在这种情况下，每个页面自动被拆分为自己的包，仅在请求页面时加载。这可以通过减少初始包大小和改善
    TTFB 显著提升性能。
- en: Developer experience and productivity
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者体验和生产力
- en: Building a custom server rendering implementation can be a complex and time-consuming
    endeavor. By using a framework like Next.js or Remix, developers can focus on
    building features and functionality for their application instead of worrying
    about the underlying server rendering infrastructure. This can lead to increased
    productivity and a better overall developer experience.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 构建自定义的服务器渲染实现可能是一个复杂且耗时的工作。通过使用像 Next.js 或 Remix 这样的框架，开发者可以专注于为其应用程序构建功能和功能，而不必担心底层的服务器渲染基础设施。这可以提高生产力和整体开发者体验。
- en: Best practices and conventions
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践和约定
- en: 'Using a framework like Next.js or Remix can help enforce best practices and
    conventions in your project. These frameworks have been designed with best practices
    in mind, and by following their conventions, you can ensure that your application
    is built on a solid foundation:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Next.js 或 Remix 这样的框架可以帮助确保项目中遵循最佳实践和约定。这些框架已经考虑到了最佳实践，并通过遵循它们的约定，您可以确保应用程序建立在坚实的基础之上：
- en: '[PRE21]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Considering the benefits and optimizations provided by established frameworks
    like Next.js and Remix, it becomes evident that building a custom server rendering
    solution for a React application is not an ideal approach. By leveraging these
    frameworks, you can save development time, ensure that best practices are followed,
    and benefit from the ongoing improvements and support provided by their respective
    communities.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到像 Next.js 和 Remix 这样的成熟框架提供的好处和优化，可以明显看出，为 React 应用构建自定义服务器渲染解决方案并不是一个理想的方法。通过利用这些框架，您可以节省开发时间，确保遵循最佳实践，并从各自社区提供的持续改进和支持中受益。
- en: Chapter Review
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节复习
- en: In conclusion, server-side rendering and hydration are powerful techniques that
    can significantly improve the performance, user experience, and SEO of web applications.
    React provides a rich set of APIs for server rendering, such as `renderToString`
    and `renderToPipeableStream`, each with its own strengths and trade-offs. By understanding
    these APIs and selecting the right one based on factors such as application size,
    server environment, and developer experience, you can optimize your React application
    for both server- and client-side performance.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，服务器端渲染和水合是强大的技术，可以显著改善 Web 应用的性能、用户体验和 SEO。React 提供了一系列丰富的服务器渲染 API，例如
    `renderToString` 和 `renderToPipeableStream`，每个都有其独特的优势和折衷方案。通过理解这些 API，并根据应用大小、服务器环境和开发者经验等因素选择合适的
    API，您可以优化 React 应用的服务器端和客户端性能。
- en: As we’ve seen throughout this chapter, `renderToString` is a simple and straightforward
    API for server rendering that is suitable for smaller applications. However, it
    may not be the most efficient option for larger applications due to its synchronous
    nature and potential to block the event loop. On the other hand, `renderToPipeableStream`
    is a more advanced and flexible API that allows for better control over the rendering
    process and improved integration with other Node.js streams, making it a more
    suitable choice for larger applications.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章中所示，`renderToString` 是一个简单直接的服务器渲染 API，适用于较小的应用。然而，由于其同步性质和可能阻塞事件循环，对于较大的应用可能不是最高效的选择。另一方面，`renderToPipeableStream`
    是一个更高级和灵活的 API，允许更好地控制渲染过程，并与其他 Node.js 流集成，因此对于较大的应用更为合适。
- en: Review Questions
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复习问题
- en: Now that you’ve gained a solid understanding of server-side rendering and hydration
    in React, it’s time to test your knowledge with some review questions. If you
    can confidently answer these, it’s a good sign that you’ve got a solid understanding
    of mechanism in React and can comfortably move forward. If you cannot, we’d suggest
    reading through things a little more, although this will not hurt your experience
    as you continue through the book.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经对 React 中的服务器端渲染和水合有了坚实的理解，现在是时候用一些复习问题来测试您的知识了。如果您能自信地回答这些问题，这表明您对 React
    中的机制有了坚实的理解，并且可以轻松地继续前进。如果不能，我们建议您再仔细阅读一些内容，尽管这不会对您继续阅读本书时的体验造成损害。
- en: What is the main advantage of using server-side rendering in a React application?
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 React 应用程序中使用服务器端渲染的主要优势是什么？
- en: How does hydration work in React, and why is it important?
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React 中的水合是如何工作的，为什么它很重要？
- en: What is resumability? How does it claim to be superior to hydration?
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是可恢复性？它声称比水合更为优越的是如何实现的？
- en: What are the key benefits and weaknesses of client-only rendering?
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端仅渲染的关键优势和弱点是什么？
- en: What are the key differences between the `renderToReadableStream` and `renderToPipeableStream`
    APIs in React?
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React 中 `renderToReadableStream` 和 `renderToPipeableStream` API 之间的主要区别是什么？
- en: Up Next
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来
- en: Once you’ve mastered server-side rendering and hydration, you’re ready to explore
    even more advanced topics in React development. In the next chapter, we’ll dive
    into concurrent React. As web applications become more complex, handling asynchronous
    actions becomes increasingly important for creating smooth user experiences.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您掌握了服务器端渲染和水合，您就可以准备探索 React 开发中更多的高级主题了。在下一章中，我们将深入研究并发 React。随着 Web 应用程序变得越来越复杂，处理异步操作对于创建平滑用户体验变得越来越重要。
- en: By learning how to leverage concurrent React, you’ll be able to create highly
    performant, scalable, and user-friendly applications that can handle complex data
    interactions with ease. So, stay tuned and get ready to level up your React skills
    as we continue our journey into the world of concurrent React!
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 通过学习如何利用并发 React，您将能够创建高性能、可扩展且用户友好的应用程序，能够轻松处理复杂的数据交互。因此，请继续关注，准备好在我们继续探索并发
    React 的旅程中提升您的 React 技能！
