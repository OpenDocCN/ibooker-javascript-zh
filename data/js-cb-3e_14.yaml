- en: Chapter 12\. Working with HTML
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章。与HTML一起工作
- en: In 1995 Netscape tasked software developer Brendan Eich with creating a programming
    language designed to add interactivity to pages in the Netscape Navigator browser.
    In response, Eich infamously developed the first version of JavaScript in 10 days.
    A few years later, JavaScript became a cross-browser standard through the adoption
    of the ECMAScript standardization.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 1995年，网景公司委托软件开发者布兰登·艾奇创建一种旨在为网景导航器浏览器页面添加交互性的编程语言。作为回应，艾奇在10天内臭名昭著地开发了JavaScript的第一个版本。几年后，通过ECMAScript标准化的采纳，JavaScript成为了跨浏览器的标准。
- en: Despite the early attempt at standardization, web developers battled for years
    with browsers that had different JavaScript engine interpretations or features.
    Popular libraries, such as jQuery, effectively allowed us to write simple cross-browser
    JavaScript. Thankfully, today’s browsers share a near uniform implementation of
    the language, allowing web developers to write “vanilla” (library-free) JavaScript
    to interact with an HTML page.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管早期尝试进行了标准化，但多年来，Web开发人员与具有不同JavaScript引擎解释或功能的浏览器作斗争。流行的库，如jQuery，有效地允许我们编写简单的跨浏览器JavaScript。值得庆幸的是，今天的浏览器几乎共享了对该语言的统一实现，使Web开发人员能够编写与HTML页面交互的“纯净”（无库）JavaScript。
- en: When working with HTML, we are working with the Document Object Model (DOM),
    which is the data representation of the HTML page. The recipes in this chapter
    will review how to interact with the DOM of an HTML page by selecting, updating,
    and removing elements from the page.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理HTML时，我们正在处理文档对象模型（DOM），这是HTML页面的数据表示。本章中的示例将回顾如何通过选择、更新和删除页面中的元素与HTML页面的DOM进行交互。
- en: Accessing a Given Element and Finding Its Parent and Child Elements
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问给定元素并找到其父元素和子元素
- en: Problem
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to access a specific web page element, and then find its parent and
    child elements.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要访问特定的网页元素，然后找到其父元素和子元素。
- en: Solution
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Give the element a unique identifier:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 给元素一个唯一的标识符：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Use `document.getElementById()` to get a reference to the specific element:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`document.getElementById()`获取对特定元素的引用：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Find its parent via the `parentNode` property:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`parentNode`属性找到其父元素：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Find its children via the `childNodes` property:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`childNodes`属性找到其子元素：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Discussion
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: A web document is organized like an upside-down tree, with the topmost element
    at the root and all other elements branching out beneath. Except for the root
    element (HTML), each element has a parent `node`, and all of the elements are
    accessible via the `document`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 网页文档的组织结构类似于倒置的树，顶部元素位于根部，所有其他元素都在其下分支。除了根元素（HTML）外，每个元素都有一个父`节点`，所有元素都可以通过`document`访问。
- en: There are several different techniques available for accessing these document
    elements, or *nodes* as they’re called in the DOM. Today, we access these nodes
    through standardized versions of the DOM, such as DOM Levels 2 and 3\. Originally,
    though, a de facto technique was to access the elements through the browser object
    model, sometimes referred to as DOM Level 0\. DOM Level 0 was invented by the
    leading browser company of the time, Netscape, and its use has been supported
    (more or less) in most browsers since. The key object for accessing web page elements
    in the DOM Level 0 is the `document` object.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种不同的技术可用于访问这些文档元素，或者在DOM中称为*节点*。如今，我们通过DOM的标准化版本（如DOM Level 2和3）访问这些节点。不过，最初，一种事实上的技术是通过浏览器对象模型访问元素，有时称为DOM
    Level 0。DOM Level 0是由当时的主要浏览器公司网景发明的，并且自那时以来在大多数浏览器中得到了支持（或多或少）。在DOM Level 0中访问网页元素的关键对象是`document`对象。
- en: 'The most commonly used DOM method is `document.getElementById()`. It takes
    one parameter: a case-sensitive string with the element’s identifier. It returns
    an `element` object, which is referenced to the element if it exists; otherwise,
    it returns null.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的DOM方法是`document.getElementById()`。它接受一个参数：元素的标识符，区分大小写的字符串。如果元素存在，则返回一个引用到该元素的`element`对象；否则返回null。
- en: Note
  id: totrans-20
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: There are numerous ways to get one specific web page element, including the
    use of selectors, covered later in the chapter. But you’ll always want to use
    the most restrictive method possible, and you can’t get more restrictive than
    `document.getElementById()`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以获取一个特定的网页元素，包括后面章节中介绍的选择器的使用。但您始终希望使用可能性最小的方法，并且您无法比`document.getElementById()`更严格了。
- en: 'The returned `element` object has a set of methods and properties, including
    several inherited from the `node` object. The `node` methods are primarily associated
    with traversing the document tree. For instance, to find the parent node for the
    element, use the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的 `element` 对象具有一组方法和属性，包括从 `node` 对象继承的一些属性。`node` 方法主要与遍历文档树相关。例如，要查找元素的父节点，请使用以下代码：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can find out the type of element for each node through the `nodeName` property:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过 `nodeName` 属性了解每个节点的元素类型：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you want to find out what children an element has, you can traverse a collection
    of them via a `NodeList`, obtained using the `childNodes` property:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要了解一个元素具有哪些子节点，可以通过 `childNodes` 属性遍历它们的集合：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Given the element in the solution, the output would be:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 针对解决方案中的元素，输出将是：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You might be surprised by what appeared as a child node. In this example, whitespace
    before and after the paragraph element is itself a child node with a `nodeName`
    of `#text`. For the following `div` element:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会对出现的子节点感到惊讶。在这个例子中，段落元素前后的空白本身是一个具有 `nodeName` 为 `#text` 的子节点。对于以下的 `div`
    元素：
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'the `demodiv` element (node) has five children, not two:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`demodiv` 元素（节点）有五个子节点，而不是两个：'
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The best way to see how messy the DOM can be is to use a debugger such as the
    Firefox or Chrome developer tools, access a web page, and then utilize whatever
    DOM inspection tool the debugger provides. I opened a simple page in Chrome and
    used the developer tools to display the element tree, as shown in [Figure 12-1](#chrome_display_page).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到 DOM 可以有多混乱，最好的方法是使用诸如 Firefox 或 Chrome 开发者工具之类的调试器，访问网页，然后利用调试器提供的任何 DOM
    检查工具来显示元素树。我在 Chrome 中打开了一个简单的页面，并使用开发者工具显示了元素树，如 [图 12-1](#chrome_display_page)
    所示。
- en: '![jsc3 1201](assets/jsc3_1201.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![jsc3 1201](assets/jsc3_1201.png)'
- en: Figure 12-1\. Examining the element tree of a web page using Chrome’s Developer
    Tools
  id: totrans-36
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-1\. 使用 Chrome 开发者工具检查网页的元素树
- en: Traversing the Results from querySelectorAll() with forEach()
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `forEach()` 遍历 `querySelectorAll()` 的结果
- en: Problem
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to loop over the `nodeList` returned from a call to `querySelectorAll()`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望遍历从调用 `querySelectorAll()` 返回的 `nodeList`。
- en: Solution
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'In modern browsers, you can use `forEach()` when working with a `NodeList`
    (the collection returned by `querySelectorAll()`):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代浏览器中，使用 `forEach()` 处理 `NodeList`（由 `querySelectorAll()` 返回的集合）是可行的：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Discussion
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: '`forEach()` is an array method, but `querySelectorAll()` produces a `NodeList`
    which is a different type of object than an array. Thankfully, modern browsers
    have built-in support for `forEach`, allowing us to iterate over a `NodeList`
    as though it is an array.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`forEach()` 是一个数组方法，但 `querySelectorAll()` 返回的是一个 `NodeList`，它是一种与数组不同的对象类型。幸运的是，现代浏览器内置支持
    `forEach`，允许我们像处理数组一样迭代 `NodeList`。'
- en: 'Unfortunately, Internet Explorer (IE) does not support using `forEach` in this
    way. If you’d like to support IE, the recommended approach is to include a polyfill
    that uses a standard `for` loop under the hood:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Internet Explorer（IE）不支持以这种方式使用 `forEach`。如果您想要支持 IE，推荐的方法是包含一个使用标准 `for`
    循环的 polyfill：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the polyfill, we check for the existence of `NodeList.prototype.forEach`.
    If it does not exist, a `forEach` method is added to the `NodeList` prototype
    that uses a `for` loop to iterate over the results of a DOM query. By doing so,
    you can use the `forEach` syntax freely across your codebase.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 polyfill 中，我们检查是否存在 `NodeList.prototype.forEach`。如果不存在，则向 `NodeList` 原型添加一个使用
    `for` 循环来遍历 DOM 查询结果的 `forEach` 方法。通过这样做，您可以在整个代码库中自由地使用 `forEach` 语法。
- en: Adding Click Functionality to an Element
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为元素添加点击功能
- en: Problem
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to add JavaScript functionality when a user clicks a button, link,
    or element on the page.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在用户点击页面上的按钮、链接或元素时添加 JavaScript 功能。
- en: Solution
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Add a `click` event listener for the element:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为元素添加一个 `click` 事件监听器：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Discussion
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The `addEventListener()` method allows our JavaScript to listen for a specific
    type of event and define a function that will be called when the event is triggered.
    In the previous example, I have added a `click` listener to a button element.
    When the button is clicked, the `clickHandler` function will be called, which
    fires an alert.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`addEventListener()` 方法允许我们的 JavaScript 监听特定类型的事件，并定义一个在触发事件时调用的函数。在前面的示例中，我已经为按钮元素添加了一个
    `click` 监听器。当按钮被点击时，将调用 `clickHandler` 函数，该函数触发一个警告框。'
- en: 'By default, you should use a `button` element for clickable event handlers,
    as it is the most accessible solution for handling click events. The `button`
    element can be styled to appear as a link if necessary for the application’s design.
    However, it is appropriate to use an element when the fallback behavior of linking
    to a page, should the JavaScript fail to load, is the desired behavior. When doing
    so, the `preventDefault` event method allows you to override the default link
    behavior:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情   默认情况下，您应该使用`button`元素来处理可点击的事件处理程序，因为这是处理点击事件的最易访问的解决方案。如果需要，`button`元素可以样式化为链接，以适应应用程序的设计。然而，当希望在JavaScript加载失败时，链接到页面的后备行为是所需的行为时，使用一个元素是合适的。当这样做时，`preventDefault`事件方法允许您覆盖默认的链接行为：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Tip
  id: totrans-58
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: In traditional JavaScript functions, the `this` keyword would be bound to the
    item being clicked. However, when using JavaScript’s newer arrow function syntax,
    such as in this example, the value of `this` is inherited from the parent function,
    which by default is `window`. This can be confusing if you are accustomed to nonarrow
    syntax functions. If you are interested in reading more, I recommend [Joe Cardillo’s
    article on the topic](https://oreil.ly/wK7Ik).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的JavaScript函数中，`this`关键字会绑定到被点击的项目。然而，当使用JavaScript的新箭头函数语法，如本例中所示时，`this`的值是从父函数继承的，默认情况下是`window`。如果你习惯于非箭头函数语法，这可能会让人感到困惑。如果您有兴趣了解更多，我推荐阅读[Joe
    Cardillo的相关文章](https://oreil.ly/wK7Ik)。
- en: 'On rare instances, it may be desirable to make a block element, such as a `div`
    clickable. I’d recommend doing so sparingly, in favor of the `button` element
    whenever possible. However, for these occasions, you will need to ensure that
    the functionality is accessible for those using screen readers and keyboard navigation.
    First, in your markup apply a `role` of `button` and a `tabindex` value. The `role`
    property will inform screen reader users that this is a clickable element, while
    the `tabindex` will make the element keyboard navigable:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在罕见的情况下，可能希望使一个块级元素，如`div`，变为可点击。我建议谨慎使用，尽可能选择`button`元素。然而，在这些情况下，您需要确保功能对使用屏幕阅读器和键盘导航的用户是可访问的。首先，在您的标记中应用`role`为`button`和`tabindex`值。`role`属性将通知屏幕阅读器用户这是一个可点击的元素，而`tabindex`将使元素可以通过键盘导航：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this instance, we use a `keydown` event handler. This will allow keyboard
    users to interact with the element:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在此实例中，我们使用`keydown`事件处理程序。这将允许键盘用户与元素进行交互：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Finding All Elements That Share an Attribute
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找所有具有相同属性的元素
- en: Problem
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to find all elements in a web document that share the same attribute.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您想在网页文档中找到所有具有相同属性的元素。
- en: Solution
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use the *universal selector* (`*`) in combination with the attribute selector
    to find all elements that have an attribute, regardless of its value:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*通用选择器*（`*`）结合属性选择器，查找所有具有属性的元素，无论其值是什么：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The universal selector can also be used to find all elements with an attribute
    that’s assigned the same value:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通用选择器也可以用来查找所有具有相同值的属性的元素：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Discussion
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The solution demonstrates a rather elegant query selector, the *universal selector*
    (`*`). The universal selector evaluates all elements, so it’s the one you want
    to use when you need to verify *something* about each element. In the solution,
    we want to find all of the elements with a given attribute.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案演示了一个相当优雅的查询选择器，*通用选择器*（`*`）。通用选择器会评估所有元素，因此在需要验证*每个元素的某些信息*时，您应该使用它。在解决方案中，我们要找到所有具有特定属性的元素。
- en: 'To test whether an attribute exists, all you need to do is list the attribute
    name within square brackets (*`[attrname]`*). In the solution, we’re first testing
    whether the element contains the `class` attribute. If it does, it’s returned
    with the element collection:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试一个属性是否存在，您只需在方括号内列出属性名称（*`[attrname]`*）。在解决方案中，我们首先测试元素是否包含`class`属性。如果存在，则与元素集合一起返回：
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we’re getting all elements with a `class` attribute value of `red`. If
    you’re not sure of the class name, you can use the substring-matching query selector:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们获取所有`class`属性值为`red`的元素。如果您不确定类名，可以使用子字符串匹配查询选择器：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now any class name that contains the substring `red` matches.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，任何包含子字符串`red`的类名都匹配。
- en: 'You could also modify the syntax to find all elements that don’t have a certain
    value. For instance, to find all `div` elements that don’t have the target class
    name, use the `:not` negation operator:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以修改语法以找到所有不具有特定值的元素。例如，要查找所有不具有目标类名的`div`元素，使用`:not`否定运算符：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Accessing All Elements of a Specific Type
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问特定类型的所有元素
- en: Problem
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to access all `img` elements in a given document.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你想访问给定文档中的所有`img`元素。
- en: Solution
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use the `document.getElementsByTagName()` method, passing in `img` as the parameter:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`document.getElementsByTagName()`方法，传入`img`作为参数：
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Discussion
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'The `document.getElementsByTagName()` method returns a collection of nodes
    (a `NodeList`) of a given element type, such as the `img` tag in the solution.
    The collection can be traversed like an array, and the order of nodes is based
    on the order of the elements within the document (the first `img` element in the
    page is accessible at index 0, etc.):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`document.getElementsByTagName()`方法返回给定元素类型（如解决方案中的`img`标签）的节点集合（`NodeList`）。该集合可以像数组一样遍历，并且节点的顺序基于文档中元素的顺序（页面中的第一个`img`元素可通过索引0访问等）：'
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As discussed in [“Traversing the Results from querySelectorAll() with forEach()”](#traversing_results_queryselect),
    a `NodeList` collection can be traversed like an array, but it isn’t an `Array`
    object. You can’t use `Array` object methods, such as `push()` and `reverse()`,
    with a `NodeList`. Its only property is `length`, and its only method is `item()`,
    returning the element at the position given by an index passed in as a parameter:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如在[“使用`forEach()`遍历`querySelectorAll()`的结果”](#traversing_results_queryselect)中讨论的那样，`NodeList`集合可以像数组一样遍历，但它不是`Array`对象。你不能使用`Array`对象的方法，比如`push()`和`reverse()`，在`NodeList`上。它的唯一属性是`length`，唯一的方法是`item()`，传入一个索引作为参数返回该位置的元素：
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`NodeList` is an intriguing object because it’s a live collection, which means
    changes made to the document after the `NodeList` is retrieved are reflected in
    the collection. [Example 12-1](#demonstrating_getelementsbytagnamecomma) demonstrates
    the `NodeList` live collection functionality, as well as `getElementsByTagName`.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`NodeList`是一个有趣的对象，因为它是一个实时集合，这意味着在检索`NodeList`之后对文档进行的更改会反映在集合中。示例 12-1展示了`NodeList`实时集合的功能，以及`getElementsByTagName`。'
- en: In the example, three images in the web page are accessed as a `NodeList` collection
    using the `getElementsByTagName` method. The `length` property, with a value of
    `3`, is output to the console. Immediately after, a new paragraph and `img` elements
    are created, and the `img` is appended to the paragraph. To append the paragraph
    following the others in the page, `getElementsByTagName` is used again, this time
    with the paragraph tags (`p`). We’re not really interested in the paragraphs,
    but in the paragraphs’ parent elements, found via the `parentNode` property on
    each paragraph.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，通过`getElementsByTagName`方法作为`NodeList`集合访问网页中的三个图像。`length`属性值为`3`，输出到控制台。紧接着，创建了一个新段落和`img`元素，并将`img`附加到段落中。为了在页面中追加这些段落，再次使用`getElementsByTagName`，这次使用段落标签（`p`）。我们实际上不关心段落，而是段落的父元素，通过每个段落上的`parentNode`属性找到它们。
- en: The new paragraph element is appended to the paragraph’s parent element, and
    the previously accessed `NodeList` collection’s length property is again printed
    out. Now, the value is `4`, reflecting the addition of the new `img` element.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 新段落元素被附加到段落的父元素，并且先前访问的`NodeList`集合的长度属性再次被打印出来。现在，值为`4`，反映了新添加的`img`元素。
- en: Example 12-1\. Demonstrating `getElementsByTagName` and the `NodeList` live
    collection property
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-1\. 演示`getElementsByTagName`和`NodeList`实时集合属性
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[Example 12-1](#demonstrating_getelementsbytagnamecomma) will log the following
    output to the browser console:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 12-1](#demonstrating_getelementsbytagnamecomma)将在浏览器控制台中记录以下输出：'
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In addition to using `getElementsByTagName()` with a specific element type,
    you can also pass the universal selector (`*`) as a parameter to the method to
    get all elements:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用`getElementsByTagName()`来获取特定元素类型之外，还可以将通用选择器（`*`）作为方法的参数传递，以获取所有元素：
- en: '[PRE26]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: See Also
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: In the code demonstrated in the discussion, the children nodes are traversed
    using a traditional `for` loop. In modern browsers, the `forEach()` method can
    be used directly with a `NodeList`, as demonstrated in [“Traversing the Results
    from querySelectorAll() with forEach()”](#traversing_results_queryselect).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论中演示的代码中，使用传统的`for`循环遍历子节点。在现代浏览器中，可以直接使用`NodeList`的`forEach()`方法，如在[“使用 forEach()
    遍历 querySelectorAll() 的结果”](#traversing_results_queryselect)中所示。
- en: Discovering Child Elements Using the Selectors API
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用选择器 API 发现子元素
- en: Problem
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to get a list of all instances of a child element, such as `img` elements,
    that are descendants of a parent element, such as `article` elements, without
    having to traverse an entire collection of elements.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 想要获取所有子元素实例的列表，比如`img`元素，这些子元素是父元素（如`article`元素）的后代，而不必遍历整个元素集合。
- en: Solution
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use the Selectors API and access the `img` elements contained within `article`
    elements using CSS-style selector strings:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用选择器 API 并使用 CSS 样式选择器字符串访问包含在`article`元素中的`img`元素：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Discussion
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: There are two selector query API methods. The first, `querySelectorAll()`, is
    demonstrated in the solution; the second is `querySelector()`. The difference
    between the two is that `querySelectorAll()` returns all elements that match the
    selector criteria, while `querySelector()` only returns the first found result.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种选择器查询 API 方法。第一种是`querySelectorAll()`，在解决方案中进行了演示；第二种是`querySelector()`。两者之间的区别在于`querySelectorAll()`返回匹配选择器条件的所有元素，而`querySelector()`只返回找到的第一个结果。
- en: 'The selector syntax is derived from CSS selector syntax, except that rather
    than style the selected elements, they’re returned to the application. In the
    example, all `img` elements that are descendants of `article` elements are returned.
    To access all `img` elements regardless of parent element, use:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器语法源自 CSS 选择器语法，不同之处在于不会为所选元素设置样式，而是将它们返回给应用程序。例如，返回所有属于`article`元素后代的`img`元素。要访问所有`img`元素而不管父元素，请使用：
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the solution, you’ll get all `img` elements that are direct or indirect
    descendants of an `article` element. This means that if the `img` element is contained
    within a `div` that’s within an `article`, the `img` element will be among those
    returned:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案中，您将获得所有直接或间接属于`article`元素的`img`元素。这意味着如果`img`元素包含在`article`内的`div`中，`img`元素将是返回结果之一：
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If you want only those `img` elements that are direct children of an `article`
    element, use the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只想获取`article`元素的直接子级`img`元素，请使用以下方法：
- en: '[PRE30]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you’re interested in accessing all `img` elements that are immediately followed
    by a paragraph, use:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想访问紧随段落的所有`img`元素，请使用：
- en: '[PRE31]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If you’re interested in an `img` element that has an empty `alt` attribute,
    use the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对具有空`alt`属性的`img`元素感兴趣，请使用以下方法：
- en: '[PRE32]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If you’re only interested in `img` elements that don’t have an empty `alt`
    attribute, use:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只对没有空`alt`属性的`img`元素感兴趣，请使用：
- en: '[PRE33]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The negation pseudoselector (`:not`) is used to find all `img` elements with
    `alt` attributes that are not empty.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 否定伪选择器（`:not`）用于查找所有具有非空`alt`属性的`img`元素。
- en: Unlike the collection returned with `getElementsByTagName()` covered earlier,
    the collection of elements returned from `querySelectorAll()` is *not* a “live”
    collection. Updates to the page are not reflected in the collection if the updates
    occur after the collection is retrieved.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前介绍的`getElementsByTagName()`返回的集合不同，从`querySelectorAll()`返回的元素集合*不*是“活动”集合。如果更新发生在检索集合之后，则页面的更新不会反映在集合中。
- en: Note
  id: totrans-125
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Though the Selectors API is a wonderful creation, it shouldn’t be used for every
    document query. To keep your applications performant, I recommend always using
    the most restrictive query possible when accessing elements. For example, it’s
    more efficient (meaning faster for the browser) to use `getElementById()` to get
    a specific element given an identifier than using `querySelectorAll()` for the
    same element.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然选择器 API 是一个很棒的创建，但不应该用于每个文档查询。为了保持应用程序的性能，我建议在访问元素时始终使用最严格的查询可能性。例如，使用`getElementById()`来获取具有特定标识符的特定元素比使用`querySelectorAll()`更有效率（意味着对浏览器更快）。
- en: See Also
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: There are three different CSS selector specifications, labeled as Selectors
    Level 1, Level 2, and Level 3\. [CSS Selectors Level 3](https://oreil.ly/rGfxD)
    contains links to the documents defining the other levels. These documents provide
    the definitions of, and examples for, the different types of selectors.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种不同的 CSS 选择器规范，分别标记为选择器 Level 1、Level 2 和 Level 3。[CSS 选择器 Level 3](https://oreil.ly/rGfxD)
    包含指定其他级别文档的链接。这些文档提供了不同类型选择器的定义和示例。
- en: Changing an Element’s Class Value
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改元素的类值
- en: Problem
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to update the CSS rules applied to an element by changing its class
    value.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过更改其类值来更新应用于元素的 CSS 规则。
- en: Solution
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use the `classList` property of an element to add, remove, and toggle class
    values:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用元素的 `classList` 属性来添加、删除和切换类值：
- en: '[PRE34]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Discussion
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Using `classList` allows you to easily manipulate the class properties of a
    selected element. This can come in handy for updating or swapping styles without
    using inline CSS. At times, it may be helpful to check if an element already has
    a class value applied, which can be accomplished with the `contains` method:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `classList` 可以轻松操作所选元素的类属性。这在更新或交换样式而不使用内联 CSS 时非常方便。有时，检查元素是否已应用类值也可能很有帮助，这可以通过
    `contains` 方法实现：
- en: '[PRE35]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'It is also possible to add, remove, or toggle multiple classes, either by passing
    them each as individual properties or using a spread operator:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过将它们作为单独的属性传递或使用扩展运算符来添加、删除或切换多个类：
- en: '[PRE36]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Setting an Element’s Style Attribute
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置元素的样式属性
- en: Problem
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to directly add or replace an inline style on a specific element.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要直接添加或替换特定元素的内联样式。
- en: Solution
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'To change one CSS property as an inline style, modify the property value via
    the element’s `style` property:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要作为内联样式更改一个 CSS 属性，请通过元素的 `style` 属性修改属性值：
- en: '[PRE37]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To modify one or more CSS properties for a single element, you can use `setAttribute()`
    and create an entire CSS style rule:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改单个元素的一个或多个 CSS 属性，可以使用 `setAttribute()` 并创建整个 CSS 样式规则：
- en: '[PRE38]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'These techniques set an inline style value for the HTML element, which will
    appear within the HTML itself. To demonstrate further, the following JavaScript
    sets a style attribute on an element with an ID of `card`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术为 HTML 元素设置了内联样式值，这些值将出现在 HTML 中。为了进一步演示，以下 JavaScript 在具有 ID `card` 的元素上设置了样式属性：
- en: '[PRE39]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The resulting HTML output includes the inline style value:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的 HTML 输出包含内联样式值：
- en: '[PRE40]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Discussion
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'An element’s CSS properties can be modified in JavaScript using one of three
    approaches. As the solution demonstrates, the simplest approach is to set the
    property’s value directly using the element’s `style` property:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用三种方法之一在 JavaScript 中修改元素的 CSS 属性。如解决方案所示，最简单的方法是直接使用元素的 `style` 属性设置属性值：
- en: '[PRE41]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If the CSS property contains a hyphen, such as `font-family` or `background-color`,
    use the *CamelCase notation* for the property:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 CSS 属性包含连字符，例如 `font-family` 或 `background-color`，则使用 *CamelCase 符号法* 设置属性：
- en: '[PRE42]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The CamelCase notation removes the dash and capitalizes the first letter following
    the dash.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: CamelCase 符号法去除连字符并将其后的第一个字母大写。
- en: 'You can also use `setAttribute()` or `cssText` to set the `style` property.
    This is useful when adding multiple styles:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 `setAttribute()` 或 `cssText` 来设置 `style` 属性。在添加多个样式时很有用：
- en: '[PRE43]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `setAttribute()` method is a way of adding an attribute or replacing the
    value of an existing attribute for a web page element. The first argument to the
    method is the attribute name (automatically lowercased if the element is an HTML
    element) and the new attribute value.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`setAttribute()` 方法是向 Web 页面元素添加属性或替换现有属性值的一种方法。该方法的第一个参数是属性名（如果元素是 HTML 元素，则自动转换为小写），第二个是新的属性值。'
- en: When setting the `style` attribute, all CSS properties that are changed must
    be specified at the same time, as setting the attribute erases any previously
    set values. However, setting the `style` attribute using `setAttribute()` does
    not erase any settings made in a stylesheet, or set by default by the browser.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置 `style` 属性时，所有更改的 CSS 属性必须同时指定，因为设置属性会擦除任何先前设置的值。然而，使用 `setAttribute()`
    设置 `style` 属性不会擦除样式表中的任何设置，也不会由浏览器默认设置。
- en: 'Extra: Accessing an Existing Style Setting'
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 额外：访问现有样式设置
- en: 'For the most part, accessing existing attribute values is as easy as setting
    them. Instead of using `setAttribute()`, use `getAttribute()`. For example, to
    get the value of the class:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，访问现有属性值与设置它们一样简单。而不是使用`setAttribute()`，使用`getAttribute()`。例如，要获取类的值：
- en: '[PRE44]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Getting access to a style setting, though, is much trickier, because a specific
    element’s style settings at any one time is a composite of all settings merged
    into a whole. This *computed style* for an element is what you’re most likely
    interested in when you want to see specific style settings for the element at
    any point in time. Happily, there is a method for that, `window.getComputedStyle()`,
    which will return the current computed styles applied to the element:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，获取样式设置要复杂得多，因为特定元素的样式设置随时是所有设置的合成整体。这个元素的*计算样式*在你想要查看特定时刻元素的具体样式设置时可能是你最感兴趣的。幸运的是，有一个方法可以做到，即`window.getComputedStyle()`，它将返回应用于元素的当前计算样式：
- en: '[PRE45]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Advanced
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级
- en: 'Rather than using `setAttribute()` to add or modify the attribute, you can
    create an attribute and attach it to the element using `createAttribute()` to
    create an `Attr` node, set its value using the `nodeValue` property, and then
    use `setAttribute()` to add the attribute to the element:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 与其使用`setAttribute()`添加或修改属性，你可以创建一个属性并使用`createAttribute()`将其附加到元素，以创建一个`Attr`节点，设置其值使用`nodeValue`属性，然后使用`setAttribute()`将属性添加到元素中：
- en: '[PRE46]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You can add any number of attributes to an element using either `createAttribute()`
    and `setAttribute()`, or `setAttribute()` directly. Both approaches are equally
    efficient, so unless there’s a real need, you’ll most likely want to use the simpler
    approach of setting the attribute name and value directly using `setAttribute()`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`createAttribute()`和`setAttribute()`或直接使用`setAttribute()`来为元素添加任意数量的属性。这两种方法同样有效，所以除非确实有必要，你很可能想要使用更简单的方法直接设置属性名和值，使用`setAttribute()`。
- en: When would you use `createAttribute()`? If the attribute value is going to be
    another entity reference, as is allowed with XML, you’ll need to use `createAttribute()`
    to create an `Attr` node, as `setAttribute()` only supports simple strings.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 何时会使用`createAttribute()`？如果属性值将是另一个实体引用（如 XML 中允许的），你需要使用`createAttribute()`来创建一个`Attr`节点，因为`setAttribute()`仅支持简单字符串。
- en: Adding Text to a New Paragraph
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向新段落添加文本
- en: Problem
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to create a new paragraph with text and insert it into the document.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要创建一个包含文本的新段落并将其插入到文档中。
- en: Solution
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use the `createTextNode` method to add text to an element:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`createTextNode`方法向元素添加文本：
- en: '[PRE47]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Discussion
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'The text within an element is, itself, an object within the DOM. Its type is
    a `Text` node, and it is created using a specialized method, `createTextNode()`.
    The method takes one parameter: the string containing the text.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 元素内的文本本身是 DOM 中的一个对象。它的类型是`Text`节点，并使用专门的方法`createTextNode()`创建。该方法接受一个参数：包含文本的字符串。
- en: '[Example 12-2](#demonstrating_various_methods_for_adding) shows a web page
    with a `div` element containing four paragraphs. The JavaScript creates a new
    paragraph from text provided by the user via a prompt. The text could just as
    easily have come from a server communication or other process.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 12-2](#demonstrating_various_methods_for_adding) 显示一个包含四个段落的`div`元素的网页。JavaScript
    从用户通过提示提供的文本创建一个新段落。文本同样可以来自服务器通信或其他过程。'
- en: The provided text is used to create a text node, which is then appended as a
    child node to the new paragraph. The `paragraph` element is inserted in the web
    page before the first paragraph.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的文本用于创建一个文本节点，然后将其作为子节点附加到新段落中。`paragraph`元素在第一个段落之前插入到网页中。
- en: Example 12-2\. Demonstrating various methods for adding content to a web page
  id: totrans-182
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-2\. 展示向网页添加内容的各种方法
- en: '[PRE48]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Caution
  id: totrans-184
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Inserting user-supplied text directly into a web page without scrubbing the
    text first is not a good idea. When you leave a door open, all sorts of nasty
    things can crawl in. [Example 12-2](#demonstrating_various_methods_for_adding)
    is for demonstration purposes only.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 直接将用户提供的文本插入网页而不先清理文本并不是一个好主意。一旦留下后门，各种恶意内容可能会悄悄爬进来。[示例 12-2](#demonstrating_various_methods_for_adding)
    仅用于演示目的。
- en: Inserting a New Element in a Specific DOM Location
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在特定 DOM 位置插入新元素
- en: Problem
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to insert a new paragraph just before the third paragraph within a
    `div` element.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要在一个`div`元素内第三个段落之前插入一个新段落。
- en: Solution
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use some method to access the third paragraph, such as `getElementsByTagName()`,
    to get all of the paragraphs for a `div` element. Then use the `createElement()`
    and `insertBefore()` DOM methods to add the new paragraph just before the existing
    third paragraph:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 使用某种方法访问第三段落，例如`getElementsByTagName()`，以获取`div`元素的所有段落。然后使用`createElement()`和`insertBefore()`
    DOM方法，在现有的第三段落之前添加新段落：
- en: '[PRE49]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Discussion
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The `document.createElement()` method creates any HTML element, which then can
    be inserted or appended into the page. In the solution, the new paragraph element
    is inserted before an existing paragraph using `insertBefore()`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`document.createElement()`方法创建任何HTML元素，然后可以将其插入或附加到页面中。在解决方案中，使用`insertBefore()`在现有段落之前插入新段落元素。'
- en: Because we’re interested in inserting the new paragraph before the existing
    third paragraph, we need to retrieve a collection of the `div` element’s paragraphs,
    check to make sure a third paragraph exists, and then use `insertBefore()` to
    insert the new paragraph before the existing one. If the third paragraph doesn’t
    exist, we can append the element to the end of the `div` element using `appendChild()`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们希望在现有的第三段落之前插入新段落，所以需要检索`div`元素段落的集合，确保第三段落存在，然后使用`insertBefore()`在现有段落之前插入新段落。如果第三段落不存在，则可以使用`appendChild()`将元素附加到`div`元素的末尾。
- en: Checking If a Checkbox Is Checked
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查复选框是否已选中
- en: Problem
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to verify that a user has checked a checkbox in your application.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要验证应用程序中的用户是否已选中复选框。
- en: Solution
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Select the checkbox element and validate the status with the `checked` property.
    In this example, I am selecting an HTML `input` checkbox element with an `id`
    of `check` and listening for a click event. When the event is fired, the `validate`
    function is run, which looks at the `checked` property of the element and logs
    its status to the console:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 选择复选框元素，并使用`checked`属性验证其状态。在此示例中，我选择了一个具有`id`为`check`的HTML `input`复选框元素，并监听点击事件。当事件触发时，运行`validate`函数，该函数查看元素的`checked`属性并将其状态记录到控制台：
- en: '[PRE50]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Discussion
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'A common pattern is for a user to be presented with a checkbox to make some
    sort of acknowledgement, such as accepting terms of service. In these instances,
    it is common to disable a button unless the user has checked the checkbox. We
    can modify the previous example to add this functionality:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 用户通常会看到一个复选框，以进行某种确认，例如接受服务条款。在这些情况下，通常会禁用按钮，除非用户已选中复选框。我们可以修改先前的示例以添加此功能：
- en: '[PRE51]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Adding Up Values in an HTML Table
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在HTML表中累加数值
- en: Problem
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to sum all numbers in a table column.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望对表列中的所有数字求和。
- en: Solution
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Traverse the table column containing numeric string values, convert the values
    to numbers, and sum the numbers:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历包含数字字符串值的表列，将值转换为数字并对数字求和：
- en: '[PRE52]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Discussion
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'The `:nth-of-type(n)` selector matches the specific child (`n`) of an element.
    By using `td:nth-of-type(2)` we are selecting the second `td` child element. In
    the example HTML markup, the second `td` element in the table is a numeric value:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`:nth-of-type(n)`选择器匹配元素的特定子元素（`n`）。通过使用`td:nth-of-type(2)`，我们选择第二个`td`子元素。在示例HTML标记中，表格中第二个`td`元素是一个数值：'
- en: '[PRE53]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `parseInt()` and `parseFloat()` methods convert strings to numbers, but
    `parseFloat()` is more adaptable when it comes to handling numbers in an HTML
    table. Unless you’re absolutely certain all of the numbers will be integers, `parseFloat()`
    can work with both integers and floating-point numbers.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`parseInt()`和`parseFloat()`方法将字符串转换为数字，但是在处理HTML表中的数字时，`parseFloat()`更具适应性。除非您确定所有数字都是整数，否则`parseFloat()`可以处理整数和浮点数。'
- en: '[Example 12-3](#converting_table_values_to_numbers_and_s) demonstrates how
    to convert and sum up numeric values in an HTML table, and then how to insert
    a table row with this sum, at the end. The code uses `document.querySelectorAll()`,
    which uses a different variation on the CSS selector, `td + td`, to access the
    data this time. This selector finds all table cells that are preceded by another
    table cell.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 12-3](#converting_table_values_to_numbers_and_s)演示了如何转换和累加HTML表中的数字值，然后如何在末尾插入一个包含此总和的表行。代码使用了`document.querySelectorAll()`，这次使用了CSS选择器`td
    + td`的不同变体来访问数据。此选择器查找所有紧随另一个表格单元格之前的表格单元格。'
- en: Example 12-3\. Converting table values to numbers and summing the results
  id: totrans-215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-3\. 将表格值转换为数字并汇总结果
- en: '[PRE54]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Being able to provide a sum or other operation on table data is helpful if you’re
    working with dynamic updates, such as accessing rows of data from a database.
    The fetched data may not be able to provide summary values, or you may not want
    to provide summary data until a web page reader chooses to do so. The users may
    want to manipulate the table results, and then push a button to perform the summing
    operation.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 能够对表格数据进行求和或其他操作在处理动态更新时非常有帮助，比如从数据库中访问数据行。获取的数据可能无法提供汇总值，或者直到网页读者选择执行操作时才想要提供汇总数据。用户可能希望操作表格结果，然后点击按钮执行求和操作。
- en: 'Adding rows to a table is straightforward, as long as you remember the steps:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 向表格添加行非常简单，只要记住以下步骤：
- en: Create a new table row using `document.createElement("tr")`.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`document.createElement("tr")`创建新的表格行。
- en: Create each table row cell using `document.createElement("td")`.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`document.createElement("td")`创建每个表格行单元格。
- en: Create each table row cell’s data using `document.createTextNode()`, passing
    in the text of the node (including numbers, which are automatically converted
    to a string).
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`document.createTextNode()`创建每个表格行单元格的数据，传入节点的文本（包括数字，它们会自动转换为字符串）。
- en: Append the text node to the table cell.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文本节点附加到表格单元格。
- en: Append the table cell to the table row.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将表格单元格附加到表格行。
- en: Append the table row to the table. Rinse, repeat.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将表格行附加到表格。反复进行。
- en: 'Extra: forEach and querySelectorAll'
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'Extra: forEach 和 querySelectorAll'
- en: 'In the preceding example, I’m using the `forEach()` method to iterate over
    the results of `querySelectorAll()`, which returns a `NodeList`, not an array.
    Though `forEach()` is an array method, modern browsers have implemented `NodeList.prototype.for​E⁠ach()`,
    which enables it iterating over a `NodeList` with the `forEach()` syntax, as discussed
    in [“Traversing the Results from querySelectorAll() with forEach()”](#traversing_results_queryselect).
    The alternative would be a loop:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，我使用`forEach()`方法迭代`querySelectorAll()`的结果，后者返回一个`NodeList`，而不是数组。尽管`forEach()`是数组方法，现代浏览器已经实现了`NodeList.prototype.forEach()`，使其能够使用`forEach()`语法迭代`NodeList`，正如在[“使用forEach()遍历querySelectorAll()的结果”](#traversing_results_queryselect)中讨论的那样。另一种方法是使用循环：
- en: '[PRE55]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Extra: Modularization of Globals'
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'Extra: 全局变量的模块化'
- en: 'As part of a growing effort to *modularize* JavaScript, the `parseFloat()`
    and `parseInt()` methods are now attached to the `Number` object, as new *static*
    methods, as of ECMAScript 2015:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 作为*模块化*JavaScript日益增长努力的一部分，`parseFloat()` 和 `parseInt()` 方法现在作为新的*静态*方法附加到
    `Number` 对象上，自 ECMAScript 2015 起：
- en: '[PRE56]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'These modules have reached widespread browser adoption, but can be polyfilled
    for older browser support, using a tool like Babel or on their own:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模块已经得到广泛的浏览器支持，但可以通过像Babel这样的工具或单独支持的方式进行旧版浏览器的填充：
- en: '[PRE57]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Deleting Rows from an HTML Table
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从HTML表格中删除行
- en: Problem
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to remove one or more rows from an HTML table.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要从HTML表格中移除一个或多个行。
- en: Solution
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use the `removeChild()` method on an HTML table row, and all of the child elements,
    including the row cells, are also removed:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML表格行上使用`removeChild()`方法，所有子元素，包括行单元格，也会被移除：
- en: '[PRE58]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Discussion
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: When you remove an element from the web document, you’re not only removing the
    element, you’re removing all of its child elements. In this *DOM pruning* you
    get a reference to the removed element if you want to process its contents before
    it’s completely discarded. The latter is helpful if you want to provide some kind
    of *undo* method in case you accidentally select the wrong table row.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从网页文档中移除一个元素时，不仅仅是移除了该元素，还移除了它所有的子元素。在这个*DOM修剪*过程中，如果你希望在完全丢弃之前处理其内容，可以获取对已移除元素的引用。后者在你希望在不小心选择错误的表格行时提供某种*撤销*方法时非常有帮助。
- en: To demonstrate the nature of DOM pruning, in [Example 12-4](#adding_and_removing_table_rows_and_assoc),
    DOM methods `createElement()` and `createTextNode()` are used to create table
    rows and cells, as well as the text inserted into the cells. As each table row
    is created, an event handler is attached to the row’s *click* event. If any of
    the new table rows is clicked, a function is called that removes the row from
    the table. The removed table row element is then traversed, and the data in its
    cells is extracted and concatenated to a string, which is printed out.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示 DOM 剪枝的性质，在 [示例 12-4](#adding_and_removing_table_rows_and_assoc) 中，使用 DOM
    方法 `createElement()` 和 `createTextNode()` 创建表行和单元格，以及插入到单元格中的文本。每个表行创建时，都会附加到行的
    *click* 事件处理程序。如果点击任何新的表行，将调用一个函数，从表中移除该行。然后遍历已移除的表行元素，并提取并连接其单元格中的数据到一个字符串中，然后将其打印出来。
- en: Example 12-4\. Adding and removing table rows and associated table cells and
    data
  id: totrans-242
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-4\. 添加和移除表行及其关联的表格单元格和数据
- en: '[PRE59]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Hiding Page Sections
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐藏页面部分
- en: Problem
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to hide an existing page element and its children until needed.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要隐藏现有页面元素及其子元素，直到需要时。
- en: Solution
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'You can set the CSS `visibility` property to hide and show the element:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以设置 CSS `visibility` 属性来隐藏和显示元素：
- en: '[PRE60]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Or you can use the CSS `display` property:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 或者您可以使用 CSS `display` 属性：
- en: '[PRE61]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Discussion
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Both the CSS `visibility` and `display` properties can be used to hide and show
    elements. There is one major difference between the two that impacts which one
    you’ll use.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: CSS `visibility` 和 `display` 属性都可以用于隐藏和显示元素。它们之间有一个主要区别会影响您选择使用哪个。
- en: The `visibility` property controls the element’s visual rendering, but its presence
    also affects other elements. When an element is hidden, it still takes up page
    space. The `display` property, on the other hand, removes the element completely
    from the page layout.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`visibility` 属性控制元素的视觉渲染，但其存在也会影响其他元素。当元素隐藏时，仍然占据页面空间。另一方面，`display` 属性完全从页面布局中移除元素。'
- en: 'The `display` property can be set to several different values, but four are
    of particular interest to us:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`display` 属性可以设置为几种不同的值，但其中四种对我们特别感兴趣：'
- en: '`none`'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`none`'
- en: When display is set to `none`, the element is removed completely from display.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `display` 设置为 `none` 时，元素完全从显示中移除。
- en: '`block`'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`block`'
- en: When display is set to `block`, the element is treated like a `block` element,
    with a line break before and after.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `display` 设置为 `block` 时，元素会像 `block` 元素一样对待，前后都有换行。
- en: '`inline-block`'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`inline-block`'
- en: When display is set to `inline-block`, the contents are formatted like a `block`
    element, which is then flowed like inline content.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `display` 设置为 `inline-block` 时，内容会像 `block` 元素一样格式化，然后像内联内容一样流动。
- en: '`inherit`'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`inherit`'
- en: This is the default display, and specifies that the `display` property is inherited
    from the element’s parent.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这是默认显示，并指定 `display` 属性从元素的父级继承。
- en: There are other values, but these are the ones we’re most likely to use within
    JavaScript applications.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他值，但这些是我们在 JavaScript 应用中最有可能使用的。
- en: Unless you’re using absolute positioning with the hidden element, you’ll want
    to use the CSS `display` property. Otherwise, the element will affect the page
    layout, pushing any elements that follow down and to the right, depending on the
    type of hidden element.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 除非使用绝对定位和隐藏元素，否则应使用 CSS `display` 属性。否则，该元素会影响页面布局，将后续元素推到右下角，具体取决于隐藏元素的类型。
- en: There is another approach to removing an element out of page view, and that
    is to move it totally offscreen using a negative left value. This could work,
    especially if you’re creating a slider element that will slide in from the left.
    It’s also an approach that the accessibility community has suggested using when
    you have content that you want rendered by assistive technology (AT) devices,
    but not visually rendered.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种方法可以将元素从页面视图中移除，即使用负左值将其完全移出屏幕。这在创建从左侧滑入的滑块元素时特别有效。这也是辅助技术（AT）设备建议使用的方法，当您希望内容由辅助技术设备呈现，但不在视觉上呈现时。
- en: Creating Hover-Based Pop-Up Info Windows
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建基于悬停的弹出信息窗口
- en: Problem
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to create an interaction where a user mouses over a thumbnail image
    and additional information is displayed.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要创建一个互动，用户将鼠标悬停在缩略图图像上时显示附加信息。
- en: Solution
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: This interaction is based on four different functionalities.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 此交互基于四种不同的功能。
- en: 'First, you need to capture the `mouseover` and `mouseout` events for each image
    thumbnail in order to display or remove the pop-up window, respectively. In the
    following code, the cross-browser event handlers are attached to all images in
    the page:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要捕获每个图像缩略图的`mouseover`和`mouseout`事件，以显示或移除弹出窗口。在以下代码中，跨浏览器事件处理程序附加到页面中的所有图像：
- en: '[PRE62]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Second, you need to access something about the item you’re hovering over in
    order to know what to use to populate the pop-up bubble. The information can be
    in the page, or you can use web server communication to get the information:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，您需要访问悬停在其上的项目的某些内容，以了解如何填充弹出气泡。这些信息可以在页面中，或者您可以使用Web服务器通信获取信息：
- en: '[PRE63]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Third, you need to either show the pop-up window, if it already exists and
    is not displayed, or create the window. In the following code, the pop-up window
    is created just below the object, and just to the right when the web server call
    returns with the information about the item. The `getBoundingClientRect()` method
    is used to determine the location where the pop-up should be placed, and `createElement()`
    and `createTextNode()` are used to create the pop-up:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，如果弹出窗口已经存在但没有显示，您需要显示弹出窗口，或者创建新窗口。在以下代码中，当Web服务器返回项目信息时，弹出窗口会在对象正下方创建，并且向右移动。使用`getBoundingClientRect()`方法确定弹出窗口应放置的位置，使用`createElement()`和`createTextNode()`创建弹出窗口：
- en: '[PRE64]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Lastly, when the `mouseover` event fires, you need to either hide the pop-up
    window or remove it—whichever makes sense in your setup. Since the application
    created a new pop-up window in the `mouseover` event, it removes the pop-up in
    the `mouseout` event handler:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当`mouseover`事件触发时，您需要隐藏弹出窗口或将其移除——根据您的设置决定。因为应用程序在`mouseover`事件中创建了新的弹出窗口，所以它会在`mouseout`事件处理程序中移除弹出窗口：
- en: '[PRE65]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Discussion
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Creating a pop-up information or help window doesn’t have to be complicated
    if you keep the action simple and follow the four steps outlined in the solution.
    If the pop-up provides help for `form` elements, then you might want to cache
    the information within the page, and just show and hide pop-up elements as needed.
    However, if you have pages with hundreds of items, you’ll have better performance
    if you get the pop-up window information on demand via a web service call.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您按照解决方案中概述的四个步骤简单操作，并且弹出窗口提供`form`元素的帮助，那么创建弹出信息或帮助窗口就不必复杂化。但是，如果您的页面上有数百个项目，通过Web服务调用按需获取弹出窗口信息会获得更好的性能。
- en: When I positioned the pop-up in the example, I didn’t place it directly over
    the object. The reason is that I’m not capturing the mouse position to have the
    pop-up follow the cursor around, ensuring that I don’t move the cursor directly
    over the pop-up. But if I statically position the pop-up partially over the object,
    the web page readers could move their mouse over the pop-up, which triggers the
    event to hide the pop-up…which then triggers the event to show the pop-up, and
    so on. This creates a flicker effect, not to mention a lot of network activity.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当我定位示例中的弹出窗口时，我没有直接将其放在对象上方。原因是我没有捕获鼠标位置来使弹出窗口跟随光标移动，确保我不会直接移动鼠标指向弹出窗口。但是，如果我静态地将弹出窗口部分放在对象上方，Web页面读者可能会将鼠标移到弹出窗口上，从而触发隐藏弹出窗口的事件……然后触发显示弹出窗口的事件，如此反复。这会产生闪烁效果，更不用说大量的网络活动了。
- en: If, instead, I allowed the mouse events to continue by returning `true` from
    either event handler function, when the web page readers move their mouse over
    the pop-up, the pop-up won’t go away. However, if they move the mouse from the
    image to the pop-up, and then to the rest of the page, the event to trigger the
    pop-up event removal won’t fire, and the pop-up is left on the page.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我允许鼠标事件继续（通过从任一事件处理程序函数返回`true`），那么当Web页面读者将鼠标移到弹出窗口上时，弹出窗口不会消失。但是，如果他们将鼠标从图像移到弹出窗口，然后移到页面的其余部分，将不会触发移除弹出窗口事件，弹出窗口就会留在页面上。
- en: The best approach is to place the pop-up directly under (or to the side, or
    a specific location in the page) rather than directly over the object.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳方法是将弹出窗口直接放置在对象的下方（或侧边，或页面的特定位置），而不是直接覆盖对象。
- en: Validating Form Data
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证表单数据
- en: Problem
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Your web application gathers data from the users using HTML forms. Before you
    send that data to the server, though, you want to make sure it’s well formed,
    complete, and valid while providing feedback to the user.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 您的Web应用程序使用HTML表单从用户那里收集数据。但在将数据发送到服务器之前，您希望确保数据格式正确、完整且有效，并向用户提供反馈。
- en: Solution
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use the HTML5’s built-in form validation attributes, which can be extended
    with an external library for string validation:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 使用HTML5内置的表单验证属性，可以通过外部库进行字符串验证的扩展：
- en: '[PRE66]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'You can use a standalone library, such as [validator.js](https://github.com/validatorjs/validator.js),
    to check for validity as a user types:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用独立的库，比如[validator.js](https://github.com/validatorjs/validator.js)，在用户输入时进行有效性检查：
- en: '[PRE67]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Discussion
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: By now, we should not be writing our own forms validation routines. Not unless
    we’re dealing with some really bizarre form behavior and/or data. And by bizarre,
    I mean so far outside the ordinary that trying to incorporate a JavaScript library
    would actually be harder than doing it ourselves—a “the form field value must
    be a string except on Thursdays, when it must be a number—but reverse that in
    even months” type of validation.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们不应该编写自己的表单验证程序。除非我们处理的是一些非常奇怪的表单行为和/或数据。所谓的奇怪，是指远远超出寻常的范围，试图将JavaScript库整合进去实际上比自己做更难——比如“表单字段值必须是字符串，除了星期四必须是数字，但在偶数月份则相反”的验证类型。
- en: You have a lot of options for libraries, and I’ve only demonstrated one. The
    *validator.js* library is a nice, simple, easy-to-use library that provides validation
    for many different types of strings. It doesn’t require that you modify the form
    fields, either, which means it’s easier to just drop it in, instead of reworking
    the form. Any and all styling and placement of error messages is developer dependent,
    too.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 您有很多库选项，我只演示了其中一个。*validator.js*库是一个不错的、简单易用的库，可以为多种不同类型的字符串提供验证。它也不要求您修改表单字段，这意味着只需轻松地将其插入即可，而不必重新设计表单。所有的样式和错误消息的放置也取决于开发者。
- en: In the solution, the code adds an event listener to each `input` element. When
    a user makes any change to the field, the `input` event listener is fired and
    calls the `inputValidator` function, which checks the value against the *validator.js*
    library. If the value is invalid, minimal CSS styling is used to add a red border
    to the input field. When the value is valid, no style is added.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案中，代码为每个`input`元素添加了事件监听器。当用户对字段进行任何更改时，将触发`input`事件监听器，并调用`inputValidator`函数，该函数使用*validator.js*库检查值。如果值无效，将使用最小的CSS样式向输入字段添加红色边框。当值有效时，则不添加样式。
- en: Sometimes you need a smaller library specifically for one type of data validation.
    Credit cards are tricky things, and though you can ensure a correct format, the
    values contained in them must meet specific rules in order to be considered valid
    credit card submissions.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，您可能需要一个专门用于某种类型数据验证的小型库。信用卡是棘手的东西，虽然您可以确保正确的格式，但其中包含的值必须满足特定规则，才能被视为有效的信用卡提交。
- en: 'In addition to the other validation libraries, you can also incorporate a credit
    card validation library, such as [Payment](https://github.com/jessepollak/payment),
    which provides a straightforward validation API. As an example, specify that a
    field is a credit card number after the form loads:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 除了其他验证库，你还可以集成信用卡验证库，比如[Payment](https://github.com/jessepollak/payment)，它提供了一个直接的验证API。例如，在表单加载后指定字段为信用卡号码：
- en: '[PRE68]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'And then when the form is submitted, validate the credit card number:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在提交表单时验证信用卡号码：
- en: '[PRE69]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The library doesn’t just check format; it also ensures that the value meets
    a valid card number for all of the major card companies. Depending on how you
    are processing credit cards, the payment processor may provide similar functionality
    in the client-side code. For example, the payment processor Stripe’s [Stripe.js](https://oreil.ly/GqPVh)
    includes a credit card validation API.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 该库不仅检查格式，还确保值符合所有主要信用卡公司的有效卡号。根据您如何处理信用卡，支付处理器在客户端代码中可能提供类似的功能。例如，支付处理器Stripe的[Stripe.js](https://oreil.ly/GqPVh)包括信用卡验证API。
- en: Lastly, you can pair client and server validation, using the same library or
    different ones. In the example, we are using *validator.js* in the browser, but
    it can also be used to validate inputs on the backend in a Node application.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以使用客户端和服务器验证，使用相同或不同的库。在此示例中，我们在浏览器中使用*validator.js*，但它也可以用于Node应用程序中的后端验证。
- en: 'Extra: HTML5 Form Validation Techniques'
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附加：HTML5 表单验证技术
- en: 'HTML5 offers fairly extensive built-in form validation, which does not require
    JavaScript, including:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5 提供了相当广泛的内置表单验证功能，无需 JavaScript，包括：
- en: '`min` and `max`'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`min` 和 `max`'
- en: The minimum and maximum values of numeric inputs
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 数字输入的最小值和最大值
- en: '`minlength` and `maxlength`'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`minlength` 和 `maxlength`'
- en: The minimum and maximum length of string inputs
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串输入的最小和最大长度
- en: '`pattern`'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`pattern`'
- en: A regular expression pattern that the entered input must follow
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 输入必须遵循的正则表达式模式
- en: '`required`'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`required`'
- en: Required inputs must be completed before the form can be submitted
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 必填输入必须在提交表单之前完成
- en: '`type`'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`type`'
- en: Allows developers to specify a content type for an input, such as date, email
    address, number, password, URL, or some other specific preset type
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 允许开发人员为输入指定内容类型，例如日期、电子邮件地址、数字、密码、URL 或其他特定预设类型。
- en: Additionally, CSS pseudoselectors can be used to match `:valid` and `:invalid`
    inputs.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可以使用 CSS 伪选择器匹配 `:valid` 和 `:invalid` 输入。
- en: Because of this, for simple forms you may not need JavaScript at all. If you
    need finite control over the appearance and behavior of form validation, you’re
    better off using a JavaScript library than depending on the HTML5 and CSS forms
    validation specifications. If you do, though, make sure to incorporate accessibility
    features into your forms. I recommend reading [WebAIM’s “Creating Accessible Forms”](https://oreil.ly/5oL3E).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于简单的表单，您可能根本不需要 JavaScript。如果您需要对表单验证的外观和行为有限控制，建议使用 JavaScript 库，而不是依赖
    HTML5 和 CSS 的表单验证规范。不过，确保将无障碍功能整合到您的表单中。我建议阅读[WebAIM 的“创建无障碍表单”](https://oreil.ly/5oL3E)。
- en: Highlighting Form Errors and Accessibility
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 突出显示表单错误和无障碍功能
- en: Problem
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to highlight form field entries that have incorrect data, and you want
    to ensure the highlighting is effective for all web page users.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望突出显示输入有错误的表单字段，并确保对所有网页用户都有效果。
- en: Solution
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use CSS to highlight the incorrectly entered form field, and use WAI-ARIA (Web
    Accessibility Initiative-Accessible Rich Internet Applications) markup to ensure
    the highlighting is apparent to all users:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 CSS 突出显示输入错误的表单字段，并使用 WAI-ARIA（Web Accessibility Initiative-Accessible Rich
    Internet Applications）标记，以确保所有用户都能看到突出显示：
- en: '[PRE70]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'For the fields that need to be validated, assign a function to the form field’s
    `oninput` event handler that checks whether the field value is valid. If the value
    is invalid, display information to the user about the error at the same time that
    you highlight the field:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 对需要验证的字段，将一个函数分配给表单字段的 `oninput` 事件处理程序，以检查字段值是否有效。如果值无效，同时显示有关错误的信息，并突出显示字段：
- en: '[PRE71]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'For the fields that need a required value, assign a function to the field’s
    `onblur` event handler that checks whether a value has been entered:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 对需要必填值的字段，将一个函数分配给字段的 `onblur` 事件处理程序，以检查是否已输入值：
- en: '[PRE72]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: If any of the validation checks are performed as part of the form submission,
    make sure to cancel the submission event if the validation fails.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何验证检查作为表单提交的一部分执行，请确保在验证失败时取消提交事件。
- en: Discussion
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The WAI-ARIA provides a way of marking certain fields and behaviors so that
    assistive devices do whatever is the equivalent behavior for people who need these
    devices. If a person is using a screen reader, setting the `aria-invalid` attribute
    to `true` (or adding it to the element) should trigger an audible warning in the
    screen reader—comparable to a color indicator doing the same for people who aren’t
    using assistive technologies.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: WAI-ARIA 提供了一种标记特定字段和行为的方式，使辅助设备为需要这些设备的人提供相应的行为。如果使用屏幕阅读器，将 `aria-invalid`
    属性设置为 `true`（或添加到元素中）应触发屏幕阅读器中的听觉警告，这与为不使用辅助技术的人员提供的颜色指示器相当。
- en: Note
  id: totrans-331
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Read more on WAI-ARIA at the [Web Accessibility Initiative at the W3C](https://oreil.ly/8wGnc).
    On Windows, I recommend using [NVDA](http://www.nvaccess.org), an open source,
    freely available screen reader, for testing whether your application is responding
    as you think it should with a screen reader. For macOS, I recommend using the
    built-in VoiceOver tool with the Safari browser.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在[Web Accessibility Initiative at the W3C](https://oreil.ly/8wGnc)上了解更多关于 WAI-ARIA
    的信息。在 Windows 上，我推荐使用[NVDA](http://www.nvaccess.org)，这是一个开源免费的屏幕阅读器，用于测试您的应用程序是否与屏幕阅读器响应如您所预期。在
    macOS 上，建议使用内置的 VoiceOver 工具结合 Safari 浏览器。
- en: In addition, the `role` attribute can be set to several values of which one,
    “alert,” triggers a comparable behavior in screen readers (typically saying out
    the field contents).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`role` 属性可以设置为几个值，其中一个“alert”，在屏幕阅读器中触发类似的行为（通常将字段内容读出）。
- en: Providing these cues are essential when you’re validating form elements. You
    can validate a form before submission and provide a text description of everything
    that’s wrong. A better approach, though, is to validate data for each field as
    the user finishes, so they’re not left with a lot of irritating error messages
    at the end.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证表单元素时，提供这些线索是至关重要的。您可以在提交之前验证表单，并提供关于所有错误的文本描述。然而，更好的方法是在用户完成时为每个字段验证数据，这样他们最终不会被留下大量令人恼火的错误消息。
- en: As you validate the field, you can ensure your users know exactly which field
    has failed by using a visual indicator. It shouldn’t be the only method used to
    mark an error, but it is an extra courtesy.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证字段时，您可以确保用户准确知道哪个字段失败了，通过使用视觉指示器。这不应是标记错误的唯一方法，但这是一种额外的礼貌。
- en: If you highlight an incorrect form field entry with colors, avoid those that
    are hard to differentiate from the background. If the form background is white,
    and you use a dark yellow, gray, red, blue, green, or other color, there’s enough
    contrast that it doesn’t matter if the person viewing the page is color-blind
    or not. In the example, I used a darker pink in the form field.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您用颜色突出显示错误的表单字段条目，请避免与背景颜色难以区分的颜色。如果表单背景是白色，并且您使用深黄色、灰色、红色、蓝色、绿色或其他颜色，有足够的对比度，无论查看页面的人是否色盲。在示例中，我在表单字段中使用了较深的粉色。
- en: I could have set the color directly, but it makes more sense to handle both
    updates—setting `aria-invalid` and changing the color—with one CSS setting. Luckily,
    CSS *attribute selectors* simplify our task in this regard.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 直接设置颜色可能更为直接，但通过一个 CSS 设置来处理更新更为合理 —— 设置 `aria-invalid` 和改变颜色。幸运的是，CSS *属性选择器*
    在这方面简化了我们的任务。
- en: In addition to using color, you also need to provide a text description of the
    error, so there’s no question in the user’s mind about what the problem is.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用颜色外，您还需要提供一个关于错误的文本描述，这样用户就不会对问题感到困惑。
- en: How you display the information is also an important consideration. None of
    us really like to use alert boxes, if we can avoid them. Alert boxes can obscure
    the form, and the only way to access the form element is to dismiss the alert
    with its error message. A better approach is to embed the information in the page,
    near the form. We also want to ensure the error message is available to people
    who are using assistive technologies, such as a screen reader. This is easily
    accomplished by assigning an ARIA `alert` `role` to the element containing the
    alert for those using screen readers or other AT devices.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 如何显示信息也是一个重要考虑因素。我们都不喜欢使用警报框，如果可能的话。警报框可能会遮挡表单，访问表单元素的唯一方式是解除带有错误消息的警报。更好的方法是将信息嵌入页面，靠近表单附近。我们还希望确保错误消息对使用辅助技术（如屏幕阅读器）的人员可用。通过为包含屏幕阅读器或其他辅助技术设备的警报元素分配
    ARIA `alert` `role` 来轻松实现这一点。
- en: One final bonus to using `aria-invalid` is it can be used to discover all incorrect
    fields when the form is submitted. Just search on all elements where the attribute
    is present and if any are discovered, you know there’s still an invalid form field
    value that needs correcting.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `aria-invalid` 的另一个额外好处是，在提交表单时，它可以用来发现所有不正确的字段。只需搜索所有具有该属性的元素，如果发现任何错误字段值，就知道还需要更正。
- en: '[Example 12-5](#providing_visual_and_other_cues_when_val) demonstrates how
    to highlight an invalid entry on one of the form elements, and highlight missing
    data in another. The example also traps the form submit, and checks whether any
    invalid form field flags are still set. Only if everything is clear is the form
    submission allowed to proceed.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 12-5](#providing_visual_and_other_cues_when_val) 演示了如何突出显示一个表单元素中的无效输入，并突出显示另一个中缺少的数据。该示例还捕获表单提交，并检查是否仍然设置了任何无效表单字段标志。只有在一切清楚的情况下，才允许表单提交继续。'
- en: Example 12-5\. Providing visual and other cues when validating form fields
  id: totrans-342
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-5\. 在验证表单字段时提供视觉和其他线索
- en: '[PRE73]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: If either of the validated fields is incorrect in the application, the `aria-invalid`
    attribute is set to `true` in the field, and an ARIA `role` is set to `alert`
    on the error message, as shown in [Figure 12-2](#highlighting_an_incorrect_form_field).
    When the error is corrected, the `aria-invalid` attribute is removed, as is the
    alert message. Both have the effect of changing the background color for the form
    field.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序中任一经过验证的字段不正确，则在该字段中将`aria-invalid`属性设置为`true`，并在错误消息上设置ARIA `role`为`alert`，如[图12-2](#highlighting_an_incorrect_form_field)所示。当错误被纠正时，`aria-invalid`属性被移除，警报消息也被移除。这两者都会改变表单字段的背景颜色。
- en: '![jsc3 1202](assets/jsc3_1202.png)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![jsc3 1202](assets/jsc3_1202.png)'
- en: Figure 12-2\. Highlighting an incorrect form field
  id: totrans-346
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-2\. 突出显示不正确的表单字段
- en: Notice in the code that the element wrapping the targeted form field is set
    to its correct state when the data entered is correct, so that when a field is
    corrected it doesn’t show up as inaccurate or missing on the next go-round. I
    remove the existing message alert regardless of the previous event, as it’s no
    longer valid with the new event.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意代码中，当输入的数据正确时，包裹目标表单字段的元素被设置为其正确状态，这样当字段被更正时，它不会在下一轮中显示为不准确或缺失。我移除现有的消息警报，无论之前的事件如何，因为它对新事件不再有效。
- en: You can also disable or even hide the correctly entered form elements as a way
    to accentuate those with incorrect or missing data. However, I don’t recommend
    this approach. Your users may find as they fill in the missing information that
    their answers in other fields are incorrect. If you make it difficult for them
    to correct the fields, they’re not going to be happy with the experience—or the
    company, person, or organization providing the form.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以禁用或甚至隐藏正确输入的表单元素，以突出显示那些具有不正确或缺失数据的元素。然而，我不推荐这种方法。用户可能会发现，当他们填写缺失信息时，其他字段中的答案是不正确的。如果让他们难以更正字段，他们将不会对体验或提供表单的公司、个人或组织感到满意。
- en: Another approach you can take is to only do validation when the form is submitted.
    Many built-in libraries operate this way. Rather than check each field for mandatory
    or correct values as your users tab through, you only apply the validation rules
    when the form is submitted. This allows users who want to fill out the form in
    a different order to do so without getting irritating validation messages as they
    tab through.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以采取的另一种方法是仅在提交表单时进行验证。许多内置库都是这样操作的。与其在用户通过时检查每个字段是否具有必填或正确的值，不如在提交表单时应用验证规则。这样，希望以不同顺序填写表单的用户可以在不受到烦人的验证消息干扰的情况下这样做。
- en: Using JavaScript to highlight a form field with incorrect and missing data is
    only one part of the form submission process. You’ll also have to account for
    JavaScript being turned off, which means you have to provide the same level of
    feedback when processing the form information on the server, and providing the
    result on a separate page.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JavaScript突出显示具有不正确和缺失数据的表单字段只是表单提交过程的一部分。您还必须考虑到JavaScript被关闭的情况，这意味着在服务器上处理表单信息并在单独页面上提供结果时，您必须提供相同级别的反馈。
- en: It’s also important to mark if a form field is required ahead of time. Use an
    asterisk in the form field label, with a note that all form fields with an asterisk
    are required. Use the `aria-required` and attribute to ensure this information
    is communicated to those using assistive devices. I also recommend using the HTML5
    `required` attribute when using `aria-required`, which provides built-in browser
    validation.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 标记表单字段是否为必填也很重要。在表单字段标签中使用星号，并注明所有带星号的表单字段都是必填的。使用`aria-required`属性确保这些信息传达给使用辅助设备的人。我还建议在使用`aria-required`时使用HTML5的`required`属性，这提供了内置的浏览器验证。
- en: See Also
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: In [“Validating Form Data”](#validating_forms) I cover form validation libraries
    and modules to simplify form validation. I also touch on using the HTML5 declarative
    form validation techniques.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“验证表单数据”](#validating_forms)中，我介绍了简化表单验证的表单验证库和模块。我还涉及使用HTML5声明性表单验证技术。
- en: Creating an Accessible Automatically Updated Region
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个可访问的自动更新区域
- en: Problem
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You have a section of a web page that is updated periodically, such as a section
    that lists recent updates to a file, or one that reflects recent Twitter activity
    on a subject. You want to ensure that when the page updates, those using a screen
    reader are notified of the new information.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 您有一个网页的部分定期更新，例如列出文件的最新更新或反映某个主题的最近 Twitter 活动的部分。您希望在页面更新时，使用屏幕阅读器的用户能够收到新信息的通知。
- en: Solution
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use WAI-ARIA *region* attributes on the element being updated:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在正在更新的元素上使用 WAI-ARIA *region* 属性：
- en: '[PRE74]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Discussion
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: A section of the web page that can be updated after the page is loaded, and
    without direct user intervention, calls for WAI-ARIA Live Regions. These are probably
    the simplest ARIA functionality to implement, and they provide immediate, positive
    results. And there’s no code involved, other than the JavaScript you need to create
    the page updates.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 页面加载后可以更新的网页部分，且无需直接用户干预，需要使用 WAI-ARIA Live Regions。这可能是最简单的 ARIA 功能之一，而且它们提供即时且积极的结果。除了创建页面更新所需的
    JavaScript 之外，不需要其他代码。
- en: '[PRE75]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: From left to right, the `role` is set to `log`, which would be used when polling
    for log updates from a file. Other options include `status`, for a status update,
    and a more general `region` value, for an undetermined purpose.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 从左到右，`role` 设置为 `log`，用于从文件轮询日志更新时使用。其他选项包括 `status`，用于状态更新，以及更通用的 `region`
    值，用于未确定的目的。
- en: The `aria-live` region attribute is set to `polite`, because the update isn’t
    a critical update. The `polite` setting tells the screen reader to voice the update,
    but not interrupt a current task to do so. If I had used a value of `assertive`,
    the screen reader would interrupt whatever it is doing and voice the content.
    Always use `polite`, unless the information is critical.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '`aria-live` 区域属性设置为 `polite`，因为更新不是关键性更新。`polite` 设置告诉屏幕阅读器朗读更新，但不会中断当前任务。如果我使用
    `assertive` 值，屏幕阅读器会中断正在执行的任务并朗读内容。除非信息很关键，否则始终使用 `polite`。'
- en: The `aria-atomic` is set to `false`, so that the screen reader only voices new
    additions, based on whatever is set with `aria-relevant`. It could get very annoying
    to have the screen reader voice the entire set with each new addition, as would
    happen if this value is set to `true`.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '`aria-atomic` 设置为 `false`，因此屏幕阅读器仅朗读基于 `aria-relevant` 设置的新添加内容。如果将此值设置为 `true`，屏幕阅读器每次添加新内容时都会朗读整个集合，可能会非常恼人。'
- en: Lastly, the `aria-relevant` is set to `additions`, as we don’t care about the
    entries being removed from the top. This setting is actually the default setting
    for this attribute, so, technically, it isn’t needed. In addition, assistive technology
    devices don’t have to support this attribute. Still, I’d rather list it than not.
    Other values are `removals`, `text`, and `all` (for all events). You can specify
    more than one, separated by a space.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`aria-relevant` 设置为 `additions`，因为我们不关心从顶部删除的条目。这实际上是此属性的默认设置，所以在技术上是不需要的。此外，辅助技术设备不必支持此属性。不过，我宁愿列出它而不是不列出。其他值包括
    `removals`、`text` 和 `all`（表示所有事件）。您可以用空格分隔多个值。
- en: This WAI-ARIA–enabled functionality was probably the one that impressed me the
    most. One of my first uses for fetching remote data, years ago, was to update
    a web page with information. It was frustrating to test the page with a screen
    reader (JAWS, at the time) and hear nothing but silence every time the page was
    updated. I can’t even imagine how frustrating it was for those who needed the
    functionality.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这个启用了 WAI-ARIA 功能的功能可能是给我留下印象最深刻的一个。很多年前，我首次使用远程数据获取，用于更新网页信息。当时，测试带屏幕阅读器（当时是
    JAWS）的页面时，每次页面更新都听到一片寂静，真是令人沮丧。我甚至无法想象那些需要这功能的人会有多么沮丧。
- en: Now we have it, and it’s so easy to use. It’s a win-win.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有它了，使用起来非常简单。这是一举两得。
