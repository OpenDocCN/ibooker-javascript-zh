- en: Chapter 7\. Concurrent React
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '第 7 章. 并发 React  '
- en: In the previous chapter, we delved deep into the world of server-side rendering
    with React. We examined the importance of server-side rendering for improving
    the performance and user experience of our applications, especially in the context
    of modern web development. We explored different server rendering APIs, such as
    `renderToString` and `renderToPipeableStream`, and discussed their use cases and
    benefits. We also touched upon the challenges of implementing server-side rendering
    and how it’s better to rely on established frameworks like Next.js and Remix to
    handle the complexities for us.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '在上一章中，我们深入探讨了使用 React 进行服务器端渲染的世界。我们探讨了服务器端渲染对于提高应用程序性能和用户体验的重要性，尤其是在现代 Web
    开发背景下。我们探讨了不同的服务器渲染 API，例如 `renderToString` 和 `renderToPipeableStream`，并讨论了它们的用例和优势。我们还触及了实施服务器端渲染的挑战，以及依赖像
    Next.js 和 Remix 这样的成熟框架来处理这些复杂性的重要性。  '
- en: We covered the concept of hydration and its significance in connecting server-rendered
    markup with client-side React components, creating a seamless user experience.
    Additionally, we discussed the potential security issues and challenges that come
    with managing multiple client connections in a serverful environment, emphasizing
    the need for using frameworks that handle these concerns effectively.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '我们讨论了水合和其在将服务器渲染的标记与客户端 React 组件连接中的重要性，从而创建无缝的用户体验。此外，我们还讨论了在服务器环境中管理多个客户端连接时可能出现的潜在安全问题和挑战，强调了使用能有效处理这些问题的框架的必要性。  '
- en: Now, as we transition to the next concurrent React—we will build upon our understanding
    of all that we’ve learned so far. We will dive into the Fiber reconciler and learn
    about the concurrent features of React, as well as how efficiently it manages
    updates and rendering. By examining scheduling, deferring updates, and render
    lanes, we’ll gain insights into the performance optimizations made possible by
    React’s core architecture.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，随着我们迈向下一个并发 React——我们将建立在我们迄今所学的一切的基础上。我们将深入了解 Fiber 协调器，并学习 React 的并发特性，以及它如何高效地管理更新和渲染。通过研究调度、推迟更新和渲染通道，我们将深入了解
    React 核心架构所可能实现的性能优化。  '
- en: Note
  id: totrans-4
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: '注  '
- en: Once again, it’s worth noting that Fiber itself and the things we’re about to
    discuss are implementation details in React that are likely to change and that
    you don’t need to know to use React effectively. However, learning the underlying
    mechanisms will help you better understand how React works and how to use it effectively,
    while also making you more knowledgeable as an engineer in general.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '再次强调，Fiber 本身以及我们即将讨论的事物是 React 中的实现细节，可能会发生变化，并且您并不需要深入了解它们来有效使用 React。然而，了解底层机制将帮助您更好地理解
    React 的工作原理和有效使用方法，同时也会使您作为工程师更加有见识。  '
- en: With that, let’s embark on our journey into the fascinating world of concurrent
    React, as we continue to build on our expertise and discover new ways to harness
    the power of React for creating high-performance applications.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '有了这些，让我们踏上我们进入并发 React 的迷人世界的旅程，继续在我们的专业知识上建立，并发现使用 React 创造高性能应用的新方法。  '
- en: The Problem with Synchronous Rendering
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '同步渲染的问题  '
- en: To recap, the problem with synchronous rendering is that it blocks the main
    thread, which can lead to a poor user experience. This is especially true for
    complex applications with many components and frequent updates. In such cases,
    the UI can become unresponsive, resulting in a frustrating user experience.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '总结一下，同步渲染的问题在于它阻塞了主线程，这可能导致用户体验不佳。对于具有许多组件和频繁更新的复杂应用程序尤其如此。在这种情况下，UI 可能变得无响应，导致令人沮丧的用户体验。  '
- en: 'A typical mitigation step to this problem is to batch a series of updates into
    one update and minimize work done on the main thread: instead of processing 10
    things 10 times, batch them and process them once. We covered batching in [Chapter 4](ch04.html#ch04),
    so we won’t go into more detail here, but for the purposes of our discussion,
    it’s important to understand that batching is a mitigation step to these problems,
    but even that has limitations, as we’ll uncover in the next few paragraphs.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的典型缓解措施是将一系列更新批处理成一个更新，并尽量减少在主线程上的工作：不是对 10 个事物进行 10 次处理，而是将它们批处理并处理一次。我们在
    [第 4 章](ch04.html#ch04) 中讨论了批处理，所以我们在这里不再详细展开，但是为了我们的讨论目的，理解批处理是解决这些问题的一种缓解措施是很重要的，但即使如此，它也有其局限性，我们将在接下来的几段中揭示。
- en: The problems we’ve been talking about, even with batching, are further compounded
    by the fact that by design, synchronous rendering has no sense of priority. It
    treats all updates equally, regardless of their visibility. For example, with
    sync rendering you may block the main thread with rendering work for items that
    the user can’t see, such as tabs that aren’t visible, content behind a modal,
    or content in a loading state. You still want those items to render if there is
    CPU available, but you want to prioritize rendering the thing the user can see
    and interact with. Before React had concurrent features, we often had situations
    where critical updates were blocked by less important ones, resulting in a poor
    user experience.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 即使通过批处理，我们所讨论的问题，由于同步渲染的设计特性，进一步加剧了。同步渲染对所有更新都没有优先级的概念。它平等地处理所有更新，无论其可见性如何。例如，使用同步渲染，您可能会阻塞主线程进行用户看不到的项目的渲染工作，比如未显示的选项卡、模态框后面的内容或加载状态中的内容。如果有
    CPU 可用，仍然希望这些项目能够渲染，但希望优先渲染用户能够看到和交互的内容。在 React 拥有并发特性之前，我们经常遇到关键更新被较不重要的更新所阻塞，导致用户体验不佳。
- en: With concurrent rendering, React can prioritize updates based on their importance
    and urgency, ensuring that critical updates are not blocked by less important
    ones. This allows React to maintain a responsive UI even under heavy load, resulting
    in a better user experience. For example, when a user hovers over or clicks on
    a button, the expectation is that it immediately shows feedback for that action.
    If React is working on rerendering a long list of items, then the hover or active
    state feedback will be delayed until the entire list is rendered. With concurrent
    rendering, rendering tasks that are CPU bound and CPU intensive can be given a
    back seat to rendering tasks that are more important, such as user interactions
    and animations.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 通过并发渲染，React 可以根据更新的重要性和紧急性优先处理更新，确保关键更新不被较不重要的更新所阻塞。这使得 React 在高负载下依然能保持响应式的用户界面，从而提升用户体验。例如，当用户悬停或点击按钮时，期望立即显示相应的反馈。如果
    React 正在重新渲染一长串项目列表，则悬停或活动状态的反馈会延迟到整个列表渲染完成之后才显示出来。通过并发渲染，CPU 密集型的渲染任务可以暂时让位于更重要的渲染任务，如用户交互和动画效果。
- en: 'Moreover, with the concurrent rendering capabilities, React is able to time
    slice: that is, it can break up the rendering process into smaller chunks and
    process them incrementally. This allows React to perform work over multiple frames,
    and if the work needs to be interrupted, it can be.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，有了并发渲染的能力，React 能够进行时间分片：即将渲染过程分解为较小的片段并逐步处理它们。这使得 React 能够跨多帧执行工作，并且如果需要中断工作，也可以实现。
- en: We’ll dive into all of this together starting now.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们将共同深入探讨所有这些内容。
- en: Revisiting Fiber
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视 Fiber
- en: As covered in [Chapter 4](ch04.html#ch04), the Fiber reconciler is the core
    mechanism in React that enables concurrent rendering. It was introduced in React
    16 and represented a significant architectural shift from the previous stack reconciler.
    The primary goal of the Fiber reconciler is to improve the responsiveness and
    performance of React applications, particularly for large and complex UIs.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [第四章](ch04.html#ch04) 所述，Fiber 协调器是 React 中实现并发渲染的核心机制。它在 React 16 中引入，代表了与之前的堆栈协调器相比的重大架构转变。Fiber
    协调器的主要目标是提高大型和复杂 UI 的响应性能。
- en: The Fiber reconciler achieves this by breaking the rendering process into smaller,
    more manageable units of work called Fibers. This allows React to pause, resume,
    and prioritize rendering tasks, making it possible to defer or schedule updates
    based on their importance. This improves the responsiveness of the application
    and ensures that critical updates are not blocked by less important tasks.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Fiber 协调器通过将渲染过程拆分为更小、更可管理的工作单元（称为 Fibers）来实现这一点。这使得 React 能够暂停、恢复和优先处理渲染任务，从而可以根据其重要性推迟或调度更新。这提高了应用的响应能力，并确保关键更新不会被较不重要的任务所阻塞。
- en: Scheduling and Deferring Updates
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调度和推迟更新
- en: React’s ability to schedule and defer updates is crucial for maintaining a responsive
    application. The Fiber reconciler enables this functionality by relying on a scheduler
    and a number of efficient APIs. These APIs allow React to perform work during
    idle periods and schedule updates at the most opportune times.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: React 能够调度和推迟更新的能力对于保持应用的响应能力至关重要。Fiber 协调器通过依赖调度器和一些高效的 API 实现了这一功能。这些 API
    允许 React 在空闲期间执行工作，并在最合适的时间安排更新。
- en: 'We’ll dive into the scheduler in more detail in upcoming sections, but for
    now, consider it to be exactly what it sounds like: a system that receives updates
    and says, “you do this now,” “you do this later,” etc., using browser APIs like
    `setTimeout`, `MessageChannel`, and others.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节更详细地探讨调度器，但现在可以将其视为它听起来的样子：一个接收更新并说“现在做这个”，“稍后做这个”等的系统，使用浏览器的 API，如
    `setTimeout`，`MessageChannel` 等。
- en: Consider a real-time chat application where users can send and receive messages.
    We will have a chat component that displays a list of messages, and a message
    input component where users can type and submit their messages. Additionally,
    the chat application receives new messages from the server in real time. In this
    scenario, we want to prioritize user interactions (typing and submitting messages)
    to maintain a responsive experience, while ensuring that incoming messages are
    rendered efficiently without blocking the UI.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个实时聊天应用程序，用户可以发送和接收消息。我们将有一个聊天组件，显示消息列表，以及一个消息输入组件，用户可以输入并提交他们的消息。此外，聊天应用程序实时从服务器接收新消息。在这种情况下，我们希望优先考虑用户交互（输入和提交消息），以保持响应式体验，同时确保新消息能够高效地渲染，而不阻塞用户界面。
- en: 'To make this example a little more concrete, let’s create some components.
    First, a list of messages:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个例子更具体化，让我们创建一些组件。首先是消息列表：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we have a message input component that allows users to type and submit
    messages:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个消息输入组件，允许用户输入和提交消息：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Finally, we have a chat component that combines the two components and handles
    the logic for sending and receiving messages:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个聊天组件，结合了这两个组件，并处理发送和接收消息的逻辑：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, React’s concurrent rendering capabilities come into play by
    efficiently managing the updates of both the message list and the user’s interactions
    with the message input. When a user types or submits a message, React prioritizes
    the text input updates above other updates to ensure a smooth user experience.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，React 的并发渲染能力发挥作用，通过高效地管理消息列表的更新和用户与消息输入的交互。当用户输入或提交消息时，React 优先处理文本输入更新，以确保流畅的用户体验。
- en: 'When new messages arrive from the server and need to be rendered, they are
    rendered in the default/unknown render lane, which updates the DOM synchronously
    and instantly in a blocking manner: this would delay any user input. If we want
    rendering the new list of messages to be de-prioritized, we can wrap the corresponding
    state update in a `startTransition` function from the `useTransition` hook, like
    so:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当从服务器接收到新消息并需要渲染时，它们会在默认/未知的渲染通道中渲染，这会同步且立即地阻塞 DOM：这会延迟任何用户输入。如果我们希望渲染新的消息列表的优先级较低，我们可以将相应的状态更新包装在
    `useTransition` 钩子的 `startTransition` 函数中，如下所示：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With this, we signal to React to schedule the message list updates with a lower
    priority and render them without blocking the UI, allowing the chat application
    to function efficiently, even under heavy load. Thus, user input is never interrupted,
    and incoming messages are rendered with a lower priority than user interactions
    since they are less critical to the user experience.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们向 React 发出信号，以较低的优先级安排消息列表更新，并在不阻塞用户界面的情况下渲染它们，使聊天应用程序能够在高负载下高效运行。因此，用户输入不会被打断，而新消息的渲染优先级低于用户交互，因为它们对用户体验的重要性较小。
- en: This example demonstrates how React’s concurrent rendering capabilities can
    be leveraged to build responsive applications that handle complex interactions
    and frequent updates without compromising on performance or user experience. We
    will dive deeper into `useTransition` further in this chapter. For now, let’s
    look a little deeper at how, exactly, React schedules updates.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了如何利用 React 的并发渲染能力来构建响应式应用程序，处理复杂的交互和频繁的更新，同时不影响性能或用户体验。我们将在本章节后面深入讨论
    `useTransition`。现在，让我们稍微深入了解一下，React 如何精确地安排更新。
- en: Diving Deeper
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入探讨
- en: 'In React, the process of scheduling, prioritizing, and deferring updates is
    essential to maintaining a responsive user interface. This process ensures that
    high-priority tasks are addressed promptly, while low-priority tasks can be deferred,
    allowing the UI to remain smooth even under heavy load. To delve deeper into this
    topic, we’ll examine several core concepts: the scheduler, the priority levels
    of tasks, and the mechanisms that defer updates.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 中，调度、优先级和延迟更新的过程对于维护响应式用户界面至关重要。该过程确保高优先级任务得到及时处理，而低优先级任务可以延迟处理，从而使
    UI 在高负载下保持流畅。为了深入探讨这个主题，我们将研究几个核心概念：调度器、任务的优先级以及推迟更新的机制。
- en: Note
  id: totrans-34
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Before we proceed—let’s remind ourselves one more time that the information
    covered here consists of implementation details and is *not requisite to using
    React*. However, understanding these concepts will help you better understand
    how React works and how to use it effectively, while also teaching you the underlying
    mechanism that you can apply in other engineering endeavors, improving your overall
    skill set. With that in mind, let’s proceed.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前——让我们再次提醒自己，这里涵盖的信息包括实现细节，*并非使用 React 的必要条件*。然而，理解这些概念将帮助您更好地理解 React
    的工作原理以及如何有效使用它，同时教授您可以应用于其他工程任务中的基础机制，提升整体技能水平。有了这个想法，让我们继续。
- en: The Scheduler
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调度器
- en: At the core of React’s architecture, the scheduler is a standalone package that
    provides timing-related utilities, independent of the Fiber reconciler. React
    uses this scheduler within the reconciler. The scheduler and reconciler, through
    the usage of render lanes, enable tasks to cooperate by prioritizing and organizing
    them based on their urgency. We will dive deep into render lanes shortly. The
    scheduler’s primary role in React today is to manage the yielding of the main
    thread, mainly by scheduling microtasks to ensure smooth execution.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 架构的核心，调度器是一个独立的包，提供与时间相关的实用程序，与 Fiber 协调器无关。React 在协调器内部使用这个调度器。通过使用渲染通道，调度器和协调器使任务能够通过优先级和组织方式进行协作，根据它们的紧迫性。我们将很快深入研究渲染通道。调度器在今天的
    React 中的主要作用是管理主线程的让出，主要通过调度微任务来确保平滑执行。
- en: 'To understand this in a little more detail, let’s look at a portion of React’s
    source code at the time of writing:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更详细地了解这一点，让我们看一下 React 源代码的部分内容：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `ensureRootIsScheduled` function in React’s codebase plays a crucial role
    in managing the rendering process. When a React root, represented by `root: FiberRoot`,
    receives an update, this function is called to perform two critical actions. Remember
    from [Chapter 4](ch04.html#ch04): a React root is the final “swap” that happens
    during the commit phase to make updates.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '在 React 代码库中，`ensureRootIsScheduled` 函数在管理渲染过程中扮演着至关重要的角色。当 React 根据 `root:
    FiberRoot` 接收到更新时，调用此函数执行两个关键操作。请回忆[第四章](ch04.html#ch04)：React 根是在提交阶段发生的最后一次“交换”，以完成更新。'
- en: 'When `ensureRootIsScheduled` is called, it confirms that the root is included
    in the root schedule: a list that tracks which roots need to be processed. Secondly,
    it ensures the existence of a pending microtask dedicated to processing this root
    schedule.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `ensureRootIsScheduled` 时，它确认将根包含在根调度列表中：跟踪需要处理的根。其次，它确保存在一个专用于处理此根调度的待处理微任务。
- en: 'A microtask is a concept in JavaScript event-loop management, representing
    a type of task that is managed by the microtask queue. To understand microtasks,
    it’s important to first have a basic grasp of the JavaScript event loop and the
    task queues associated with it:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 微任务是 JavaScript 事件循环管理中的一个概念，表示由微任务队列管理的一种任务类型。要理解微任务，首先需要基本了解 JavaScript 事件循环及其相关的任务队列：
- en: Event loop
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环
- en: 'The JavaScript engine uses an event loop to manage asynchronous operations.
    The event loop continuously checks if there’s any work (like executing a callback)
    that needs to be done. It operates on two kinds of task queues: the task queue
    (macro task queue) and the microtask queue.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 引擎使用事件循环来管理异步操作。事件循环不断检查是否有工作（如执行回调）需要完成。它操作两种任务队列：任务队列（宏任务队列）和微任务队列。
- en: Task queue (macro task queue)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 任务队列（宏任务队列）
- en: This queue holds tasks such as handling events, executing `setTimeout` and `set​Interval`
    callbacks, and performing I/O operations. Tasks in this queue are processed one
    at a time, and the next task is picked up only after the current one is completed.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 该队列包含处理事件、执行`setTimeout`和`setInterval`回调以及执行I/O操作等任务。这些任务逐个处理，只有在当前任务完成后才会继续下一个任务。
- en: Microtask queue
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 微任务队列
- en: A microtask is a smaller, more immediate task. Microtasks arise from operations
    like promises, `Object.observe`, and `MutationObserver`. They are stored in the
    microtask queue, which is different from the regular task queue.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 微任务是一种更小、更即时的任务。微任务源自诸如promises、`Object.observe`和`MutationObserver`等操作。它们存储在微任务队列中，这与常规任务队列不同。
- en: Execution
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 执行
- en: Microtasks are processed at the end of the current task, before the JavaScript
    engine picks up the next (macro) task from the task queue. After executing a task,
    the engine checks if there are any microtasks in the microtask queue and executes
    them all before moving on. This ensures that microtasks are processed quickly
    and in order, just after the currently executing script and before any other tasks,
    like rendering or handling events.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 微任务在当前任务结束之前处理，然后JavaScript引擎从任务队列中获取下一个（宏）任务。执行完任务后，引擎会检查微任务队列中是否有任何微任务，并在继续之前执行它们。这确保微任务快速且有序地处理，就在当前脚本执行之后，但在其他任务（如渲染或处理事件）之前。
- en: Characteristics and usage
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 特点和用法
- en: Microtasks have higher priority over other tasks in the task queue, meaning
    they are executed before moving on to the next macro task. If a microtask continuously
    adds more microtasks to the queue, it can lead to a situation where the task queue
    never gets processed. This is known as *starvation*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 微任务在任务队列中具有更高的优先级，这意味着它们在继续执行下一个宏任务之前会被执行。如果一个微任务不断向队列中添加更多微任务，可能会导致任务队列永远不会被处理。这被称为*饥饿*。
- en: In the context of React and the `ensureRootIsScheduled` function, a microtask
    is used to ensure that the processing of the root schedule happens promptly and
    with high priority, right after the current script execution and before the browser
    performs other tasks like rendering or handling events. This helps in maintaining
    smooth UI updates and efficient task management within the React framework.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在React和`ensureRootIsScheduled`函数的背景下，微任务用于确保根调度的处理迅速且具有高优先级，就在当前脚本执行之后，但在浏览器执行其他任务（如渲染或处理事件）之前。这有助于在React框架内保持平滑的UI更新和高效的任务管理。
- en: The function starts by adding the root to the schedule. This involves checking
    if the root is either the last scheduled one or already present in the schedule.
    If it’s not present, the function adds the root to the end of the schedule, updating
    the `lastScheduledRoot` to point to the current root. If no root was previously
    scheduled (`lastScheduledRoot === null`), the current root becomes both the first
    and the last in the schedule.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数首先将根节点添加到调度中。这涉及检查根节点是否是最后一个被调度的节点或已经存在于调度中。如果不存在，函数将根节点添加到调度末尾，并更新`lastScheduledRoot`指向当前根节点。如果之前没有调度过根节点（`lastScheduledRoot
    === null`），当前根节点将成为调度中的第一个和最后一个节点。
- en: Next, the function sets the flag `mightHavePendingSyncWork` to `true`. This
    flag signals that there might be synchronous work pending, essential for the `flushSync`
    function, which we’ll cover in the next section.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，该函数将标志`mightHavePendingSyncWork`设置为`true`。该标志表示可能有同步工作待处理，这对于`flushSync`函数至关重要，我们将在下一节中介绍。
- en: The function then ensures that a microtask is scheduled to process the root
    schedule. This is done by calling `scheduleImmediateTask(processRootScheduleInMicrotask)`.
    This scheduling happens both within and outside of React’s `act` testing utility
    scope, indicated by `__DEV__` and `ReactCurrentActQueue.current`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，该函数确保安排一个微任务来处理根节点的调度。这是通过调用`scheduleImmediateTask(processRootScheduleInMicrotask)`来实现的。这种调度既发生在React的`act`测试实用程序范围内，也发生在其范围之外，由`__DEV__`和`ReactCurrentActQueue.current`指示。
- en: Another significant part of this function is the conditional block checking
    the `enableDeferRootSchedulingToMicrotask` flag. If this flag is disabled, the
    function schedules the render task immediately instead of deferring it to a microtask.
    This part is marked with a `TODO` comment (at the time of writing), indicating
    future plans to enable this feature for unlocking additional functionalities.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的另一个重要部分是条件块，检查 `enableDeferRootSchedulingToMicrotask` 标志。如果此标志已禁用，函数将立即安排渲染任务，而不是推迟到微任务。这部分带有一个
    `TODO` 注释（截至撰写时），指示未来计划启用此功能，以解锁额外的功能。
- en: Finally, the function includes a condition for handling legacy updates within
    React’s `act` utility. This is specific to testing scenarios where updates are
    batched differently, and it records whenever a legacy update is scheduled.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，函数包括一个处理 React `act` 实用程序中传统更新的条件。这是针对测试场景的特定处理，其中更新以不同方式批处理，并记录每当安排传统更新时。
- en: The long and short of this is that `ensureRootIsScheduled` is a sophisticated
    function that integrates several aspects of React’s scheduling and rendering logic,
    focusing on efficiently managing updates to React roots and ensuring smooth rendering
    by strategically scheduling tasks and microtasks.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 长话短说，`ensureRootIsScheduled` 是一个复杂的函数，集成了 React 调度和渲染逻辑的几个方面，重点是通过策略性调度任务和微任务，有效管理对
    React 根的更新，并确保平滑渲染。
- en: 'From this, we understand the role of the scheduler in React: scheduling work
    based on the render lanes that work falls into. We get pretty deep into lanes
    in the next section, but for now, suffice it to say that lanes are indicative
    of an update’s priority.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 从中我们可以理解 React 中调度器的角色：根据工作落入的渲染 lane 进行工作调度。在接下来的部分中，我们会深入探讨 lane，但现在只需知道 lane
    表示更新的优先级即可。
- en: 'If we model the scheduler’s behavior in code, it would look like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用代码建模调度器的行为，会像这样：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'From this, we see that:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 从中我们可以看到：
- en: If the next lane is `Sync`, then the scheduler queues a microtask to process
    the next lane immediately. Ideally, by now we understand what microtasks are and
    how this fits.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果下一个 lane 是`Sync`，那么调度器会将一个微任务排队，立即处理下一个 lane。理想情况下，我们现在应该理解微任务是什么及其如何适用。
- en: If the next lane is not `Sync`, then the scheduler schedules a callback and
    processes the next lane.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果下一个 lane 不是`Sync`，那么调度器会安排一个回调并处理下一个 lane。
- en: 'Thus, the scheduler is exactly what it sounds like: a system that schedules
    functions to run determined by that function’s lane. OK, we’ve been talking about
    lanes for a while. Let’s dive in and understand them in detail!'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，调度器确实如其名：一个根据函数 lane 调度运行函数的系统。好了，我们已经讨论了一段时间的 lane。让我们深入了解并详细理解它们！
- en: Render Lanes
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染 Lane
- en: Render lanes are an essential part of React’s scheduling system, which ensures
    efficient rendering and prioritization of tasks. A lane is a unit of work that
    represents a priority level and can be processed by React as part of its rendering
    cycle. The concept of render lanes was introduced in React 18, replacing the previous
    scheduling mechanism that used expiration times. Let’s dive into the details of
    render lanes, how they work, and their underlying representation as bitmasks.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染 lane 是 React 调度系统的重要组成部分，确保任务的高效渲染和优先级排序。一个 lane 是一个工作单元，代表一个优先级级别，并可以作为
    React 渲染周期的一部分进行处理。渲染 lane 的概念是在 React 18 中引入的，取代了先前使用过期时间的调度机制。让我们深入了解渲染 lane
    的细节、工作原理以及其作为位掩码的底层表示。
- en: Note
  id: totrans-69
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Once again, these are implementation details in React that may change at any
    time. The point here is to understand the underlying mechanism that will help
    us in our everyday engineering work, and will also help us understand how React
    works and enable us to use it more effectively or fluently. It would serve us
    well to not get hung up on the details, but to instead stick to the mechanism
    and its potential for real-world application.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这些是 React 中的实现细节，随时可能会更改。这里的重点是理解这些底层机制，这将有助于我们在日常工程工作中，也将帮助我们理解 React
    的工作方式，并使我们能够更有效或更流畅地使用它。最好不要被细节困扰，而是坚持机制及其在实际应用中的潜力。
- en: First off, a render lane is a lightweight abstraction that React uses to organize
    and prioritize updates that need to be made during the rendering process.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，渲染 lane 是 React 使用的轻量级抽象，用于组织和优先处理渲染过程中需要进行的更新。
- en: 'For example, when you call `setState`, that update is put into a lane. We can
    understand the different priorities based on the context of the updates, like
    so:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当你调用 `setState` 时，该更新被放入一个通道中。我们可以根据更新的上下文理解不同的优先级，如下所示：
- en: If `setState` is called inside of a click handler, it is put into the Sync lane
    (highest priority) and scheduled in a microtask.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在点击处理程序内部调用 `setState`，它将被放入同步通道（最高优先级），并在微任务中调度。
- en: If `setState` is called inside a transition from `startTransition`, it’s put
    in a transition lane (lower priority) and scheduled in a microtask.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在 `startTransition` 过渡内部调用 `setState`，它将放入一个过渡通道（较低优先级）并在微任务中调度。
- en: 'Each lane corresponds to a specific priority level, with higher-priority lanes
    processed before lower-priority lanes. Some examples of lanes in React are:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 每个通道对应于特定的优先级级别，高优先级通道在低优先级通道之前处理。在React中，一些通道的示例包括：
- en: '`SyncHydrationLane`'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`SyncHydrationLane`'
- en: When users click on a React app during hydration, the click event is put into
    this lane.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在水合期间用户点击React应用时，点击事件被放入此通道。
- en: '`SyncLane`'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`SyncLane`'
- en: When users click on a React app, the click event is put into this lane.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击React应用时，点击事件被放入此通道。
- en: '`InputContinuousHydrationLane`'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`InputContinuousHydrationLane`'
- en: Hover events, scroll events, and other continuous events during hydration are
    put into this lane.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 悬停事件、滚动事件以及水合期间的其他连续事件被放入此通道。
- en: '`InputContinuousLane`'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`InputContinuousLane`'
- en: Same as the preceding, but for after a React app is hydrated.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前相同，但是在React应用程序水合后。
- en: '`DefaultLane`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`DefaultLane`'
- en: Any updates from the network, timers like `setTimeout`, and the initial render
    where priority isn’t inferred are put into this lane.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 从网络上的任何更新、像 `setTimeout` 这样的定时器，以及优先级无法推断的初始渲染都放入此通道。
- en: '`TransitionHydrationLane`'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`TransitionHydrationLane`'
- en: Any transitions from `startTransition` during hydration are put into this lane.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`startTransition` 期间的任何过渡都放入此通道。'
- en: '`TransitionLanes` (1–15)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`TransitionLanes`（1–15）'
- en: Any transitions from `startTransition` after hydration are put into these lanes.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`startTransition` 后的任何过渡都放入这些通道。'
- en: '`RetryLanes` (1–4)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`RetryLanes`（1–4）'
- en: Any Suspense retries are put into these lanes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 任何Suspense重试都放入这些通道。
- en: It’s worth noting that these lanes are indicative of React’s internal implementation
    at the time of writing and are subject to change. To reiterate, the point of this
    book is to understand the *mechanism* by which React works without being too married
    to the exact implementation details, so the names of lanes likely don’t matter
    too much. What matters infinitely more is our understanding of the mechanism—that
    is, how React uses the concept—and how we can apply it to our work.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，这些通道表示了撰写时React的内部实现，并可能会更改。再次强调，本书的重点是理解React工作的*机制*，而不是过于依赖确切的实现细节，因此通道名称可能并不重要。更重要的是我们对机制的理解——即React如何使用这个概念，以及我们如何将其应用到工作中。
- en: How Render Lanes Work
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染通道的工作原理
- en: When a component updates or a new component is added to the render tree, React
    assigns a lane to the update based on its priority using the lanes we previously
    discussed. As we know, the priority is determined by the type of update (e.g.,
    user interaction, data fetching, or background task) and other factors, such as
    the component’s visibility.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件更新或新组件添加到渲染树时，React根据其优先级使用我们之前讨论过的通道为更新分配通道。正如我们所知，优先级由更新的类型（例如，用户交互、数据获取或后台任务）和其他因素（例如组件的可见性）确定。
- en: 'React then uses the render lanes to schedule and prioritize updates in the
    following manner:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，React使用渲染通道按以下方式安排和优先处理更新：
- en: 1. Collect updates
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 收集更新
- en: React collects all the updates that have been scheduled since the last render
    and assigns them to their respective lanes based on their priority.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: React收集自上次渲染以来已安排的所有更新，并根据其优先级将它们分配到各自的通道中。
- en: 2\. Process lanes
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 流程通道
- en: React processes the updates in their respective lanes, starting with the highest
    priority lane. Updates in the same lane are batched together and processed in
    a single pass.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: React按其各自的通道处理更新，从最高优先级通道开始。同一通道中的更新被批处理在一起，并在单次处理中处理。
- en: 3\. Commit phase
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 提交阶段
- en: After processing all the updates, React enters the commit phase, where it applies
    the changes to the DOM, runs effects, and performs other finalization tasks.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 处理所有更新后，React进入提交阶段，在此阶段应用更改到DOM，运行效果，并执行其他完成任务。
- en: 4\. Repeat
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. 重复
- en: The process repeats for each render, ensuring that updates are always processed
    in priority order, and that high-priority updates are not starved by lower-priority
    ones.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 每次渲染都会重复这个过程，确保更新始终按优先级顺序处理，并且高优先级的更新不会被低优先级的更新所抢占。
- en: React takes care of assigning updates to the correct lanes based on these priorities,
    allowing the application to function efficiently without manual intervention.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: React 根据这些优先级将更新分配到正确的 lane 中，使得应用程序能够在不需要开发者手动干预的情况下高效运行。
- en: 'When an update is triggered, React performs the following steps to determine
    its priority and assign it to the correct lane:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当触发更新时，React 执行以下步骤来确定其优先级并将其分配到正确的 lane 中：
- en: 1. Determine the update’s context
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 确定更新的上下文
- en: React evaluates the context in which the update was triggered. This context
    could be a user interaction, an internal update due to state or props changes,
    or even an update that’s a result of a server response. The context plays a crucial
    role in determining the priority of the update.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: React 评估触发更新的上下文。这个上下文可以是用户交互，由于状态或 props 变化而导致的内部更新，甚至是由服务器响应导致的更新。上下文在确定更新优先级方面起着关键作用。
- en: 2\. Estimate priority based on the context
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 根据上下文估计优先级
- en: Based on the context, React estimates the priority of the update. For instance,
    if the update is a result of user input, it’s likely to have a higher priority,
    while an update triggered by a noncritical background process might have a lower
    priority. We’ve already discussed the different priority levels in detail, so
    we won’t go into more detail here.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上下文，React 估计更新的优先级。例如，如果更新是用户输入的结果，则可能具有较高的优先级，而由非关键后台进程触发的更新可能具有较低的优先级。我们已经详细讨论了不同的优先级级别，所以在这里我们不会再详细讨论。
- en: 3\. Check for any priority overrides
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 检查是否有任何优先级覆盖
- en: In some cases, developers can explicitly set the priority of an update using
    React’s `useTransition` or `useDeferredValue` hooks. If such a priority override
    is present, React will consider the provided priority instead of the estimated
    one.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，开发者可以使用 React 的 `useTransition` 或 `useDeferredValue` hooks 明确设置更新的优先级。如果存在这样的优先级覆盖，React
    将考虑提供的优先级而不是估计的优先级。
- en: 4\. Assign the update to the correct lane
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. 将更新分配到正确的 lane 中
- en: Once the priority is determined, React assigns the update to the corresponding
    lane. This process is done using the bitmask we just looked at, which allows React
    to efficiently work with multiple lanes and ensure that updates are correctly
    grouped and processed.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定了优先级，React 将更新分配给相应的 lane。这个过程使用我们刚刚查看的位掩码完成，它允许 React 高效地处理多个 lane，并确保更新被正确地分组和处理。
- en: Throughout this process, React relies on its internal heuristics and the context
    in which updates occur to make informed decisions about their priorities. This
    dynamic assignment of priorities and lanes allows React to balance responsiveness
    and performance, ensuring that applications function efficiently without manual
    intervention from developers.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个过程中，React 依赖其内部启发式算法和更新发生的上下文来做出关于它们优先级的知情决策。这种动态分配优先级和 lane 的方法使得 React
    能够在不需要开发者手动干预的情况下平衡响应性和性能，确保应用程序高效运行。
- en: Let’s look into how exactly React processes updates in their respective lanes.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看 React 如何精确处理其各自 lane 中的更新。
- en: Processing Lanes
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理 Lanes
- en: 'Once updates have been assigned to their respective lanes, React processes
    them in priority order. In our chat application example, React would process updates
    in the following order:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦更新被分配到它们各自的 lane 中，React 将按照优先级顺序处理它们。在我们的聊天应用示例中，React 将按以下顺序处理更新：
- en: '`ImmediatePriority`'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImmediatePriority`'
- en: Process updates to the message input, ensuring it remains responsive and updates
    quickly.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 处理消息输入的更新，确保保持响应性并快速更新。
- en: '`UserBlockingPriority`'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserBlockingPriority`'
- en: Process updates to the typing indicator, providing users with real-time feedback.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 处理打字指示器的更新，为用户提供实时反馈。
- en: '`NormalPriority`'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`NormalPriority`'
- en: Process updates to the message list, displaying new messages and updates at
    a reasonable pace.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 处理消息列表的更新，以合理的速度显示新消息和更新。
- en: By processing updates in priority order, React ensures that the most important
    parts of the application remain responsive even under heavy load.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通过按优先级顺序处理更新，React 确保应用程序的最重要部分即使在负载较重的情况下也能保持响应性。
- en: Commit Phase
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提交阶段
- en: After processing all the updates in their respective lanes, React enters the
    commit phase, where it applies the changes to the DOM, runs effects, and performs
    other finalization tasks. In our chat application example, this might include
    updating the message input value, showing or hiding the typing indicator, and
    appending new messages to the message list. React then moves on to the next render
    cycle, repeating the process of collecting updates, processing lanes, and committing
    changes.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理各自车道中的所有更新后，React 进入提交阶段，在此阶段将这些更改应用于 DOM，运行效果，并执行其他的完成任务。在我们的聊天应用示例中，这可能包括更新消息输入值，显示或隐藏输入指示器，以及将新消息追加到消息列表中。React
    然后继续到下一个渲染周期，重复收集更新、处理车道和提交更改的过程。
- en: 'This process, however, is exceedingly more complex than we can truly appreciate
    in this book: there are concepts like *entanglement*, which decides when two lanes
    need to be processed together, and further concepts like *rebasing*, which decides
    when an update needs to be rebased on top of updates that have already been processed.
    Rebasing is useful, for example, in cases where a transition is interrupted by
    a sync update before it finished, and you need to run both together.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个过程比我们在本书中真正能够欣赏到的要复杂得多：有像*纠缠*这样的概念，它决定何时需要一起处理两条车道，以及像*重基*这样的进一步概念，它决定何时需要将更新重新基于已经处理过的更新之上。例如，在过渡被同步更新中断之前，需要同时运行两者时，重基就非常有用。
- en: There’s also a lot to say here about flushing effects. For example, like when
    there is a synchronous update, React may flush effects before/after the update
    to ensure consistent ordering of state between sync updates.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 还有很多关于刷新效果的话题值得讨论。例如，当存在同步更新时，React 可能会在更新之前/之后刷新效果，以确保状态在同步更新之间的一致排序。
- en: 'Ultimately, this is why React exists, and the true value React adds behind
    the scenes as an abstraction layer: it fundamentally handles the update problems,
    their prioritization, and their ordering for us, while we continue to focus on
    our applications.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，这就是 React 存在的原因，以及 React 作为一个抽象层在幕后为我们处理更新问题、它们的优先级和排序问题，而我们则继续专注于我们的应用程序。
- en: 'It’s important to note that while React is good at estimating priorities, it’s
    not always perfect. As a developer, you may sometimes need to override the default
    priority assignments using some of the APIs we’ve mentioned so far: `useTransition`
    and `useDeferredValue` to fine-tune your application’s performance and responsiveness.
    Let’s dive into these APIs in more detail.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，虽然 React 在估算优先级方面表现良好，但并不总是完美的。作为开发者，有时您可能需要使用我们迄今为止提到的一些 API：`useTransition`和`useDeferredValue`来覆盖默认的优先级分配，以微调应用程序的性能和响应能力。让我们更详细地探讨这些
    API。
- en: useTransition
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: useTransition
- en: '`useTransition` is a powerful React Hook that allows you to manage the priority
    of state updates in your components and prevent the UI from becoming unresponsive
    due to high-priority updates. It’s particularly useful when dealing with updates
    that can be visually disruptive, such as loading new data or navigating between
    pages.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`useTransition`是一个强大的 React Hook，允许你管理组件中状态更新的优先级，并防止由于高优先级更新而导致 UI 变得不响应。在处理可能对视觉有影响的更新，如加载新数据或在页面之间导航时，特别有用。'
- en: It essentially puts whatever update you wrap in its returned `startTransition`
    function into the transition lane, which is lower priority than the Sync lane
    as we’ve seen earlier, allowing you to control the timing of updates and maintain
    a smooth user experience, even when other higher-priority updates are competing
    for the main thread.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 它基本上是将你在其返回的`startTransition`函数中包装的任何更新放入转换车道中，该车道的优先级低于之前看到的同步车道，这允许你控制更新的时机，并在其他高优先级更新争夺主线程时保持平滑的用户体验。
- en: '`useTransition` is a hook, meaning you can only use it inside function components.
    It returns an array containing two elements:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`useTransition`是一个钩子，意味着你只能在函数组件内部使用它。它返回一个包含两个元素的数组：'
- en: '`isPending`'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`isPending`'
- en: 'A boolean indicating whether a transition is in progress. One interesting part
    about the way `useTransition` works is that the first thing it does when you call
    `startTransition` is schedule a sync `setState({ isPending: false })` on this
    property, which means updates depending on `isPending` need to be fast or it defeats
    the purpose of `useTransition`.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '一个布尔值，指示是否正在进行过渡。`useTransition`的一个有趣之处在于当您调用`startTransition`时，它首先在此属性上调度同步`setState({
    isPending: false })`，这意味着依赖于`isPending`的更新需要快速，否则就会失去`useTransition`的意义。'
- en: '`startTransition`'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`startTransition`'
- en: A function that you can use to wrap updates that should be deferred or given
    a lower priority.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用一个函数来包装那些应该延迟执行或者优先级较低的更新。
- en: It’s probably worth mentioning here that there is also a `startTransition` API
    that is available not as a hook, but as a regular function. The second way to
    start a nonurgent transition is by using the function `startTransition` imported
    directly from React. This approach doesn’t give us access to the `isPending` flag,
    but it’s available for places in your code when you can’t use hooks, like `useTransition`,
    but still want to signal a low-priority update to React.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里值得一提的是，还有一个名为 `startTransition` 的API，它不是作为钩子，而是作为一个普通函数可用。第二种启动非紧急转换的方法是使用直接从React导入的
    `startTransition` 函数。这种方法不会给我们提供 `isPending` 标志的访问，但它适用于代码中无法使用钩子（如 `useTransition`
    ）但仍希望向React信号低优先级更新的场合。
- en: Simple Example
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单示例
- en: 'Here’s a simple example that demonstrates the basic usage of `useTransition`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个简单的示例，演示了 `useTransition` 的基本用法：
- en: '[PRE6]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, we use `useTransition` to manage the priority of a state update
    that increments a counter. By wrapping the `setCount` update inside the `startTransition`
    function, we are telling React that this update can be deferred, preventing the
    UI from becoming unresponsive if there are other high-priority updates happening
    simultaneously.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用 `useTransition` 来管理一个状态更新的优先级，该更新会增加一个计数器。通过将 `setCount` 更新包装在 `startTransition`
    函数内部，我们告诉 React 可以延迟这个更新，防止UI在同时进行其他高优先级更新时变得无响应。
- en: 'Advanced Example: Navigation'
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级示例：导航
- en: '`useTransition` is also useful when navigating between pages. By managing the
    priority of updates related to navigation, you can ensure that the user experience
    remains smooth and responsive, even when dealing with complex page transitions.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`useTransition` 在页面导航时也很有用。通过管理与导航相关的更新的优先级，你可以确保用户体验保持流畅和响应，即使处理复杂的页面转换。'
- en: 'Consider this example where we demonstrate how to use `useTransition` for managing
    page transitions in a single-page application (SPA):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个示例，我们演示如何在单页应用程序（SPA）中使用 `useTransition` 来管理页面转换：
- en: '[PRE7]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, we have two simple components representing different pages
    in our SPA. We use `useTransition` to wrap the state update that changes the current
    page, ensuring that the page transition is deferred if there are other high-priority
    updates (like user input) happening simultaneously.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有两个简单的组件，代表SPA中的不同页面。我们使用 `useTransition` 来包装更改当前页面的状态更新，确保如果同时发生其他高优先级更新（如用户输入），页面转换会被延迟。
- en: In this example, you might be thinking, “Wait, shouldn’t the page transition
    be instant though since it happens in response to a user click?” Yes, you’d be
    right; however, if the next page requires some data to be fetched using `Suspense`,
    then the page transition might be delayed. This is where `useTransition` comes
    in handy, as it allows you to manage the priority of updates related to navigation,
    ensuring that the user experience remains smooth and responsive, even when dealing
    with complex page transitions. It’s worth noting that if the next page data fetching
    happens in an effect, then `startTranstion` won’t wait for the data in the effect
    to be fetched; however, when you suspend inside of a transition, React will tie
    the `isPending` state to the data fetch and the rendering of that data when it
    comes back.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你可能会想：“等等，点击用户后，页面转换不应该是即时的吗？” 是的，你是对的；然而，如果下一页需要使用 `Suspense` 获取一些数据，那么页面转换可能会延迟。这就是
    `useTransition` 派上用场的地方，它允许你管理与导航相关的更新的优先级，确保用户体验保持流畅和响应，即使处理复杂的页面转换。 值得注意的是，如果下一页的数据获取发生在效果内，那么
    `startTransition` 不会等待效果内的数据被获取；然而，当你在转换中挂起时，React 会将 `isPending` 状态与数据获取及数据返回时的渲染绑定在一起。
- en: In this case, the `isPending` state will be `true` while the page transition
    is in progress, allowing us to immediately show a loading indicator to the user
    in response to their button click. Once the transition is complete, the `isPending`
    state will be `false`, and the new page will be rendered.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当页面转换正在进行时，`isPending` 状态将为 `true`，允许我们立即在用户点击按钮时显示加载指示器。一旦转换完成，`isPending`
    状态将为 `false`，并且新页面将被渲染。
- en: Diving Deeper
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深入了解
- en: With the background knowledge of React’s Fiber architecture, the React scheduler,
    priority levels, and the render lanes mechanism, we can now delve into the inner
    workings of the `useTransition` hook.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了 React 的 Fiber 架构、React 调度器、优先级级别和渲染通道机制的背景知识后，我们现在可以深入探讨`useTransition`钩子的内部工作原理。
- en: The `useTransition` hook works by creating a transition and assigning a specific
    priority level to the updates made within that transition. When an update is wrapped
    in a transition, React ensures that the update gets scheduled and rendered based
    on the assigned priority level.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`useTransition`钩子通过创建一个转换并为该转换内的更新分配特定的优先级级别来工作。当一个更新被包装在转换中时，React 确保根据分配的优先级级别进行调度和渲染更新。'
- en: 'Here’s an overview of the steps involved in using the `useTransition` hook:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用`useTransition`钩子涉及的步骤概述：
- en: Import and invoke the `useTransition` hook within a functional component.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数组件内部导入并调用`useTransition`钩子。
- en: 'The hook returns an array with two elements: the first is the `isPending` state,
    and the second is the `startTransition` function.'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该钩子返回一个包含两个元素的数组：第一个是`isPending`状态，第二个是`startTransition`函数。
- en: Use the `startTransition` function to wrap any state update or component rendering
    that you want to control the timing of.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`startTransition`函数来包装希望控制时机的任何状态更新或组件渲染。
- en: The `isPending` state provides an indicator of whether the transition is still
    in progress or has completed.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`isPending`状态指示转换是否仍在进行中或已完成。'
- en: React ensures that updates wrapped in a transition are treated with the appropriate
    priority level. This is achieved by using the scheduler and render lanes mechanism
    to assign and manage the updates.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React 确保包装在转换中的更新按照适当的优先级级别处理。这通过使用调度器和渲染通道机制来分配和管理更新实现。
- en: By using `useTransition`, we can effectively control the timing of updates and
    maintain a smooth user experience, even when other higher-priority updates are
    competing for the main thread.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`useTransition`，我们可以有效地控制更新的时机，并保持流畅的用户体验，即使其他优先级更高的更新也在竞争主线程。
- en: useDeferredValue
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: useDeferredValue
- en: '`useDeferredValue` is a React Hook that allows for the deferral of certain
    UI updates to a later time, especially useful in scenarios where the application
    is dealing with a heavy load or computationally intensive tasks, thereby aiding
    in managing update prioritization and promoting smoother transitions and an improved
    user experience.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`useDeferredValue`是一个 React Hook，允许将某些 UI 更新推迟到稍后，特别是在应用程序处理重负载或计算密集任务的场景中非常有用，从而帮助管理更新优先级并促进更平滑的过渡和更好的用户体验。'
- en: During the initial render, the returned deferred value is the same as the supplied
    value. In subsequent updates, `useDeferredValue` helps maintain a smooth user
    experience by keeping the old value for a longer duration before updating to the
    new value, particularly in scenarios with computationally intensive operations.
    This does not entail multiple rerenders with old and new values, but a controlled
    update to the new value. This mechanism is akin to a `stale-while-revalidate`
    strategy, holding on to stale values to keep the UI responsive while awaiting
    new values.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始渲染期间，返回的延迟值与提供的值相同。在后续更新中，`useDeferredValue`通过在更新至新值之前保持旧值来维持流畅的用户体验，特别是在涉及计算密集操作的情况下。这不涉及使用旧值和新值进行多次重新渲染，而是控制更新到新值。这种机制类似于`stale-while-revalidate`策略，保持过时值以保持
    UI 的响应性同时等待新值。
- en: 'Looking through React’s commit history, we see that the first implementation
    of `useDeferredValue` looked something like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览 React 的提交历史，我们可以看到`useDeferredValue`的首次实现大致如下：
- en: '[PRE8]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Let’s chat a bit about what this code is doing. Initially, it sets up a state
    (`newValue`) with the initial value passed to it. The function then utilizes the
    `useEffect` hook to observe changes in this value. When a change is detected,
    the `startTransition` function is invoked, which is crucial for deferring the
    update.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要讨论一下这段代码的作用。最初，它设置了一个带有传递给它的初始值的状态（`newValue`）。然后，该函数利用`useEffect`钩子来观察这个值的变化。当检测到变化时，会调用`startTransition`函数，这对于推迟更新至关重要。
- en: Within `startTransition`, the state is updated to the new value using `setNewValue`.
    The use of `startTransition` signifies to React that this update is not urgent,
    allowing React to prioritize other, more critical updates first. This is more
    or less exactly how `useDeferredValue` works today and should be helpful for our
    mental model of it.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在`startTransition`中，使用`setNewValue`将状态更新为新值。使用`startTransition`表示给React这个更新不是紧急的，允许React优先处理其他更关键的更新。这基本上就是`useDeferredValue`今天的工作方式，对我们对其的心智模型应该是有帮助的。
- en: '`useDeferredValue` is a part of React’s concurrent features that enables interruptibility
    by allowing certain state updates to be deferred.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`useDeferredValue`是React并发功能的一部分，它通过允许延迟某些状态更新来实现可中断性。'
- en: When a component rerenders with a deferred value, React keeps showing the old
    value for a certain period, allowing high-priority updates to be processed before
    low-priority ones. This breaks up the rendering work into smaller chunks, which
    can be spread out over time, improving responsiveness and ensuring that high-priority
    updates (like user interactions) are not delayed by lower-priority updates, hence
    boosting positive user experience.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件重新渲染具有延迟值时，React会在一定时间内继续显示旧值，允许高优先级更新在低优先级更新之前处理。这将渲染工作分解为较小的块，可以随时间分布，提高响应性，并确保高优先级更新（如用户交互）不会被低优先级更新延迟，从而提升积极的用户体验。
- en: Purpose of useDeferredValue
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`useDeferredValue`的目的
- en: The primary purpose of `useDeferredValue` is to allow you to defer the rendering
    of less critical updates. This is particularly useful when you want to prioritize
    more important updates, such as user interactions, over less critical ones, such
    as displaying updated data from the server.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`useDeferredValue`的主要目的是允许您推迟渲染较不重要的更新。当您希望优先处理更重要的更新（例如用户交互）而不是较不重要的更新（例如显示来自服务器的更新数据）时，这将特别有用。'
- en: By using `useDeferredValue`, you can provide a smoother user experience and
    ensure that your application remains responsive even under heavy load or when
    dealing with complex operations.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`useDeferredValue`，您可以提供更流畅的用户体验，并确保您的应用程序即使在负载较重或处理复杂操作时也保持响应。
- en: To use `useDeferredValue`, you will need to import it from the React package
    and pass a value to be deferred as its argument. The hook will then return a deferred
    version of the value that can be used in your component.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`useDeferredValue`，您需要从React包中导入它，并将一个值作为其参数传递。然后，该钩子将返回该值的延迟版本，可用于您的组件中。
- en: 'Here’s an example of how to use `useDeferredValue` in a simple application:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何在简单应用程序中使用`useDeferredValue`的示例：
- en: '[PRE9]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this example, we have a search input and a `SearchResults` component that
    displays the results. We use `useDeferredValue` to defer the rendering of the
    search results, allowing the application to prioritize user input and remain responsive
    even when rendering the list of results is expensive. Let’s understand this in
    a little more detail:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们有一个搜索输入和一个显示结果的`SearchResults`组件。我们使用`useDeferredValue`来推迟搜索结果的渲染，使应用程序能够优先处理用户输入，并在渲染结果列表昂贵时保持响应。让我们稍微详细了解一下：
- en: We use `memo` on the component to make sure it doesn’t unnecessarily update,
    as we’ve discussed in prior chapters.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在组件上使用`memo`，以确保它不会不必要地更新，正如我们在之前的章节中讨论的那样。
- en: When it updates, it causes performance problems because it’s expensive to render.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当更新时，会导致性能问题，因为渲染成本高昂。
- en: When we give it a deferred prop, `deferredSearchValue`, since the prop itself
    is updated after more urgent rendering work, so is the component. Thus, the component
    only rerenders when there’s no more urgent work to be done, like updating the
    text input field.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们给它一个延迟的属性，`deferredSearchValue`，因为该属性本身是在更紧急的渲染工作之后更新的，所以组件也是如此。因此，只有在没有更紧急的工作需要完成时，例如更新文本输入字段时，组件才会重新渲染。
- en: One might ask here, “Why not just debounce or throttle `searchValue`?”
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这里可能会有人问，“为什么不只是对`searchValue`进行防抖或节流？”
- en: 'Great question. Let’s contrast those here:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 很好的问题。让我们在这里进行对比：
- en: Debouncing
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 防抖
- en: Involves a pause before updating the list, waiting for the user to finish typing,
    such as a delay of one second
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 包括在更新列表之前等待一段时间，等待用户完成输入，例如延迟一秒钟。
- en: Throttling
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 节流
- en: Updates the list at regular intervals, say, no more than once per second
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 定期更新列表，比如每秒钟不超过一次
- en: While these methods can be effective in certain situations, `useDeferredValue`
    emerges as a more tailored solution for rendering optimization since it adapts
    seamlessly to the performance capabilities of the user’s device and isn’t some
    arbitrary delay.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些方法在某些情况下可能非常有效，但`useDeferredValue`作为更为精细的渲染优化解决方案显现出来，因为它可以无缝地适应用户设备的性能能力，而不是一种任意的延迟。
- en: The key difference with `useDeferredValue` lies in its dynamic approach to delays.
    It eliminates the need for setting a fixed delay time. On a high-performance device,
    such as a powerful laptop, the delay in rerendering is almost imperceptible, occurring
    almost instantaneously. Conversely, on slower devices, the rendering delay adjusts
    accordingly, causing the list to update with a slight lag in response to the input,
    proportional to the device’s speed.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`useDeferredValue`的关键区别在于其动态延迟处理方法。它消除了设置固定延迟时间的需要。在高性能设备（如强大的笔记本电脑）上，重新渲染延迟几乎是不可察觉的，几乎是即时发生的。相反，在较慢的设备上，渲染延迟会相应调整，导致列表响应输入时稍有滞后，与设备速度成比例。'
- en: Moreover, `useDeferredValue` has a significant advantage in its ability to interrupt
    deferred rerenders. In scenarios where React is processing a substantial list,
    and the user enters a new keystroke, React can pause the rerendering, respond
    to the new input, and then resume the rendering process in the background. This
    is a contrast to debouncing and throttling, which, despite delaying updates, can
    still lead to a disjointed experience as they block interactivity during rendering.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`useDeferredValue`在其中断延迟重新渲染方面具有显著优势。在React处理大量列表的情况下，用户输入新字符时，React可以暂停重新渲染，响应新输入，然后在后台恢复渲染过程。这与防抖和节流形成对比，后者尽管延迟更新，但仍可能导致在渲染过程中阻塞交互体验的不连贯。
- en: That said, debouncing and throttling are still useful in scenarios not directly
    related to rendering. For instance, they can be effective in reducing the frequency
    of network requests. These techniques can also be used in conjunction with `useDeferredValue`
    for a comprehensive optimization strategy.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，防抖和节流在与渲染无直接关系的场景中仍然很有用。例如，它们可以有效地减少网络请求的频率。这些技术也可以与`useDeferredValue`结合使用，形成全面的优化策略。
- en: 'Based on all of this, we see several advantages to using `useDeferredValue`
    in React applications:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这一切，我们在React应用中使用`useDeferredValue`看到了几个优势：
- en: Improved responsiveness
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 提升响应速度
- en: In the example, when the user types into the search box, the input field updates
    immediately and the results are deferred. If the user quickly types five characters
    in a row, the input field updates immediately five times, and the `searchResults`
    are only rendered once, after the user stops typing. For characters 1–4, the rendering
    of `SearchResults` is interrupted by the new values.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，当用户在搜索框中输入时，输入字段会立即更新，而结果则被延迟处理。如果用户快速连续输入五个字符，输入字段会立即更新五次，而`searchResults`只有在用户停止输入后才会渲染一次。对于第1至第4个字符，`SearchResults`的渲染会被新值中断。
- en: Declarative prioritization
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式优先级处理
- en: '`useDeferredValue` provides a simple and declarative way to manage the prioritization
    of updates in your application. By encapsulating the logic for deferring updates
    within the hook, you can keep your component code clean and focused on the essential
    aspects of your app.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`useDeferredValue`提供了一种简单而声明式的方式来管理应用中更新优先级的逻辑。通过将延迟更新的逻辑封装在钩子内部，您可以保持组件代码的清晰性，并专注于应用的核心方面。'
- en: Better resource utilization
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的资源利用
- en: By deferring less critical updates, `useDeferredValue` allows your application
    to make better use of available resources. This can help reduce the likelihood
    of performance bottlenecks and improve the overall performance of your application.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 通过延迟处理较不重要的更新，`useDeferredValue`允许应用更好地利用可用资源。这可以帮助减少性能瓶颈的可能性，提升应用的整体性能。
- en: When to Use useDeferredValue
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用`useDeferredValue`
- en: '`useDeferredValue` is most useful in situations where your application needs
    to prioritize certain updates over others. Some common scenarios where you might
    consider using `useDeferredValue` include:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`useDeferredValue`在需要优先处理某些更新的情况下非常有用。一些常见的情况包括：'
- en: Searching or filtering large data sets
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索或过滤大数据集
- en: Rendering complex visualizations or animations
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染复杂的可视化或动画
- en: Updating data from a server in the background
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后台从服务器更新数据
- en: Handling computationally expensive operations that could impact user interactions
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理可能影响用户交互的计算密集型操作
- en: 'Let’s take a look at an example where `useDeferredValue` can be particularly
    useful. Imagine we have a large list of items that we want to filter based on
    user input. Filtering a large list can be computationally expensive, so using
    `useDeferredValue` can help keep the application responsive:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，`useDeferredValue` 特别有用。想象我们有一个大列表的项目，我们想根据用户输入进行过滤。过滤大列表可能计算开销大，因此使用
    `useDeferredValue` 可以帮助保持应用程序的响应：
- en: '[PRE10]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, we use `useDeferredValue` to defer the rendering of the filtered
    list. As the user types in the filter input, the deferred value updates less frequently,
    allowing the application to prioritize the user input and remain responsive.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用 `useDeferredValue` 来推迟渲染过滤后的列表。当用户在过滤输入中输入时，推迟的值更新频率较低，允许应用程序优先处理用户输入并保持响应。
- en: The `useMemo` hooks are used to memoize the items and `filteredItems` arrays,
    preventing unnecessary rerendering and recalculations. This further improves the
    performance of the application.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`useMemo` 钩子用于记忆项目和 `filteredItems` 数组，防止不必要的重新渲染和重新计算。这进一步提升了应用程序的性能。'
- en: When Not to Use useDeferredValue
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不适合使用 `useDeferredValue` 的情况
- en: While `useDeferredValue` can be beneficial in certain scenarios, it’s important
    to recognize the trade-offs. Namely, by deferring updates, there’s a possibility
    that the data displayed to the user might be slightly out-of-date. While this
    is usually acceptable for less critical updates, it’s important to consider the
    implications of displaying stale data to users.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 `useDeferredValue` 在某些场景下有益，但认识到其中的权衡是很重要的。通过推迟更新，显示给用户的数据可能略有过时。虽然这通常对较不重要的更新是可以接受的，但重要的是要考虑向用户显示过时数据的影响。
- en: A good question to ask yourself when deciding whether to use `useDeferredValue`
    or not is, “Is this update user input?”
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定是否使用 `useDeferredValue` 时，可以问自己一个好问题：“这个更新是否来自用户输入？”
- en: 'React is called React for a reason: it enables our web applications to react
    to things. Anything that causes a user to expect a reaction ought not be deferred.
    Everything else should be.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: React 之所以被称为 React，是因为它使我们的Web应用程序能够对事物做出反应。任何使用户期望得到反应的东西都不应被推迟。其他所有事情则应该推迟。
- en: While the usage of `useDeferredValue` can greatly enhance your application’s
    responsiveness under load, it should not be seen as a magic bullet. Always remember
    that the best way to improve performance is to write efficient code and avoid
    unnecessary computations.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 `useDeferredValue` 的使用可以极大地增强应用程序在负载下的响应能力，但不应视为灵丹妙药。永远记住，提高性能的最佳方式是编写高效的代码并避免不必要的计算。
- en: Problems with Concurrent Rendering
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发渲染的问题
- en: Concurrent rendering, while allowing for performant and responsive user interactions,
    presents new problems for developers to consider. The main problem is that it’s
    difficult to reason about the order in which updates will be processed, which
    can lead to unexpected behavior and bugs.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管并发渲染可以实现高性能和响应用户交互，但也给开发者带来了新的问题需要考虑。主要问题是很难理解更新处理的顺序，这可能导致意外行为和bug。
- en: One such bug is called *tearing*, where the UI becomes inconsistent due to updates
    being processed out of order. This can happen when a component depends on some
    value that is updated while it’s still rendering, causing applications to be rendered
    with inconsistent data. Let’s dive into this a little bit.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一种bug称为 *撕裂*，其中由于更新被处理的顺序不正确，导致UI变得不一致。当组件依赖于在其仍在渲染时更新的某些值时，就会发生这种情况，从而导致应用程序使用不一致的数据进行渲染。让我们深入了解一下这个问题。
- en: Tearing
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 撕裂
- en: Tearing is a bug that occurs when a component depends on some state that is
    updated while the application is still rendering. To understand this, let’s contrast
    synchronous rendering with concurrent rendering.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**撕裂** 是一个bug，在组件依赖某些在应用程序仍在渲染时更新的状态时发生。要理解这一点，让我们对比同步渲染和并发渲染。'
- en: In a synchronous world, React would walk down a tree of components and render
    them one by one, from top to bottom. This ensures that the state of the application
    is consistent throughout the rendering process, as each component is rendered
    with the latest state.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在同步世界中，React 会遍历组件树并依次从顶部到底部渲染它们。这确保了应用程序在整个渲染过程中状态一致，因为每个组件都是使用最新的状态进行渲染的。
- en: 'Consider this example:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个例子：
- en: '[PRE11]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'At the very top of our app, we have `count`: a variable that we set globally
    and keep updating via `setInterval` outside of the React render cycle so that
    we can simulate a tearing bug by having it update while the application is rendering.
    Since rendering is concurrent and interruptible, it’s possible for the `ExpensiveComponent`
    to be rendered with different values for `count`, resulting in inconsistent data
    being displayed to the user, or tearing.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们应用的顶部，我们有 `count`：一个我们全局设置并通过 `setInterval` 在 React 渲染周期之外不断更新的变量，以便我们可以模拟一个撕裂错误，即在应用程序渲染时更新它。由于渲染是并发和可中断的，`ExpensiveComponent`
    可能会以不同的 `count` 值被渲染，导致向用户显示不一致的数据或撕裂。
- en: We expect to see inconsistent values for `count` rendered inside `ExpensiveComponent`
    as React “stops” rendering on user input to prioritize a more urgent update, like
    updating the text input field, thereby leaving a stale value of `count` in the
    `ExpensiveComponent`, but only sometimes.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望在 `ExpensiveComponent` 内部渲染的 `count` 值不一致，因为 React 在用户输入时“停止”渲染以优先处理更紧急的更新，比如更新文本输入字段，从而在
    `ExpensiveComponent` 中留下了 `count` 的旧值，但并非总是如此。
- en: Our example renders a text input field and a list of five `ExpensiveComponent`s.
    These components are not memoized intentionally to illustrate a point here, as
    they cause performance problems and we need these performance problems, to identify
    tearing for the purposes of understanding it. In the real world, you’ll want to
    wrap `ExpensiveComponent` in `React.memo`. Here, we’re intentionally avoiding
    this to demonstrate tearing—which you’ll want to avoid in your application.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例渲染了一个文本输入字段和五个 `ExpensiveComponent` 的列表。这些组件故意没有进行记忆化，以说明一个问题，因为它们会导致性能问题，我们需要这些性能问题来识别撕裂以便理解。在实际应用中，你会想要在
    `ExpensiveComponent` 中使用 `React.memo` 进行包装。在这里，我们故意避免这样做来演示撕裂——你将希望在你的应用程序中避免这种情况。
- en: '`ExpensiveComponent` takes a long time to render, simulating a computationally
    expensive operation. The `ExpensiveComponent` also displays the current value
    of the `count` variable, which is incremented every millisecond and read from
    an external store, in this case the global namespace.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExpensiveComponent` 需要花费很长时间来渲染，模拟计算密集型操作。`ExpensiveComponent` 还显示了 `count`
    变量的当前值，该值每毫秒递增并从外部存储中读取，在本例中是全局命名空间。'
- en: If we run this example, we’ll see that for the five instances of `ExpensiveComponent`
    that we render, after typing a few keystrokes in the `input`, the `ExpensiveComponent`s
    will render with different values for `count`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个例子，我们会看到我们渲染的五个 `ExpensiveComponent` 实例，在输入几个按键后，这些 `ExpensiveComponent`
    将以不同的 `count` 值进行渲染。
- en: This is because the `ExpensiveComponent` is rendered five times, and each time
    it’s rendered, the value of `count` is different. Since React is rendering the
    components concurrently, it’s possible for the `ExpensiveComponent` to be rendered
    with different values for `count`, resulting in inconsistent data displayed to
    the user.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 `ExpensiveComponent` 被渲染了五次，每次它被渲染时，`count` 的值都不同。由于 React 同时渲染组件，`ExpensiveComponent`
    可能会以不同的 `count` 值被渲染，导致向用户显示不一致的数据。
- en: 'This is called tearing, and it’s a bug that can occur when a component depends
    on some state that is updated while the application is still rendering. In this
    case, the `ExpensiveComponent` depends on the `count` variable, which is updated
    while the component is still rendering, causing the application to be rendered
    with inconsistent data. With tearing, we see the following output for the five
    instances of `ExpensiveComponent`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为撕裂，这是一种错误，可能会在应用程序仍在渲染时发生，当组件依赖于某些在更新的状态时。在这种情况下，`ExpensiveComponent` 依赖于
    `count` 变量，而该变量在组件仍在渲染时更新，导致应用程序以不一致的数据进行渲染。对于 `ExpensiveComponent` 的五个实例，我们看到以下输出：
- en: '`Expensive count is 568`'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`昂贵的计数为 568`'
- en: '`Expensive count is 568`'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`昂贵的计数为 568`'
- en: '`Expensive count is 569`'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`昂贵的计数为 569`'
- en: '`Expensive count is 569`'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`昂贵的计数为 569`'
- en: '`Expensive count is 570`'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`昂贵的计数为 570`'
- en: This makes sense because earlier instances of the component are rendered, the
    updated `count` value is flushed/committed to the DOM, and lower instances continue
    to be rendered and yielded (flushed, updated) with newer values of `count`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有道理的，因为早期的组件实例被渲染时，更新的 `count` 值被刷新/提交到 DOM，较低的实例继续被渲染和产生（刷新，更新）新的 `count`
    值。
- en: 'This isn’t a huge deal because React will eventually render the consistent
    state. The bigger issue is when you have something like:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是一个大问题，因为 React 最终会渲染出一致的状态。更大的问题是当你遇到这样的情况时：
- en: '[PRE12]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With this code, if the user is deleted from the global store between renders,
    this will throw a sudden error that can surprise a user. This is why tearing is
    a problem.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段代码，如果用户在渲染之间从全局存储中删除，则会抛出突然的错误，这可能会让用户感到意外。这就是撕裂的问题所在。
- en: To solve this problem of tearing, React exposes a hook called `useSyncExternalStore`.
    Let’s dive into this hook.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个撕裂问题，React提供了一个名为`useSyncExternalStore`的钩子。让我们深入了解一下这个钩子。
- en: useSyncExternalStore
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: useSyncExternalStore
- en: '`useSyncExternalStore` is a React Hook that allows you to synchronize external
    state with the internal state of your application. It’s particularly useful when
    dealing with computationally expensive operations that might cause tearing if
    not handled properly. The “sync” in `useSyncExternalStore` has a double meaning.
    It’s “synchronize,” but it’s also “synchronous”: it forces a synchronous update
    when the store changes.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`useSyncExternalStore`是一个React Hook，允许您将外部状态与应用程序的内部状态同步。在处理可能导致撕裂的计算密集操作时特别有用，如果不正确处理可能会导致撕裂。`useSyncExternalStore`中的“sync”有双重含义。它是“同步”，但也是“同步的”：它在存储更改时强制同步更新。'
- en: 'The `useSyncExternalStore` hook has the following signature:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`useSyncExternalStore`钩子的签名如下：'
- en: '[PRE13]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`store.subscribe`'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`store.subscribe`'
- en: A function that receives a callback function as its first and only argument.
    Inside this function, you can subscribe to changes in the external store and call
    the callback function whenever the store changes. The callback can be considered
    a call to prompt React to rerender the component with the new value. The expected
    return of this function is a cleanup function that unsubscribes from the store.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 一个接收回调函数作为其第一个且唯一参数的函数。在此函数内部，您可以订阅外部存储的更改，并在存储更改时调用回调函数。回调可以被视为调用以提示React使用新值重新渲染组件的调用。此函数的预期返回是一个清除函数，用于取消订阅存储。
- en: 'A typical `subscribe` function looks like this:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的`subscribe`函数看起来像这样：
- en: '[PRE14]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'A simple use case for this would be subscribing to browser events, such as
    `resize` or `scroll` events, and updating the component when these events occur,
    like this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的用例是订阅浏览器事件，比如`resize`或者`scroll`事件，在这些事件发生时更新组件，就像这样：
- en: '[PRE15]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, our React components would rerender whenever the browser window is resized.
    However, how does it get the new value? That’s where the second argument to `useSyncExternalStore`
    comes in.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的React组件将在浏览器窗口大小调整时重新渲染。但是，它如何获取新值？这就是`useSyncExternalStore`的第二个参数发挥作用的地方。
- en: '`store.getSnapshot`'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`store.getSnapshot`'
- en: A function that returns the current value of the external store. This function
    is called whenever the component is rendered, and the returned value is used to
    update the component’s internal state. This function is called synchronously,
    so it should not perform any asynchronous operations or have any side effects.
    Moreover, this function ensures the state at render time is consistent across
    multiple instances of the component.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 一个返回外部存储当前值的函数。每当组件渲染时调用此函数，并使用返回的值来更新组件的内部状态。此函数是同步调用的，因此不应执行任何异步操作或具有任何副作用。此外，此函数确保在渲染时状态在组件的多个实例之间保持一致。
- en: 'To follow our window resize example, this is how we would get the current window
    size:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随我们的窗口大小调整示例，这是我们如何获取当前窗口大小的方法：
- en: '[PRE16]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The object with `{ width, height }` is the snapshot of the current state of
    the window, and it’s what `useSyncExternalStore` will return. We can then use
    this object in our component with confidence that its state will always be consistent
    across concurrent renders.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 具有`{ width, height }`的对象是窗口当前状态的快照，这是`useSyncExternalStore`将返回的内容。然后，我们可以放心地在组件中使用此对象，确保其状态始终在并发渲染之间保持一致。
- en: How can we have this confidence? It’s because the `immediatelyRerenderSynchronously`
    function forces a synchronous rerender and does not allow React to defer it. This
    is the key to solving tearing.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何能够有这种信心呢？这是因为`immediatelyRerenderSynchronously`函数强制同步重新渲染，并且不允许React推迟它。这是解决撕裂问题的关键。
- en: Now, let’s take a look at how we can use `useSyncExternalStore` to solve the
    tearing problem in our previous example. If we recall, we saw a list of `ExpensiveComponent`s
    that rendered with different values for `count` due to tearing. Let’s see how
    we can fix this using `useSyncExternalStore`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用`useSyncExternalStore`来解决我们上一个示例中的撕裂问题。如果我们回想一下，由于撕裂，我们看到了一个`ExpensiveComponent`列表，其渲染的`count`具有不同的值。让我们看看如何使用`useSyncExternalStore`来修复这个问题。
- en: 'For starters, we don’t want to subscribe to the store and have React rerender
    when updates happen; but instead we want consistent state when rerenders happen
    due to user input. So our `subscribe` function will be empty, but to get consistent
    state, we’ll use the `getSnapshot` function to get the current value of `count`
    and return it:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们不想在订阅商店并且当更新发生时重新渲染 React；相反，我们希望当用户输入导致重新渲染时，有一致的状态。因此我们的`subscribe`函数将是空的，但是为了得到一致的状态，我们将使用`getSnapshot`函数来获取`count`的当前值并返回它：
- en: '[PRE17]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This is what our previous example will look like with `useSyncExternalStore`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们之前示例中使用`useSyncExternalStore`的效果：
- en: '[PRE18]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, if we run this example, we will see that the `ExpensiveComponent`s render
    with the same value for `count`, preventing tearing from occurring. This is because
    the `useSyncExternalStore` hook ensures that the state at render time is consistent
    across multiple instances of the component.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行此示例，我们将看到`ExpensiveComponent`使用相同的`count`值重新渲染，从而防止撕裂的发生。这是因为`useSyncExternalStore`钩子确保在渲染时状态跨组件的多个实例之间保持一致。
- en: We don’t use a `subscribe` function because its purpose is to tell React when
    to rerender with the latest state, but in our case we just want state to be consistent
    across renders. We use the `getSnapshot` function to get the current value of
    `count` and return it, ensuring that the state at render time is consistent across
    multiple instances of the component.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不使用`subscribe`函数，因为它的目的是告诉 React 何时使用最新状态重新渲染，但在我们的情况下，我们只想要在渲染之间保持状态一致。我们使用`getSnapshot`函数获取`count`的当前值并返回它，确保在渲染时状态在组件的多个实例之间保持一致。
- en: This is how we can use `useSyncExternalStore` to solve the tearing problem in
    our previous example, ensuring that the state at render time is consistent across
    multiple instances of the component.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何在之前示例中使用`useSyncExternalStore`解决撕裂问题的方式，确保在渲染时状态跨组件的多个实例之间保持一致。
- en: OK, this ensures that when the text input changes and `ExpensiveComponent` rerenders,
    it will have the same value of `count` as the other instances of `ExpensiveComponent`,
    preventing tearing—but what if we wanted to update `count` inside `ExpensiveComponent`
    at the same interval that we update `count` outside of `ExpensiveComponent`?
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了当文本输入变化并且`ExpensiveComponent`重新渲染时，它将具有与`ExpensiveComponent`的其他实例相同的`count`值，从而防止撕裂。但是，如果我们想要在`ExpensiveComponent`内部以与我们在`ExpensiveComponent`外部更新`count`的相同间隔更新`count`，那该怎么办呢？
- en: 'We just create a store for this that follows the same update rules:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需为此创建一个遵循相同更新规则的存储：
- en: '[PRE19]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, whenever `count` changes, `ExpensiveComponent` will rerender with the
    new value of `count`, and we’ll see the same value for `count` across all instances
    of `ExpensiveComponent`. The change detection logic itself can be as simple or
    as complex as you want it to be, but the key is that we understand the mechanisms
    of how `useSyncExternalStore` does its main things, which are:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当`count`变化时，`ExpensiveComponent`将会重新渲染，并且我们会看到所有`ExpensiveComponent`实例中的`count`都显示相同的新值。变更检测逻辑本身可以简单也可以复杂，但关键是我们理解了`useSyncExternalStore`如何保证其主要功能的机制，即：
- en: Ensuring consistent state across concurrent renders
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保并发渲染时状态保持一致
- en: Forcing a synchronous rerender when the store changes
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当存储更改时强制同步重新渲染
- en: Now that we understand how `useSyncExternalStore` works and solves the tearing
    problem, we have a solid grasp not only of concurrent rendering in React but also
    of how to solve some of the problems that come with it. This is a great place
    to be in as a React developer.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们理解了`useSyncExternalStore`的工作原理和如何解决撕裂问题，不仅对 React 中的并发渲染有了牢固的掌握，还知道如何解决一些相关问题。这对于作为
    React 开发者而言是一个很好的起点。
- en: This was quite a deep dive, but we’re nearly done. Let’s review.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一次相当深入的探索，但我们快要完成了。让我们来回顾一下。
- en: Chapter Review
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节回顾
- en: This comprehensive conversation focused on the deep exploration of concurrent
    React, touching on multiple aspects, including the Fiber Reconciler, scheduling,
    deferring updates, render lanes, and new hooks, such as `useTransition` and `useDeferredValue`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这场全面的对话聚焦于并发 React 的深度探索，涉及多个方面，包括 Fiber 调和器、调度、推迟更新、渲染通道以及新的钩子，如`useTransition`和`useDeferredValue`。
- en: We began by discussing the Fiber reconciler, the heart of React’s concurrent
    rendering engine. It’s the algorithm behind the framework’s ability to break work
    into smaller chunks and manage the execution priority, allowing React to be “interruptible”
    and support concurrent rendering. This contributes significantly to the ability
    of React to handle complex, high-performance applications smoothly, ensuring user
    interactions remain responsive even during heavy computation.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先讨论了 Fiber 协调器，这是 React 并发渲染引擎的核心。它是框架能够将工作分解为更小块并管理执行优先级的算法，使得 React 可以“中断”并支持并发渲染。这显著促进了
    React 处理复杂、高性能应用程序的能力，确保用户交互在重计算过程中仍能保持响应。
- en: Then we moved on to the concept of scheduling and deferring updates, which essentially
    allows React to prioritize certain state updates over others. React can defer
    lower-priority updates in favor of higher-priority ones, thus maintaining a smooth
    user experience even under heavy load. An example illustrated a chat application
    where incoming message updates were intelligently scheduled and rendered without
    blocking the user interface.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们转向了调度和推迟更新的概念，这本质上允许 React 优先处理某些状态更新而不是其他。React 可以推迟低优先级更新以支持高优先级更新，从而在重负载下保持流畅的用户体验。一个例子展示了聊天应用程序中如何智能调度和渲染传入消息更新，而不阻塞用户界面。
- en: The discussion then moved to render lanes, a central concept in React’s concurrent
    features. Render lanes are a mechanism that React uses to assign priority to updates
    and effectively manage their execution. It’s the secret behind how React decides
    which updates are urgent and need to be processed immediately and which ones can
    be deferred until later. The detailed explanation mentioned how these render lanes
    use bitmasking to efficiently handle multiple priorities.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论随后转向了渲染通道，这是 React 并发特性的核心概念。渲染通道是 React 使用的一种机制，用于为更新分配优先级并有效管理它们的执行。它是 React
    如何决定哪些更新是紧急且需要立即处理，哪些可以推迟到稍后的秘密。详细解释提到这些渲染通道如何使用位掩码来高效处理多个优先级。
- en: We then delved into the new hooks introduced for concurrent operations in React,
    `useTransition` and `useDeferredValue`. These hooks are designed to handle transitions
    and provide smoother user experiences, particularly for operations that take a
    considerable amount of time.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们深入介绍了 React 中为并发操作引入的新钩子 `useTransition` 和 `useDeferredValue`。这些钩子旨在处理过渡并提供更流畅的用户体验，特别是对于需要较长时间操作的情况。
- en: The `useTransition` hook was first discussed, which allows React to transition
    between states in a way that ensures a responsive user interface even if the new
    state takes a while to prepare. In other words, it allows for delaying an update
    to the next render cycle if the component is currently rendering.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 首先讨论了 `useTransition` 钩子，它允许 React 在确保响应用户界面的同时过渡到不同状态，即使新状态需要一段时间准备。换句话说，它允许将更新延迟到下一个渲染周期，如果组件当前正在渲染。
- en: We also discussed the `useDeferredValue` hook, which defers the update of less
    critical parts of a component, thus preventing janky user experience. It essentially
    allows React to “hold on” to the previous value for a little longer if the new
    value is taking too much time.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了 `useDeferredValue` 钩子，它推迟了组件较不重要部分的更新，从而避免了用户体验不佳。它基本上允许 React “保持”先前的值更长时间，如果新值花费太多时间。
- en: Finally, we dove into issues with concurrency, including tearing, and explored
    how `useSyncExternalStore` can help keep state consistent across multiple concurrent
    renders.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们深入探讨了并发中的问题，包括 tearing，并探讨了 `useSyncExternalStore` 如何帮助保持跨多个并发渲染一致的状态。
- en: Throughout the conversation, the recurring theme was understanding the “what”
    and “why” behind React’s strategies for managing complex, dynamic applications
    with heavy computation, and how developers can utilize these strategies to deliver
    a smooth, responsive user experience.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个对话中，重复出现的主题是理解 React 处理复杂、动态应用程序和重计算时的策略的“什么”和“为什么”，以及开发者如何利用这些策略来提供流畅、响应迅速的用户体验。
- en: Review Questions
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复习问题
- en: 'Let’s ask ourselves a few questions to test our understanding of the concepts
    in this chapter:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们问自己几个问题，以测试我们对本章概念的理解：
- en: What is the Fiber reconciler in React, and how does it contribute to the handling
    of complex, high-performance applications?
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Fiber 协调器在 React 中的作用是什么，它如何有助于处理复杂的高性能应用程序？
- en: Explain the concept of scheduling and deferring updates in React. How does it
    help in maintaining a smooth user experience even under heavy load?
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释React中调度和推迟更新的概念。它如何帮助在高负载下保持流畅的用户体验？
- en: What are render lanes in React, and how do they manage the execution of updates?
    Can you describe how render lanes use bitmasking to handle multiple priorities?
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是React中的渲染通道，它们如何管理更新的执行？您能描述渲染通道如何使用位掩码处理多个优先级吗？
- en: What is the purpose of the `useTransition` and `useDeferredValue` hooks in React?
    Describe a situation where each hook would be beneficial.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`useTransition`和`useDeferredValue`钩子在React中的目的是什么？描述每个钩子有益的情境。'
- en: When might it be inappropriate to use `useDeferredValue`? What are some of the
    trade-offs involved with using these hooks?
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时使用`useDeferredValue`可能不合适？使用这些钩子涉及哪些权衡？
- en: Up Next
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来
- en: Now that you have a deep understanding of the concurrent features of React and
    its inner workings, you are well equipped to harness its full potential in building
    high-performance applications. In [Chapter 8](ch08.html#ch08), we will explore
    various popular frameworks built on top of React, such as Next.js and Remix, which
    further streamline the development process by providing best practices, conventions,
    and additional features.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您深刻理解了React的并发特性及其内部工作原理，可以充分利用它在构建高性能应用程序方面的潜力。在[第8章](ch08.html#ch08)，我们将探讨建立在React之上的各种流行框架，如Next.js和Remix，它们通过提供最佳实践、约定和额外功能进一步简化开发过程。
- en: These frameworks are designed to help you build complex applications with ease,
    taking care of many common concerns, such as server rendering, routing, and code
    splitting. By leveraging the power of these frameworks, you can focus on building
    your application’s features and functionality while ensuring optimal performance
    and user experience.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这些框架旨在帮助您轻松构建复杂的应用程序，处理许多常见问题，如服务器渲染、路由和代码拆分。通过利用这些框架的力量，您可以专注于构建应用程序的功能和功能，同时确保优化性能和用户体验。
- en: Stay tuned for an in-depth exploration of these powerful frameworks, and learn
    how to build scalable, performant, and feature-rich applications using React and
    its ecosystem.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 敬请期待对这些强大框架的深入探讨，了解如何利用React及其生态系统构建可扩展、高性能和功能丰富的应用程序。
