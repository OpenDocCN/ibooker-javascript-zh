- en: Chapter 5\. Quality Assurance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章\. 质量保证
- en: '*Quality assurance* is a phrase that is prone to send shivers down the spines
    of developers—which is unfortunate. After all, don’t you want to make quality
    software? Of course you do. So it’s not the end goal that’s the sticking point;
    it’s the politics of the matter. I’ve found that two common situations arise in
    web development:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*质量保证*是一个容易让开发人员心生畏惧的短语——这是不幸的。毕竟，您不是想要制造高质量的软件吗？当然是。因此，关键不在于最终目标，而是于政策的处理。我发现在Web开发中存在两种常见情况：'
- en: Large or well-funded organizations
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 大型或财力雄厚的组织
- en: There’s usually a QA department, and, unfortunately, an adversarial relationship
    springs up between QA and development. This is the worst thing that can happen.
    Both departments are playing on the same team, for the same goal, but QA often
    defines success as finding more bugs, while development defines success as generating
    fewer bugs, and that serves as the basis for conflict and competition.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通常会有一个质量保证部门，不幸的是，质量保证和开发之间会出现对抗性关系。这是可能发生的最糟糕的事情。虽然两个部门都在为同一个目标而战，但质量保证通常将成功定义为发现更多的缺陷，而开发则将成功定义为生成更少的缺陷，这就成为冲突和竞争的基础。
- en: Small organizations and organizations on a budget
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 小型组织和预算有限的组织
- en: Often, there is no QA department; the development staff is expected to serve
    the dual role of establishing QA and developing software. This is not a ridiculous
    stretch of the imagination or a conflict of interest. However, QA is a very different
    discipline than development, and it attracts different personalities and talents.
    This is not an impossible situation, and certainly there are developers out there
    who have the QA mind-set, but when deadlines loom, it’s usually QA that gets the
    short shrift, to the project’s detriment.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，没有质量保证部门；开发人员预计要同时兼顾建立质量保证和开发软件的双重角色。这并不是想象或利益冲突的荒谬伸展。然而，质量保证是与开发非常不同的学科，吸引不同的个性和才能。这不是一个不可能的情况，当然也有开发人员具备质量保证思维方式，但是在截止日期逼近时，通常是质量保证受到短缺待遇，对项目的影响不利。
- en: 'With most real-world endeavors, multiple skills are required, and increasingly,
    it’s harder to be an expert in all of those skills. However, some competency in
    the areas for which you are not directly responsible will make you more valuable
    to the team and make the team function more effectively. A developer acquiring
    QA skills offers a great example: these two disciplines are so tightly intertwined
    that cross-disciplinary understanding is extremely valuable.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数真实世界的努力来说，需要多种技能，并且越来越难成为所有这些技能的专家。然而，对于您不直接负责的领域有一定的能力将使您对团队更有价值，并使团队运作更有效。开发人员获取质量保证技能是一个很好的例子：这两个领域紧密相连，跨学科的理解极为重要。
- en: It is also common to shift activities traditionally done by QA to development,
    making developers responsible for QA. In this paradigm, software engineers who
    specialize in QA act almost as consultants to developers, helping them build QA
    into their development workflow. Whether QA roles are divided or integrated, it
    is clear that understanding QA is beneficial to developers.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个常见的做法是将传统上由质量保证完成的活动转移到开发部门，使开发人员负责质量保证。在这种范式中，专门从事质量保证的软件工程师几乎像开发人员的顾问，帮助他们将质量保证融入其开发工作流程中。无论质量保证角色是分开还是整合的，理解质量保证对开发人员都是有益的。
- en: This book is not for QA professionals; it is aimed at developers. So my goal
    is not to make you a QA expert but to give you some experience in that area. If
    your organization has a dedicated QA staff, it will make it easier for you to
    communicate and collaborate with them. If you do not, it will give you a starting
    point to establishing a comprehensive QA plan for your project.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本书不是针对质量保证专业人士的，而是面向开发人员的。因此，我的目标不是让您成为质量保证专家，而是为您提供一些在该领域获得经验的机会。如果您的组织有专门的质量保证人员，那么您将更容易与他们沟通和合作。如果没有，这将为您建立项目全面质量保证计划提供一个起点。
- en: 'In this chapter, you’ll learn the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学到以下内容：
- en: Quality fundamentals and effective habits
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 质量基础和有效习惯
- en: The types of tests (unit and integration)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试类型（单元测试和集成测试）
- en: How to write unit tests with Jest
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Jest 编写单元测试
- en: How to write integration tests with Puppeteer
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Puppeteer 编写集成测试
- en: How to configure ESLint to help prevent common errors
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何配置 ESLint 以帮助预防常见错误
- en: What continuous integration is and where to start learning about it
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连续集成是什么以及如何开始学习它
- en: The QA Plan
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QA 计划
- en: 'Development is, by and large, a creative process: envisioning something and
    then translating it into reality. QA, in contrast, lives more in the realm of
    validation and order. As such, a large part of QA is simply a matter of *knowing
    what needs to be done* and *making sure it gets done*. It is a discipline well-suited
    for checklists, procedures, and documentation. I would go so far as to say the
    primary activity of QA is not the testing of software itself but the *creation
    of a comprehensive, repeatable QA plan*.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 开发基本上是一个创造性的过程：设想某事然后将其变成现实。相比之下，QA更多地生活在验证和秩序的领域。因此，QA的一个重要部分只是*知道需要做什么*并*确保它被完成*。因此，QA是一种非常适合使用清单、流程和文档的学科。我甚至可以说，QA的主要活动不是软件本身的测试，而是*创建全面且可重复的QA计划*。
- en: I recommend the creation of a QA plan for every project, no matter how big or
    small (yes, even your weekend “fun” project!). The QA plan doesn’t have to be
    big or elaborate; you can put it in a text file or a word processing document
    or a wiki. The objective of the QA plan is to record all of the steps you’ll take
    to ensure that your product is functioning as intended.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议为每个项目创建一个QA计划，无论其大小如何（是的，即使是您的周末“娱乐”项目也是如此！）。QA计划不必很大或很复杂；您可以将其放在文本文件、文字处理文档或wiki中。QA计划的目标是记录您将采取的所有步骤，以确保您的产品按预期运行。
- en: 'In whatever form it takes, the QA plan is a living document. You will update
    it in response to the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 无论采取什么形式，QA计划都是一个活的文档。您将根据以下内容更新它：
- en: New features
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新功能
- en: Changes in existing features
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有功能的变化
- en: Removed features
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已删除的功能
- en: Changes in testing technologies or techniques
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试技术或技术的变化
- en: Defects that were missed by the QA plan
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: QA计划未发现的缺陷
- en: That last point deserves special mention. No matter how robust your QA is, defects
    will happen. And when they do, you should ask yourself, “How could we have prevented
    this?” When you answer that question, you can modify your QA plan accordingly
    to prevent future instances of this type of defect.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点特别值得一提。无论您的质量保证（QA）多么健全，缺陷都会发生。当它们发生时，您应该问自己：“我们如何才能预防这种情况？”当您回答了这个问题，就可以相应地修改您的QA计划，以防止将来发生这种类型的缺陷。
- en: By now you might be getting a feel for the not insignificant effort involved
    in QA, and you might be reasonably wondering how much effort you want to put into
    it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您可能已经感受到QA所需的不小的努力，并且您可能合理地想知道您想要投入多少努力。
- en: 'QA: Is It Worth It?'
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QA：是否值得？
- en: QA can be expensive—sometimes *very* expensive. So is it worth it? It’s a complicated
    formula with complicated inputs. Most organizations operate on some kind of “return
    on investment” model. If you spend money, you must expect to receive at least
    as much money in return (preferably more). With QA, though, the relationship can
    be muddy. A well-established and well-regarded product, for example, may be able
    to get by with quality issues for longer than a new and unknown project. Obviously,
    no one *wants* to produce a low-quality product, but the pressures in technology
    are high. Time-to-market can be critical, and sometimes it’s better to come to
    market with something that’s less than perfect than to come to market with the
    perfect product months later.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: QA有时可能会非常昂贵——*非常*昂贵。那么这是否值得呢？这是一个复杂的公式，涉及复杂的输入。大多数组织采用某种“投资回报”模型。如果您花钱，您必须期望能够获得至少同等数量的回报（最好是更多）。然而，与QA相关的关系可能会变得混淆。例如，一个经过充分建立和良好评价的产品，可能比一个新的和未知的项目能够更长时间地容忍质量问题。显然，没有人*想*制造低质量的产品，但技术上的压力很大。时间至关重要，有时候，与其在几个月后推出完美的产品，不如在市场上推出一个不完美的产品更好。
- en: 'In web development, quality can be broken down into four dimensions:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web开发中，质量可以分解为四个维度：
- en: Reach
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖率
- en: 'Reach refers to the market penetration of your product: the number of people
    viewing your website or using your service. There’s a direct correlation between
    reach and profitability: the more people who visit the website, the more people
    who buy the product or service. From a development perspective, search engine
    optimization (SEO) will have the biggest impact on reach, which is why we will
    be including SEO in our QA plan.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖率指的是您产品的市场渗透率：访问您网站或使用您服务的人数。覆盖率与盈利能力直接相关：访问网站的人越多，购买产品或服务的人也越多。从开发的角度来看，搜索引擎优化（SEO）将对覆盖率产生最大影响，这也是为什么我们将在我们的QA计划中包含SEO。
- en: Functionality
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 功能性
- en: Once people are visiting your site or using your service, the quality of your
    site’s functionality will have a large impact on user retention; a site that works
    as advertised is more likely to drive return visits than one that isn’t. Functionality
    offers the most opportunity for test automation.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦人们访问您的网站或使用您的服务，您网站功能的质量将对用户保留率产生重大影响；一个按照承诺运行的网站比那些没有按照承诺运行的网站更有可能促使用户再次访问。功能性为测试自动化提供了最大的机会。
- en: Usability
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 可用性
- en: Where functionality is concerned with functional correctness, usability evaluates
    human-computer interaction (HCI). The fundamental question is, “Is the functionality
    delivered in a way that is useful to the target audience?” This often translates
    to “Is it easy to use?” though the pursuit of ease can often oppose flexibility
    or power; what seems easy to a programmer might be different from what seems easy
    to a nontechnical consumer. In other words, you must consider your target audience
    when assessing usability. Since a fundamental input to a usability measurement
    is a user, usability is not usually something that can be automated. However,
    user testing should be included in your QA plan.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及功能正确性时，可用性评估人机交互（HCI）。根本问题是：“功能以对目标受众有用的方式提供了吗？”这通常转化为“使用起来容易吗？”尽管追求易用性往往会与灵活性或强大性相对立；对程序员来说容易的东西可能与非技术消费者认为容易的东西不同。换句话说，评估可用性时必须考虑目标受众。由于可用性评估的一个基本输入是用户，因此通常无法自动化。然而，用户测试应包括在您的QA计划中。
- en: Aesthetics
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 美学
- en: Aesthetics is the most subjective of the four dimensions and is therefore the
    least relevant to development. While there are few development concerns when it
    comes to your site’s aesthetics, routine reviews of your site’s aesthetics should
    be part of your QA plan. Show your site to a representative sample audience, and
    find out if it feels dated or does not invoke the desired response. Keep in mind
    that aesthetics is time sensitive (aesthetic standards shift over time) and audience
    specific (what appeals to one audience may be completely uninteresting to another).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 美学是四个维度中最主观的，因此对开发的影响最小。虽然在涉及到您网站美学时，开发上的担忧很少，但您的QA计划应包括对网站美学的定期审查。向代表性样本观众展示您的网站，并了解它是否显得过时或未引发预期的反应。请记住，美学是时间敏感的（审美标准随时间变化）和特定于受众的（一个受众喜欢的东西可能完全无趣于另一个受众）。
- en: While all four dimensions should be addressed in your QA plan, functionality
    testing and SEO can be tested automatically during development, so that will be
    the focus of this chapter.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您的QA计划应涵盖所有四个维度，但功能性测试和SEO可以在开发过程中进行自动化测试，因此本章将重点放在这些方面。
- en: Logic Versus Presentation
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑与呈现
- en: 'Broadly speaking, in your website, there are two “realms”: *logic* (often called
    *business logic*, a term I eschew because of its bias toward commercial endeavor)
    and *presentation*. You can think of your website’s logic existing in kind of
    a pure intellectual domain. For example, in our Meadowlark Travel scenario, there
    might be a rule that a customer must possess a valid driver’s license before renting
    a scooter. This is a simple data-based rule: for every scooter reservation, the
    user needs a valid driver’s license. The *presentation* of this is disconnected.
    Perhaps it’s just a checkbox on the final form of the order page, or perhaps the
    customer has to provide a valid driver’s license number, which is validated by
    Meadowlark Travel. It’s an important distinction, because things should be as
    clear and simple as possible in the logic domain, whereas the presentation can
    be as complicated or as simple as it needs to be. The presentation is also subject
    to usability and aesthetic concerns, whereas the business domain is not.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 广义上说，在您的网站中，有两个“领域”：*逻辑*（通常称为*业务逻辑*，我因其对商业活动的偏见而避免使用此术语）和*呈现*。您可以将您网站的逻辑想象成一种纯粹的智力领域。例如，在我们的Meadowlark
    Travel场景中，可能存在一个规则，即客户在租用滑板车之前必须拥有有效的驾驶证。这是一个简单的数据规则：每次滑板车预订，用户都需要有效的驾驶证。而*呈现*则是分离的。也许它只是订单页面最后表单上的一个复选框，或者客户必须提供一个由Meadowlark
    Travel验证的有效驾驶证号码。这是一个重要的区别，因为在逻辑领域中应尽可能清晰简单，而呈现可以根据需要复杂或简单。呈现还受可用性和美学问题的影响，而业务领域则不受此影响。
- en: Whenever possible, you should seek a clear delineation between your logic and
    presentation. There are many ways to do that, and in this book, we will be focusing
    on encapsulating logic in JavaScript modules. Presentation, on the other hand,
    will be a combination of HTML, CSS, multimedia, JavaScript, and frontend frameworks
    like React, Vue, or Angular.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，您应该寻求清晰地区分您的逻辑和表现。有很多方法可以做到这一点，在本书中，我们将专注于将逻辑封装在JavaScript模块中。另一方面，展示将是HTML、CSS、多媒体、JavaScript以及像React、Vue或Angular这样的前端框架的组合。
- en: The Types of Tests
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试类型
- en: 'The type of testing we will be considering in this book falls into two broad
    categories: unit testing and integration testing (I am considering system testing
    to be a type of integration testing). Unit testing is very fine-grained, testing
    single components to make sure they function properly, whereas integration testing
    tests the interaction between multiple components or even the whole system.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我将考虑的测试类型分为两大类：单元测试和集成测试（我认为系统测试是集成测试的一种类型）。单元测试非常精细，测试单个组件以确保其正常工作，而集成测试测试多个组件之间甚至整个系统的交互。
- en: In general, unit testing is more useful and appropriate for logic testing. Integration
    testing is useful in both realms.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，单元测试在逻辑测试中更加有用和适当。集成测试在两个领域都很有用。
- en: Overview of QA Techniques
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QA技术概述
- en: 'In this book, we will be using the following techniques and software to accomplish
    thorough testing:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用以下技术和软件来进行彻底的测试：
- en: Unit tests
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试
- en: Unit tests cover the smallest units of functionality in your application, usually
    a single function. They are almost always written by developers, not QA (though
    QA should be empowered to assess the quality and coverage of unit tests). In this
    book, we’ll be using Jest for unit tests.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试覆盖应用程序中最小的功能单元，通常是单个函数。它们几乎总是由开发人员编写，而不是QA（尽管QA应该有能力评估单元测试的质量和覆盖范围）。在本书中，我们将使用Jest进行单元测试。
- en: Integration tests
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试
- en: Integration tests cover larger units of functionality, usually involving multiple
    parts of your application (functions, modules, subsystems, etc.). Since we are
    building web applications, the “ultimate” integration test is to render the application
    in a browser, manipulate that browser, and verify that the application behaves
    as expected. These tests are typically more complicated to set up and maintain,
    and since the focus of this book isn’t QA, we’ll have only one simple example
    of this, using Puppeteer and Jest.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试覆盖应用程序中更大的功能单元，通常涉及多个部分（函数、模块、子系统等）。由于我们正在构建Web应用程序，“终极”集成测试是在浏览器中呈现应用程序，操作该浏览器，并验证应用程序是否按预期行为。这些测试通常更复杂，设置和维护起来更加困难，由于本书的重点不是QA，我们只有一个简单的示例，使用Puppeteer和Jest。
- en: Linting
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Linting
- en: Linting isn’t about finding errors but *potential* errors. The general concept
    of linting is that it identifies areas that could represent possible errors, or
    fragile constructs that could lead to errors in the future. We will be using ESLint
    for linting.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Linting并不是为了发现错误，而是*潜在*的错误。Linting的一般概念是识别可能表示潜在错误的区域，或者脆弱的结构可能导致将来出现错误。我们将使用ESLint进行Linting。
- en: Let’s start with Jest, our test framework (which will run both unit and integration
    tests).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从Jest开始，我们的测试框架（将运行单元测试和集成测试）。
- en: Installing and Configuring Jest
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和配置Jest
- en: 'I struggled somewhat to decide which testing framework to use in this book.
    Jest began its life as a framework to test React applications (and it is still
    the obvious choice for that), but Jest is not React-specific and is an excellent
    general-purpose testing framework. It’s certainly not the only one: [Mocha](https://mochajs.org),
    [Jasmine](https://jasmine.github.io), [Ava](https://github.com/avajs/ava), and
    [Tape](https://github.com/substack/tape) are also excellent choices.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定在本书中使用哪个测试框架方面，我有些挣扎。Jest最初是作为测试React应用程序的框架而诞生的（现在仍然是这样做的明显选择），但Jest并不专门针对React，它是一个优秀的通用测试框架。当然，Jest并不是唯一的选择：[Mocha](https://mochajs.org)、[Jasmine](https://jasmine.github.io)、[Ava](https://github.com/avajs/ava)和[Tape](https://github.com/substack/tape)也是优秀的选择。
- en: In the end, I chose Jest because I feel it offers the best overall experience
    (an opinion backed by Jest’s excellent scores in the [State of JavaScript 2018](http://bit.ly/33ErHUE)
    survey). That said, there are a lot of similarities among the testing frameworks
    mentioned here, so you should be able to take what you learn and apply it to your
    favorite test framework.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我选择了Jest，因为我觉得它提供了最好的整体体验（这一观点得到了Jest在[2018 JavaScript现状](http://bit.ly/33ErHUE)调查中的优秀评分支持）。也就是说，这里提到的测试框架有很多相似之处，因此您应该能够将学到的知识应用到您喜欢的测试框架中。
- en: 'To install Jest, run the following from your project root:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装Jest，请从您的项目根目录运行以下命令：
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: (Note that we use `--save-dev` here; this tells npm that this is a development
    dependency and is not needed for the application itself to function; it will be
    listed in the `devDependencies` section of the *package.json* file instead of
    the `dependencies` section.)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: （请注意，我们在这里使用了`--save-dev`；这告诉npm这是一个开发依赖项，并且不需要它来使应用程序本身正常运行；它将在*package.json*文件的`devDependencies`部分而不是`dependencies`部分中列出。）
- en: 'Before we move on, we need a way to run Jest (which will run any tests in our
    project). The conventional way to do that is to add a script to *package.json*.
    Edit *package.json* (*ch05/package.json* in the companion repo), and modify the
    `scripts` property (or add it if it doesn’t exist):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们需要一种方法来运行Jest（它将运行项目中的任何测试）。通常的做法是在*package.json*中添加一个脚本。编辑*package.json*（在伴随的仓库中的*ch05/package.json*），并修改`scripts`属性（如果不存在则添加）：
- en: '[PRE1]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now you can run all the tests in your project simply by typing that:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您只需键入以下内容即可运行项目中的所有测试：
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you try that now, you’ll probably get an error that there aren’t any tests
    configured…because we haven’t added any yet. So let’s write some unit tests!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在尝试，可能会收到一个错误，提示没有配置任何测试……因为我们还没有添加任何测试。所以让我们编写一些单元测试！
- en: Note
  id: totrans-65
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Normally, if you add a script to your *package.json* file, you would run it
    with `npm run`. For example, if you added a script `foo`, you would type `npm
    run foo` to run it. The `test` script is so common, however, that npm knows to
    run it if you simply type `npm test`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，如果您在*package.json*文件中添加了一个脚本，您可以通过`npm run`来运行它。例如，如果您添加了一个名为`foo`的脚本，您可以键入`npm
    run foo`来运行它。然而，`test`脚本非常常见，因此npm知道如果您简单地键入`npm test`，它就会运行它。
- en: Unit Testing
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: Now we’ll turn our attention to unit testing. Since the focus of unit testing
    is on isolating a single function or component, we’ll first need to learn about
    mocking, an important technique for achieving that isolation.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将把注意力转向单元测试。由于单元测试的重点是隔离单个函数或组件，因此我们首先需要学习模拟，这是实现隔离的重要技术之一。
- en: Mocking
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟
- en: One of the challenges you’ll frequently face is how to write code that is “testable.”
    In general, code that tries to do too much or assumes a lot of dependencies is
    harder to test than focused code that assumes few or no dependencies.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您经常面临的挑战之一是如何编写“可测试”的代码。一般来说，试图做太多或假设很多依赖关系的代码比专注于少量或没有依赖关系的代码更难测试。
- en: Whenever you have a dependency, you have something that needs to be *mocked*
    (simulated) for effective testing. For example, our primary dependency is Express,
    which is already thoroughly tested, so we don’t need or want to test Express itself,
    just *how we use it*. The only way we can determine if we’re using Express correctly
    is to simulate Express itself.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您有一个依赖项时，您就需要对其进行*mock*（模拟）以进行有效的测试。例如，我们的主要依赖项是Express，它已经经过了彻底的测试，因此我们不需要也不想测试Express本身，只需要测试*我们如何使用它*。我们能够确定我们是否正确使用Express的唯一方法就是模拟Express本身。
- en: 'The routes we currently have (the home page, About page, 404 page, and 500
    page) are pretty difficult to test because they assume three dependencies on Express:
    they assume we have an Express app (so we can have `app.get`), as well as request
    and response objects. Fortunately, it’s pretty easy to eliminate the dependence
    on the Express app itself (the request and response objects are harder…more on
    that later). Fortunately, we’re not using very much functionality from the response
    object (we’re using only the `render` method), so it will be easy to mock it,
    which we will see shortly.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前拥有的路由（主页、关于页面、404页面和500页面）在测试时相当困难，因为它们假设对Express有三个依赖：它们假设我们有一个Express应用程序（所以我们可以有`app.get`），以及请求和响应对象。幸运的是，很容易消除对Express应用程序本身的依赖性（请求和响应对象则更难……稍后详细讨论）。幸运的是，我们并没有从响应对象中使用太多功能（我们仅使用`render`方法），因此很容易对其进行mock，我们很快就会看到。
- en: Refactoring the Application for Testability
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为了增强可测试性重构应用程序
- en: We don’t really have a lot of code in our application to test yet. To date,
    we’ve currently added only a handful of route handlers and the `getFortune` function.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在我们的应用程序中，我们并没有太多的代码需要测试。到目前为止，我们只添加了少数路由处理程序和 `getFortune` 函数。
- en: 'To make our app more testable, we’re going to *extract* the actual route handlers
    to their own library. Create a file *lib/handlers.js* (*ch05/lib/handlers.js*
    in the companion repo):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的应用程序更易于测试，我们将*提取*实际的路由处理程序到它们自己的库中。创建一个文件 *lib/handlers.js*（在配套仓库中是 *ch05/lib/handlers.js*）：
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now we can rewrite our *meadowloark.js* application file to use these handlers
    (*ch05/meadowlark.js* in the companion repo):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以重写我们的 *meadowloark.js* 应用程序文件来使用这些处理程序（在配套仓库中是 *ch05/meadowlark.js*）：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It’s easier now to test those handlers: they are just functions that take request
    and response objects, and we need to verify that we’re using those objects correctly.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试这些处理程序变得更容易了：它们只是接受请求和响应对象的函数，我们需要验证我们是否正确地使用了这些对象。
- en: Writing Our First Test
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写我们的第一个测试
- en: There are multiple ways to identify tests to Jest. The two most common are to
    put tests in subdirectories named *__test__* (two underscores before and after
    *test*) and to name files with the extension *.test.js*. I personally like to
    combine the two techniques because they both serve a purpose in my mind. Putting
    tests in *__test__* directories keeps my test from cluttering up my source directories
    (otherwise, everything will look doubled in your source directory…you’ll have
    a *foo.test.js* for every file *foo.js*), and having the *.test.js* extension
    means that if I’m looking at a bunch of tabs in my editor, I can see at a glance
    what is a test and what is source code.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以让 Jest 找到测试。最常见的两种方法是将测试放在名为 *__test__* 的子目录中（在 *test* 前后加上两个下划线），以及将文件命名为
    *.test.js* 扩展名。我个人喜欢结合这两种技术，因为它们各自在我的脑海中都有用途。将测试放在 *__test__* 目录中可以防止我的测试混杂在源代码目录中（否则，你的源目录中将会看到一份
    *foo.test.js* 对应每个 *foo.js* 文件），而使用 *.test.js* 扩展名则意味着，如果我在编辑器中查看一堆选项卡，我一眼就能看出哪些是测试，哪些是源代码。
- en: 'So let’s create a file called *lib/__tests__/handlers.test.js* (*ch05/lib/__tests__/handlers.test.js*
    in the companion repo):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们创建一个名为 *lib/__tests__/handlers.test.js*（在配套仓库中是 *ch05/lib/__tests__/handlers.test.js*）的文件：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you’re new to testing, this will probably look pretty weird, so let’s break
    it down.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对测试还不太熟悉，这可能看起来有点奇怪，所以让我们一步步来分析。
- en: First, we import the code we’re trying to test (in this case, the route handlers).
    Then each test has a description; we’re trying to describe what’s being tested.
    In this case, we want to make sure that the home page gets rendered.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入要测试的代码（在本例中是路由处理程序）。然后，每个测试都有一个描述；我们试图描述正在测试的内容。在这种情况下，我们要确保首页得到渲染。
- en: 'To invoke our render, we need request and response objects. We’d be writing
    code all week if we wanted to simulate the whole request and response objects,
    but fortunately we don’t actually need much from them. We know that we don’t need
    anything at all from the request object in this case (so we just use an empty
    object), and the only thing we need from the response object is a render method.
    Note how we construct the render function: we just call a Jest method called *jest.fn()*.
    This creates a generic mock function that keeps track of how it’s called.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用我们的渲染器，我们需要请求和响应对象。如果我们要模拟整个请求和响应对象，可能需要写上整整一周的代码，但幸运的是，我们实际上并不需要它们太多内容。我们知道，在这种情况下，我们根本不需要请求对象中的任何内容（所以我们只是使用一个空对象），而我们从响应对象中唯一需要的是一个渲染方法。注意我们如何构造渲染函数：我们只需调用一个名为
    *jest.fn()* 的 Jest 方法。这将创建一个通用的模拟函数，用于跟踪它的调用方式。
- en: 'Finally, we get to the important part of the test: assertions. We’ve gone to
    all the trouble to invoke the code we’re testing, but how do we assert that it
    did what it should? In this case, what the code should do is call the `render`
    method of the response object with the string `home`. Jest’s mock function keeps
    track of all the times it got called, so all we have to do is verify it got called
    exactly once (it would probably be a problem if it got called twice), which is
    what the first `expect` does, and that it gets called with `home` as its first
    argument (the first array index specifies which invocation, and the second one
    specifies which argument).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到测试的重要部分：断言。我们已经费了很大的劲来调用我们正在测试的代码，但是我们如何断言它是否按照预期工作？在这种情况下，代码应该调用响应对象的`render`方法，并传递字符串`home`。Jest的模拟函数会跟踪它被调用的所有次数，所以我们只需验证它被调用了一次（如果调用了两次可能会有问题），这就是第一个`expect`所做的事情，并且它被调用时`home`作为第一个参数传入（第一个数组索引指定调用，第二个数组索引指定参数）。
- en: Tip
  id: totrans-88
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Tip
- en: It can get tedious to constantly be rerunning your tests every time you make
    a change to your code. Fortunately, most test frameworks have a “watch” mode that
    constantly monitors your code and tests for changes and reruns them automatically.
    To run your tests in watch mode, type `npm test -- --watch` (the extra double-dash
    is necessary to let npm know to pass the `--watch` argument to Jest).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当您每次对代码进行更改时，不断重新运行测试可能会变得乏味。幸运的是，大多数测试框架都有一个“观察”模式，它会持续监视您的代码和测试的更改并自动重新运行它们。要在观察模式下运行您的测试，请键入`npm
    test -- --watch`（额外的双破折号是必需的，让npm知道将`--watch`参数传递给Jest）。
- en: Go ahead and change your `home` handler to render something other than the home
    view; you’ll notice that your test has now failed, and you caught a bug!
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 请继续修改您的`home`处理程序，以渲染除主页视图之外的其他内容；您会注意到您的测试现在失败了，并且您捕捉到了一个错误！
- en: 'We can now add tests for our other routes:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以为其他路由添加测试：
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note some extra functionality in the “about” and server error tests. The “about”
    render function gets called with a fortune, so we’ve added an expectation that
    it will get a fortune that is a string that contains at least one character. It’s
    beyond the scope of this book to describe all of the functionality that is available
    to you through Jest and its `expect` method, but you can find comprehensive documentation
    on the [Jest home page](https://jestjs.io). Note that the server error handler
    takes four arguments, not two, so we have to provide additional mocks.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意“about”和服务器错误测试中的一些额外功能。 “about”渲染函数被调用时会带有一个幸运符，因此我们添加了一个期望，即它将获得一个包含至少一个字符的字符串作为幸运符。本书的范围不包括描述通过Jest及其`expect`方法可用的所有功能，但您可以在[Jest主页](https://jestjs.io)找到详尽的文档。请注意，服务器错误处理程序需要四个参数，而不是两个，因此我们必须提供额外的模拟。
- en: Test Maintenance
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试维护
- en: You might be realizing that tests are not a “set it and forget it” affair. For
    example, if we renamed our “home” view for legitimate reasons, our test would
    fail, and then we would have to fix the test in addition to fixing the code.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能意识到测试并不是一劳永逸的事务。例如，如果出于合理的原因重命名我们的“home”视图，我们的测试会失败，然后我们不得不修复代码之外还要修复测试。
- en: For this reason, teams put a lot of effort into setting realistic expectations
    about what should be tests and how specific the tests should be. For example,
    we didn’t have to check to see if the “about” handler was being called with a
    fortune…which would save us from having to fix the test if we ditch that feature.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，团队花了很多精力来设定关于应该进行测试以及测试应该有多具体的现实期望。例如，我们不必检查“about”处理程序是否被带有幸运符调用过...这样做将节省我们免于不得不修复测试的麻烦，如果我们放弃了该功能。
- en: Furthermore, I can’t offer much advice about how thoroughly you should test
    your code. I would expect you to have very different standards for testing code
    for avionics or medical equipment than for testing the code behind a marketing
    website.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我不能为您提供有关测试代码深入程度的建议。我预计您对测试航空电子设备或医疗设备的代码的标准会与测试营销网站背后的代码有很大不同。
- en: What I can offer you is a way to answer the question, “How much of my code is
    tested?” The answer to that is called *code coverage*, which we’ll discuss next.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以为您提供一种回答“我的代码有多少被测试覆盖？”这个问题的方法，答案叫做*代码覆盖率*，我们接下来会讨论它。
- en: Code Coverage
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码覆盖率
- en: Code coverage offers a quantitative answer to how much of your code is tested,
    but like most topics in programming, there are no simple answers.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率提供了对您的代码有多少被测试覆盖的量化答案，但像编程中的大多数主题一样，没有简单的答案。
- en: 'Jest helpfully provides some automated code coverage analysis. To see how much
    of your code is tested, run the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 提供了一些有用的自动化代码覆盖分析。要查看你的代码被测试了多少，运行以下命令：
- en: '[PRE7]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you’ve been following along, you should see a bunch of reassuringly green
    “100%” coverage numbers for the files in *lib*. Jest will report on the coverage
    percentage of statements (Stmts), branches, functions (Funcs), and lines.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直在跟进，你应该看到 *lib* 文件夹中一堆令人放心的绿色“100%”覆盖率数字。Jest 将报告语句（Stmts）、分支、函数（Funcs）和行的覆盖率百分比。
- en: Statements are referring to JavaScript statements, such as every expression,
    control flow statement, etc. Note that you could have 100% line coverage but not
    100% statement coverage because you can put multiple statements on a single line
    in JavaScript. Branch coverage refers to control flow statements, such as `if-else`.
    If you have an `if-else` statement and your test exercises only the `if` part,
    you will have 50% branch coverage for that statement.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 语句是指 JavaScript 语句，例如每个表达式、控制流语句等。请注意，你可以拥有 100% 的行覆盖率，但不一定有 100% 的语句覆盖率，因为你可以在
    JavaScript 中将多个语句放在一行上。分支覆盖率涉及控制流语句，例如 `if-else`。如果你有一个 `if-else` 语句，而你的测试仅执行了
    `if` 部分，那么这个语句的分支覆盖率为 50%。
- en: You may note that *meadowlark.js* does not have 100% coverage. This is not necessarily
    a problem; if you look at our refactored *meadowlark.js* file, you’ll see that
    most of what’s in there now is simply configuration…we’re just gluing things together.
    We’re configuring Express with the relevant middleware and starting the server.
    Not only would it be hard to meaningfully test this code, but it’s a reasonable
    argument that you shouldn’t have to since it’s merely assembling well-tested code.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到 *meadowlark.js* 并不具备 100% 的覆盖率。这并不一定是问题；如果你看一下我们重构后的 *meadowlark.js*
    文件，你会发现现在大部分内容只是配置……我们只是把各种东西粘合在一起。我们正在用相关的中间件配置 Express 并启动服务器。不仅这段代码很难进行有意义的测试，而且合理的论点是你不应该这样做，因为它只是组装经过充分测试的代码。
- en: You could even make the argument that the tests we’ve written so far are not
    particularly useful; they’re also just verifying that we’re configuring Express
    correctly.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以提出一个论点，迄今为止我们编写的测试并不特别有用；它们也只是验证我们是否正确配置了 Express。
- en: Once again, I have no easy answers. At the end of the day, the type of application
    you’re building, your level of experience, and the size and configuration of your
    team will have a large impact on how far down the test rabbit hole you go. I encourage
    you to err on the side of *too much* testing than *not enough*, but with experience,
    you’ll find the “just right” sweet spot.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 再次地，我没有简单的答案。在一天结束时，你正在构建的应用类型、你的经验水平以及团队的规模和配置将对你有多深入地进行测试产生很大影响。我鼓励你在测试方面保守一点，比不足要多一些，但随着经验的增加，你会找到“恰到好处”的甜蜜点。
- en: Integration Testing
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试
- en: 'There’s currently nothing interesting to test in our application; we just have
    a couple of pages and there’s no interaction. So before we write an integration
    test, let’s add some functionality that we can test. In the interest of keeping
    things simple, we’ll let that functionality be a link that allows you to get from
    the home page to the About page. It doesn’t get much simpler than that! And yet,
    as simple as that would appear to a user, it is a true integration test because
    it’s exercising not only two Express route handlers, but also the HTML and the
    DOM interaction (the user clicking the link and the resulting page navigation).
    Let’s add a link to *views/home.handlebars*:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用中目前没有什么有趣的东西可以测试；我们只有几个页面，没有互动。因此，在编写集成测试之前，让我们添加一些可以测试的功能。为了保持简单，我们让这个功能是一个链接，可以让你从主页跳转到关于页面。事实上，用户看起来这似乎很简单，但这是一个真正的集成测试，因为它不仅测试了两个
    Express 路由处理程序，还测试了 HTML 和 DOM 交互（用户点击链接和结果页面导航）。让我们在 *views/home.handlebars*
    中添加一个链接：
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You might be wondering about the `data-test-id` attribute. To make testing,
    we need some way to identify the link so we can (virtually) click it. We could
    have used a CSS class for this, but I prefer to reserve classes for styling and
    use data attributes for automation. We also could have searched for the text *About
    Us*, but that would be a fragile and expensive DOM search. We also could have
    queried against the `href` parameter, which would make sense (but then it would
    be harder to make this test fail, which we want to do for educational purposes).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想到`data-test-id`属性。为了进行测试，我们需要一种方法来识别链接，以便可以（虚拟）点击它。我们可以使用CSS类来实现这一点，但我更喜欢将类保留用于样式化，而使用数据属性进行自动化。我们还可以搜索*关于我们*的文本，但这将是一个脆弱且昂贵的DOM搜索。我们还可以根据`href`参数进行查询，这也是有道理的（但这样做会使得这个测试很难失败，这是我们出于教育目的希望的）。
- en: We can go ahead and run our application and verify with our clumsy human hands
    that the functionality works as intended before we move on to something more automated.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以启动我们的应用程序，并用我们笨拙的人类手来验证功能是否按预期工作，然后再进入更自动化的内容。
- en: 'Before we jump into installing Puppeteer and writing an integration test, we
    need to modify our application so that it can be required as a module (right now
    it is designed only to be run directly). The way to do that in Node is a little
    opaque: at the bottom of *meadowlark.js*, replace the call to `app.listen` with
    the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始安装Puppeteer并编写集成测试之前，我们需要修改我们的应用程序，使其可以作为模块被引用（目前它只能直接运行）。在Node中做到这一点的方法有点不透明：在*meadowlark.js*的底部，用以下内容替换对`app.listen`的调用：
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: I’ll skip the technical explanation for this as it’s rather tedious, but if
    you’re curious, a careful reading of [Node’s module documentation](http://bit.ly/32BDO3H)
    will make it clear. What’s important to know is that if you run a JavaScript file
    directly with node, `require.main` will equal the global `module`; otherwise,
    it’s being imported from another module.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我将跳过这个技术解释，因为它相当冗长，但如果你感兴趣，仔细阅读[Node的模块文档](http://bit.ly/32BDO3H)将会让你明白。重要的是要知道，如果你直接用node运行一个JavaScript文件，`require.main`将等于全局的`module`；否则，它是从另一个模块中导入的。
- en: 'Now that we’ve got that out of the way, we can install Puppeteer. Puppeteer
    is essentially a controllable, headless version of Chrome. (*Headless* simply
    means that the browser is capable of running without actually rendering a UI on-screen.)
    To install Puppeteer:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经搞定了，可以安装Puppeteer了。Puppeteer本质上是一个可控的、无头版本的Chrome浏览器。（*无头*意味着浏览器可以在不渲染UI的情况下运行。）要安装Puppeteer：
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We’ll also install a small utility to find an open port so that we don’t get
    a lot of test errors because our app can’t start on the port we requested:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将安装一个小工具来找到一个空闲端口，这样我们的应用程序就不会因为无法在请求的端口上启动而产生大量的测试错误：
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now we can write an integration that does the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写一个执行以下操作的集成：
- en: Starts our application server on an unoccupied port
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个未占用的端口上启动我们的应用程序服务器
- en: Launches a headless Chrome browser and opens a page
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个无头Chrome浏览器并打开一个页面
- en: Navigates to our application’s home page
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到我们应用程序的主页
- en: Finds a link with `data-test-id="about"` and clicks it
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找带有`data-test-id="about"`的链接并点击它
- en: Waits for the navigation to happen
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待导航发生
- en: Verifies that we are on the */about* page
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证我们是否在*/about*页面上
- en: 'Create a directory called *integration-tests* (you’re welcome to call it something
    else if you like) and a file in that directory called *basic-navigation.test.js*
    (*ch05/integration-tests/basic-navigation.test.js* in the companion repo):'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为*integration-tests*（如果你愿意，也可以起其他名字）的目录，并在该目录中创建一个文件*basic-navigation.test.js*（在伴随的仓库中是*ch05/integration-tests/basic-navigation.test.js*）：
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We are using Jest’s `beforeEach` and `afterEach` hooks to start our server before
    each test and stop it after each test (right now we have only one test, so this
    will really be meaningful when we add more tests). We could instead use `beforeAll`
    and `afterAll` so we’re not starting and tearing down our server for every test,
    which may speed up your tests, but at the cost of not having a “clean” environment
    for each test. That is, if one of your tests makes changes that affect the outcome
    of future tests, you’re introducing hard-to-maintain dependencies.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用Jest的`beforeEach`和`afterEach`钩子在每个测试之前启动服务器，并在每个测试之后关闭它（现在我们只有一个测试，所以当我们添加更多测试时，这将变得更有意义）。我们也可以使用`beforeAll`和`afterAll`，这样我们就不会为每个测试都启动和关闭服务器，这可能会加快测试速度，但代价是每个测试都不会有一个“干净”的环境。也就是说，如果你的某个测试对后续测试结果产生影响，你就引入了难以维护的依赖关系。
- en: Our actual test uses Puppeteer’s API, which gives us a lot of DOM query functionality.
    Note that almost everything here is asynchronous, and we’re using `await` liberally
    to make the test easier to read and write (almost all of the Puppeteer API calls
    return a promise).^([1](ch05.xhtml#idm45053597189896)) We wrap the navigation
    and the click together in a call to `Promise.all` to prevent race conditions per
    the Puppeteer documentation.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际测试使用了 Puppeteer 的 API，它为我们提供了大量的 DOM 查询功能。请注意，这里几乎所有的操作都是异步的，我们大量使用 `await`
    来使测试更易于阅读和编写（几乎所有 Puppeteer API 调用都返回一个 promise）。^([1](ch05.xhtml#idm45053597189896))
    我们将导航和点击包装在 `Promise.all` 调用中，以避免竞争条件，按照 Puppeteer 文档的建议。
- en: There’s far more functionality in the Puppeteer API than I could hope to cover
    in this book. Fortunately, it has [excellent documentation](http://bit.ly/2KctokI).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Puppeteer API 中有比我在本书中能够涵盖的功能多得多。幸运的是，它有 [优秀的文档](http://bit.ly/2KctokI)。
- en: Testing is a vital backstop in ensuring the quality of your product, but it’s
    not the only tool at your disposal. Linting helps you prevent common errors in
    the first place.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是确保产品质量的重要后备工具，但它并不是你手头唯一的工具。代码检查帮助你在第一时间防止常见错误。
- en: Linting
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码检查
- en: 'A good linter is like having a second set of eyes: it will spot things that
    will slide right past our human brains. The original JavaScript linter is Douglas
    Crockford’s JSLint. In 2011, Anton Kovalyov forked JSLint, and JSHint was born.
    Kovalyov found that JSLint was becoming too opinionated, and he wanted to create
    a more customizable, community-developed JavaScript linter. After JSHint came
    Nicholas Zakas’ [ESLint](https://eslint.org), which has become the most popular
    choice (it won by a landslide in the [2017 State of JavaScript survey](http://bit.ly/2Q7w32O)).
    In addition to its ubiquity, ESLint appears to be the most actively maintained
    linter, and I prefer its flexible configuration over JSHint, and it is what I
    am recommending.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的代码检查器就像有第二双眼睛一样：它会发现那些会轻易被我们的大脑忽略的问题。最初的 JavaScript 代码检查器是道格拉斯·克罗克福德的 JSLint。2011年，安东·科瓦留夫分叉了
    JSLint，JSHint 诞生了。科瓦留夫发现 JSLint 变得过于主观，他想创建一个更可定制、由社区开发的 JavaScript 代码检查器。在 JSHint
    之后是尼古拉斯·扎卡斯的 [ESLint](https://eslint.org)，它已成为最受欢迎的选择（在 [2017 JavaScript 现状调查](http://bit.ly/2Q7w32O)
    中遥遥领先）。除了普及性之外，ESLint 显然是最积极维护的代码检查器，我更喜欢它灵活的配置而不是 JSHint，并且这也是我推荐的。
- en: ESLint can be installed on a per project basis or globally. To avoid inadvertently
    breaking things, I try to avoid global installations (for example, if I install
    ESLint globally and update it frequently, old projects may no longer lint successfully
    because of breaking changes, and now I have to do the extra work of updating my
    project).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ESLint 可以基于每个项目安装或全局安装。为了避免无意中破坏东西，我尽量避免全局安装（例如，如果我全局安装 ESLint 并经常更新它，旧项目可能由于破坏性更改而无法成功
    lint，现在我必须额外工作来更新我的项目）。
- en: 'To install ESLint in your project:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要在你的项目中安装 ESLint：
- en: '[PRE13]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'ESLint requires a configuration file to tell it which rules to apply. Doing
    this from scratch would be a time-consuming task, so fortunately ESLint provides
    a utility for creating one for you. From your project root, run the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ESLint 需要一个配置文件来告诉它应用哪些规则。从零开始做这件事将是一项耗时的任务，所幸 ESLint 提供了一个实用工具来为你创建。从你的项目根目录运行以下命令：
- en: '[PRE14]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-140
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If we installed ESLint globally, we could just use `eslint --init`. The awkward
    `./node_modules/.bin` path is required to directly run locally installed utilities.
    We’ll see soon that we don’t have to do that if we add utilities to the `scripts`
    section of our *package.json* file, which is recommended for things we do frequently.
    However, creating an ESLint configuration is something we have to do only once
    per project.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们全局安装了 ESLint，我们可以直接使用 `eslint --init`。笨拙的 `./node_modules/.bin` 路径是必须的，以便直接运行本地安装的工具。我们很快会看到，如果我们将工具添加到
    *package.json* 文件的 `scripts` 部分，我们就不必这样做，这对于我们经常做的事情是推荐的。但是，创建 ESLint 配置是我们每个项目只需要做一次的事情。
- en: 'ESLint will ask you some questions. For most of them, it’s safe to choose the
    defaults, but a couple deserve note:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ESLint 会询问你一些问题。对于大多数问题，选择默认值是安全的，但有几个值得注意：
- en: What type of modules does your project use?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你的项目使用哪种类型的模块？
- en: Since we’re using Node (as opposed to code that will run in the browser), you’ll
    want to choose “CommonJS (require/exports).” You may have client-side JavaScript
    in your project too, in which case you may want a separate lint configuration.
    The easiest way to do this is to have two separate projects, but it is possible
    to have multiple ESLint configurations in the same project. Consult the [ESLint
    documentation](https://eslint.org/) for more information.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们使用的是 Node（而不是将在浏览器中运行的代码），你会想要选择“CommonJS (require/exports)”。“你的项目中可能也有客户端
    JavaScript，这种情况下可能需要一个单独的 lint 配置。最简单的方法是在同一个项目中有两个分开的项目，但在同一个项目中有多个 ESLint 配置也是可能的。请参阅
    [ESLint 文档](https://eslint.org/) 获取更多信息。
- en: Which framework does your project use?
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你的项目使用哪个框架？
- en: Unless you see Express on there (I don’t at the time of this writing), choose
    “None of these.”
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你在那里看到 Express（在我写作时还没有），选择“None of these”。
- en: Where does your code run?
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码在哪里运行？
- en: Choose Node.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 Node。
- en: 'Now that ESLint is set up, we need a convenient way of running it. Add the
    following to the `scripts` section of your *package.json*:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 ESLint 已经设置好了，我们需要一个便捷的方式来运行它。将以下内容添加到你的 *package.json* 的 `scripts` 部分：
- en: '[PRE15]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that we have to explicitly tell ESLint what files and directories we want
    to lint. This is an argument for collecting all of your source under one directory
    (usually *src*).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们必须明确告诉 ESLint 我们要 lint 哪些文件和目录。这是一个建议将所有源代码集中在一个目录（通常是 *src*）下的理由。
- en: 'Now brace yourself and run the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在准备好，运行以下命令：
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You’ll probably see a lot of unpleasant-looking errors—that’s usually what
    happens when you first run ESLint. However, if you’ve been following along with
    the Jest test, there will be some spurious errors related to Jest, which look
    like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会看到很多看起来不太好看的错误—通常当你第一次运行 ESLint 时会发生这种情况。然而，如果你一直在进行 Jest 测试，会有一些与 Jest
    相关的误报错误，看起来像这样：
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'ESLint (quite sensibly) doesn’t appreciate unrecognized global variables. Jest
    injects global variables (notably `test`, `describe`, `jest`, and `expect`). Fortunately,
    this is an easy problem to fix. In your project root, open the *.eslintrc.js*
    file (this is the ESLint configuration). In the `env` section, add the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ESLint（非常合理地）不允许未识别的全局变量。Jest 注入了全局变量（特别是 `test`、`describe`、`jest` 和 `expect`）。幸运的是，这是一个容易解决的问题。在你的项目根目录下，打开
    *.eslintrc.js* 文件（这是 ESLint 的配置文件）。在 `env` 部分，添加以下内容：
- en: '[PRE18]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now if you run `npm run lint` again, you should see a lot fewer errors.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果你再次运行 `npm run lint`，你应该会看到更少的错误。
- en: 'So what to do about the remaining errors? Here’s where I can offer wisdom but
    no specific guidance. Broadly speaking, a linting error has one of three causes:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 那么剩下的错误怎么办？这就是我能提供智慧但无具体指导的地方。总体来说，Lint 错误有三种原因：
- en: It’s a legitimate problem, and you should fix it. It may not always be obvious,
    in which case you may need to refer to the ESLint documentation for the particular
    error.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个合法的问题，你应该解决它。有时候问题可能并不明显，这时你可能需要参考 ESLint 文档中特定错误的部分。
- en: It’s a rule you don’t agree with, and you can simply disable it. Many of the
    rules in ESLint are a matter of opinion. I’ll demonstrate disabling a rule in
    a moment.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个你不同意的规则，你可以简单地禁用它。ESLint 中的许多规则都是主观的。稍后我会演示如何禁用一个规则。
- en: You agree with the rule, but there’s an instance where it’s infeasible or costly
    to fix in some specific circumstance. For those situations, you can disable rules
    for only specific lines in a file, which we’ll also see an example of.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你同意这个规则，但在特定情况下修复它是不可行或成本很高的。对于这些情况，你可以仅为文件中特定行禁用规则，我们也将看到一个示例。
- en: 'If you’ve been following along, you should currently see the following errors:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直在跟进，你现在应该看到以下错误：
- en: '[PRE19]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'ESLint complains about console logging because it’s not necessarily a good
    way to provide output for your application; it can be noisy and inconsistent,
    and, depending on how you run it, the output can get swept under the rug. However,
    for our use, let’s say it doesn’t bother us and we want to disable that rule.
    Open your *.eslintrc* file, find the `rules` section (if there isn’t a `rules`
    section, create one at the top level of the exported object), and add the following
    rule:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ESLint 抱怨控制台日志，因为这不一定是为你的应用提供输出的好方法；它可能会很嘈杂和不一致，并且根据运行方式，输出可能被忽略。然而，对于我们的用途，假设它并不影响我们，我们想要禁用这个规则。打开你的
    *.eslintrc* 文件，找到 `rules` 部分（如果没有 `rules` 部分，请在导出对象的顶层创建一个），然后添加以下规则：
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now if we run `npm run lint` again, we’ll see that error is no more! The next
    one is a little trickier….
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们再次运行`npm run lint`，就会看到这个错误不见了！接下来的问题有点棘手……
- en: 'Open *lib/handlers.js* and consider the line in question:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 打开*lib/handlers.js*，考虑问题行：
- en: '[PRE21]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ESLint is correct; we’re providing `next` as an argument but not doing anything
    with it (we’re also not doing anything with `err` and `req`, but because of the
    way JavaScript treats function arguments, we have to put *something* there so
    we can get at `res`, which we *are* using).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ESLint是正确的；我们将`next`作为参数传递，但没有做任何操作（我们也没有处理`err`和`req`，但由于JavaScript处理函数参数的方式，我们必须放置*某些*内容以便可以获取到`res`，我们确实在使用它）。
- en: 'You may be tempted to just remove the `next` argument. “What’s the harm?” you
    may think. And indeed, there would be no runtime errors, and your linter would
    be happy…but a hard-to-see harm would be done: your custom error handler would
    stop working! (If you want to see for yourself, throw an exception from one of
    your routes and try visiting it, and then remove the `next` argument from the
    `serverError` handler.)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会被诱惑只是删除`next`参数。“有什么害处？”你可能会想。确实，不会有运行时错误，并且你的代码检查工具会很高兴……但会造成一个难以察觉的伤害：你的自定义错误处理程序将停止工作！（如果你想自己看看，可以从一个路由抛出一个异常，然后尝试访问它，然后从`serverError`处理程序中删除`next`参数。）
- en: 'Express is doing something subtle here: it’s using the number of actual arguments
    you pass to it to recognize that it’s supposed to be an error handler. Without
    that `next` argument—whether you use it or not—Express no longer recognizes it
    as an error handler.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Express在这里做了一些微妙的事情：它使用您传递给它的实际参数数量来识别它应该是一个错误处理程序。如果没有那个`next`参数，无论您是否使用它，Express都不再将其识别为错误处理程序。
- en: Note
  id: totrans-173
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'What the Express team has done with the error handler is undeniably “clever,”
    but clever code can often be confusing, easy to break, or inscrutable. As much
    as I love Express, this is one choice I think the team got wrong: I think it should
    have found a less idiosyncratic and more explicit way to specify an error handler.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Express团队在错误处理程序上所做的事情无疑是“聪明”的，但聪明的代码往往会令人困惑、容易出错或难以理解。尽管我非常喜欢Express，但这是我认为团队做错的选择之一：我认为它应该找到一种不那么特异的、更明确的方式来指定错误处理程序。
- en: 'We can’t change our handler code, and we need our error handler, but we like
    this rule and don’t want to disable it. We could just live with the error, but
    the errors will accumulate and be a constant irritation, and they will eventually
    corrode the very point of having a linter. Fortunately, we can fix it by disabling
    that rule for that single line. Edit *lib/handlers.js* and add the following around
    your error handler:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法更改处理程序代码，我们需要我们的错误处理程序，但我们喜欢这个规则，不想禁用它。我们可以忍受这个错误，但错误会积累并成为一个不断的烦恼，最终会侵蚀拥有代码检查工具的初衷。幸运的是，我们可以通过禁用该规则来解决这个问题。在*lib/handlers.js*中编辑，并在你的错误处理程序周围添加以下内容：
- en: '[PRE22]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Linting can be a little frustrating at first—it may feel like it’s constantly
    tripping you up. And certainly you should feel free to disable rules that don’t
    suit you. Eventually, you will find it less and less frustrating as you learn
    to avoid the common mistakes that linting is designed to catch.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 刚开始时代码检查可能有点令人沮丧——似乎它不停地让你出错。当然，你应该随意禁用那些不适合你的规则。随着你学会避免代码检查旨在捕捉的常见错误，你会发现它越来越不令人沮丧。
- en: 'Testing and linting are undeniably useful, but any tool is worthless if you
    never use it! It may seem crazy that you would go to the time and trouble to write
    unit tests and set up linting, but I’ve seen it happen, especially when the pressure
    is on. Fortunately, there is a way to ensure that these helpful tools don’t get
    forgotten: continuous integration.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 测试和代码检查无疑是有用的，但任何工具如果你从不使用它就毫无价值！也许你会觉得很疯狂，你会花费时间和精力编写单元测试和设置代码检查，但我看过这种情况发生，尤其是在压力之下。幸运的是，有一种方法可以确保这些有用的工具不被遗忘：持续集成。
- en: Continuous Integration
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成
- en: 'I’ll leave you with another extremely useful QA concept: continuous integration
    (CI). It’s especially important if you’re working on a team, but even if you’re
    working on your own, it can provide some helpful discipline.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我给你留下另一个非常有用的QA概念：持续集成（CI）。如果你在团队中工作，这尤为重要，但即使你是独自工作，它也可以提供一些有益的纪律性。
- en: Basically, CI runs some or all of your tests every time you contribute code
    to a source code repository (you can control which branches this applies to).
    If all of the tests pass, nothing usually happens (you may get an email saying
    “good job,” depending on how your CI is configured).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，持续集成会在每次向源代码库贡献代码时运行一些或所有的测试（你可以控制这适用于哪些分支）。如果所有测试都通过了，通常不会发生任何事情（根据你的持续集成配置，你可能会收到一封“干得好”的电子邮件）。
- en: If, on the other hand, there are failures, the consequences are usually more…public.
    Again, it depends on how you configure your CI, but usually the entire team gets
    an email saying that you “broke the build.” If your integration master is really
    sadistic, sometimes your boss is also on that email list! I’ve even known teams
    that set up lights and sirens when someone broke the build, and in one particularly
    creative office, a tiny robotic foam missile launcher fired soft projectiles at
    the offending developer! It’s a powerful incentive to run your QA toolchain before
    committing.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果测试失败，后果通常更为……公开。同样，这取决于你如何配置你的持续集成，但通常整个团队都会收到一封邮件，告诉你“破坏了构建”。如果你的集成主管真的很刻薄，有时你的老板也会在那个邮件列表中！我甚至知道一些团队，他们设置了灯光和警报器，当有人破坏了构建时，一个微型机器人泡沫导弹发射器会向违规开发者发射软弹！这是在提交代码之前运行你的
    QA 工具链的一个强大激励。
- en: It’s beyond the scope of this book to cover installing and configuring a CI
    server, but a chapter on QA wouldn’t be complete without mentioning it.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的范围不包括安装和配置持续集成服务器，但涉及到 QA 的一章如果没有提到它，就不算完整。
- en: Currently, the most popular CI server for Node projects is [Travis CI](https://travis-ci.org/).
    Travis CI is a hosted solution, which can be appealing (it saves you from having
    to set up your own CI server). If you’re using GitHub, it offers excellent integration
    support. [CircleCI](https://circleci.com) is another option.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Node 项目中最流行的持续集成服务器是[Travis CI](https://travis-ci.org/)。Travis CI 是一种托管解决方案，这可能很吸引人（它可以帮助你避免设置自己的持续集成服务器）。如果你使用
    GitHub，它提供了优秀的集成支持。[CircleCI](https://circleci.com) 是另一个选择。
- en: If you’re working on a project on your own, you may not get much benefit from
    a CI server, but if you’re working on a team or an open source project, I highly
    recommend looking into setting up CI for your project.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是独自工作在一个项目上，你可能不会从持续集成服务器中获得太多好处，但如果你在团队或开源项目中工作，我强烈建议你考虑为你的项目设置持续集成。
- en: Conclusion
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: This chapter covered a lot of ground, but I consider these essential real-world
    skills in any development framework. The JavaScript ecosystem is dizzyingly large,
    and if you’re new to it, it can be hard to know where to start. I hope this chapter
    pointed you in the right direction.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了很多内容，但我认为这些是任何开发框架中的基本实际技能。JavaScript 生态系统非常庞大，如果你是新手，可能很难知道从哪里开始。我希望本章能指导你朝着正确的方向前进。
- en: 'Now that we have some experience with these tools, we’ll turn our attention
    to some fundamentals of the Node and Express objects that bracket everything that
    happens in an Express application: the request and response objects.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对这些工具有了一些经验，接下来我们将关注 Node 和 Express 对象的一些基本原理，这些对象包围着 Express 应用程序中发生的所有事情：请求和响应对象。
- en: ^([1](ch05.xhtml#idm45053597189896-marker)) If you are unfamiliar with `await`,
    I recommend [this article](http://bit.ly/2rEXU0d) by Tamas Piros.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch05.xhtml#idm45053597189896-marker)) 如果你对 `await` 不熟悉，我推荐阅读[Tamas Piros
    的这篇文章](http://bit.ly/2rEXU0d)。
