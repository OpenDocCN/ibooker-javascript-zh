- en: Chapter 10\. Modular JavaScript Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章。模块化 JavaScript 设计模式
- en: In the world of scalable JavaScript, when we say an application is *modular*,
    we often mean it’s composed of a set of highly decoupled, distinct pieces of functionality
    stored in modules. Loose coupling facilitates easier maintainability of apps by
    removing *dependencies* where possible. When implemented efficiently, it becomes
    pretty easy to see how changes to one part of a system may affect another.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在可扩展 JavaScript 的世界中，当我们说一个应用程序是 *模块化* 的时候，通常意味着它由一组高度解耦且独立的功能模块组成。松散耦合通过尽可能去除
    *依赖关系*，有助于更轻松地维护应用程序。当有效实施时，很容易看出系统的一部分变更如何影响另一部分。
- en: In the earlier chapters, we covered the importance of modular programming and
    the modern way of implementing modular design patterns. While [ES2015](https://oreil.ly/Pcc5o)
    introduced native modules to JavaScript, writing modular JavaScript was still
    possible before 2015.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们讨论了模块化编程的重要性以及实现现代模块化设计模式的方式。虽然 [ES2015](https://oreil.ly/Pcc5o) 向 JavaScript
    引入了原生模块，但在 2015 年之前，编写模块化 JavaScript 仍然是可能的。
- en: 'In this section, we will look at three formats for modular JavaScript using
    classic JavaScript (ES5) syntax: Asynchronous Module Definition (AMD), CommonJS,
    and Universal Module Definition (UMD). To learn more about JavaScript modules,
    please refer to [Chapter 5](ch05.xhtml#modern-javascript-syntax), which covers
    ES2015+ syntax for module imports, exports, and more.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨使用经典 JavaScript（ES5）语法的三种模块化 JavaScript 格式：异步模块定义（AMD）、CommonJS 和通用模块定义（UMD）。要了解更多关于
    JavaScript 模块的信息，请参阅 [第 5 章](ch05.xhtml#modern-javascript-syntax)，其中涵盖了 ES2015+
    语法用于模块的导入、导出等。
- en: A Note on Script Loaders
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本加载器注意事项
- en: It isn’t easy to discuss AMD and CommonJS modules without talking about [script
    loaders](https://oreil.ly/ssCQT). Script loading was a means to a goal. Modular
    JavaScript could be implemented only using compatible script loaders.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 谈论 AMD 和 CommonJS 模块时，很难不谈论 [脚本加载器](https://oreil.ly/ssCQT)。脚本加载是一种达到目标的手段。只有使用兼容的脚本加载器才能实现模块化
    JavaScript。
- en: Several great loaders were available for handling module loading in the AMD
    and CommonJS formats, but I personally preferred [RequireJS](https://oreil.ly/Ri_9R)
    and [curl.js](https://oreil.ly/s7QRg).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个优秀的加载器可用于处理 AMD 和 CommonJS 格式的模块加载，但我个人更喜欢 [RequireJS](https://oreil.ly/Ri_9R)
    和 [curl.js](https://oreil.ly/s7QRg)。
- en: AMD
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AMD
- en: The AMD format was introduced as a proposal for defining modules in which both
    the module and dependencies can be [asynchronously loaded](https://oreil.ly/iTNe3).
    The overall goal for the AMD format is to provide a solution for modular JavaScript
    that developers could use. It has several distinct advantages, including being
    both asynchronous and highly flexible by nature, which removes the tight coupling
    one might commonly find between code and module identity. Many developers enjoyed
    using AMD, and one could consider it a reliable stepping stone toward [JavaScript
    modules](https://oreil.ly/yxADG), which were unavailable at the time.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: AMD 格式作为定义模块的提案被引入，其中模块和依赖项可以异步加载。AMD 格式的总体目标是为开发人员提供可以使用的模块化 JavaScript 解决方案。它具有几个明显的优点，包括异步加载和高度灵活，这消除了代码与模块标识之间常见的紧密耦合。许多开发人员喜欢使用
    AMD，并且可以认为它是通向当时不可用的 JavaScript 模块的可靠过渡阶段。
- en: AMD began as a draft specification for a module format on the CommonJS list,
    but as it couldn’t reach full consensus, further development of the format moved
    to the [amdjs group](https://oreil.ly/0-XeU).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: AMD 最初作为 CommonJS 列表上的一个模块格式草案，但由于无法达成全面共识，该格式的进一步开发移至 [amdjs 组](https://oreil.ly/0-XeU)。
- en: It was embraced by projects including Dojo, MooTools, and even jQuery. Although
    the term *CommonJS AMD format* has been seen in the wild occasionally, it’s best
    to refer to it as just AMD or Async Module support because not all participants
    on the CommonJS list wished to pursue it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 它被包括 Dojo、MooTools 甚至 jQuery 在内的项目所采纳。尽管在野外偶尔可以见到 *CommonJS AMD 格式* 这个术语，但最好将其称为仅仅是
    AMD 或异步模块支持，因为并非所有 CommonJS 列表上的参与者都希望追求它。
- en: Note
  id: totrans-11
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: There was a time when the proposal was referred to as Modules Transport/C. However,
    because the spec wasn’t geared toward transporting existing CommonJS modules but
    rather for defining modules, it made more sense to opt for the AMD naming convention.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经有一段时间，这个提案被称为“模块传输/C”。然而，由于规范并非面向传输现有的 CommonJS 模块，而是用于定义模块，因此选择 AMD 命名约定更为合理。
- en: Getting Started with Modules
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块入门
- en: 'The first two concepts worth noting about AMD are the ideas of a `define` method
    for facilitating module definition and a `require` method for handling dependency
    loading. `define` is used to define named or unnamed modules using the following
    signature:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 AMD 值得注意的前两个概念是 `define` 方法用于简化模块定义和 `require` 方法用于处理依赖项加载。`define` 用于定义具名或匿名模块，使用以下签名：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As we can tell by the inline comments, the `module_id` is an optional argument
    that is typically required only when non-AMD concatenation tools are being used
    (there may be some other edge cases where it’s useful, too). When this argument
    is left out, we refer to the module as *anonymous*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如内联注释所示，`module_id` 是一个可选参数，通常仅在使用非 AMD 连接工具时才需要（可能还有一些其他情况下它也很有用）。当省略此参数时，我们将模块称为
    *匿名*。
- en: When working with anonymous modules, the idea of a module’s identity is DRY
    (Don’t repeat yourself), making it trivial to avoid duplication of filenames and
    code. Because the code is more portable, it can be easily moved to other locations
    (or around the filesystem) without needing to alter the code itself or change
    its module ID. Consider the `module_id` similar to the concept of folder paths.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理匿名模块时，模块身份的概念是 DRY（不要重复自己），这使得避免文件名和代码重复变得轻而易举。由于代码更具可移植性，可以轻松地将其移动到其他位置（或者文件系统中的其他位置）而无需修改代码本身或更改其模块
    ID。将 `module_id` 视为类似于文件夹路径的概念。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Developers can run this same code on multiple environments using an AMD optimizer
    that works with a CommonJS environment such as [r.js](https://oreil.ly/48dSL).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员可以在多个环境中使用 AMD 优化器运行相同的代码，该优化器适用于 CommonJS 环境，如 [r.js](https://oreil.ly/48dSL)。
- en: Back to the `define` signature, the `dependencies` argument represents an array
    of dependencies required by the module we are defining, and the third argument
    (`definition` `function` or `factory function`) is a function that’s executed
    to instantiate our module. A bare bones module could be defined as in [Example 10-1](#understanding_AMD_define).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 `define` 的签名，`dependencies` 参数表示我们正在定义的模块所需的一组依赖项数组，第三个参数（`definition` `function`
    或 `factory function`）是一个执行以实例化我们的模块的函数。一个最简单的模块可以像 [示例 10-1](#understanding_AMD_define)
    中定义的那样。
- en: 'Example 10-1\. Understanding AMD: `define()`'
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-1\. 理解 AMD：`define()`
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: On the other hand, `require` is typically used to load code in a top-level JavaScript
    file or within a module should we wish to fetch dependencies dynamically. An example
    of its usage is in [Example 10-2](#understanding_AMD_require).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`require` 通常用于在顶层 JavaScript 文件中加载代码或者在模块内部加载依赖项。其使用示例在 [示例 10-2](#understanding_AMD_require)
    中。
- en: 'Example 10-2\. Understanding AMD: `require()`'
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-2\. 理解 AMD：`require()`
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[Example 10-3](#dynamically-loaded-dependencies) shows a dynamically loaded
    dependency:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10-3](#dynamically-loaded-dependencies) 展示了动态加载的依赖：'
- en: Example 10-3\. Dynamically loaded dependencies
  id: totrans-27
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-3\. 动态加载的依赖
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[Example 10-4](#understanding-amd-plugins) shows defining an AMD-compatible
    plug-in.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10-4](#understanding-amd-plugins) 展示了如何定义一个兼容 AMD 的插件。'
- en: 'Example 10-4\. Understanding AMD: plug-ins'
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-4\. 理解 AMD：插件
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-32
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Although `css!` is included for loading Cascading Style Sheets (CSS) dependencies
    in the preceding example, it’s important to remember that this approach has some
    caveats, such as not being able to establish when the CSS is fully loaded. Depending
    on how we approach our build process, it may also result in CSS being included
    as a dependency in the optimized file, so use CSS as a loaded dependency in such
    cases with caution. If you’re interested in doing this, we can explore [@VIISON’s
    RequireJS CSS plug-in](https://oreil.ly/PrLim).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在前面的示例中包含 `css!` 用于加载层叠样式表（CSS）依赖，但重要的是要记住，这种方法有一些注意事项，例如无法确定 CSS 是否完全加载。根据我们的构建过程的不同方法，这可能导致
    CSS 作为优化文件的依赖项被包含在内，因此在这种情况下谨慎使用 CSS 作为加载的依赖项。如果您有兴趣尝试这样做，我们可以探索 [@VIISON’s RequireJS
    CSS plug-in](https://oreil.ly/PrLim)。
- en: 'This example could simply be looked at as `requirejs(["app/myModule"], function(){})`,
    which indicates the loader’s top-level globals are being used. This is how to
    kick off the top-level loading of modules with different AMD loaders. However,
    if a `define()` function is passed as a local require, all `require([]`) examples
    apply to both types of loader: curl.js and RequireJS (Examples [10-5](#loading-amd-using-requirejs)
    and [10-6](#loading-amd-using-curljs)).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以简单地被看作是`requirejs(["app/myModule"], function(){})`，这表明顶级加载器正在被使用。这是如何启动具有不同AMD加载器的顶级模块加载的方式。然而，如果`define()`函数作为本地require传递，所有`require([])`示例都适用于curl.js和RequireJS（示例[10-5](#loading-amd-using-requirejs)和[10-6](#loading-amd-using-curljs)）。
- en: Example 10-5\. Loading AMD modules using RequireJS
  id: totrans-35
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例10-5\. 使用RequireJS加载AMD模块
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Example 10-6\. Loading AMD modules using curl.js
  id: totrans-37
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例10-6\. 使用curl.js加载AMD模块
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'What follows is the code for modules with deferred dependencies:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是具有延迟依赖关系的模块代码：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As we’ve seen in previous sections, design patterns can be highly effective
    in improving how we approach structuring solutions to common development problems.
    [John Hann](https://oreil.ly/SrQI5) has given some excellent presentations about
    AMD module design patterns covering the Singleton, Decorator, Mediator, and others.
    I highly recommend checking out his [slides](https://oreil.ly/7koME).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在以往的章节中，设计模式在改善我们处理常见开发问题的解决方案结构化方法上可以发挥极大的效果。[约翰·汉](https://oreil.ly/SrQI5)关于AMD模块设计模式的出色演讲，涵盖了单例模式、装饰者模式、中介者模式等等。我强烈推荐查看他的[幻灯片](https://oreil.ly/7koME)。
- en: AMD Modules with jQuery
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用jQuery的AMD模块
- en: 'jQuery comes with only one file. However, given the plug-in-based nature of
    the library, we can demonstrate how straightforward it is to define an AMD module
    that uses it here:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery只有一个文件。然而，考虑到库的插件化特性，我们可以演示如何定义一个使用它的AMD模块：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: However, there is something missing from this example, and it’s the registration
    concept.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这个例子缺少了一些东西，那就是注册概念。
- en: Registering jQuery as an async-compatible module
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将jQuery注册为异步兼容模块
- en: One of the key features that landed in jQuery 1.7 was support for registering
    jQuery as an asynchronous module. A number of compatible script loaders (including
    RequireJS and curl) are capable of loading modules using an asynchronous module
    format, which means fewer hacks are required to get things working.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 1.7 中引入的一个关键特性是支持将jQuery注册为异步模块。多个兼容的脚本加载器（包括RequireJS和curl）能够使用异步模块格式加载模块，这意味着在使事情运行起来时需要的hack更少。
- en: If a developer wants to use AMD and does not want her jQuery version leaking
    into the global space, she should call `noConflict` in their top-level module
    that uses jQuery. In addition, since multiple versions of jQuery can be on a page,
    there are special considerations that an AMD loader must account for, so jQuery
    only registers with AMD loaders that have recognized these concerns, which are
    indicated by the loader specifying `define.amd.jQuery`. RequireJS and curl are
    two loaders that do so.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果开发者希望使用AMD，并且不希望她的jQuery版本泄漏到全局空间，她应该在使用jQuery的顶级模块中调用`noConflict`。此外，由于页面上可能存在多个版本的jQuery，AMD加载器必须考虑特殊情况，因此jQuery只在AMD加载器中注册为已识别这些问题的加载器所支持的模块，这些问题由加载器指定的`define.amd.jQuery`表示。RequireJS和curl是两个这样做的加载器。
- en: 'The named AMD provides a robust and safe safety blanket for most use cases:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 命名AMD为大多数用例提供了一个强大而安全的安全保护：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Why was AMD a better choice for writing modular JavaScript?
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么AMD是编写模块化JavaScript的更好选择？
- en: We have now reviewed several code samples taking us through what AMD is capable
    of. It appears to be more than just a typical Module pattern, but why was it a
    better choice for modular application development?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经回顾了几个代码示例，展示了AMD的功能。它似乎不仅仅是一个典型的模块模式，那么为什么它对于模块化应用开发是更好的选择呢？
- en: Provides a clear proposal for how to approach defining flexible modules.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供了一个明确的建议，来定义灵活的模块。
- en: Significantly cleaner than the present global namespace and `<script>` tag solutions
    many of us rely on. There’s a clean way to declare standalone modules and dependencies
    they may have.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比目前的全局命名空间和`<script>`标签解决方案干净得多。有一种清晰的方法来声明独立的模块及其可能的依赖关系。
- en: Module definitions are encapsulated, helping us to avoid pollution of the global
    namespace.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块定义是封装的，帮助我们避免全局命名空间的污染。
- en: Arguably works better than some alternative solutions (e.g., CommonJS, which
    we’ll be looking at shortly). It doesn’t have issues with cross-domain, local,
    or debugging and doesn’t rely on server-side tools to be used. Most AMD loaders
    support loading modules in the browser without a build process.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以说比某些替代方案（例如，CommonJS，我们很快将会讨论）更有效。它没有跨域、本地或调试问题，并且不依赖于服务器端工具来使用。大多数AMD加载器支持在浏览器中加载模块，无需构建过程。
- en: Provides a “transport” approach for including multiple modules in a single file.
    Other approaches like CommonJS have yet to agree on a transport format.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供了一种“传输”方法，可以在单个文件中包含多个模块。其他如CommonJS的方法尚未就传输格式达成一致。
- en: It’s possible to lazy-load scripts if this is needed.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要的话，可以延迟加载脚本。
- en: Note
  id: totrans-59
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Most of the points mentioned are valid for YUI’s module-loading strategy.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数提到的观点对于YUI的模块加载策略也是有效的。
- en: Related reading for AMD
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与AMD相关的阅读
- en: '[The RequireJS Guide to AMD](https://oreil.ly/uPEJg)'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[RequireJS指南到AMD](https://oreil.ly/uPEJg)'
- en: '[What’s the Fastest Way to Load AMD Modules?](https://oreil.ly/Z04H9)'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[如何最快地加载AMD模块？](https://oreil.ly/Z04H9)'
- en: '[AMD vs. CommonJS, What’s the Better Format?](https://oreil.ly/W4Fqi)'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[AMD vs. CommonJS，哪个格式更好？](https://oreil.ly/W4Fqi)'
- en: '[The Future Is Modules Not Frameworks](https://oreil.ly/A9S7c)'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[未来是模块而不是框架](https://oreil.ly/A9S7c)'
- en: '[AMD No Longer a CommonJS Specification](https://oreil.ly/Tkti9)'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[AMD不再是CommonJS规范](https://oreil.ly/Tkti9)'
- en: '[On Inventing JavaScript Module Formats and Script Loaders](https://oreil.ly/AB01l)'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[关于发明JavaScript模块格式和脚本加载器](https://oreil.ly/AB01l)'
- en: '[The AMD Mailing List](https://oreil.ly/jdTYO)'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[AMD邮件列表](https://oreil.ly/jdTYO)'
- en: Script loaders and frameworks that support AMD
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持AMD的脚本加载器和框架
- en: 'In-browser:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器内：
- en: '[RequireJS](https://oreil.ly/Ri_9R)'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[RequireJS](https://oreil.ly/Ri_9R)'
- en: '[curl.js](https://oreil.ly/fi105)'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[curl.js](https://oreil.ly/fi105)'
- en: '[Yabble](https://oreil.ly/oBWDi)'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Yabble](https://oreil.ly/oBWDi)'
- en: '[PINF](https://oreil.ly/C28-D)'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[PINF](https://oreil.ly/C28-D)'
- en: And more
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有更多
- en: 'Server-side:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端：
- en: '[RequireJS](https://oreil.ly/Ri_9R)'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[RequireJS](https://oreil.ly/Ri_9R)'
- en: '[PINF](https://oreil.ly/TJldu)'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[PINF](https://oreil.ly/TJldu)'
- en: AMD Conclusions
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AMD结论
- en: Having used AMD for several projects, I conclude that it ticks a lot of the
    checkboxes that developers creating serious applications might desire from a better
    module format. It avoids the need to worry about globals, supports named modules,
    doesn’t require server transformation to function, and is a pleasure to use for
    dependency management.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在几个项目中使用AMD后，我得出结论，它符合开发人员从更好的模块格式中可能希望得到的许多需求。它避免了担心全局变量，支持命名模块，不需要服务器转换即可运行，并且在依赖管理方面使用起来非常愉快。
- en: It’s also an excellent addition for modular development using Backbone.js, ember.js,
    or other structural frameworks for keeping applications organized.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用Backbone.js、ember.js或其他结构化框架来保持应用程序组织化的模块化开发，这也是一个很好的补充。
- en: As AMD was heavily discussed within the Dojo and CommonJS worlds, we know it’s
    had time to mature and evolve. We also know it’s been battle-tested in the wild
    by a number of large companies to build nontrivial applications (IBM, BBC iPlayer),
    and so, if it didn’t work, chances are they would have abandoned it, but they
    didn’t.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于AMD在Dojo和CommonJS世界中得到了广泛讨论，我们知道它已经有了时间成熟和演变。我们也知道它已经在实际项目中经过大公司的考验来构建非常规模的应用程序（IBM，BBC
    iPlayer），所以如果它不起作用，他们很有可能会放弃它，但他们没有。
- en: That said, there are still areas where AMD could have been improved. Developers
    who have used the format for some time may feel the AMD boilerplate/wrapper code
    was an annoying overhead. While I share this concern, there were tools such as
    [Volo](https://oreil.ly/TLSYv) that helped work around these issues, and I would
    argue that, on the whole, the pros with using AMD far outweighed the cons.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，仍然有一些地方可以改进AMD。使用该格式一段时间的开发人员可能会觉得AMD的包装代码是一种烦人的开销。虽然我也有这个担忧，但有一些工具，如[Volo](https://oreil.ly/TLSYv)，帮助解决了这些问题，我认为总体来说，使用AMD的利弊远远超过了不利因素。
- en: CommonJS
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CommonJS
- en: The CommonJS module proposal specifies a simple API for declaring modules server-side.
    Unlike AMD, it attempts to cover broader concerns such as I/O, file-system, promises,
    and more.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: CommonJS 模块提案为声明服务器端模块提供了一个简单的API。与AMD不同，它试图涵盖更广泛的问题，如I/O、文件系统、promises等。
- en: Originally called ServerJS in a project started by Kevin Dangoor back in 2009,
    the format was later formalized by [CommonJS](https://oreil.ly/EUFt3), a volunteer
    working group that aims to design, prototype, and standardize JavaScript APIs.
    They attempted to ratify standards for both [modules](https://oreil.ly/v_hsu)
    and [packages](https://oreil.ly/Trgzj).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最初由凯文·丹古尔在2009年启动的项目中称为ServerJS，后来该格式由[CommonJS](https://oreil.ly/EUFt3)，一个志愿工作组正式规范化，旨在设计、原型化和标准化JavaScript
    API。他们试图为[模块](https://oreil.ly/v_hsu)和[包](https://oreil.ly/Trgzj)制定标准。
- en: Getting Started
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入门指南
- en: From a structural perspective, a CommonJS module is a reusable piece of JavaScript
    that exports specific objects made available to any dependent code. Unlike AMD,
    there are typically no function wrappers around such modules (so we won’t see
    `define` here, for example).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从结构上看，CommonJS模块是可重用的JavaScript片段，它导出特定对象，供任何依赖代码使用。与AMD不同，这些模块通常没有函数包装器（例如，在这里我们不会看到`define`）。
- en: 'CommonJS modules contain two primary parts: a free variable named `exports`,
    which includes the objects a module wishes to make available to other modules,
    and a `require` function that modules can use to import the exports of other modules
    (Examples [10-7](#understanding-common-js-exports), [10-8](#basic-consumption-of-exports),
    and [10-9](#amd-equivalent-first-commonjs)).'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: CommonJS模块包含两个主要部分：一个名为`exports`的自由变量，其中包含模块希望向其他模块提供的对象，以及模块可以使用的`require`函数来导入其他模块的exports（示例[10-7](#understanding-common-js-exports)、[10-8](#basic-consumption-of-exports)和[10-9](#amd-equivalent-first-commonjs)）。
- en: 'Example 10-7\. Understanding CommonJS: `require()` and `exports`'
  id: totrans-90
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-7\. 理解CommonJS：`require()` 和 `exports`
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Example 10-8\. Basic consumption of `exports`
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-8\. `exports` 的基本使用
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In [Example 10-8](#basic-consumption-of-exports), we first import the module
    containing the `foo` function from [Example 10-7](#understanding-common-js-exports)
    using the `require()` function. Then, we consume the `foo` function by calling
    it from the imported module with `exampleModule.foo()`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 10-8](#basic-consumption-of-exports)中，我们首先使用`require()`函数从[示例 10-7](#understanding-common-js-exports)导入包含`foo`函数的模块。然后，我们通过从导入的模块调用它来消费`foo`函数，使用`exampleModule.foo()`。
- en: Example 10-9\. AMD-equivalent of the first CommonJS example
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-9\. 第一个CommonJS示例的AMD等效
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This can be done as AMD supports a [simplified CommonJS wrapping](https://oreil.ly/IzG9s)
    feature.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过AMD支持的[简化的CommonJS包装](https://oreil.ly/IzG9s)功能来完成。
- en: Consuming Multiple Dependencies
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用多个依赖项
- en: '*app.js*:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*app.js*：'
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*bar.js:*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*bar.js*：'
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*foo.js:*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*foo.js*：'
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: CommonJS in Node.js
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Node.js中的CommonJS
- en: The ES module format has become the standard format for encapsulating JavaScript
    code for reuse, but CommonJS is the default in Node.js. CommonJS modules are the
    original way to package JavaScript code for [Node.js](https://oreil.ly/4Bh_O),
    although starting with version 13.2.0, Node.js has stable support of ES modules.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ES模块格式已成为封装JavaScript代码以便复用的标准格式，但在Node.js中默认使用CommonJS。CommonJS模块是为[Node.js](https://oreil.ly/4Bh_O)打包JavaScript代码的原始方式，尽管从版本13.2.0开始，Node.js稳定支持ES模块。
- en: 'By default, Node.js treats the following as CommonJS modules:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Node.js将以下内容视为CommonJS模块：
- en: Files with a *.cjs* extension
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展名为 *.cjs* 的文件
- en: Files with a *.js* extension when the nearest parent *package.json* file contains
    a top-level field *type* with a value of *commonjs*
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当最近的父级*package.json*文件包含值为*commonjs*的顶级字段*type*时，具有扩展名为*.js*的文件
- en: Files with a *.js* extension when the nearest parent *package.json* file doesn’t
    contain a top-level field *type*
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当最近的父级*package.json*文件不包含顶级字段*type*时，具有*.js*扩展名的文件
- en: Files with an extension that is not *.mjs*, *.cjs*, *.json*, *.node*, or *.js*
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有不是*.mjs*、*.cjs*、*.json*、*.node*或*.js*扩展名的文件
- en: Calling `require()` always uses the CommonJS module loader, while calling `import()`
    always uses the ECMAScript module loader irrespective of the type value configured
    in the nearest parent *package.json*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`require()`始终使用CommonJS模块加载器，而调用`import()`则始终使用ECMAScript模块加载器，不考虑在最近的父级*package.json*中配置的type值。
- en: Many Node.js libraries and modules are written with CommonJS. For browser support,
    all major browsers support the ES module syntax, and you can use import/export
    in frameworks like React and Vue.js. These frameworks use a transpiler like Babel
    to compile the import/export syntax to `require()`, which older Node.js versions
    natively support. Libraries written using ES6 module syntax will be transpiled
    to CommonJS under the hood if you run the code in Node.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Node.js库和模块使用CommonJS编写。为了浏览器支持，所有主流浏览器支持ES模块语法，并且你可以在像React和Vue.js这样的框架中使用import/export。这些框架使用像Babel这样的转译器将import/export语法编译成`require()`，而旧版本的Node.js本身支持这种方式。如果在Node中运行代码，使用ES6模块语法编写的库将在底层转译为CommonJS。
- en: Is CommonJS Suitable for the Browser?
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CommonJS适合浏览器吗？
- en: There are developers who feel that CommonJS is better suited to server-side
    development, which is one reason there was a disagreement over whether AMD or
    CommonJS should be used as the de facto standard before ES2015\. Some arguments
    against CommonJS were that many CommonJS APIs address server-oriented features
    that one would be unable to implement at a browser level in JavaScript—for example,
    *io*, *system*, and *js* could be considered unimplementable by the nature of
    their functionality.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 有些开发人员认为CommonJS更适合服务器端开发，这也是在ES2015成为事实标准之前，是否应该使用AMD或CommonJS存在争议的原因之一。一些反对CommonJS的观点是，许多CommonJS
    API涉及服务器导向特性，这些特性在JavaScript的浏览器级别可能无法实现，例如*io*、*system*和*js*可以考虑由于其功能的性质而不可实现。
- en: Regardless, it’s useful to know how to structure CommonJS modules so that we
    can better appreciate how they fit in when defining modules that may be used everywhere.
    Modules with applications on both the client and server include validation, conversion,
    and templating engines. Some developers approached choosing which format to use
    by opting for CommonJS when a module can be used in a server-side environment
    and using AMD or ES2015 if this is not the case.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，了解如何构造CommonJS模块非常有用，这样我们就能更好地理解它们在定义可以在各处使用的模块时的适用性。在客户端和服务器都有应用的模块包括验证、转换和模板引擎。一些开发人员在选择使用哪种格式时，选择在可以在服务器端使用模块时使用CommonJS，而在不是这种情况下则使用AMD或ES2015。
- en: ES2015 and AMD modules can define more granular things like constructors and
    functions. CommonJS modules can only define objects, which can be tedious to work
    with if we’re trying to obtain constructors from them. For new projects in Node.js,
    ES2015 modules provide an alternative to CommonJS on the server and also ensure
    that the syntax is identical to the client-side code. Thus, it creates an easier
    route to isomorphic JavaScript, which can run in the browser or on the server.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ES2015和AMD模块可以定义更细粒度的东西，如构造函数和函数。CommonJS模块只能定义对象，如果我们试图从中获取构造函数，则可能会变得繁琐。对于Node.js中的新项目，ES2015模块为服务器端提供了与客户端代码相同的语法，同时也确保了更容易的同构JavaScript路径，可以在浏览器或服务器上运行。
- en: Although it’s beyond the scope of this section, you may have noticed that there
    were different types of `require` methods mentioned when discussing AMD and CommonJS.
    The concern with a similar naming convention is confusion, and the community is
    split on the merits of a global `require` function. John Hann’s suggestion here
    is that rather than calling it `require`, which would probably fail to achieve
    the goal of informing users about the different between a global and inner `require`,
    it may make more sense to rename the global loader method something else (e.g.,
    the name of the library). It’s for this reason that a loader like curl.js uses
    `curl()` instead of `require`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这超出了本节的范围，但你可能注意到在讨论AMD和CommonJS时提到了不同类型的`require`方法。对于类似命名约定的担忧是混淆，社区对于全局`require`函数的优点存在分歧。John
    Hann在这里建议，与其称其为`require`，这可能不能实现告知用户全局和内部`require`之间差异的目标，更好地将全局加载器方法命名为其他名称可能更有意义（例如，库的名称）。因此，像curl.js这样的加载器使用`curl()`而不是`require`。
- en: Related Reading for CommonJS
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CommonJS相关阅读
- en: '[JavaScript Growing Up](https://oreil.ly/NeuFT)'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[JavaScript的成长](https://oreil.ly/NeuFT)'
- en: '[The RequireJS Notes on CommonJS](https://oreil.ly/Nb-5e)'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[关于CommonJS的RequireJS笔记](https://oreil.ly/Nb-5e)'
- en: '[Taking Baby Steps with Node.js and CommonJS—Creating Custom Modules](https://oreil.ly/ZpO5u)'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[用Node.js和CommonJS迈出第一步——创建自定义模块](https://oreil.ly/ZpO5u)'
- en: '[Asynchronous CommonJS Modules for the Browser](https://oreil.ly/gJhQA)'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[用于浏览器的异步CommonJS模块](https://oreil.ly/gJhQA)'
- en: '[The CommonJS Mailing List](https://oreil.ly/rL3C2)'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CommonJS邮件列表](https://oreil.ly/rL3C2)'
- en: 'AMD and CommonJS: Competing, but Equally Valid Standards'
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AMD 和 CommonJS：竞争，但同样有效的标准
- en: Both AMD and CommonJS are valid module formats with different end goals.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: AMD 和 CommonJS 都是具有不同终极目标的有效模块格式。
- en: AMD adopts a browser-first approach to development, opting for asynchronous
    behavior and simplified backward compatibility, but it doesn’t have any concept
    of file I/O. It supports objects, functions, constructors, strings, JSON, and
    many other types of modules, running natively in the browser. It’s incredibly
    flexible.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: AMD 采用了面向浏览器的开发方法，选择了异步行为和简化的向后兼容性，但它没有任何文件 I/O 的概念。它原生支持在浏览器中运行的对象、函数、构造函数、字符串、JSON
    和许多其他类型的模块。它非常灵活。
- en: CommonJS, on the other hand, takes a server-first approach, assuming synchronous
    behavior, no global *baggage*, and attempts to cater to the future (on the server).
    What I mean by this is that because CommonJS supports unwrapped modules, it can
    feel a little closer to the ES2015+ specifications, freeing us of the `define()`
    wrapper that AMD enforces. CommonJS modules, however, support objects only as
    modules.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，CommonJS 采用了服务器优先的方法，假设同步行为，没有全局*包袱*，并试图满足未来（在服务器上）。我的意思是，因为 CommonJS 支持未包装的模块，它可能感觉更接近
    ES2015+ 规范，从而免除了 AMD 强制的 `define()` 包装器。然而，CommonJS 模块仅支持对象作为模块。
- en: 'UMD: AMD and CommonJS-Compatible Modules for Plug-ins'
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UMD：AMD 和 CommonJS 兼容的插件模块
- en: These solutions could be a little lacking for developers wishing to create modules
    that can work in browser and server-side environments. To help alleviate this,
    James Burke, I, and several other developers created [Universal Module Definition
    (UMD)](https://oreil.ly/HaHHJ).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这些解决方案对希望创建能够在浏览器和服务器端环境中工作的模块的开发人员可能有些欠缺。为了帮助缓解这一问题，James Burke、我和其他几位开发人员创建了[通用模块定义（UMD）](https://oreil.ly/HaHHJ)。
- en: UMD is an experimental module format that allows the definition of modules that
    work in both client and server environments with all or most of the popular script-loading
    techniques available at the time of writing. Although the idea of (yet) another
    module format may be daunting, we will cover UMD briefly for thoroughness.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: UMD 是一种实验性模块格式，允许定义在客户端和服务器环境中均可运行的模块，并支持写作时的大多数流行脚本加载技术。尽管再次引入（另一种）模块格式的想法可能令人生畏，我们将为了全面性而简要介绍
    UMD。
- en: 'We began defining UMD by looking at the simplified CommonJS wrapper supported
    in the AMD specification. Developers wishing to write modules as if they were
    CommonJS modules could use the following CommonJS-compatible format:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始定义 UMD，看看在 AMD 规范中支持的简化的 CommonJS 包装器。希望以 CommonJS 模块的方式编写模块的开发人员可以使用以下兼容
    CommonJS 的格式：
- en: Basic AMD hybrid format
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本的 AMD 混合格式
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It’s essential, however, to note that a module is really only treated as a CommonJS
    module if it doesn’t contain a dependency array and the definition function contains
    one parameter at minimum. This also won’t work correctly on some devices (e.g.,
    the PS3). For further information about the wrapper, see the [RequireJS documentation](https://oreil.ly/7A9k6).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，重要的是要注意，如果模块不包含依赖数组并且定义函数包含至少一个参数，那么模块才真正被视为 CommonJS 模块。这在某些设备上（例如 PS3）可能无法正常工作。有关包装器的更多信息，请参阅[RequireJS
    文档](https://oreil.ly/7A9k6)。
- en: Taking this further, we wanted to provide several different patterns that worked
    with AMD and CommonJS and solved typical compatibility problems developers wishing
    to develop such modules had with other environments.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步说，我们希望提供几种不同的模式，这些模式与 AMD 和 CommonJS 兼容，并解决了开发人员在其他环境中希望开发这些模块时遇到的典型兼容性问题。
- en: One such variation we can see next allows us to use CommonJS, AMD, or browser
    globals to create a module.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 下面我们可以看到一种变体，允许我们使用 CommonJS、AMD 或浏览器全局来创建模块。
- en: Using CommonJS, AMD, or browser globals to create a module
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 CommonJS、AMD 或浏览器全局来创建模块
- en: Define a module `commonJsStrict`, which depends on another module called `b`.
    The filename implies the module’s name, and it’s best practice for the filename
    and the exported global to have the same name.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个名为 `commonJsStrict` 的模块，它依赖于另一个名为 `b` 的模块。文件名暗示了模块的名称，最佳实践是文件名和导出的全局变量具有相同的名称。
- en: 'If the module `b` also uses the same boilerplate type in the browser, it will
    create a global `.b` that is used. If we don’t wish to support the browser global
    patch, we can remove the `root` and pass `this` as the first argument to the top
    function:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模块 `b` 在浏览器中也使用相同的样板类型，它将创建一个名为 `.b` 的全局变量供使用。如果我们不希望支持浏览器全局修补程序，我们可以删除 `root`
    并将 `this` 作为顶部函数的第一个参数传递：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The UMD repository contains variations covering modules that work optimally
    in the browser, those best for providing exports, those optimal for CommonJS runtimes,
    and even those that work best for defining jQuery plug-ins, which we will look
    at next.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: UMD 仓库包含了各种变体，涵盖了在浏览器中最佳运行的模块、最适合提供导出的模块、在 CommonJS 运行时最佳运行的模块，甚至是最适合定义 jQuery
    插件的模块，我们将在下面讨论这些内容。
- en: jQuery plug-ins that function in all environments
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在所有环境中都有效的 jQuery 插件
- en: 'UMD provides two patterns for working with jQuery plug-ins: one that defines
    plug-ins that work well with AMD and browser globals and another that can also
    work in CommonJS environments. jQuery is not likely to be used in most CommonJS
    environments, so keep this in mind unless we’re working with an environment that
    does play well with it.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: UMD 提供了两种适用于 jQuery 插件的模式：一种定义适用于 AMD 和浏览器全局的插件，另一种也可以在 CommonJS 环境中使用。jQuery
    不太可能在大多数 CommonJS 环境中使用，请记住这一点，除非我们正在处理与之兼容良好的环境。
- en: We will now define a plug-in composed of a core and an extension to that core.
    The core plug-in is loaded into a `$.core` namespace, which can then be easily
    extended using plug-in extensions via the namespacing pattern. Plug-ins loaded
    via `script` tags automatically populate a `plugin` namespace under `core` (i.e.,
    `$.core.plugin.methodName()`).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将定义一个由核心和该核心的扩展组成的插件。核心插件加载到 `$.core` 命名空间中，可以通过命名空间模式轻松地使用插件扩展（即通过 `script`
    标签加载的插件自动填充到 `core` 下的 `plugin` 命名空间中，即 `$.core.plugin.methodName()`）。
- en: The pattern can be nice to work with, because plug-in extensions can access
    properties and methods defined in the base or, with a bit of tweaking, override
    default behavior so that it can be extended to do more. A loader is also not required
    to make any of this fully functional.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式非常好用，因为插件扩展可以访问基础中定义的属性和方法，或者通过一些调整覆盖默认行为，以便进行扩展以实现更多功能。加载器也不需要使这些功能完全可用。
- en: For more details of what is being done, please see the inline comments in these
    code samples.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有关正在进行的详细信息，请参阅这些代码示例中的内联注释。
- en: '*usage.html:*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*usage.html:*'
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*pluginCore.js:*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*pluginCore.js:*'
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*pluginExtension.js:*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*pluginExtension.js:*'
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: UMD doesn’t aim to replace AMD or CommonJS but merely offers some supplemental
    assistance for developers wishing to get their code working in more environments
    today. For further information or to contribute suggestions toward this experimental
    format, see [this GitHub page](https://oreil.ly/H2pUf).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: UMD 并不旨在取代 AMD 或 CommonJS，而只是为希望在更多环境中使其代码正常工作的开发人员提供一些补充帮助。有关更多信息或对这种实验性格式提出建议，请参阅[此
    GitHub 页面](https://oreil.ly/H2pUf)。
- en: Related reading for UMD and AMD
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有关 UMD 和 AMD 的相关阅读
- en: '[Using AMD Loaders to Write and Manage Modular JavaScript](https://oreil.ly/Zgs_G)'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用 AMD 加载器编写和管理模块化 JavaScript](https://oreil.ly/Zgs_G)'
- en: '[AMD Module Patterns: Singleton](https://oreil.ly/IP22B)'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[AMD 模块模式：单例](https://oreil.ly/IP22B)'
- en: '[Standards and Proposals for JavaScript Modules and jQuery](https://oreil.ly/I-3jy)'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[JavaScript 模块和 jQuery 的标准与提案](https://oreil.ly/I-3jy)'
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This section reviewed several options for writing modular JavaScript using different
    module formats before ES2015+.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 本节回顾了在 ES2015+ 之前使用不同模块格式编写模块化 JavaScript 的几个选项。
- en: These formats had several advantages over using the Module pattern alone, including
    avoiding the need to manage global variables, better support for static and dynamic
    dependency management, improved compatibility with script loaders, better compatibility
    for modules on the server, and more.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这些格式相对于单独使用模块模式具有几个优点，包括避免管理全局变量的需要，更好地支持静态和动态依赖管理，改进脚本加载器的兼容性，增强服务器上模块的兼容性等。
- en: To conclude our discussion of classic design and architecture patterns, I want
    to touch on one area where we can apply patterns to structure and organize our
    JavaScript code in the next chapter on Namespacing patterns.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束我们对经典设计和架构模式的讨论之前，我想触及一个领域，即我们可以在下一章关于命名空间模式中应用模式来结构化和组织我们的 JavaScript 代码。
