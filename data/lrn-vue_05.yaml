- en: Chapter 5\. Composition API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章\. 组合 API
- en: In the previous chapter, you learned how to compose Vue components using the
    classic Options API. Despite it being the most common API for composing Vue components
    since Vue 2, using Options API can lead to unnecessary code complexity, unreadability
    for large component code, and logic reusability between them. For such use cases,
    this chapter introduces an alternative approach for composing Vue components,
    the Composition API.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，您已经学习了如何使用经典的 Options API 组合 Vue 组件。尽管 Options API 自 Vue 2 以来一直是组合 Vue
    组件最常见的 API，但使用 Options API 可能会导致不必要的代码复杂性、大型组件代码的不可读性以及它们之间逻辑重用的问题。针对这些用例，本章介绍了组合
    Vue 组件的另一种方法，即组合 API。
- en: In this chapter, we will explore the different composition hooks to create a
    functional stateful element in Vue. We also will learn how to combine Options
    API and Composition API for better reactive control and to compose our own reusable
    composable for our application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探索不同的组合挂钩，以创建 Vue 中的功能状态元素。我们还将学习如何结合 Options API 和组合 API，以获得更好的响应控制，并为应用程序组合我们自己可重用的组合物。
- en: Setting Up Components with Composition API
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用组合 API 设置组件
- en: Composing components using the Options API is a common practice in Vue. However,
    in many cases, we want to reuse part of the component logic without worrying about
    the overlapping data and methods like in mixins^([1](ch05.html#id998)), or a component
    that is more readable and organized. Composition API can be helpful in such scenarios.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vue 中，使用 Options API 组合组件是一种常见的实践。然而，在许多情况下，我们希望重用部分组件逻辑，而不必担心数据和方法的重叠，如混入（见
    [第5章](ch05.html#id998)）。组合 API 在这种情况下非常有帮助。
- en: Introduced in Vue 3.0, Composition API provides an alternative way to compose
    stateful and reactive components with the help of the `setup()` hook ([“setup”](ch03.html#setup_hook_03))
    or `<script setup>` tag. The `setup()` hook is part of the component’s options
    object and runs *once* before initializing and creating the component instance
    (before `beforeCreate()` hook).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 组合 API 是在 Vue 3.0 中引入的，它提供了一种用 `setup()` 挂钩（[“setup”](ch03.html#setup_hook_03)）或
    `<script setup>` 标记初始化和创建组件实例之前运行 *一次* 的替代方式，用于组合有状态和响应式组件。
- en: You can *only* use Composition API functions or composables ([“Creating Your
    Reusable Composables”](#reusable_hooks_06)) within this hook or its equivalent
    syntax `<script setup>` tag. This combination creates a stateful functional component
    and provides an excellent place to define the component’s reactive state and methods
    and initialize other lifecycle hooks (see [“Using the Lifecycle Hooks”](#lifecycle_hooks_03))
    with more straightforward code readability.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 您*只能*在此挂钩或其等效语法 `<script setup>` 标记中使用组合 API 函数或可组合物（[“创建可重用的组合物”](#reusable_hooks_06)）。这种组合创建了一个有状态的功能性组件，并提供了一个绝佳的地方来定义组件的响应状态和方法，并初始化其他生命周期挂钩（参见
    [“使用生命周期挂钩”](#lifecycle_hooks_03)），使代码更易读。
- en: Let’s explore the power of Composition API, starting with `ref()` and `reactive()`
    functions to handle your component’s reactive data.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索组合 API 的强大之处，从使用 `ref()` 和 `reactive()` 函数处理组件的响应数据开始。
- en: Handling Data with ref() and reactive()
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `ref()` 和 `reactive()` 处理数据
- en: In [Chapter 2](ch02.html#unique_chapter_id_02), you learned about the `data()`
    function property in the Options API for initializing the component’s data ([“Creating
    Local State with Data Properties”](ch02.html#local_state)). All the data properties
    in the returned object from `data()` are reactive, meaning the Vue engine will
    automatically watch for changes on each declared data property. However, this
    default functionality may cause overhead in your component when you have many
    data properties, most of which are static. In such cases, the Vue engine still
    enables watchers for these static values, which is unnecessary. To limit the number
    of excessive data watchers and to have more control over which data properties
    to observe, Vue introduced the `ref()` and `reactive()` functions in the Composition
    API.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第2章](ch02.html#unique_chapter_id_02) 中，您学习了 Options API 中的 `data()` 函数属性，用于初始化组件的数据（[“使用数据属性创建本地状态”](ch02.html#local_state)）。从
    `data()` 返回的所有数据属性都是响应式的，这意味着 Vue 引擎会自动监视每个声明的数据属性的更改。然而，默认功能可能会在组件中造成过多的开销，特别是当您有许多静态数据属性时。在这种情况下，Vue
    引擎仍会为这些静态值启用观察器，这是不必要的。为了限制过多的数据观察器数量并更好地控制要观察的数据属性，Vue 在组合 API 中引入了 `ref()` 和
    `reactive()` 函数。
- en: Using ref()
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `ref()`
- en: '`ref()` is a function that accepts a single argument and returns a reactive
    object with that argument as its initial value. We call this returned object the
    `ref` object:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`ref()` 是一个接受单一参数并返回具有该参数作为初始值的响应式对象的函数。我们称这个返回的对象为 `ref` 对象：'
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Or in `<script setup>`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 或者在 `<script setup>` 中：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We then can access the return object’s current value through its single `value`
    property within the `script` section. For example, the code in [Example 5-1](#example_01_06)
    creates a reactive object with the initial value of 0.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以在 `script` 部分通过其单一的 `value` 属性访问返回对象的当前值。例如，[示例 5-1](#example_01_06) 中的代码创建了一个初始值为
    0 的响应式对象。
- en: Example 5-1\. Using `ref()` to create a reactive message with an initial value
    of “Hello World”
  id: totrans-16
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-1\. 使用 `ref()` 创建一个具有初始值“Hello World”的响应式消息
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-18
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you use Options API with `setup()` hook, you can access `message` in other
    part of component’s without `.value`, i.e., `message` is sufficient.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Options API 和 `setup()` 钩子，你可以在组件的其他部分访问 `message` 而不需要 `.value`，即 `message`
    就足够了。
- en: However, in the `template` tag section, you can retrieve its value directly
    without the `value` property. For example, the code in [Example 5-2](#example_02_06)
    will print the same `message` as [Example 5-1](#example_01_06), but to the browser.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 `template` 标签部分，你可以直接获取其值而不需要 `value` 属性。例如，[示例 5-2](#example_02_06) 中的代码将会将同样的
    `message` 输出到浏览器，就像 [示例 5-1](#example_01_06) 一样。
- en: Example 5-2\. Accessing `message` value in the `template` section
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-2\. 在 `template` 部分访问 `message` 的值
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-23
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `ref()` function infers types for the return object from the initial value
    passed. If you explicitly want to define the type of the return object, you can
    use the TypeScript syntax `ref<type>()`, such as `ref<string>()`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`ref()` 函数根据传入的初始值推断返回对象的类型。如果你想显式定义返回对象的类型，可以使用 TypeScript 语法 `ref<type>()`，例如
    `ref<string>()`。'
- en: Since the ref object is reactive and mutable, we can change its value by assigning
    a new value to its `value` property. The Vue engine then will trigger the relevant
    watchers and update the component.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `ref` 对象是响应式且可变的，我们可以通过给其 `value` 属性赋新值来改变其值。Vue 引擎将会触发相关的 watcher 并更新组件。
- en: In [Example 5-3](#example_03_06), we will re-create the `MyMessageComponent`
    (from [Example 3-3](ch03.html#example_03_03) with Options API), which accepts
    input from the user and changes the `message` displayed.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 5-3](#example_03_06) 中，我们将重新创建 `MyMessageComponent`（从 [示例 3-3](ch03.html#example_03_03)
    使用 Options API 创建），该组件接受用户输入并改变显示的 `message`。
- en: Example 5-3\. Using `ref()` to create a reactive `MyMessageComponent`
  id: totrans-27
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-3\. 使用 `ref()` 创建一个响应式的 `MyMessageComponent`
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When we change the input field’s value, the browser will show the updated `message`
    value accordingly, as shown in [Figure 5-1](#figure_06_03_06).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们改变输入字段的值时，浏览器将相应地显示更新后的 `message` 值，如 [图 5-1](#figure_06_03_06) 所示。
- en: '![A screenshot of the browser showing the updated message value](assets/lvue_0501.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![浏览器截图显示更新的消息值](assets/lvue_0501.png)'
- en: Figure 5-1\. The value displayed changes when we change the input field’s value
  id: totrans-31
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-1\. 当我们改变输入字段的值时，显示的值也会随之改变。
- en: In the Vue tab of the browser’s Developer Tools, we can see ref object `message`
    listed under the `setup` section, with the indication `Ref` ([Figure 5-2](#figure_05_06a)).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器的 Vue 标签页中的开发者工具中，我们可以看到 `message` 被列在 `setup` 部分的 `ref` 对象下，带有 `Ref` 标识（见
    [图 5-2](#figure_05_06a)）。
- en: '![A screenshot of the browser''s Vue tab showing the ref object](assets/lvue_0502.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![浏览器 Vue 标签页显示的 `ref` 对象截图](assets/lvue_0502.png)'
- en: Figure 5-2\. The `message` ref object is listed under the `setup` section
  id: totrans-34
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-2\. `message` 的 `ref` 对象列在 `setup` 部分下
- en: If we add another static data `title` to the component ([Example 5-4](#example_05_06)),
    the Vue tab will show the `title` data property without the indication ([Figure 5-3](#figure_05_06)).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们向组件添加另一个静态数据 `title`（[示例 5-4](#example_05_06)），Vue 标签页将显示 `title` 数据属性而没有标识（见
    [图 5-3](#figure_05_06)）。
- en: Example 5-4\. Adding static `title` to `MyMessageComponent`
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-4\. 向 `MyMessageComponent` 添加静态的 `title`
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![A screenshot of the browser''s Vue tab showing the data property without
    the indication](assets/lvue_0503.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![浏览器 Vue 标签页显示没有标识的数据属性](assets/lvue_0503.png)'
- en: Figure 5-3\. The `title` data property is listed without the indication
  id: totrans-39
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-3\. 列出了 `title` 数据属性而没有标识
- en: The previous code ([Example 5-4](#example_05_06)) is equivalent to [Example 5-5](#example_06_06)
    with `setup()` hook.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码（[示例 5-4](#example_05_06)）等同于使用 `setup()` 钩子的 [示例 5-5](#example_06_06)。
- en: Example 5-5\. Using `setup()` hook to create a reactive `MyMessageComponent`
  id: totrans-41
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-5\. 使用 `setup()` 钩子创建一个响应式的 `MyMessageComponent`
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can use the `ref()` function to create a reactive object for any primitive
    type (such as `string`, `number`, `boolean`, `null`, `undefined`, etc.) and any
    object type. However, for the object type such as array and object, the `ref()`
    returns an intensely reactive object, meaning both the ref object and its nested
    properties are mutable, as seen in [Example 5-6](#example_07_06).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`ref()`函数为任何原始类型（如`string`、`number`、`boolean`、`null`、`undefined`等）和任何对象类型创建响应式对象。但是，对于数组和对象等对象类型，`ref()`返回一个强烈响应式对象，意味着`ref`对象及其嵌套属性均可变，如[示例 5-6](#example_07_06)所示。
- en: Example 5-6\. Using `ref()` to create a deeply reactive object
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-6\. 使用`ref()`创建深度响应式对象
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In [Example 5-6](#example_07_06), we can replace the property `name` of `user`
    and the entire `user` object with a new value. We consider this case a *bad practice*
    in Vue, which can lead to performance issues for large data structures, and unexpected
    behaviors. To avoid falling into such a situation, I would recommend that you
    use the `shallowRef()` and `reactive()` functions instead, depending on your use
    case:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 5-6](#example_07_06)中，我们可以替换`user`的属性`name`和整个`user`对象的属性值。在Vue中，我们认为这种情况是*不良实践*，可能会导致大型数据结构的性能问题和意外行为。为了避免陷入这种情况，我建议您根据具体情况使用`shallowRef()`和`reactive()`函数：
- en: If you want to create a reactive object-type data and *replace it later on with
    new value*, use `shallowRef()`. A good example is integrating the component with
    asynchronous data fetching with the help of lifecycle composition hooks, as seen
    in [Example 5-7](#example_08_06).
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想创建一种响应式对象类型的数据，并*稍后用新值替换它*，请使用`shallowRef()`。一个很好的例子是将组件与异步数据获取集成到生命周期组合钩子中，如[示例 5-7](#example_08_06)所示。
- en: If you want to create a reactive object-type data and *update its properties
    only*, use `reactive()`, which we will cover in the next section.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想创建一种仅*更新其属性*的响应式对象类型数据，请使用`reactive()`，我们将在下一节中介绍。
- en: Example 5-7\. Using `shallowRef()` to manage external data fetching
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-7\. 使用`shallowRef()`管理外部数据获取
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[![1](assets/1.png)](#co_composition_api_CO1-1)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_composition_api_CO1-1)'
- en: Create a reactive `user` variable of type `User` with the initial data using
    `shallowRef`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`shallowRef`创建一个初始数据为`User`类型的响应式`user`变量。
- en: '[![2](assets/2.png)](#co_composition_api_CO1-2)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_composition_api_CO1-2)'
- en: Create a reactive `error` variable that can be `undefined` or of type `Error`
    using `shallowRef`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`shallowRef`创建一个可以是`undefined`或`Error`类型的响应式`error`变量。
- en: '[![3](assets/3.png)](#co_composition_api_CO1-3)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_composition_api_CO1-3)'
- en: Replace the value of `user` with the response’s data, assuming it is of type
    `User`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 用响应数据替换`user`的值，假设它是`User`类型。
- en: '[![4](assets/4.png)](#co_composition_api_CO1-4)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_composition_api_CO1-4)'
- en: Update the value of `error` when an error occurred.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生错误时，更新`error`的值。
- en: Using reactive()
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`reactive()`
- en: 'The `reactive()` function is similar to the `ref()` function, except:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`reactive()`函数类似于`ref()`函数，除了：'
- en: It accepts object-type data as its argument.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它接受对象类型的数据作为其参数。
- en: You can directly access the reactive return object without `value` and its properties.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以直接访问不带`value`及其属性的响应式返回对象。
- en: 'Only the return object’s nested properties are mutable, and trying to modify
    the return object’s value directly or using the `value` property will result in
    an error:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 仅返回对象的嵌套属性可变，尝试直接修改返回对象的值或使用`value`属性将导致错误：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'But you can modify `user` object’s properties, such as `name` and `age`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 但您可以修改`user`对象的属性，例如`name`和`age`：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-67
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Behind the scenes, `ref()` triggers `reactive()`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，`ref()`触发`reactive()`。
- en: One important note is that the `reactive()` function returns a reactive `proxy`
    version of the original passed object. Hence, if we make any change to the reactive
    return object, it would be reflected on the original object, and vice versa, as
    seen in [Example 5-8](#example_08_06_01).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的注意事项是，`reactive()`函数返回原始传递对象的响应式`proxy`版本。因此，如果我们对响应式返回对象进行任何更改，将反映在原始对象上，反之亦然，如[示例 5-8](#example_08_06_01)所示。
- en: Example 5-8\. Modify both the original object and the reactive object
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-8\. 修改原始对象和响应式对象
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, the properties of both `defaultValue` and `user` change when
    `user` changes and vice versa. Hence it will be best if you are extra cautious
    when using the `reactive()` function. You should use the spread syntax (`…​`)
    to create a new object before passing to the `reactive()` instead ([Example 5-9](#example_09_06)).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当`user`变化时，`defaultValue`和`user`的属性都会改变，反之亦然。因此，在使用`reactive()`函数时需要特别小心。在传递给`reactive()`之前，应使用展开语法（`…​`）创建一个新对象（见[示例 5-9](#example_09_06)）。
- en: Example 5-9\. Using `reactive()` with spread syntax
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-9\. 使用带展开语法的`reactive()`
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-75
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: The `reactive()` function enables profound reactivity conversion for the initial
    object. Thus, it can lead to undesired performance issues for the large data structure.
    In a scenario where you only want to observe the root object’s properties and
    not their descendant, you should use the `shallowReactive()` function instead.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`reactive()`函数能够深度转换初始对象的响应性。因此，对于大型数据结构可能导致不希望的性能问题。在只想观察根对象属性而不是它们的后代的情况下，应改用`shallowReactive()`函数。'
- en: You also can combine `ref()` and `reactive()`, though I don’t recommend it due
    to its complexity and the reactivity unwrapping mechanism. If there is a need
    to create a reactive object from another reactive object, you should use `computed()`
    instead (see [“Using computed()”](#computed_hook_06)).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以结合使用`ref()`和`reactive()`，尽管我不建议这样做，因为其复杂性和响应性解包机制。如果需要从另一个响应式对象创建响应式对象，应改用`computed()`（参见[“使用computed()”](#computed_hook_06)）。
- en: '[Table 5-1](#table_01_06) summarizes the use cases for `ref()`, `reactive()`,
    `shallowRef()`, and `shallow``Reactive()`.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[Table 5-1](#table_01_06)总结了`ref()`、`reactive()`、`shallowRef()`和`shallow``Reactive()`的用例。'
- en: Table 5-1\. Use cases for `ref()`, `reactive()`, `shallowRef()` and `shallowReactive()`
    functions
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Table 5-1\. `ref()`、`reactive()`、`shallowRef()`和`shallowReactive()`函数的用例
- en: '| Hook | When to use |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 钩子 | 使用时机 |'
- en: '| --- | --- |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ref()` | Primitive data types for general cases or object-type when there
    is a need for reassigning both the object and its properties. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `ref()` | 用于一般情况下的原始数据类型，或在需要重新分配对象及其属性时的对象类型。 |'
- en: '| `shallowRef()` | Object type only as a placeholder for later reassigning
    and no property observation. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `shallowRef()` | 仅作为占位符的对象类型，稍后可重新分配且无属性观察。 |'
- en: '| `reactive()` | For property observation of object-type data, including nested
    properties. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `reactive()` | 用于观察对象类型数据的属性，包括嵌套属性。 |'
- en: '| `shallowReactive()` | For property observation of object-type data, excluding
    nested properties. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `shallowReactive()` | 用于观察对象类型数据的属性，但不包括嵌套属性。 |'
- en: Next, we will look at the lifecycle composition hooks and what they offer.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看生命周期组合钩子及其提供的功能。
- en: Using the Lifecycle Hooks
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用生命周期钩子
- en: In [“Component Lifecycle Hooks”](ch03.html#component_lifecycle_03), we learned
    the component’s lifecycle hooks and how they look in the classic Vue’s Options
    API as properties of the component’s options object. With Composition API, the
    lifecycle hooks are separate functions that we need to import from the `vue` package
    before using them to execute logic at specific points in a component’s lifecycle.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“组件生命周期钩子”](ch03.html#component_lifecycle_03)中，我们了解了组件的生命周期钩子及其在经典Vue的Options
    API中作为组件选项对象的属性显示。使用Composition API时，生命周期钩子是我们需要从`vue`包导入的独立函数，然后在组件生命周期的特定点使用它们来执行逻辑。
- en: The Composition API’s lifecycle hooks are similar to the ones in the Options
    API, except the syntax now contains the prefix `on` (for example, `mounted` becomes
    `onMounted` in Composition API). [Table 5-2](#table_02_06) shows the mapping from
    Options API to Composition API for some lifecycle hooks.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Composition API的生命周期钩子与Options API中的钩子类似，唯一区别是现在的语法包含前缀`on`（例如，在Composition
    API中，`mounted`变成了`onMounted`）。[Table 5-2](#table_02_06)展示了一些生命周期钩子从Options API到Composition
    API的映射。
- en: Table 5-2\. Lifecycle hooks from Options API to Composition API
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Table 5-2\. 从Options API到Composition API的生命周期钩子
- en: '| Options API | Composition API | Description |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| Options API | Composition API | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `beforeMount()` | `onBeforeMount()` | Call before the first render of the
    component. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `beforeMount()` | `onBeforeMount()` | 在组件首次渲染之前调用。 |'
- en: '| `mounted()` | `onMounted()` | Call after Vue renders and mounts the component
    to the DOM. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `mounted()` | `onMounted()` | 在Vue渲染并将组件挂载到DOM后调用。 |'
- en: '| `beforeUpdate()` | `onBeforeUpdate()` | Call after the component’s update
    process starts. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `beforeUpdate()` | `onBeforeUpdate()` | 在组件更新过程开始后调用。 |'
- en: '| `updated()` | `onUpdated()` | Call after Vue renders the updated component
    to the DOM. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `updated()` | `onUpdated()` | 在 Vue 渲染更新后调用。 |'
- en: '| `beforeUnmount()` | `onBeforeUnmount()` | Call before unmounting the component.
    |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `beforeUnmount()` | `onBeforeUnmount()` | 在卸载组件之前调用。 |'
- en: '| `unmounted()` | `onUnmounted()` | Call after Vue removes and destroys the
    component instance. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `unmounted()` | `onUnmounted()` | 在 Vue 删除和销毁组件实例后调用。 |'
- en: You probably noticed here that not all Options API’s lifecycle hooks have an
    equivalent in Composition API, such as `beforeCreate()` and `created()`. Instead,
    we use `setup()` or `<script setup>` with other Composition API hooks to achieve
    the same result and even define the component’s logic in a more organized way.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能注意到，不像 Options API 中的 `beforeCreate()` 和 `created()` 钩子，Composition API 中并非所有生命周期钩子都有等价项。相反，我们使用
    `setup()` 或 `<script setup>` 与其他 Composition API 钩子来实现相同的结果，甚至更有组织地定义组件的逻辑。
- en: 'We use the above hooks to register callbacks that Vue will execute when appropriate
    by passing the callback function as its only argument. For example, to register
    a callback to `beforeMount()` hook, we can do this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用上述钩子注册回调函数，当适当时 Vue 将执行这些回调函数。例如，要注册一个回调函数到 `beforeMount()` 钩子，我们可以这样做：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Since Vue triggers `setup()` before creating the component instance, there
    is no access to the `this` instance, both in `setup()` and in the hooks registered
    within it. The following code will print out `undefined` ([Figure 5-4](#figure_11_06))
    when in use:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Vue 在创建组件实例之前触发 `setup()`，因此在其中注册的钩子和 `setup()` 中都无法访问 `this` 实例。在使用时，以下代码将输出
    `undefined`（[Figure 5-4](#figure_11_06)）：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![A screenshot displaying a console log of undefined when accessing this in
    the Composition lifecycle hook](assets/lvue_0504.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![访问 Composition 生命周期钩子中的 this 返回 undefined 的控制台日志截图](assets/lvue_0504.png)'
- en: Figure 5-4\. Accessing `this` in the Composition lifecycle hook yields `undefined`
  id: totrans-105
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 5-4\. 在 Composition 生命周期钩子中访问 `this` 返回 `undefined`
- en: 'However, you can access the component’s DOM instance (like `this.$el` as in
    Options API) by using the `ref()` hook and `ref` directive, like how we define
    `input``Ref` in this example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，通过使用 `ref()` 钩子和 `ref` 指令，我们可以像在本例中定义 `inputRef` 一样访问组件的 DOM 实例（类似于 Options
    API 中的 `this.$el`）：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then bind it to the `ref` directive in the template:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在模板中将其绑定到 `ref` 指令：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, we can access the DOM instance in the `onMounted()` or `onUpdated()`
    hook:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在 `onMounted()` 或 `onUpdated()` 钩子中访问 DOM 实例：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: After mounting the component, `inputRef` will refer to the input element’s correct
    DOM instance. Every time the user changes the input field, Vue will trigger the
    `onUpdated()` hook and update the DOM instance accordingly. [Figure 5-5](#figure_12_06)
    shows the console log after mounting and the user typing in the input field.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 组件挂载后，`inputRef` 将引用输入元素的正确 DOM 实例。每当用户更改输入字段时，Vue 将触发 `onUpdated()` 钩子，并相应更新
    DOM 实例。[Figure 5-5](#figure_12_06) 显示了挂载后控制台日志以及用户在输入字段中键入的情况。
- en: '![A screenshot displaying a console log after mounting and user typing in the
    input field](assets/lvue_0505.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![挂载后和用户在输入字段中键入后显示控制台日志的截图](assets/lvue_0505.png)'
- en: Figure 5-5\. Console log after mounting and the user making a change to the
    input field
  id: totrans-114
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 5-5\. 组件挂载后控制台日志以及用户更改输入字段
- en: Composition API’s lifecycle hooks can be helpful in many cases compared to the
    Options API’s lifecycle hooks, especially when you want to keep your functional
    component’s logic concise and organized. You can also combine the lifecycle hooks
    with other Composition API hooks to achieve more complex logic and create your
    reusable custom hooks (see [“Creating Your Reusable Composables”](#reusable_hooks_06)).
    In the next section, we will look at other significant Composition API hooks,
    starting with `watch()`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Composition API 的生命周期钩子在许多情况下与 Options API 的生命周期钩子相比非常有帮助，特别是当您希望保持函数组件逻辑简洁和有组织时。您还可以将生命周期钩子与其他
    Composition API 钩子结合使用，以实现更复杂的逻辑，并创建可重用的自定义钩子（参见 [“创建您的可重用组合”](#reusable_hooks_06)）。在下一节中，我们将查看其他重要的
    Composition API 钩子，首先是 `watch()`。
- en: Understanding Watchers in Composition API
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Composition API 中理解 Watchers
- en: 'Like the Options API’s `watch()`, the Composition API’s `watch()` hook is used
    to observe for changes and invoke the callback in reactive data. `watch()` accepts
    three arguments, as shown in this syntax:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 Options API 中的 `watch()`，Composition API 中的 `watch()` 钩子用于观察变化并在响应式数据中调用回调函数。`watch()`
    接受三个参数，如下所示的语法：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`sources` is the reactive data for Vue to observe. It can be a single piece
    of reactive data, a getter function that returns reactive data, or an array of
    those.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sources`是Vue观察的反应性数据。它可以是单个反应性数据、返回反应性数据的getter函数或这些的数组。'
- en: '`cb` is the callback function that Vue will execute when any of the `sources`
    changes. This function accepts two main arguments: `newValue` and `oldValue`,
    and an optional side effect cleanup function to trigger before the next invoke.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cb`是Vue在`sources`任一变化时执行的回调函数。此函数接受两个主要参数：`newValue`和`oldValue`，以及一个可选的副作用清理函数，在下一次调用之前触发。'
- en: '`options` are the options for the `watch()` hook, which is optional and contains
    the fields described in [Table 5-3](#watch_options_fields_table).'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`options`是`watch()`钩子的选项，这是可选的，包含[表5-3](#watch_options_fields_table)中描述的字段。'
- en: Table 5-3\. The `watch()` options’ fields
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 表5-3\. `watch()`选项字段
- en: '| Property | Description | Accepted type | Default value | Required? |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 | 接受的类型 | 默认值 | 是否必需？ |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `deep` | Indicates whether Vue should observe changes in the nested properties
    of the target data (if any). | boolean | `false` | No |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `deep` | 指示Vue是否应观察目标数据（如果有）的嵌套属性的更改。 | 布尔值 | `false` | 否 |'
- en: '| `immediate` | Indicates whether to trigger the handler immediately after
    mounting the component. | boolean | `false` | No |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `immediate` | 指示在挂载组件后立即触发处理程序。 | 布尔值 | `false` | 否 |'
- en: '| `flush` | Indicates the timing order of the handler’s execution. By default,
    Vue triggers the handler before updating the Vue component. | `pre`, `post`, `sync`
    | `pre` | No |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `flush` | 指示处理程序执行的时间顺序。默认情况下，Vue在更新Vue组件之前触发处理程序。 | `pre`、`post`、`sync`
    | `pre` | 否 |'
- en: '| `onTrack` | For debugging when it tracks the reactive data, *only in development
    mode*. | Function | `undefined` | No |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `onTrack` | 用于调试时追踪反应性数据，*仅在开发模式下*。 | 函数 | `undefined` | 否 |'
- en: '| `onTrigger` | For debugging when triggering the callback, *only in development
    mode*. | Function | `undefined` | No |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `onTrigger` | 用于调试时触发回调，*仅在开发模式下*。 | 函数 | `undefined` | 否 |'
- en: And it returns a `WatchStopHandle` function that we can use to stop the watcher
    anytime.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 并返回一个`WatchStopHandle`函数，我们可以随时用来停止观察器。
- en: Let’s look at the `UserWatcherComponent` component with the same template presented
    in [Chapter 3](ch03.html#unique_chapter_id_03)’s [Example 3-17](ch03.html#example_03_10),
    where we allow modifying `user.name` and `user.age` based on a default `user`
    object. We will rewrite its `<script>` using Composition API, as in [Example 5-10](#example_11_06).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`UserWatcherComponent`组件，其模板与[第三章](ch03.html#unique_chapter_id_03)的[示例3-17](ch03.html#example_03_10)相同，其中允许基于默认的`user`对象修改`user.name`和`user.age`。我们将重新编写其`<script>`，采用Composition
    API，如[示例5-10](#example_11_06)所示。
- en: Example 5-10\. `UserWatcherComponent` component using `setup()` and `ref()`
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例5-10\. 使用`setup()`和`ref()`的`UserWatcherComponent`组件
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Then, we add a watcher for the `user` object, as in [Example 5-11](#example_12_06).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为`user`对象添加一个观察器，就像[示例5-11](#example_12_06)中所示。
- en: Example 5-11\. Using the `watch()` hook for watching `user` data
  id: totrans-135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例5-11\. 使用`watch()`钩子监视`user`数据
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: By default, Vue will trigger the callback function only when the `user` changes.
    In the previous example, because we use `reactive()` to create `user`, Vue will
    automatically enable `deep` to watch for its properties. In case you want Vue
    to only observe a specific property of `user`, such as `user.name`, we can create
    a getter function that returns that property and pass it as the `sources` argument
    to `watch()`, as in [Example 5-12](#example_13_06).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Vue仅在`user`更改时触发回调函数。在前面的示例中，因为我们使用`reactive()`创建`user`，Vue将自动启用`deep`以观察其属性的更改。如果您希望Vue仅观察`user`的特定属性，例如`user.name`，我们可以创建一个返回该属性的getter函数，并将其作为`sources`参数传递给`watch()`，如[示例5-12](#example_13_06)所示。
- en: Example 5-12\. Using the `watch()` hook for watching a specific property of
    `user`
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例5-12\. 使用`watch()`钩子监视`user`的特定属性
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When you make a change to the `user.name`, the console log will display the
    message shown in [Figure 5-6](#figure_13_06).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当您更改`user.name`时，控制台日志将显示[图5-6](#figure_13_06)中显示的消息。
- en: '![A screenshot displaying a console log after changing user.name](assets/lvue_0506.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![更改用户名称后控制台日志的截图](assets/lvue_0506.png)'
- en: Figure 5-6\. Console log after changing `user.name`
  id: totrans-142
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-6\. 更改`user.name`后的控制台日志
- en: 'In case you need to trigger the watcher right after mounting the component,
    you can pass `{ immediate: true }` as the third argument to `watch()`, as in [Example 5-13](#example_14_06).'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '如果需要在挂载组件后立即触发观察器，可以将 `{ immediate: true }` 作为 `watch()` 的第三个参数传递，例如 [Example 5-13](#example_14_06)。'
- en: Example 5-13\. Using the `watch()` hook with `immediate` option
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 5-13\. 使用带有 `immediate` 选项的 `watch()` 钩子
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The console log will display the change of `user.name` from `undefined` to `John`
    right after mounting the component.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台日志将显示从 `undefined` 到 `John` 的 `user.name` 更改，就在挂载组件后立即。
- en: You can also pass a `sources` array of reactive data to `watch()`, and Vue will
    trigger the callback function with two collections of new and old values, each
    of which corresponds to the reactive data in the same order as the `sources` array,
    as shown in [Example 5-14](#example_15_06).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将一个反应性数据数组 `sources` 传递给 `watch()`，Vue 将使用新旧值的两个集合触发回调函数，每个集合与 `sources`
    数组中的反应性数据按相同顺序对应，如 [Example 5-14](#example_15_06) 中所示。
- en: Example 5-14\. Using the `watch()` hook with an array of reactive data
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 5-14\. 使用带有反应性数据数组的 `watch()` 钩子
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The above watcher will be triggered when either `user.name` or `user.age` changes
    and the console log will display the difference accordingly.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `user.name` 或 `user.age` 变化时，上述观察器将被触发，并且控制台日志将相应地显示差异。
- en: Note
  id: totrans-151
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to observe and trigger side action to multiple data changes, `watchEffect()`
    can be a better option. It will track the reactive dependencies used in the watcher’s
    function, run the function immediately right after the component renders, and
    rerun it whenever any dependencies change their value. However, you should be
    cautious using this API as it can lead to performance issues if the list of dependencies
    is extensive and the updating frequency between them is high.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要观察并触发多个数据更改的副作用操作，`watchEffect()` 可能是一个更好的选择。它将跟踪观察器函数中使用的反应性依赖项，立即在组件渲染后运行函数，并在任何依赖项更改其值时重新运行该函数。但是，使用此
    API 时需要注意性能问题，特别是如果依赖项列表很长且它们之间的更新频率很高。
- en: Using the `watch()` hook is a great way to create a dynamic observation on specific
    reactive data or its properties. But if we want to create new reactive data based
    on the existing ones, we should use `computed()`, which we will look at next.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `watch()` 钩子是在特定反应性数据或其属性上创建动态观察的好方法。但是，如果我们想要基于现有数据创建新的响应式数据，我们应该使用 `computed()`，接下来我们将看看它。
- en: Using computed()
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 computed()
- en: Similar to computed properties, we use `computed()` to create a reactive and
    cached data value derived from other reactive data. Unlike `ref()` and `reactive()`,
    `computed()` returns a *read-only* reference object, meaning we can’t manually
    reassign value to it.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于计算属性，我们使用 `computed()` 来创建一个从其他反应性数据派生的响应式和缓存的数据值。与 `ref()` 和 `reactive()`
    不同，`computed()` 返回一个 *只读* 的引用对象，意味着我们不能手动重新分配其值。
- en: Let’s take the reserved message example written in Options API in [Example 3-11](ch03.html#example_03_05)
    and rewrite it using the `computed()` hook as in [Example 5-15](#example_16_06).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以 [Example 3-11](ch03.html#example_03_05) 中 Options API 中写的保留消息示例为例，并使用 `computed()`
    钩子重写，如 [Example 5-15](#example_16_06) 中所示。
- en: Example 5-15\. `PalindromeCheck` component using `computed()`
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 5-15\. 使用 `computed()` 创建 `PalindromeCheck` 组件
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Within the `script` section, we use the `value` property of the returned object
    (`reversedMessage.value`) to access its value, like `ref()` and `reactive()`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `script` 部分内，我们使用返回对象的 `value` 属性（`reversedMessage.value`）来访问其值，就像 `ref()`
    和 `reactive()` 一样。
- en: The code in [Example 5-16](#example_17_06) shows how we create another computed
    data point to check if the message is a palindrome based on the `reversedMessage`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[Example 5-16](#example_17_06) 中的代码展示了我们如何基于 `reversedMessage` 创建另一个 computed
    数据点来检查消息是否为回文。'
- en: Example 5-16\. Using `computed()` to create new reactive `isPalindrome` data
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 5-16\. 使用 `computed()` 创建新的响应式 `isPalindrome` 数据
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice here we declare the types for `reservedMessage` and `isPalindrome` explicitly
    as `string` and `boolean` to avoid type inference errors. You can now use these
    computed data in your template ([Example 5-17](#example_18_06)).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们明确声明了 `reservedMessage` 和 `isPalindrome` 的类型为 `string` 和 `boolean`，以避免类型推断错误。现在您可以在模板中使用这些
    computed 数据（[Example 5-17](#example_18_06)）。
- en: Example 5-17\. Using data created from `computed()` in the template
  id: totrans-164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 5-17\. 在模板中使用 `computed()` 创建的数据
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This code results in the output shown in [Figure 5-7](#figure_09_06) when the
    user changes the message input.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户更改消息输入时，此代码将导致 [Figure 5-7](#figure_09_06) 中显示的输出。
- en: '![A screenshot showing the palindrome check for the input message of hello
    world](assets/lvue_0507.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![显示输入消息的回文检查的截图](assets/lvue_0507.png)'
- en: Figure 5-7\. Palindrome check component for the message using `computed()`
  id: totrans-168
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-7\. 使用`computed()`进行消息的回文检查组件
- en: When you open the Vue tab in the browser’s Developer Tools, you can see these
    computed data values available under the `setup` section of the `PalindromeCheck`
    component ([Figure 5-8](#figure_10_06)).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在浏览器的开发者工具中打开Vue选项卡时，您可以在`PalindromeCheck`组件的`setup`部分下看到这些计算数据值（见[图5-8](#figure_10_06)）。
- en: '![A screenshot showing three data values presented under setup section of the
    component in the Vue tab of the browser developer tools](assets/lvue_0508.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![显示浏览器开发者工具中Vue选项卡中组件设置部分下的三个数据值的截图](assets/lvue_0508.png)'
- en: Figure 5-8\. Computed and reactive data shown in the developer tool for the
    `PalindromeCheck` component
  id: totrans-171
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-8\. 在`PalindromeCheck`组件的开发者工具中显示的计算和反应性数据
- en: Note
  id: totrans-172
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: By default, `computed()` returns a *read-only* reactive data reference. Still,
    you can intentionally declare it as a *writable* object by passing an object of
    `{ get, set }` as the first argument to `computed()`. This mechanism stays consistent
    with `computed` properties in the Options API. However, I don’t recommend using
    this feature. You should combine it with `ref()` or `reactive()` instead.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`computed()`返回一个*只读*的反应性数据引用。但是，您可以通过将一个`{ get, set }`对象作为第一个参数传递给`computed()`来故意将其声明为一个*可写*对象。此机制与Options
    API中的`computed`属性保持一致。不过，我不建议使用这个功能。您应该改用`ref()`或`reactive()`来结合使用。
- en: We have learned how to use `computed()` and `watch()` to achieve the same result
    as the classic `computed` and `watch` option properties. You can use either of
    them, depending on your preference. You also can use these hooks to create your
    own hooks, called composables, and reuse them in other components, which we will
    explore next.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何使用`computed()`和`watch()`来实现与经典的Options API中的`computed`和`watch`选项属性相同的结果。您可以根据自己的喜好选择使用其中的任何一个。您还可以使用这些钩子函数来创建自己的钩子，称为可组合函数，并在其他组件中重用它们，接下来我们将探讨这一点。
- en: Creating Your Reusable Composables
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您的可重复使用的可组合函数
- en: One of the most exciting features of Vue 3 is the ability to create reusable
    and stateful hooks, called composables,^([2](ch05.html#id1078)) from the available
    Composition API functions. We can divide and compose common logic into readable
    composables, then use them to manage specific data state changes in different
    components. This approach helps separate the state management logic and the component
    logic, reducing our components’ complexity.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Vue 3最令人兴奋的功能之一是能够从可用的Composition API函数中创建可重复使用和有状态的钩子，称为可组合函数^([2](ch05.html#id1078))。我们可以将常见逻辑分割和组合成可读的可组合函数，然后在不同的组件中使用它们来管理特定数据状态的变化。这种方法有助于分离状态管理逻辑和组件逻辑，从而减少组件的复杂性。
- en: To start composing, you can create a new TypeScript (`.ts`) file and export
    a function that returns a reactive data object as your composable, as shown in
    [Example 5-18](#example_25_06).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始编写，您可以创建一个新的TypeScript（`.ts`）文件，并导出一个返回反应性数据对象作为您的可组合的函数，如示例[5-18](#example_25_06)所示。
- en: Example 5-18\. Creating an example composable, `useMyComposable`
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例5-18\. 创建一个示例可组合函数`useMyComposable`
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the previous code, we create a new TypeScript file named `useMyComposable.ts`
    under the `src/composables` folder and export a function called `useMyComposable`.
    The function returns a reactive data object named `myComposableData` created using
    the `reactive()` function.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在`src/composables`文件夹下创建了一个名为`useMyComposable.ts`的新TypeScript文件，并导出了一个名为`useMyComposable`的函数。该函数使用`reactive()`函数创建了一个名为`myComposableData`的反应性数据对象。
- en: Note
  id: totrans-181
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can place the composable file anywhere in your project, but I recommend
    putting it under the `src/composables` folder to keep it organized. Also, it’s
    a good practice to name the composable file with the `use` prefix, followed by
    the concise, descriptive name of the composable.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将可组合文件放置在项目的任何位置，但我建议将其放在`src/composables`文件夹下以保持组织结构。另外，建议将可组合文件命名为`use`前缀，后跟简洁明了的名称。
- en: You can then import and use `useMyComposable` in your component as shown in
    [Example 5-19](#example_19_06).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以像示例[5-19](#example_19_06)中所示那样导入和使用`useMyComposable`在您的组件中。
- en: Example 5-19\. Using the `useMyComposable` composable in the a Vue component
  id: totrans-184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例5-19\. 在Vue组件中使用`useMyComposable`可组合函数
- en: '[PRE28]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now you can access the `myComposableData` in your component’s template, and
    other parts of the component logic, as its local reactive data.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以在组件模板及其它组件逻辑中访问`myComposableData`作为其本地反应性数据。
- en: Let’s create a `useFetch` composable to query data from an external API using
    the `fetch` API, as shown in [Example 5-20](#example_22_06).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`useFetch`可组合项，使用`fetch` API从外部API查询数据，如[示例 5-20](#example_22_06)所示。
- en: Example 5-20\. Create `useFetch` composable
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-20\. 创建`useFetch`可组合项
- en: '[PRE29]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[![1](assets/1.png)](#co_composition_api_CO2-1)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_composition_api_CO2-1)'
- en: Declare the internal logic for fetching data.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 声明获取数据的内部逻辑。
- en: '[![2](assets/2.png)](#co_composition_api_CO2-2)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_composition_api_CO2-2)'
- en: Trigger fetching data during the creation of the component and update the data
    automatically.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件创建期间触发数据获取并自动更新数据。
- en: '[![3](assets/3.png)](#co_composition_api_CO2-3)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_composition_api_CO2-3)'
- en: Return the declared reactive variables.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 返回声明的响应式变量。
- en: You then can reuse `useFetch` to compose another asynchronous composable, such
    as `useGitHubRepos`, to query and manage user’s repositories data from the GitHub
    API ([Example 5-21](#example_24_06)).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以重用`useFetch`来组合另一个异步可组合项，例如`useGitHubRepos`，从GitHub API查询和管理用户的仓库数据（[示例 5-21](#example_24_06)）。
- en: Example 5-21\. Create a `useGitHubRepos` composable
  id: totrans-197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-21\. 创建`useGitHubRepos`可组合项
- en: '[PRE30]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Once done, we can use `useGitHubRepos` in a `GitHubRepos.vue` component ([Example 5-22](#example_24_08)).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们可以在`GitHubRepos.vue`组件中使用`useGitHubRepos`（[示例 5-22](#example_24_08)）。
- en: Example 5-22\. Using `useGitHubRepos` in a `GitHubRepos` component
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-22\. 在`GitHubRepos`组件中使用`useGitHubRepos`
- en: '[PRE31]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[![1](assets/1.png)](#co_composition_api_CO3-1)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_composition_api_CO3-1)'
- en: Get the `data` and rename it `repos`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 获取`data`并将其重命名为`repos`。
- en: '[![2](assets/2.png)](#co_composition_api_CO3-2)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_composition_api_CO3-2)'
- en: Iterate `repos` and display each `repo`’s information.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代`repos`并显示每个`repo`的信息。
- en: And on the browser, we will see a list of repos displayed after the fetching
    completes ([Figure 5-9](#screenshot_ch04_repos)).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 并且在浏览器上，在获取完成后，我们将看到显示一系列仓库的列表（[图 5-9](#screenshot_ch04_repos)）。
- en: '![A screenshot displaying a list of repositories retrieved from Maya Shavin''s
    GitHub account with the dedicated composable](assets/lvue_0509.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![Maya Shavin的GitHub账户检索到的仓库列表的截图](assets/lvue_0509.png)'
- en: Figure 5-9\. Retrieve and display a list of repos using `useGitHubRepos` composable
  id: totrans-208
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-9\. 使用`useGitHubRepos`可组合项检索并显示仓库列表
- en: Mapping Data Between Composables
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在可组合项之间映射数据
- en: If you need to re-map any reactive data received from another composable, use
    `computed()` or `watch()` to preserve the reactivity. [Example 5-23](#example_24_07)
    demonstrates a *non-working* example of `useFetch` inside `useGitHubRepos`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要重新映射从另一个可组合项接收的任何响应式数据，请使用`computed()`或`watch()`以保留响应性。[示例 5-23](#example_24_07)演示了在`useGitHubRepos`内部错误使用`useFetch`的*不起作用*示例。
- en: Example 5-23\. Using `useFetch` in the wrong way within `useGitHubRepos`
  id: totrans-211
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-23\. 在`useGitHubRepos`内部错误使用`useFetch`
- en: '[PRE32]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With composables, you can create your application’s state management logic in
    a modular and composable way. You can even build your library of composables to
    reuse in other Vue projects, such as theming control, data fetching, payment management
    for a store, etc. An excellent resource for composables is [VueUse](https://oreil.ly/pKJmK),
    where you can find many helpful, ready-to-use, and tested Vue composition utilities
    for your needs.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 通过可组合项，您可以以模块化和可组合的方式创建应用程序的状态管理逻辑。您甚至可以构建自己的可组合库，以便在其他Vue项目中重用，例如主题控制、数据获取、商店支付管理等。一个很好的可组合资源是[VueUse](https://oreil.ly/pKJmK)，您可以在那里找到许多有用、即用即用且经过测试的Vue组合实用程序，以满足您的需求。
- en: Since all the reactive states get initialized only when using the hook, we can
    avoid data overlapping issues like in mixins. Also, testing components have become
    more straightforward, whereby you can test each composable used in the element
    separately and keep the component’s logic small and maintainable.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有响应式状态仅在使用钩子时初始化，我们可以避免像混入中那样的数据重叠问题。此外，测试组件变得更加简单，您可以分别测试元素中使用的每个可组合项，并保持组件逻辑的小型和可维护性。
- en: After learning about Composition API and composables, how about creating your
    own composables system and using them in your components?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习了Composition API和可组合项之后，您可以考虑创建自己的可组合项系统，并在组件中使用它们。
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter explored how to rewrite our components from the Options API to
    use Composition API functions such as setup function, reactivity, and lifecycle
    hooks. We also learned to create our custom composable based on the existing ones,
    enhancing code reusability. Based on this foundation, we now understand the pros
    and cons of each API, hence their use cases for better development.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了如何从选项 API 重写组件，使用组合 API 的函数，如 setup 函数、响应性和生命周期钩子。我们还学习了如何基于现有的组合函数创建我们自己的自定义组合，增强代码的可重用性。基于这一基础，我们现在理解了每个
    API 的优缺点，因此可以更好地理解它们的使用场景以便于开发。
- en: You are ready to move to the next chapter, where you will learn how to incorporate
    external data from an API or database resource into your Vue application.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经准备好进入下一章，学习如何将来自 API 或数据库资源的外部数据整合到你的 Vue 应用程序中。
- en: ^([1](ch05.html#id998-marker)) When you use the mixin, you are writing a new
    component’s configurations.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch05.html#id998-marker)) 当你使用 mixin 时，你在编写一个新组件的配置。
- en: ^([2](ch05.html#id1078-marker)) In general, a composable is a custom hook.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch05.html#id1078-marker)) 一般来说，可组合（composable）是一个自定义的钩子。
