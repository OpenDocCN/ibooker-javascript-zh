- en: Chapter 16\. Writing Web Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第16章 写作Web应用程序
- en: While JavaScript was once used to add simple interactivity to web pages, today
    it can be used to build complicated and fully featured software applications that
    run in a web browser. The possibilities include mapping, email clients, streaming
    video sites, real-time chat applications, and much more. The line between “website”
    and “application” can be fuzzy, but one way to think about it is that an application
    is any site that takes user input and returns something as a result.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管JavaScript曾经用于向网页添加简单的交互功能，但今天它可以用于构建复杂和功能完善的软件应用程序，在Web浏览器中运行。可能性包括地图、电子邮件客户端、流媒体视频站点、实时聊天应用程序等等。网站和应用程序之间的界限可能模糊，但一种思考方式是，应用程序是任何接受用户输入并返回结果的站点。
- en: As a developer, you can develop these applications and deploy them instantly
    across the world, but this ability comes with unique challenges. As an application
    code base grows, you will need to split your codebase into smaller modules and
    ensure that users are receiving optimized code bundles. You will need to create
    features and experiences that compete with those of native mobile applications,
    such as offline functionality, notifications, and application icons. Thankfully,
    modern JavaScript and browser APIs enable these feature-rich experiences.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，你可以开发这些应用并立即在全球范围内部署，但这种能力带来了独特的挑战。随着应用程序代码库的增长，你需要将代码库拆分为更小的模块，并确保用户接收到优化的代码包。你需要创建与原生移动应用程序相竞争的功能和体验，例如离线功能、通知和应用程序图标。幸运的是，现代JavaScript和浏览器API使这些功能丰富的体验成为可能。
- en: Bundling JavaScript
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包JavaScript
- en: Problem
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to make use of JavaScript modules in a browser environment.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望在浏览器环境中使用JavaScript模块。
- en: Solution
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Make use of native JavaScript modules or a bundling tool, such as [Webpack](https://webpack.js.org).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 利用原生JavaScript模块或打包工具，如[Webpack](https://webpack.js.org)。
- en: 'Native JavaScript is supported in [all modern browsers](https://oreil.ly/FhPq9).
    If we have a simple module that exports a value, named `mod.js`:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现代浏览器中支持原生JavaScript模块。如果我们有一个简单的模块导出一个值，命名为`mod.js`：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'we can use the module natively in an HTML file:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在HTML文件中原生地使用模块：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For more advanced applications and sites, you may benefit from using a bundling
    tool that can optimize your modules. To use Webpack as a bundling tool, first
    install its dependencies with npm:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更高级的应用程序和站点，你可能会从使用一个能够优化你的模块的打包工具中受益。要将Webpack用作打包工具，首先使用npm安装其依赖项：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-14
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Before you are able to install packages from npm, your project will need a *package.json*
    file. To generate this file, make sure you are in the root of your project’s directory
    and type `npm init`. The command-line interface will then guide you through a
    series of prompts. Additional information about installing and using npm is in
    [Chapter 1](ch01.html#ch01).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在能够从npm安装包之前，你的项目将需要一个*package.json*文件。要生成此文件，请确保你在项目目录的根目录中，并输入`npm init`。然后，命令行界面将指导你完成一系列提示。有关安装和使用npm的其他信息，请参阅[第1章](ch01.html#ch01)。
- en: 'We can then create a file named *webpack.config.js* in the root of the project
    directory, where we specify the entry file and output directory:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在项目目录的根目录中创建一个名为*webpack.config.js*的文件，在其中指定入口文件和输出目录：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, add a script to the *package.json* to run the Webpack build:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在*package.json*中添加一个脚本来运行Webpack构建：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Discussion
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: JavaScript modules are now widely available and supported by browsers. This
    allows us to break our code into smaller, more maintainble pieces.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript模块现在广泛可用并受浏览器支持。这使我们能够将我们的代码分解为更小、更易维护的部分。
- en: Webpack is a popular tool for compiling JavaScript modules. The power of Webpack
    lies in the configuration file.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack是一个流行的编译JavaScript模块的工具。Webpack的强大之处在于配置文件。
- en: 'In the previous configuration file, we are instructing Webpack to look at the
    *src* directory for a file named *index.js*. This file will be the entry file
    for our project’s JavaScript:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的配置文件中，我们指示Webpack查看*src*目录中名为*index.js*的文件。这个文件将是我们项目JavaScript的入口文件：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The *index.js* file is importing two additional files, *foo.js* and *bar.js*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*index.js*文件正在导入另外两个文件，*foo.js*和*bar.js*。'
- en: When the `build` script is run, Webpack will output a new minified file named
    *bundle.js* in the *dist* directory.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行`build`脚本时，Webpack将在*dist*目录中输出一个名为*bundle.js*的新的压缩文件。
- en: Compiling simple import statements is only the tip of the iceberg. Webpack can
    be used for hot module reloading, code splitting, browser support shims, and even
    as a development server. In [“JavaScript and the Mobile Web”](#mobile-web), we’ll
    explore how Webpack can be used to reduce the size of a JavaScript bundle.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 编译简单的导入语句只是冰山一角。Webpack可用于热模块重载、代码拆分、浏览器支持的填充以及作为开发服务器使用。在[“JavaScript与移动Web”](#mobile-web)中，我们将探讨Webpack如何用于减少JavaScript捆绑包的大小。
- en: 'Extra: Using npm Modules'
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 额外：使用npm模块
- en: 'In addition to using your own modules, Webpack enables you to download and
    utilize modules directly from [npm](https://www.npmjs.com). To do so, first install
    the module and save it as a dependency to the project:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用自己的模块之外，Webpack还使您能够直接从[npm](https://www.npmjs.com)下载和使用模块。为此，请先安装模块并将其保存为项目的依赖项：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can then require the module directly in your code, without needing to specify
    the path to the module:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以直接在代码中要求模块，而无需指定模块的路径：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: JavaScript and the Mobile Web
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript与移动Web
- en: Problem
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Your website or application makes use of JavaScript, which can noticeably increase
    the time to load on mobile and slow connections.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您的网站或应用程序使用JavaScript，这可能会显著增加在移动设备和慢速连接上加载的时间。
- en: Solution
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: For sites using a small amount of JavaScript in a single file, use a tool such
    as [UglifyJS](https://github.com/mishoo/UglifyJS) to minify your JavaScript. Minification
    will reduce the size of a JavaScript file by removing unnecessary characters (such
    as whitespace).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于仅使用少量JavaScript的单个文件站点，请使用像[UglifyJS](https://github.com/mishoo/UglifyJS)这样的工具来缩小您的JavaScript。缩小将通过删除不必要的字符（例如空格）来减少JavaScript文件的大小。
- en: 'To use UglifyJS, first install it with npm:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用UglifyJS，请先通过npm安装它：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, add a script to your *package.json* file, specifying the input JavaScript
    file and a name for the minified file:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在您的*package.json*文件中添加一个脚本，指定输入JavaScript文件和缩小后的文件名：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: For larger sites and applications with multiple JavaScript files, use a bundling
    tool, such as [Webpack](https://webpack.js.org), to perform a combination of minification,
    code splitting, tree shaking, and lazy loading.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有多个JavaScript文件的较大站点和应用程序，请使用捆绑工具，例如[Webpack](https://webpack.js.org)，执行缩小、代码拆分、树摇和延迟加载的组合。
- en: Webpack automatically minifies its output in production mode, meaning that no
    specific configuration or minification tool is needed.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack在生产模式下会自动对其输出进行缩小，因此不需要特定的配置或缩小工具。
- en: 'Code splitting is the process of generating multiple bundles, so that HTML
    pages or templates only load the code they need. The following *webpack.config.js*
    file will output two JavaScript files (*index.bundle.js* and *secondary.bundle.js*)
    to the *dist* directory:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 代码拆分是生成多个捆绑包的过程，因此HTML页面或模板仅加载它们所需的代码。以下*webpack.config.js*文件将在*dist*目录中输出两个JavaScript文件（*index.bundle.js*和*secondary.bundle.js*）：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Bundles can balloon in size, particularly when importing third-party libraries
    with functionality that may not be needed. *Tree shaking* is the concept of eliminating
    dead or unused code. Webpack can be configured to eliminate dead code with the
    `optimization` setting:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 捆绑包的大小可能会激增，特别是在导入可能不需要的第三方库功能时。 *树摇* 是消除死代码或未使用代码的概念。Webpack可以通过`optimization`设置进行配置以消除死代码：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The final step for code splitting is to add a `sideEffects` field to the project’s
    *package.json* file. According to the Webpack documentation, “a *side effect*
    is defined as code that performs a special behavior when imported, other than
    exposing one or more exports.” An example of a side effect would be a global polyfill,
    which does not expose any `export` statements.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 进行代码拆分的最后一步是在项目的*package.json*文件中添加一个`sideEffects`字段。根据Webpack文档，“*side effect*”被定义为在导入时执行特殊行为的代码，除了暴露一个或多个导出。一个*side
    effect*的示例可能是全局填充，它不会暴露任何`export`语句。
- en: 'If no such file is present, we can set the following in *package.json*:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不存在这样的文件，我们可以在*package.json*中设置以下内容：
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If your project does have JavaScript files that would fall under the “side
    effect” category, we can provide them as an array:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的项目确实包含JavaScript文件，这些文件将属于“side effect”类别，我们可以将它们作为一个数组提供：
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, we can utilize Webpack to enable the lazy loading of JavaScript modules,
    only loading them when they are needed by a browser interaction. Webpack makes
    this straightforward with a dynamic `import` statements. With a file named *button.js*
    in the *src* directory, the contents of the file can be loaded when a user clicks
    a button. In *index.js*:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以利用 Webpack 实现 JavaScript 模块的延迟加载，仅在用户与浏览器交互时加载它们。Webpack 通过动态的 `import`
    语句使此过程变得简单。在 *src* 目录中有一个名为 *button.js* 的文件，当用户点击按钮时，文件的内容可以被加载。在 *index.js* 中：
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Discussion
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The fastest JavaScript is no JavaScript; however, the interactive demands of
    modern web applications often rely on client-side JavaScript. With that in mind,
    our goal is to limit the amount and file size of the JavaScript being downloaded
    by a user’s browser. Utilizing strategies such as minification, code splitting,
    tree shaking, and lazy loading allows you finer control over size and amount of
    JavaScript being loaded in a user’s browser.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最快的 JavaScript 是没有 JavaScript；然而，现代 Web 应用程序的交互需求通常依赖于客户端 JavaScript。考虑到这一点，我们的目标是限制用户浏览器下载的
    JavaScript 的数量和文件大小。利用诸如代码缩小、代码分割、摇树和延迟加载等策略，可以更精细地控制用户浏览器中加载的 JavaScript 的大小和数量。
- en: See Also
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Webpack’s [Getting Started guide](https://oreil.ly/TAnYG) is a useful introduction
    to code bundling and Webpack configuration files.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack 的[入门指南](https://oreil.ly/TAnYG)是关于代码打包和 Webpack 配置文件的有用介绍。
- en: Writing a Progressive Web Application
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写渐进式 Web 应用程序
- en: Problem
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You’d like your web application to take advantage of native application features
    such as fast load times, offline functionality, and app launching icons.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你想让你的 Web 应用程序利用本机应用程序功能，例如快速加载时间、离线功能和应用程序启动图标。
- en: Solution
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Turn your web application into a Progressive Web Application (PWA). The phrase
    “Progressive Web Applications” was coined to describe a set of technologies that,
    when combined, enable web applications to use native-like features, such as offline
    functionality and user-installed app icons, while being built with standard web
    technologies and deployed to the web.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的 Web 应用程序转变为渐进式 Web 应用程序（PWA）。术语“渐进式 Web 应用程序”用来描述一组技术，这些技术结合在一起，使得 Web 应用程序可以使用类似本机应用程序的功能，例如离线功能和用户安装的应用程序图标，同时使用标准的
    Web 技术构建和部署到 Web。
- en: 'All PWAs are required to include two features that extend beyond that of a
    typical web page:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 PWA 都需要包含超出典型网页的两个功能：
- en: Application manifest
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序清单
- en: Defines application specific features for the browser.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为浏览器定义特定应用程序功能。
- en: Service worker
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 服务工作者
- en: Enables the application’s offline functionality.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 启用应用程序的离线功能。
- en: 'The first step in creating a progressive web application is to add the web
    app manifest file. This file enables developers to control things like application
    icons, splash screens, browser display style, and view orientation. In a file
    named *manifest.json*:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 创建渐进式 Web 应用程序的第一步是添加 Web 应用程序清单文件。该文件使开发人员可以控制应用程序图标、启动画面、浏览器显示样式和视图方向等内容。在名为
    *manifest.json* 的文件中：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, in your HTML files or templates, add a reference to the manifest file and
    appropriate application icons in the document’s `<head>`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在你的 HTML 文件或模板中，在文档的 `<head>` 中添加对清单文件和适当应用程序图标的引用。
- en: Example 16-1\. PWA Metatags
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 16-1\. PWA 元标签
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The PWA install prompt is automatically triggered in Chrome when a website meets
    the PWA criteria (see [Figure 16-1](#manifest_chrome)). Once installed, the PWA’s
    icon appears on the user’s device, much like a native application ([Figure 16-2](#ios_app)).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当网站符合 PWA 标准时（参见[图 16-1](#manifest_chrome)），Chrome 会自动触发 PWA 安装提示。一旦安装完成，PWA
    的图标会出现在用户设备上，就像本机应用程序一样（参见[图 16-2](#ios_app)）。
- en: '![A screenshot of the install prompt in Chrome](assets/jsc3_1601.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![在 Chrome 中的安装提示的屏幕截图](assets/jsc3_1601.png)'
- en: Figure 16-1\. PWA install prompt
  id: totrans-76
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 16-1\. PWA 安装提示
- en: '![A screenshot of the app icon on a mobile device](assets/jsc3_1602.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![在移动设备上显示应用图标的屏幕截图](assets/jsc3_1602.png)'
- en: Figure 16-2\. The application can be saved to a mobile device
  id: totrans-78
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 16-2\. 应用程序可以保存到移动设备上
- en: The second step is to create a service worker. A service worker is a script
    that runs separately from the page, providing us with a way to make our sites
    work offline, run faster, and add capabilities for background features. With the
    limits of mobile connectivity, service workers provide us with a means to build
    offline-first capable applications, which will load content for our users after
    an initial site visit, regardless of network conditions. Best of all, service
    workers are truly a progressive enhancement, layering on an additional feature
    to supporting browsers without changing the functionality of our site for users
    of nonsupporting browsers.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是创建服务工作线程。服务工作线程是一个独立于页面运行的脚本，为我们提供一种方式使我们的站点脱机工作、运行更快，并添加后台功能的能力。在移动连接的限制下，服务工作线程为我们提供一种构建首次脱机能力应用程序的方式，这些应用程序将在用户首次访问站点后加载内容，而不管网络条件如何。最重要的是，服务工作线程真正是一种渐进增强，为支持的浏览器增加了额外的功能，而不会改变非支持浏览器用户的站点功能。
- en: 'When introducing a service worker, the initial step is to register the script
    that will contain our service worker code with the user’s browser. To accomplish
    this, add the script registration to the bottom of the page just before the closing
    `</body>` tag:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当引入服务工作线程时，初始步骤是向用户的浏览器注册包含我们服务工作线程代码的脚本。为了实现这一点，请在页面底部，在闭合`</body>`标签之前添加脚本注册：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This script checks for service worker support, and if the support is available,
    points the browser to a service worker script (in this case *service-worker.js*).
    For debugging purposes, the script also catches errors and logs them to the console.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本检查服务工作线程的支持情况，如果支持可用，则指向服务工作线程脚本（在本例中为 *service-worker.js*）。为了调试目的，脚本还会捕获错误并记录到控制台。
- en: 'In *service-worker.js*, begin by specifying a cache version and listing the
    files that the browser should cache:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *service-worker.js* 文件中，开始通过指定缓存版本并列出浏览器应该缓存的文件，设置 `install`、`fetch` 和 `activate`
    事件监听器。
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-85
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: For changes to the site, the `cacheVersion` needs to be updated, or users risk
    being served content from the cache.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对于网站的更改，需要更新`cacheVersion`，否则用户可能会从缓存中获取内容。
- en: Now, in the *service-worker.js* file, set up the `install`, `fetch`, and `activate`
    event listeners. The `install` event provides the browser with instructions for
    installing our cached files. The `fetch` event provides the browser with guidelines
    for handling fetch events by instructing the browser to either load the cached
    files or those received over the network. Finally, the `activate` event, which
    fires when the service worker is activated, can be used to check for existing
    items in the cache and remove them if an updated `cacheVersion` is present and
    the file is no longer in the `filestoCache` list (see [Figure 16-3](#offline)).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 *service-worker.js* 文件中，设置 `install`、`fetch` 和 `activate` 事件监听器。`install`
    事件为浏览器提供了安装缓存文件的指令。`fetch` 事件通过指示浏览器加载缓存文件或通过网络接收的文件来处理 fetch 事件。最后，当服务工作线程被激活时触发
    `activate` 事件，可以用于检查缓存中的现有项目，并在存在更新的 `cacheVersion` 和文件不再在 `filestoCache` 列表中时移除它们（见
    [图 16-3](#offline)）。
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![A screenshot of the application running in offline mode](assets/jsc3_1603.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![应用程序离线模式运行的屏幕截图](assets/jsc3_1603.png)'
- en: Figure 16-3\. With the service worker installed, the application can load files
    when offline
  id: totrans-90
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 16-3\. 配备服务工作线程后，应用可以在离线状态下加载文件。
- en: Discussion
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: A Progressive Web Application is a user-installable web application with some
    form of offline functionality. These features allow web applications to closely
    mimic the best features of native applications while providing the benefits of
    the open web.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 渐进式 Web 应用是一种用户可安装的 Web 应用程序，具有某种离线功能。这些特性使 Web 应用程序能够紧密模仿原生应用程序的最佳特性，同时提供开放
    Web 的好处。
- en: 'The web app manifest is a JSON file that provides information about the application.
    The full list of key values that it can contain are as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Web 应用清单是一个提供有关应用程序信息的 JSON 文件。它可以包含的所有关键值的完整列表如下：
- en: '`background_color`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`background_color`'
- en: A color code for a placeholder launch screen background.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 用于占位启动屏幕背景的颜色代码。
- en: '`categories`'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`categories`'
- en: An array of strings of categories that the application belongs to.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序所属类别的字符串数组。
- en: '`description`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`description`'
- en: A string description of the application.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的字符串描述。
- en: '`dir`'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`dir`'
- en: The direction in which to display characters. This can be `auto`, `ltr` (left
    to right), or `rtl` (right to left).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 显示字符的方向。可以是`auto`、`ltr`（从左到右）或`rtl`（从右到左）。
- en: '`display`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`display`'
- en: The preferred display mode. This can be either `browser`, for default browser
    behavior, or `fullscreen`, which will reduce the browser chrome on some devices.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首选的显示模式。可以是`browser`，表示默认的浏览器行为，或者是`fullscreen`，在某些设备上会减少浏览器的外壳。
- en: '`iarc_rating_id`'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`iarc_rating_id`'
- en: An International Age Rating value.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 国际年龄评级值。
- en: '`icons`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`icons`'
- en: An array of objects linking to icon images and descriptions.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一个链接到图标图像和描述的对象数组。
- en: '`lang`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`lang`'
- en: Identifies the primary language of the application.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 标识应用程序的主要语言。
- en: '`name`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`name`'
- en: The application name.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序名称。
- en: '`orientation`'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`orientation`'
- en: Allows the developer to set the default orientation of the application.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 允许开发人员设置应用程序的默认方向。
- en: '`prefer_related_applications`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`prefer_related_applications`'
- en: If set to `true`, allows the developer to specify related applications that
    should be installed instead of the web application.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置为`true`，允许开发人员指定应安装的相关应用程序，而不是Web应用程序。
- en: '`related_applications`'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`related_applications`'
- en: An array of objects containing a list of related native applications.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 包含一系列相关本地应用程序列表的对象数组。
- en: '`scope`'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`scope`'
- en: A string that contains the navigation scope of the app. Specifying a scope restricts
    navigation in application mode to that directory.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 包含应用程序的导航范围的字符串。指定范围会限制应用模式下的导航到该目录。
- en: '`screenshots`'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`screenshots`'
- en: An array of application screenshots.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用程序截图数组。
- en: '`short_name`'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`short_name`'
- en: A shortened version of the application name to be used in contexts where the
    full name is too long to display.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序名称的缩短版本，用于在显示完整名称太长时的上下文中使用。
- en: '`start_url`'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`start_url`'
- en: The URL that should open when a user launches the application.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 用户启动应用程序时应该打开的URL。
- en: '`theme_color`'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`theme_color`'
- en: A string that defines the default theme color for the application.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 定义应用程序的默认主题颜色的字符串。
- en: 'The [W3C provides an example](https://oreil.ly/zlk9P) of a robust manifest
    file for a web-based game:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[W3C提供了一个示例](https://oreil.ly/zlk9P)，展示了一个面向Web游戏的强大清单文件：'
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In addition to the web app manifest file, some platforms, such as iOS and Windows,
    require additional information which can be provided in the form of HTML metatags.
    In [Example 16-1](#pws_meta_tags), metatags are used to define a theme color,
    the iOS icon, and Windows tile settings.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Web应用清单文件外，某些平台（如iOS和Windows）还需要提供额外的信息，这些信息可以通过HTML元标签提供。在[示例16-1](#pws_meta_tags)中，元标签用于定义主题颜色、iOS图标和Windows平铺设置。
- en: Tip
  id: totrans-131
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Generating icons for all of the different device types and resolutions can be
    a tedious affair, so I recommend using [RealFaviconGenerator](https://oreil.ly/ALsQe).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为所有不同的设备类型和分辨率生成图标可能是一件繁琐的事情，因此我建议使用[RealFaviconGenerator](https://oreil.ly/ALsQe)。
- en: A service worker is a script that the browser runs in the background, parallel
    to the rendering and execution of the page. Because it is a “worker,” the service
    worker cannot access the DOM directly, however this parallel script enables all
    sorts of new use cases. One of the most exciting of these use cases is the ability
    to cache bits of our application for offline use. In the above example, I’m caching
    an HTML, JavaScript, and CSS file to provide a full-featured (if minimal) site
    experience when offline. Other use cases may include creating a separate offline
    experience or caching the shared template markup and styles, often referred to
    as the “application shell.”
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 服务工作线程是浏览器在后台运行的脚本，与页面的渲染和执行并行进行。由于它是一个“工作线程”，因此服务工作线程无法直接访问DOM，但这种并行脚本能够实现各种新的用例。其中最令人兴奋的用例之一是能够缓存应用程序的各个部分以供离线使用。在上面的示例中，我正在缓存一个HTML、JavaScript和CSS文件，以便在离线时提供一个完整的（尽管是最小化的）站点体验。其他用例可能包括创建一个独立的离线体验或缓存共享模板标记和样式，通常称为“应用程序外壳”。
- en: 'When utilizing service workers, there are a few limitations to be aware of:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用服务工作线程时，需要注意一些限制：
- en: Sites using a service worker must be served over HTTPS.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用服务工作线程的站点必须通过HTTPS提供。
- en: Service workers do not work when a user is in private browsing mode.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户处于私密浏览模式时，服务工作线程不起作用。
- en: Since service workers run as a separate thread in the browser, they do not have
    access to the DOM.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于服务工作线程在浏览器中作为一个独立的线程运行，因此它们无法访问DOM。
- en: Service workers are scoped, meaning that they should be placed in the root of
    your application.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务工作线程是有作用域的，这意味着它们应该放置在应用程序的根目录中。
- en: Cache storage sizes can vary by browser and available space on a user’s hard
    drive.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存存储大小可能因浏览器和用户硬盘空间的可用情况而异。
- en: Though I’ve created a service worker by hand in the above example, that can
    quickly become unmanageable for larger applications. The [Workbox](https://oreil.ly/Gu3Z6)
    library, created by Google, is a package for managing service workers and offline
    functionality in web applications. Workbox takes much of the pain out of versioning
    and managing the cache, as well as advanced capabilities such as background sync
    and precaching.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在上述示例中手动创建了服务工作者，但对于更大的应用程序来说，这很快就变得难以管理。由 Google 创建的 [Workbox](https://oreil.ly/Gu3Z6)
    库是用于管理 Web 应用程序中服务工作者和离线功能的包。Workbox 大大简化了版本控制和缓存管理的痛点，以及背景同步和预缓存等高级功能。
- en: Progressive web applications are an exciting step for the web and are framework
    agnostic, meaning they can be built with simple HTML, CSS, and JavaScript, or
    using the latest JavaScript frameworks. In this section we have only scratched
    the surface of the power of these technologies. Tal Alter’s book [*Building Progressive
    Web Apps*](http://shop.oreilly.com/product/0636920052067.do) (O’Reilly) offers
    a detailed look at the features and functionality of Progressive Web Applications.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 渐进式 Web 应用程序对 Web 是一大步进，它与框架无关，这意味着可以使用简单的 HTML、CSS 和 JavaScript 构建，也可以使用最新的
    JavaScript 框架。在本节中，我们只是浅尝这些技术的强大之处。Tal Alter 的书籍 [*Building Progressive Web Apps*](http://shop.oreilly.com/product/0636920052067.do)（O’Reilly
    出版）详细介绍了渐进式 Web 应用程序的特性和功能。
- en: Testing and Profiling a Progressive Web Application
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试和分析渐进式 Web 应用程序
- en: Problem
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You’d like to test that you’ve successfully fulfilled the requirements of a
    Progressive Web Application.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望测试是否成功满足了渐进式 Web 应用程序的要求。
- en: Solution
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use [Lighthouse](https://oreil.ly/hEdHB) to audit performance, accessibility,
    best practices, SEO, and Progressive Web Application criteria. The easiest way
    to access Lighthouse is within the “Lighthouse” tab of Google Chrome Developer
    Tools. Visit the site (either in production or on a local web server) and click
    “Generate Report” (see [Figure 16-4](#lighthouse-pwa)).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [Lighthouse](https://oreil.ly/hEdHB) 来审计性能、可访问性、最佳实践、SEO 和渐进式 Web 应用程序标准。访问网站（无论是在生产环境还是本地
    Web 服务器上），然后单击“生成报告”（见图 [Figure 16-4](#lighthouse-pwa)）。
- en: Lighthouse will then generate a report, making recommended improvements for
    any score reductions (see Figures [16-5](#lighthouse_high) and [16-6](#lighthouse_low)).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Lighthouse 随后将生成报告，提出任何分数降低的建议性改进（参见图 [16-5](#lighthouse_high) 和 [16-6](#lighthouse_low)）。
- en: '![A sreenshot of Google Lighthouse](assets/jsc3_1604.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![Google Lighthouse 的截图](assets/jsc3_1604.png)'
- en: Figure 16-4\. Lighthouse within Chrome Developer Tools
  id: totrans-149
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 16-4\. Chrome 开发者工具中的 Lighthouse
- en: '![A screenshot of a site with a high Lighthouse score](assets/jsc3_1605.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![一个高 Lighthouse 分数站点的截图](assets/jsc3_1605.png)'
- en: Figure 16-5\. A high score demonstrates a performant application and successful
    progressive web app
  id: totrans-151
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 16-5\. 高分表明应用程序性能优越，是成功的渐进式 Web 应用。
- en: '![A screenshot of a site with a low Lighthouse score](assets/jsc3_1606.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![一个低 Lighthouse 分数站点的截图](assets/jsc3_1606.png)'
- en: Figure 16-6\. A site receiving a low Lighthouse score will also receive recommendations
    for improvement
  id: totrans-153
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 16-6\. 分数低的站点还将获得改进建议
- en: Note
  id: totrans-154
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The general use of profiling non-Progressive Web Application sites with Lighthouse
    in the Chrome Developer Tools is covered in more detail in [“Using Lighthouse
    to Measure Best Practices”](ch11.html#lighthouse).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 关于在 Chrome 开发者工具中使用 Lighthouse 对非渐进式 Web 应用程序站点进行性能分析的一般用法更详细地介绍在 [“Using Lighthouse
    to Measure Best Practices”](ch11.html#lighthouse) 中。
- en: Discussion
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Lighthouse is a tool for measuring web best practices, including performance
    and progressive web application compatibility. It comes built into the Chrome
    Developer Tools, but can also be installed as a Firefox extension.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Lighthouse 是一款测量 Web 最佳实践的工具，包括性能和渐进式 Web 应用程序兼容性。它内置于 Chrome 开发者工具中，但也可以作为
    Firefox 扩展安装。
- en: 'In addition to being a browser tool, Lighthouse can be installed through npm
    and used on the command line or as a Node module. You would install Lighthouse
    the same as any other Node module:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 除了作为浏览器工具外，Lighthouse 还可以通过 npm 安装，并且可以在命令行中使用或作为 Node 模块使用。您可以像安装其他 Node 模块一样安装
    Lighthouse：
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'which can then be run by passing a URL as an argument:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以通过传递 URL 作为参数来运行：
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Passing a `--view` argument will open the results in your browser:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 通过传递 `--view` 参数将在浏览器中打开结果：
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can also specify an output filetype and location to store the report results:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以指定输出文件类型和位置来存储报告结果：
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And a *budget.json* file can be used to set and test against performance budget
    limitations. In a *budget.json* file, define the limitations to test against:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*budget.json* 文件可用于设置和测试性能预算限制。在 *budget.json* 文件中，定义要测试的限制：'
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Tip
  id: totrans-168
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The Google Chrome team mantains a [repository](https://github.com/GoogleChrome/budget.json)
    containing the documentation of *budget.json* options.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌 Chrome 团队维护着一个包含 *budget.json* 选项文档的[存储库](https://github.com/GoogleChrome/budget.json)。
- en: Testing locally from the command line can be helpful for local development,
    but the real power of Lighthouse as a code module is realized when used with continuous
    integration tools such as GitHub Actions, Circle CI, Jenkins, and Travis CI. The
    [Lighthouse CI](https://github.com/GoogleChrome/lighthouse-ci) module enables
    you to perform Lighthouse testing in a continuous integration pipeline, such as
    on every GitHub pull request.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行本地测试对本地开发有帮助，但作为代码模块使用 Lighthouse 的真正威力在于与 GitHub Actions、Circle CI、Jenkins
    和 Travis CI 等持续集成工具一起使用。[Lighthouse CI](https://github.com/GoogleChrome/lighthouse-ci)
    模块使您能够在持续集成流水线中执行 Lighthouse 测试，例如在每个 GitHub 拉取请求上。
- en: 'Here’s a sample configuration for CircleCI:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 CircleCI 的一个示例配置：
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Full details on how to use Lighthouse in multiple CI environments are available
    in Google’s [Getting Started guide](https://oreil.ly/7jnwx).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Google 的[入门指南](https://oreil.ly/7jnwx)中可以找到如何在多个 CI 环境中使用 Lighthouse 的详细信息。
- en: Getting the Value of the Current URL
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取当前 URL 的值
- en: Problem
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Your application needs to read the value of the current URL.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序需要读取当前 URL 的值。
- en: Solution
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use the `href` property of `window.location` to read the current value of the
    full URL:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `window.location` 的 `href` 属性来读取当前完整 URL 的值：
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Discussion
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: '`window.location` provides read-only information about the current URL or *location*
    of the document. The `href` property provides the full URL, which includes the
    protocol (such as HTTPS), hostname, the path to the current document, and any
    query strings. All together, this will match what is displayed in the user’s URL
    bar:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`window.location` 提供了关于当前文档位置或 *location* 的只读信息。`href` 属性提供了完整的 URL，包括协议（如
    HTTPS）、主机名、当前文档的路径和任何查询字符串。所有这些将与用户的 URL 栏中显示的内容匹配：'
- en: '[PRE28]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note
  id: totrans-183
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The global variable `location` is the same as `window.location`; however, I
    prefer the explicitness of using the `window` API.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量 `location` 与 `window.location` 相同；但我更喜欢使用 `window` API 来表达清晰。
- en: 'The `href` property is not the only useful one. If you already know that the
    user is on your site, it may be more useful to access the `pathname` and `search`
    properties:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`href` 属性并非唯一有用的属性。如果您已经知道用户在您的站点上，访问 `pathname` 和 `search` 属性可能更有用：'
- en: '[PRE29]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The full list of read-only properties of `window.location` are:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`window.location` 的全部只读属性列表如下：'
- en: '`hash`'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`hash`'
- en: A hash value in the URL, such as `#id`
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: URL 中的哈希值，例如 `#id`
- en: '`host`'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`host`'
- en: The domain plus port
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 域名加端口
- en: '`hostname`'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`hostname`'
- en: The domain
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 域名
- en: '`href`'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`href`'
- en: The full URL
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 完整 URL
- en: '`origin`'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`origin`'
- en: The protocol, hostname, and port
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 协议、主机名和端口
- en: '`pathname`'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`pathname`'
- en: The path of the current document
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当前文档的路径
- en: '`port`'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`port`'
- en: The server’s port number value
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端口号值
- en: '`protocol`'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`protocol`'
- en: The protocol (HTTP or HTTPS)
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 协议（HTTP 或 HTTPS）
- en: '`search`'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`search`'
- en: Query string values
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 查询字符串值
- en: Redirecting a URL
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重定向 URL
- en: Problem
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to use JavaScript to route a user to a different page.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要使用 JavaScript 将用户路由到另一页。
- en: Solution
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use either the `assign` or `replace` `window.location` method, depending on
    the goal of the redirect:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 根据重定向目的，可以使用 `window.location` 的 `assign` 或 `replace` 方法：
- en: '[PRE30]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `window.location.assign` method will route a user to a new URL, but will
    preserve the routing page in the browser history. This means that a user will
    be able to use the browser’s back button to navigate back to the page. Conversely,
    `window.location.replace` will replace the current URL in the history, disabling
    the ability to return to the current page.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`window.location.assign` 方法会将用户路由到一个新 URL，但会保留浏览器历史记录中的当前页面。这意味着用户可以使用浏览器的返回按钮返回该页面。相反，`window.location.replace`
    会替换历史记录中的当前 URL，禁用返回到当前页面的功能。'
- en: Discussion
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'By using `window.location` methods, you are able to route a user to a new URL
    using JavaScript. This allows you to reroute a user or redirect a user based on
    a page interaction. `assign` and `replace` are not the only `window.location`
    methods at your disposal. The full list of methods is as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`window.location`方法，您可以使用 JavaScript 将用户路由到新的 URL。这使您能够根据页面交互重新路由用户或重定向用户。`assign`
    和 `replace` 不是您唯一可以使用的 `window.location` 方法。完整的方法列表如下：
- en: '`.assign()`'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`.assign()`'
- en: Navigates the user’s browser to a given URL
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 将用户的浏览器导航到给定的 URL
- en: '`.reload()`'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`.reload()`'
- en: Reloads the page
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载页面
- en: '`.replace()`'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`.replace()`'
- en: Navigates the user’s browser to a given URL and removes the current document
    from the browser history
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 将用户的浏览器导航到给定的 URL，并从浏览器历史记录中删除当前文档
- en: '`toString()`'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`toString()`'
- en: Returns the current URL as a string
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 将当前 URL 作为字符串返回
- en: By leveraging these methods, you will be able to use JavaScript to manipulate
    the route of the page, which can provide useful functionality for application
    UIs and interactive routing. Although these features can be very useful when developing
    applications, full page redirects should always be done with an HTTP redirect
    with the appropriate status code of 301 for permanent redirects or 302 for temporary
    redirects.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用这些方法，您将能够使用 JavaScript 来操纵页面的路由，这可以为应用程序 UI 和交互式路由提供有用的功能。尽管在开发应用程序时这些功能非常有用，但应始终使用
    HTTP 重定向执行完整页面重定向，具体的状态码为 301 表示永久重定向或 302 表示临时重定向。
- en: Note
  id: totrans-224
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Popular JavaScript frameworks come with a routing library or can be extended
    with a third-party routing library, which can be used for robust client-side routing.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 流行的 JavaScript 框架带有路由库或可以通过第三方路由库进行扩展，用于强大的客户端路由。
- en: Copying Text to a User’s Clipboard
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将文本复制到用户的剪贴板
- en: Problem
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Your application needs to copy text, such as a share link, to the user’s clipboard.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序需要复制文本，例如共享链接，到用户的剪贴板。
- en: Solution
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: To copy text to a user’s clipboard, place the text within a text `input` or
    `textarea` element and use the `navigator.clipboard.writeText` method to copy
    the text.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要将文本复制到用户的剪贴板，将文本放在文本`input`或`textarea`元素内，并使用`navigator.clipboard.writeText`方法复制文本。
- en: 'In your HTML, include the form element as well as a button. In the example,
    I’m setting an explicit `value` for the input element. This value could also be
    set by the user or dynamically in code:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 HTML 中，包括表单元素以及一个按钮。在示例中，我为输入元素设置了一个明确的`value`。这个值也可以由用户或者在代码中动态设置：
- en: '[PRE31]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: And in the corresponding JavaScript, add an event handler to the `button` element.
    When the button is clicked, use the `select` method to select the text within
    the `input` element followed by `navigator.clipboard.writeText()` to copy the
    text to the user’s clipboard, as shown in [Example 16-2](#copy-text-js).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 并在相应的 JavaScript 中，向`button`元素添加事件处理程序。当点击按钮时，使用`select`方法选择`input`元素内的文本，然后使用`navigator.clipboard.writeText()`将文本复制到用户的剪贴板，如[示例 16-2](#copy-text-js)所示。
- en: Example 16-2\. Copying text to the clipboard
  id: totrans-234
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 16-2\. 复制文本到剪贴板
- en: '[PRE32]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Discussion
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Adding text to a user’s clipboard from a text input box is a common UI pattern
    seen in web applications such as GitHub and Google Docs. This can be a useful
    feature to simplify the sharing of information or a URL for users. The input and
    button pattern demonstrated in the primary recipe is the most common use, but
    there may be times where you want to instead copy a user selection from the page’s
    content. In this scenario, it may be useful to hide the form control. To do this,
    include the markup of the page content as well as a `textarea` or `input` element.
    In this example, I’ve used a `textarea` element and set the `tabindex` to remove
    it from the user’s tab flow, then set `aria-hidden` to `true` so that screen readers
    know to ignore the element:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Web 应用程序中经常看到从文本输入框向用户剪贴板添加文本的常见 UI 模式，例如 GitHub 和 Google Docs。这可以是一个有用的功能，用于简化用户共享信息或
    URL 的方式。主要食谱中演示的输入和按钮模式是最常见的使用方式，但有时您可能希望从页面内容的用户选择中复制。在这种情况下，隐藏表单控件可能会很有用。为此，请包括页面内容的标记以及一个`textarea`或`input`元素。在本例中，我使用了一个`textarea`元素，并将`tabindex`设置为将其从用户的标签流中移除，然后将`aria-hidden`设置为`true`，以便屏幕阅读器知道忽略该元素。
- en: '[PRE33]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In my CSS, I’ve hidden the element by placing it offscreen and giving it a
    height and width value of `0`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的 CSS 中，我通过将元素放在屏幕外并设置高度和宽度值为`0`来隐藏该元素：
- en: '[PRE34]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, in my JavaScript I follow a similar pattern as [Example 16-2](#copy-text-js),
    with the addition of using the `document.getSelection()` to get the value of any
    text that the user has selected on the page:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我的JavaScript中，我遵循类似于[示例 16-2](#copy-text-js)的模式，此外还使用`document.getSelection()`来获取用户在页面上选择的任何文本的值：
- en: '[PRE35]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Enabling easy sharing of web application content is a common pattern in the
    social web era. Using these techniques provides a pattern to simplify that interaction.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在社交网络时代，使Web应用程序内容易于分享是一种常见模式。使用这些技术提供了简化交互的模式。
- en: Enabling a Mobile-Like Notification in the Desktop Browser
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在桌面浏览器中启用类似移动设备的通知
- en: Problem
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need a way to notify a user that an event has occurred or a long-running
    process is finished, even if your site isn’t open in an active tab.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一种方式来通知用户事件已发生或长时间运行的过程已完成，即使您的网站在活动选项卡中未打开。
- en: Solution
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the Web Notifications API.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Web通知API。
- en: This API provides a relatively simple technique to pop up a notification window
    outside of the browser, so that if a person is currently looking at a web page
    in another tab, they’ll still see the notification.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 此API提供了一种相对简单的技术，可以在浏览器之外弹出通知窗口，因此如果某人当前正在另一个选项卡中查看网页，则仍会看到通知。
- en: 'To use a Web Notification, you do need to get permission. In the following
    code, Notification permission is requested when a user clicks a button. If permission
    is granted, a notification is displayed:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Web通知，确实需要获取权限。在以下代码中，当用户点击按钮时请求通知权限。如果授予权限，则显示通知：
- en: '[PRE36]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Discussion
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Mobile environments have notifications that let you know when you’ve received
    a new “Like” on a Facebook post or a new email in your email client. Traditionally,
    we didn’t have this capability in a desktop environment, though some might say
    this is a good thing.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 移动环境中有通知功能，可以让您知道在Facebook帖子上收到新的“赞”或在电子邮件客户端中收到新的电子邮件。传统上，在桌面环境中我们没有这种功能，尽管有些人可能会认为这是件好事。
- en: Still, as we create more sophisticated web applications, it may help to have
    this functionality, particularly when our applications may take a significant
    amount of time. Instead of forcing people to hang around looking at a “working”
    icon on our pages, the web page visitor can view other web pages in other tabs,
    and know they’ll get notified when the long-running process is finished.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，随着我们创建更复杂的Web应用程序，拥有此功能可能会有所帮助，特别是当我们的应用程序可能需要较长时间。而不是迫使人们在我们的页面上挂着“工作”图标，网页访问者可以在其他选项卡中查看其他网页，并知道当长时间运行的进程完成时会收到通知。
- en: In the solution, the first time the code creates a new notification, it gets
    permission from the web page visitor. If your application is created as a standalone
    web application, you can specify permissions in the manifest file, but for web
    pages, you have to ask permission.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案中，第一次代码创建新通知时，它会从网页访问者那里获取权限。如果您的应用程序是作为独立的Web应用程序创建的，您可以在清单文件中指定权限，但对于网页，则必须请求权限。
- en: 'Prior to the Notification permission request, you can also test to see if Notification
    exists, so an error is not thrown if it’s not supported:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在通知权限请求之前，您还可以测试通知是否存在，这样如果不支持它，就不会抛出错误：
- en: '[PRE37]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The Notification takes two arguments—a title string and an object with options:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 通知接受两个参数——标题字符串和带有选项的对象：
- en: '`body`'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`body`'
- en: The text message in the body of the notification
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 通知正文中的文本消息
- en: '`tag`'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`tag`'
- en: A tag to help identify notifications for global changes
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 用于标识全局更改通知的标签
- en: '`icon`'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`icon`'
- en: A custom icon
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义图标
- en: '`lang`'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`lang`'
- en: Language of notification
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 通知的语言
- en: '`dir`'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`dir`'
- en: Direction of the language
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 语言的方向
- en: 'You can also code four event handlers:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以编写四个事件处理程序：
- en: '`onerror`'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onerror`'
- en: '`onclose`'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onclose`'
- en: '`onshow`'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onshow`'
- en: '`onclose`'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onclose`'
- en: And you can programatically close the notification with `Notification.close()`,
    though Safari and Firefox automatically close the notification in a few seconds.
    All browsers provide a window close (*x*) option in the notification.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`Notification.close()`来以编程方式关闭通知，尽管Safari和Firefox会在几秒钟内自动关闭通知。所有浏览器在通知中提供窗口关闭（*x*）选项。
- en: 'Extra: Web Notifications and the Page Visibility API'
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 额外信息：Web通知和页面可见性API
- en: You can combine Web Notifications with the Page Visibility API to display the
    Notification only when the web page visitor isn’t actively looking at the web
    page.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将Web通知与页面可见性API结合使用，以便仅在网页访问者没有主动查看网页时显示通知。
- en: 'The Page Visibility API has broad support in modern browsers. It adds support
    for one event, `visibilitychange`, which is fired when the visibility of the tab
    page changes. It also supports a couple of new properties—`document.hidden` returns
    true if the tab page isn’t visible, and `document.visibilityState`, which has
    one of the following four values:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 页面可见性 API 在现代浏览器中得到广泛支持。它增加了一个事件支持，`visibilitychange`，当标签页的可见性发生变化时触发。它还支持几个新属性
    — `document.hidden` 返回 true 如果标签页不可见，`document.visibilityState` 可能有以下四个值之一：
- en: '`visible`: When the tab page is visible'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`visible`: 当标签页可见时'
- en: '`hidden`: When the tag page is hidden'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hidden`: 当标签页被隐藏时'
- en: '`prerender`: The page is being rendered but not yet visible (browser support
    is optional)'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prerender`: 页面正在呈现但尚未可见（浏览器支持是可选的）'
- en: '`unloaded`: The page is being unloaded from memory (browser support is optional)'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unloaded`: 页面正在从内存中卸载（浏览器支持是可选的）'
- en: 'To modify the solution so that the notification only fires when the tabbed
    page is hidden, modify the code to check for `visbilityState`:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改解决方案，以便通知仅在选项卡页面隐藏时触发，请修改代码以检查 `visbilityState`：
- en: '[PRE38]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Before creating the Notification, the code tests to see if the page is hidden.
    If it is, then the Notification is created. If it isn’t, then a message is written
    out to the page instead.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建通知之前，代码会测试页面是否隐藏。如果是，则创建通知。如果不是，则在页面上写入一条消息。
- en: Loading a File Locally in the Browser
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在浏览器中本地加载文件
- en: Problem
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to open an image file and output the metadata in the browser.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要在浏览器中打开图像文件并输出元数据。
- en: Solution
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use the File API:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 使用文件 API：
- en: '[PRE39]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Discussion
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The File API bolts onto the existing input element `file` type, used for file
    uploading. In addition to the capability of uploading the file to the server via
    a form upload, you can now access the file directly in JavaScript, and either
    work with it locally or upload the file to a server.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 API 添加到现有的 `file` 类型输入元素中，用于文件上传。除了通过表单上传将文件上传到服务器的功能外，现在还可以直接在 JavaScript
    中访问文件，可以在本地处理文件，或者将文件上传到服务器。
- en: Note
  id: totrans-293
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: For more on `FileReader`, check out MDN’s [page on the API](http://mzl.la/1ya0o1k),
    and a [related tutorial](http://mzl.la/1ya0qGs).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多关于 `FileReader` 的内容，请查看 MDN 的 [API 页面](http://mzl.la/1ya0o1k)，以及一个 [相关教程](http://mzl.la/1ya0qGs)。
- en: 'There are three objects in the File API:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 API 中有三个对象：
- en: '`FileList`'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileList`'
- en: A list of files to upload via `input type="file"`
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 一个通过 `input type="file"` 上传文件的文件列表
- en: '`File`'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`File`'
- en: Information about a specific file
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 关于特定文件的信息
- en: '`FileReader`'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileReader`'
- en: Object to asynchronously upload the file for client-side access
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 对象用于异步上传客户端访问的文件
- en: Each object has associated properties and events, including being able to track
    the progress of a file upload (and provide a custom progress bar), as well as
    signaling when the upload is finished. The `File` object can provide information
    about the file, including the filename, size, and MIME type. The `FileList` object
    provides a list of `File` objects, because more than one file can be specified
    if the input element has the `multiple` attribute set. The `FileReader` is the
    object that does the actual file upload.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象都有关联的属性和事件，包括能够跟踪文件上传的进度（并提供自定义进度条），以及在上传完成时发出信号。`File` 对象可以提供有关文件的信息，包括文件名、大小和
    MIME 类型。`FileList` 对象提供一个 `File` 对象列表，如果输入元素具有设置 `multiple` 属性，则可以指定多个文件。`FileReader`
    是执行实际文件上传的对象。
- en: '[Example 16-3](#loading_an_image) shows an application that uploads an image,
    embeds it in the web page, and displays some information about the image. The
    result is shown in [Figure 16-7](#using_the_files_api_to_read_a_chapter_of).'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 16-3](#loading_an_image) 展示了一个上传图像、将其嵌入网页并显示有关图像的信息的应用程序。结果显示在 [图 16-7](#using_the_files_api_to_read_a_chapter_of)
    中。'
- en: Example 16-3\. Loading an image and metadata
  id: totrans-304
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 16-3\. 加载图像和元数据
- en: '[PRE40]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '![jsc3 1607](assets/jsc3_1607.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![jsc3 1607](assets/jsc3_1607.png)'
- en: Figure 16-7\. Using the File API to read an image
  id: totrans-307
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 16-7\. 使用文件 API 读取图像
- en: Note
  id: totrans-308
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The File API is a W3C effort. For more information, you can read the [latest
    draft](http://.w3.org/TR/FileAPI) or [Mozilla’s coverage](http://mzl.la/1ya0qGs).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 API 是 W3C 的一项工作。欲了解更多信息，您可以阅读 [最新草案](http://.w3.org/TR/FileAPI) 或 [Mozilla
    的相关报道](http://mzl.la/1ya0qGs)。
- en: Extending the Possible with Web Components
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 Web 组件扩展可能性
- en: Problem
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need a component that encapsulates a specific look, feel, and behavior,
    and that you can include as easily as you’d include an HTML element, but don’t
    want to use a web framework.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个封装了特定外观、感觉和行为的组件，您可以像包含 HTML 元素一样轻松地包含它，但不希望使用 Web 框架。
- en: Solution
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Consider Web Components, which allow you to create custom and reusable HTML
    elements. Web Components consist of a Template, custom elements, and shadow DOM.
    Each will be covered in the discussion.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑 Web 组件，它允许您创建自定义且可重用的 HTML 元素。Web 组件包括模板、自定义元素和影子 DOM。每个都将在讨论中进行介绍。
- en: Discussion
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Think of a web page widget that’s completely self-contained and you have some
    resemblance to Web Components, but only in the most shallow sense. Web Components,
    as a term, encompasses several different constructs. In the following sections,
    I’ll cover each, provide examples, discuss polyfills, and what to expect in the
    future.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个完全自包含的网页小部件，并且它与 Web 组件有些相似，但仅限于表面上的相似性。作为术语，Web 组件涵盖了几种不同的构造。在接下来的章节中，我将介绍每一个，提供示例，讨论
    polyfill，并展望未来。
- en: HTML templates
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTML 模板
- en: The `template` element is now part of the HTML5 specification. Currently it’s
    [supported in most modern browsers](https://oreil.ly/SJZDC). Within the `template`
    element, we include HTML that we want to group as a whole that isn’t instantiated
    until it is *cloned*. It is parsed when loaded, to ensure it’s valid, but it doesn’t
    exist. Yet.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`template` 元素现在是 HTML5 规范的一部分。目前在大多数现代浏览器中有[支持](https://oreil.ly/SJZDC)。在 `template`
    元素内部，我们包含希望作为整体分组的 HTML 内容，直到被*克隆*之前都不会被实例化。它在加载时被解析以确保有效性，但实际上并不存在。但是。'
- en: 'Working with templates is very intuitive. Consider a common practice with today’s
    single-page JavaScript applications: taking returned data from a web service and
    formatting it as an unordered list (`ul`) (or new paragraph, or table, or whatever).
    Typically, we’d use the DOM methods to query for the existing `ul` element, create
    each list item (`li`) in the list, append text to the item, and append the item
    to the list.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模板非常直观。考虑今天的单页面 JavaScript 应用程序的常见做法：从 web 服务返回数据并将其格式化为无序列表 (`ul`)（或新段落、表格等）。通常，我们会使用
    DOM 方法查询现有的 `ul` 元素，为列表中的每个列表项 (`li`) 创建，向项目添加文本，然后将项目附加到列表中。
- en: 'What if we could cut out some of the steps? We could with the `template`. Given
    the following HTML:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够省略一些步骤会怎么样？我们可以使用 `template`。考虑以下 HTML：
- en: '[PRE41]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This is the JavaScript to add our “Hello World” template to a page:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将我们的“Hello World”模板添加到页面的 JavaScript：
- en: '[PRE42]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the example we access the `template` element, access the HTML element’s content,
    and then append it to the HTML document using `appendChild()`. As I noted, templates
    are very intuitive, but you might be wondering, what’s the point? All we’ve done
    is add more code for a process that’s already simple, but templates are important
    for their use in Custom Elements, discussed in [“Custom elements”](#custom_elements),
    as well as the [“Shadow DOM”](#shadow_dom).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我们访问 `template` 元素，访问 HTML 元素的内容，然后使用 `appendChild()` 将其附加到 HTML 文档中。正如我所指出的，模板非常直观，但您可能会想知道，它的意义何在？我们所做的只是为一个已经很简单的过程增加了更多代码，但模板在自定义元素中的使用是非常重要的，详见[“自定义元素”](#custom_elements)和[“影子
    DOM”](#shadow_dom)。
- en: Custom elements
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义元素
- en: 'The Web Components construct that has generated the most interest is the custom
    element. Instead of having to deal with existing HTML elements and their default
    behaviors and appearance, we create a custom element, package in its styling and
    behavior, and just attach it to the web page. A custom element can either extend
    an existing element or be “autonomous,” meaning it is a completely new element.
    In the following example, I will extend the HTML `<p>` element to create a new
    element named `<hello-world>`. To do so, I will first need to define a class with
    any special methods for the element:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: Web 组件构造中引起最大兴趣的是自定义元素。与处理现有 HTML 元素及其默认行为和外观不同，我们创建一个自定义元素，打包其样式和行为，然后将其附加到网页上。自定义元素可以扩展现有元素，也可以是“自主”的，意味着它是一个全新的元素。在下面的示例中，我将扩展
    HTML `<p>` 元素以创建一个名为 `<hello-world>` 的新元素。为此，我首先需要定义一个包含任何特殊方法的类：
- en: '[PRE43]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Once the class is defined, I can register my element. Note that the element
    name must contain a hyphen to avoid any potential conflicts with existing HTML
    elements:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦类被定义，我就可以注册我的元素。请注意，元素名称必须包含连字符以避免与现有 HTML 元素可能的冲突：
- en: '[PRE44]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now I can use my element in my HTML page:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我可以在我的 HTML 页面中使用我的元素：
- en: '[PRE45]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Shadow DOM
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 影子 DOM
- en: I can’t see *shadow DOM* without thinking of the fictional character “The Shadow.”
    What a great character, and appropriate, too. Only The Shadow knew what evil lurked
    in the minds of men, and only the shadow DOM knows what lurks in its element’s
    DOM.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 当我提到 *shadow DOM* 时，脑海中不禁浮现了虚构人物 “The Shadow”。多么伟大的角色，而且也很合适。只有阴影知道人们心中的邪恶，只有
    shadow DOM 知道其元素 DOM 中隐藏了什么。
- en: Dragging ourselves away from fictional distraction, the shadow DOM is the most
    twisty of the Web Components. But intriguing, too.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 摆脱虚构的干扰，影子 DOM 是 Web 组件中最复杂的部分。但也同样引人入胜。
- en: 'First, the nonmysterious bits. The shadow DOM is a DOM, a tree of nodes just
    like we’re used to when we access elements from the `document` element. The primary
    difference is that it doesn’t exist, not in a way we know a DOM existing. When
    we create a *shadow root* of an element, then it comes into existence. But then,
    whatever the element used to have, is gone. That’s the key to remember about the
    shadow DOM: creating it replaces the element’s existing DOM.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，非神秘的部分。影子 DOM 是一个 DOM，一个节点树，就像我们从 `document` 元素访问元素时一样。主要区别在于它不存在，不像我们知道
    DOM 存在的方式。当我们为一个元素创建 *影子根* 时，它就存在了。但是，元素以前拥有的任何东西都不见了。这就是要记住的关键：创建它会替换元素的现有 DOM。
- en: 'By using the `attachShadow` method, you can attach a shadow root to any element:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `attachShadow` 方法，你可以将影子根附加到任何元素上：
- en: '[PRE46]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `attachShadow` method takes one parameter (`mode`), which accepts a value
    of either `open` or `closed`. Setting the value to `open` allows you to access
    the shadow DOM in the context of the page, like any other element. The most common
    shadow DOM use case is attaching a shadow DOM to a custom element as part of its
    constructor:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`attachShadow` 方法接受一个参数（`mode`），可以接受值`open`或`closed`。将值设置为`open`允许你在页面上下文中访问影子
    DOM，就像访问任何其他元素一样。最常见的影子 DOM 使用场景是作为构造函数的一部分将影子 DOM 附加到自定义元素上：'
- en: '[PRE47]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Though the above example contains two HTML elements, global CSS styles will
    not apply to a shadow DOM element. To style a custom element with a shadow DOM,
    we would create a style element within the custom element class and apply the
    styles:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管上述示例包含两个 HTML 元素，全局 CSS 样式不会应用于影子 DOM 元素。要为具有影子 DOM 的自定义元素设置样式，我们将在自定义元素类中创建一个样式元素并应用样式：
- en: '[PRE48]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Tip
  id: totrans-342
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: The [Polymer Project](https://oreil.ly/874AX) is a collection of libraries and
    tools for working with web components.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '[Polymer 项目](https://oreil.ly/874AX) 是一组用于处理 Web 组件的库和工具。'
- en: Web components are a very interesting part of the web standards ecosystem with
    great potential. HTML templates, custom HTML elements, and the shadow DOM provide
    a means for creating small, reusable UI components. This idea of lightweight components
    has been reflected in JavaScript libraries such as React and Vue.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: Web 组件是 Web 标准生态系统中非常有趣的一部分，具有巨大潜力。HTML 模板、自定义 HTML 元素和影子 DOM 提供了一种创建小型、可重用
    UI 组件的方法。这种轻量级组件的理念已经反映在诸如 React 和 Vue 等 JavaScript 库中。
- en: Choosing a Front-End Framework
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择前端框架
- en: Problem
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You are building a complex web application that requires a JavaScript framework.
    How do you choose the right framework?
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在构建一个复杂的 Web 应用程序，需要一个 JavaScript 框架。如何选择合适的框架？
- en: Solution
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'There was a time when JavaScript frameworks seemingly came in and out of style
    faster than a fashion week runway. Thankfully, over the past few years the framework
    wars have slowed down and we have been left with a handful of excellent choices.
    Despite the slowdown of new development, it can still be challenging to choose
    the best framework for you and your project. When evaluating frameworks for a
    project, I recommend asking yourself the following questions:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经有一段时间，JavaScript 框架似乎比时装周的时尚风更快速地进入并退出流行。幸运的是，在过去几年中，框架之战已经减缓，留下了一些优秀的选择。尽管新开发的速度放缓，但为你和你的项目选择最佳框架仍然是具有挑战性的。在评估项目的框架时，我建议你问自己以下几个问题：
- en: Do I need a JavaScript framework?
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我是否需要一个 JavaScript 框架？
- en: Don’t always reach for a framework by default. Oftentimes, simple sites and
    applications may be easier to write and maintain without a framework, while being
    more performant for a user.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 不要默认情况下总是使用框架。通常情况下，简单的网站和应用程序可能更容易编写和维护，同时对用户来说更具性能。
- en: What is the type of project I’ll be developing?
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我将开发什么类型的项目？
- en: Is this a personal project? A project for a client? An enterprise project with
    long-term support needs? An open source project? Consider the maintainers of your
    project and what will best meet their needs.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个个人项目吗？是客户项目吗？是需要长期支持的企业项目吗？还是开源项目？考虑项目的维护者以及什么样的框架最能满足他们的需求。
- en: What is the level of community adoption and the longevity of the project?
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 社区采用水平和项目的长期性如何？
- en: Consider the long-term support of the framework. Is it still an active project?
    Will it be supported by a large community to answer questions and fix bugs?
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑框架的长期支持情况。它仍然是一个活跃的项目吗？是否有一个大社区支持来回答问题和修复错误？
- en: How well documented is the framework?
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 框架的文档编写得有多好？
- en: Ensure that the documentation is easy to understand and complete.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 确保文档易于理解和完整。
- en: What does the developer ecosystem for the framework look like?
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 框架的开发者生态系统如何？
- en: Evaluate the tooling, plug-ins, and metaframeworks.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 评估工具、插件和元框架。
- en: Am I familiar with the framework?
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我是否熟悉这个框架？
- en: Is the framework something that you already know or have familiarity with or
    is this a learning project?
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 框架是您已经了解或熟悉的内容，还是一个学习项目？
- en: What will be the impact on my users?
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我的用户有什么影响？
- en: Perhaps the most important question of all. Determine if a framework will impact
    the performance, accessibility, or usability of your project.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 或许最重要的问题。确定一个框架是否会影响您项目的性能、可访问性或可用性。
- en: 'While this is far from an exhaustive list, the authors of this book recommend
    looking at the following frameworks: React, Vue, Svelte, and Angular.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这远非详尽列表，但本书的作者建议查看以下框架：React、Vue、Svelte和Angular。
- en: React
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React
- en: '[React](https://reactjs.org) is a UI-driven JavaScript framework developed
    and released by Facebook. React focuses on small visual components and commonly
    makes use of `jsx`, an XML syntax within JavaScript for rendering HTML components.
    React makes updates to the page more efficient by using a representation of the
    DOM, referred to as the [virtual DOM](https://oreil.ly/oK21x).'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '[React](https://reactjs.org)是由Facebook开发和发布的UI驱动的JavaScript框架。React专注于小型视觉组件，并通常使用`jsx`，这是JavaScript中的XML语法，用于渲染HTML组件。React通过使用称为[virtual
    DOM](https://oreil.ly/oK21x)的DOM表示来使页面更新更有效率。'
- en: Vue
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Vue
- en: '[Vue](https://vuejs.org) is a community-focused, UI-driven framework. Like
    React, Vue makes use of a virtual DOM to make page updates instantaneous. Many
    view Vue as an alternative to React. The feature set is similar, but Vue makes
    use of a more HTML-friendly template syntax and is community backed, rather than
    supported by Facebook. I’d recommend giving both React and Vue a spin to see which
    best matches you and your team’s development style.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '[Vue](https://vuejs.org)是一个面向社区的、UI驱动的框架。与React类似，Vue利用虚拟DOM使页面更新即时化。许多人将Vue视为React的替代品。功能集类似，但Vue使用更友好的HTML模板语法，并且由社区支持，而不是由Facebook支持。我建议试试React和Vue，看看哪个更符合您和您团队的开发风格。'
- en: Svelte
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Svelte
- en: '[Svelte](https://svelte.dev) takes a different approach from the other JS frameworks
    here. Similar to React and Vue, it is a UI-focused library, but rather than doing
    the bulk of the work in the user’s browser, Svelte focuses on a compile step at
    development build time. The goal is to limit the tax on the user’s browser so
    that developers can build performant applications.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '[Svelte](https://svelte.dev)与这里的其他JS框架采取了不同的方法。类似于React和Vue，它是一个UI-focused库，但与其在用户浏览器中执行大部分工作不同，Svelte侧重于在开发构建时进行编译步骤。其目标是减少用户浏览器的负担，以便开发人员可以构建高性能的应用程序。'
- en: Angular
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular
- en: '[Angular](https://angular.io) is a full-featured JavaScript framework, developed
    and released by Google. Angular survived the first wave of “framework” wars and
    has adapted to a component-based architecture that is similar to modern libraries.
    Unlike React, Vue, and Svelte, Angular is a fully featured framework out of the
    box, with in-app navigation, data and state management, and testing built into
    the framework. For many, particularly enterprise-focused teams, this can be a
    useful feature as it limits decision making when building new applications or
    adding features.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '[Angular](https://angular.io)是由Google开发和发布的功能齐全的JavaScript框架。Angular在第一波“框架”战争中生存下来，并适应了类似于现代库的基于组件的架构。与React、Vue和Svelte不同，Angular是一个开箱即用的完整框架，具有应用内导航、数据和状态管理以及内置测试等功能。对于许多企业专注的团队来说，这是一个有用的功能，因为在构建新应用程序或添加功能时可以限制决策。'
