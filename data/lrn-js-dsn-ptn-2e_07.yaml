- en: Chapter 7\. JavaScript Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 JavaScript设计模式
- en: The previous chapter provided examples of the three different categories of
    design patterns. Some of these design patterns are relevant or required in the
    web development context. I have identified a few timeless patterns that can be
    helpful when applied in JavaScript. This chapter explores JavaScript implementations
    of different classic and modern design patterns. Every section is dedicated to
    one of the three categories—creational, structural, and behavioral. Let us begin
    with creational patterns.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章提供了三种不同类别设计模式的示例。其中一些设计模式在Web开发环境中是相关或必需的。我已经确定了一些可以在JavaScript中应用时有所帮助的经典模式。本章探讨了不同经典和现代设计模式的JavaScript实现。每个部分都专注于三个类别之一——创建型、结构型和行为型。让我们从创建型模式开始。
- en: Creational Patterns
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建型模式
- en: 'Creational patterns provide mechanisms to create objects. We will cover the
    following patterns:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 创建型模式提供了创建对象的机制。我们将涵盖以下模式：
- en: '[“The Constructor Pattern”](#the-constructor-pattern)'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“构造函数模式”](#the-constructor-pattern)'
- en: '[“The Module Pattern”](#the-module-pattern)'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“模块模式”](#the-module-pattern)'
- en: '[“The Revealing Module Pattern”](#the-revealing-module-pattern)'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“揭示模块模式”](#the-revealing-module-pattern)'
- en: '[“The Singleton Pattern”](#the-singleton-pattern)'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“单例模式”](#the-singleton-pattern)'
- en: '[“The Prototype Pattern”](#the-prototype-pattern)'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“原型模式”](#the-prototype-pattern)'
- en: '[“The Factory Pattern”](#the-factory-pattern)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“工厂模式”](#the-factory-pattern)'
- en: The Constructor Pattern
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数模式
- en: A constructor is a special method used to initialize a newly created object
    once the memory has been allocated for it. With ES2015+, the syntax for creating
    [classes](https://oreil.ly/TjEI1) with constructors was introduced to JavaScript.
    This enables the creation of objects as an instance of a class using the default
    [constructor](https://oreil.ly/zNmUI).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数是一种特殊的方法，用于在为其分配内存后初始化新创建的对象。使用ES2015+，引入了使用构造函数创建[类](https://oreil.ly/TjEI1)的语法到JavaScript中。这使得可以使用默认的[构造函数](https://oreil.ly/zNmUI)将对象创建为类的实例。
- en: In JavaScript, almost everything is an object, and classes are syntactic sugar
    for JavaScript’s prototypal approach to inheritance. With classic JavaScript,
    we were most often interested in object constructors. [Figure 7-1](#constructor_pattern)
    illustrates the pattern.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，几乎所有东西都是对象，而类只是JavaScript原型继承的语法糖。在经典JavaScript中，我们通常对对象构造函数感兴趣。[图7-1](#constructor_pattern)说明了这种模式。
- en: Note
  id: totrans-13
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Object constructors are used to create specific types of objects—both preparing
    the object for use and accepting arguments to set the values of member properties
    and methods when the object is first created.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对象构造函数用于创建特定类型的对象——为对象准备并在对象首次创建时接受参数以设置成员属性和方法的值。
- en: '![ljd2 0701](Images/ljd2_0701.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![ljd2 0701](Images/ljd2_0701.png)'
- en: Figure 7-1\. Constructor pattern
  id: totrans-16
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-1 构造函数模式
- en: Object Creation
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象创建
- en: 'The three common ways to create new objects in JavaScript are as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中创建新对象的三种常见方法如下：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we have declared each object as a constant, which creates a read-only
    block-scoped variable. In the final example, the `Object` constructor creates
    an object wrapper for a specific value, or where no value is passed, it creates
    an empty object and returns it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将每个对象声明为常量，这将创建一个只读的块级作用域变量。在最后一个示例中，`Object`构造函数为特定值创建一个对象包装器，或者在不传递值的情况下，它创建一个空对象并返回它。
- en: 'You can now assign keys and values to an object in the following ways:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以通过以下方式为对象分配键和值：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can even use these methods for inheritance as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以将这些方法用于继承，如下所示：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Basic Constructors
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本构造函数
- en: As discussed earlier in [Chapter 5](ch05.xhtml#modern-javascript-syntax), JavaScript
    classes were introduced in ES2015, allowing us to define templates for JavaScript
    objects and implement encapsulation and [inheritance](https://oreil.ly/VjSbn)
    using JavaScript.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[第5章](ch05.xhtml#modern-javascript-syntax)中讨论的，JavaScript类在ES2015中引入，允许我们为JavaScript对象定义模板并使用JavaScript实现封装和[继承](https://oreil.ly/VjSbn)。
- en: 'To recap, classes must include and declare a method named `constructor()`,
    which will be used to instantiate a new object. The keyword `new` allows us to
    call the constructor. The keyword `this` inside a constructor references the new
    object created. The following example shows a basic constructor:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，类必须包含并声明一个名为`constructor()`的方法，该方法将用于实例化一个新对象。关键字`new`允许我们调用构造函数。构造函数内部的关键字`this`引用创建的新对象。以下示例显示了一个基本构造函数：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is a simple version of the Constructor pattern but it suffers from some
    problems. One is that it makes inheritance difficult, and the other is that functions
    such as `toString()` are redefined for each new object created using the `Car`
    constructor. This isn’t optimal because all of the instances of the `Car` type
    should ideally share the same function.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是构造函数模式的一个简单版本，但存在一些问题。其中一个问题是它使得继承困难，另一个是像`toString()`这样的函数会为每个使用`Car`构造函数创建的新对象重新定义。这并不理想，因为`Car`类型的所有实例理想情况下应共享相同的函数。
- en: Constructors with Prototypes
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带原型的构造函数
- en: 'Prototypes in JavaScript allow you to easily define methods for all instances
    of a particular object, be it a function or a class. When we call a JavaScript
    constructor to create an object, all the properties of the constructor’s prototype
    are then made available to the new object. In this fashion, you can have multiple
    `Car` objects that access the same prototype. We can thus extend the original
    example as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 中的原型允许您轻松地为特定对象的所有实例定义方法，无论是函数还是类。当我们调用 JavaScript 构造函数来创建对象时，构造函数原型的所有属性都将对新对象可用。通过这种方式，可以拥有访问相同原型的多个`Car`对象。因此，可以扩展原始示例如下：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: All `Car` objects will now share a single instance of the `toString()` method.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 所有`Car`对象现在都共享一个`toString()`方法的实例。
- en: The Module Pattern
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块模式
- en: Modules are an integral piece of any robust application’s architecture and typically
    help keep the units of code for a project cleanly separated and organized.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是任何健壮应用架构的一个重要部分，通常有助于保持项目代码单元的清晰分离和组织。
- en: 'Classic JavaScript had several options for implementing modules, such as:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 经典 JavaScript 有几种实现模块的选项，例如：
- en: Object literal notation
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象字面量表示法
- en: The Module pattern
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块模式
- en: AMD modules
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AMD 模块
- en: CommonJS modules
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CommonJS 模块
- en: We have already discussed modern JavaScript modules (also known as “ES modules”
    or “ECMAScript modules”) in [Chapter 5](ch05.xhtml#modern-javascript-syntax).
    We will primarily use ES modules for the examples in this section.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第5章](ch05.xhtml#modern-javascript-syntax)中讨论了现代 JavaScript 模块（也称为“ES模块”或“ECMAScript模块”）。本节的示例将主要使用ES模块。
- en: Before ES2015, CommonJS modules or AMD modules were popular alternatives because
    they allowed you to export the contents of a module. We will be exploring AMD,
    CommonJS, and UMD modules later in the book in [Chapter 10](ch10.xhtml#modern-modular-javascript-design-patterns).
    First, let us understand the Module pattern and its origins.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES2015 之前，CommonJS 模块或 AMD 模块是流行的替代方案，因为它们允许你导出模块的内容。我们将在本书的[第10章](ch10.xhtml#modern-modular-javascript-design-patterns)中探讨
    AMD、CommonJS 和 UMD 模块。首先，让我们了解模块模式及其起源。
- en: The Module pattern is based partly on object literals, so it makes sense to
    refresh our knowledge of them first.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 模块模式部分基于对象字面量，因此最好先刷新我们对它们的了解。
- en: Object Literals
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象字面量
- en: 'In object literal notation, an object is described as a set of comma-separated
    name/value pairs enclosed in curly braces (`{}`). Names inside the object may
    be either strings or identifiers followed by a colon. It would be best if you
    did not use a comma after the final name/value pair in the object, as this may
    result in errors:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象字面量表示法中，对象被描述为一组逗号分隔的名称/值对，这些对被大括号（`{}`）括起来。对象内部的名称可以是字符串或标识符，后跟冒号。不应在对象的最后一个名称/值对之后使用逗号，因为这可能导致错误：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Object literals don’t require instantiation using the `new` operator but shouldn’t
    be used at the start of a statement because the opening `{` may be interpreted
    as the beginning of a new block. Outside of an object, new members may be added
    to it using the assignment as follows `myModule.property = "someValue";`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对象字面量不需要使用`new`运算符进行实例化，但不应在语句开头使用，因为开头的`{`可能被解释为新块的开始。在对象之外，可以使用赋值来向其添加新成员，如下所示：`myModule.property
    = "someValue";`。
- en: 'Here is a complete example of a module defined using object literal notation:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用对象字面量定义的模块的完整示例：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Using object literals provided a way to encapsulate and organize code. Rebecca
    Murphey has written about this topic in [depth](https://oreil.ly/rAYcw) should
    you wish to read into object literals further.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用对象字面量提供了一种封装和组织代码的方式。Rebecca Murphey已经深入探讨了这个主题，如果你希望进一步了解对象字面量，可以阅读[深入](https://oreil.ly/rAYcw)。
- en: The Module Pattern
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块模式
- en: The Module pattern was initially defined to provide private and public encapsulation
    for classes in conventional software engineering.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 模块模式最初被定义为为传统软件工程中的类提供私有和公共封装。
- en: At one point, organizing a JavaScript application of any reasonable size was
    a challenge. Developers would rely on separate scripts to split and manage reusable
    chunks of logic, and it wasn’t surprising to find 10 to 20 scripts being imported
    manually in an HTML file to keep things tidy. Using objects, the Module pattern
    was just one way to encapsulate logic in a file with both public and “private”
    methods. Over time, several custom module systems came about to make this smoother.
    Now, developers can use JavaScript modules to organize objects, functions, classes,
    or variables such that they can be easily exported or imported into other files.
    This helps prevent conflicts between classes or function names included in different
    modules. [Figure 7-2](#module) illustrates the Module pattern.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经，在JavaScript应用程序中组织任何合理大小的问题是一种挑战。开发者会依赖于单独的脚本来分割和管理可重用的逻辑块，不足为奇的是，在HTML文件中手动导入10到20个脚本来保持整洁。使用对象，模块模式只是一种在文件中封装逻辑的方法，包括公共和“私有”方法。随着时间的推移，出现了几种自定义模块系统，使这一过程更加顺畅。现在，开发者可以使用JavaScript模块来组织对象、函数、类或变量，使它们可以轻松地导出或导入到其他文件中。这有助于防止在不同模块中包含的类或函数名称之间的冲突。[图7-2](#module)说明了模块模式。
- en: '![ljd2 0702](Images/ljd2_0702.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![ljd2 0702](Images/ljd2_0702.png)'
- en: Figure 7-2\. Module pattern
  id: totrans-55
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-2\. 模块模式
- en: Privacy
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 私有性
- en: The Module pattern encapsulates the “privacy” state and organization using closures.
    It provides a way of wrapping a mix of public and private methods and variables,
    protecting pieces from leaking into the global scope and accidentally colliding
    with another developer’s interface. With this pattern, you expose only the public
    API, keeping everything else within the closure private.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 模块模式通过闭包封装了“私有性”状态和组织。它提供了一种包装公共和私有方法和变量的方式，保护这些部分不会泄漏到全局范围，并意外地与另一个开发者的接口冲突。使用这种模式，你只暴露出公共API，将其他所有内容保持在闭包内部。
- en: This gives us a clean solution where the shielding logic does the heavy lifting
    while we expose only an interface we wish other parts of our application to use.
    The pattern uses an [immediately invoked function expression (IIFE)](https://oreil.ly/5gef1)
    where an object is returned. See [Chapter 11](ch11.xhtml#namespacing-patterns)
    for more on IIFEs.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了一个干净的解决方案，其中屏蔽逻辑承担了大部分工作，而我们只暴露出我们希望应用程序其他部分使用的接口。该模式使用了一个[立即调用的函数表达式（IIFE）](https://oreil.ly/5gef1)，其中返回了一个对象。详情请参阅[第11章](ch11.xhtml#namespacing-patterns)关于IIFE的更多信息。
- en: Note that there isn’t an explicitly true sense of “privacy” inside JavaScript
    because it doesn’t have access modifiers, unlike some traditional languages. You
    can’t technically declare variables as public or private, so we use function scope
    to simulate this concept. Within the Module pattern, variables or methods declared
    are available only inside the module itself, thanks to closure. However, variables
    or methods defined within the returning object are available to everyone.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，JavaScript内部没有显式的“私有性”概念，因为它没有像一些传统语言那样的访问修饰符。在技术上，你不能声明变量为公共或私有，因此我们使用函数作用域来模拟这个概念。在模块模式中，只有在模块内部声明的变量或方法才可用，这要归功于闭包。然而，在返回对象中定义的变量或方法对所有人都是可用的。
- en: A workaround to implement privacy of variables in returned objects uses [`WeakMap()`](https://oreil.ly/SmKvK)
    discussed later in this chapter in [“Modern Module Pattern with WeakMap”](#ModernModulePattern_WeakMap).
    `WeakMap()` takes only objects as keys and cannot be iterated. Thus, the only
    way to access the object inside a module is through its reference. Outside the
    module, you can access it only through a public method defined within it. Thus,
    it ensures privacy for the object.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 实现返回对象中变量的私有性的一种解决方法使用了[`WeakMap()`](https://oreil.ly/SmKvK)，本章稍后在[“带有WeakMap的现代模块模式”](#ModernModulePattern_WeakMap)中讨论。`WeakMap()`只接受对象作为键，并且不能被迭代。因此，在模块内部，唯一访问对象的方式是通过它的引用。在模块外部，只能通过其中定义的公共方法访问它。因此，它确保了对象的私有性。
- en: History
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 历史
- en: From a historical perspective, the Module pattern was originally developed in
    2003 by several people, including [Richard Cornford](https://oreil.ly/YTZeM).
    Douglas Crockford later popularized it in his lectures. Another piece of trivia
    is that some of its features may appear quite familiar if you’ve ever played with
    Yahoo’s YUI library. The reason for this is that the Module pattern was a strong
    influence on YUI when its components were created.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史的角度来看，模块模式最初是在2003年由几个人开发的，其中包括[理查德·康福德](https://oreil.ly/YTZeM)。后来，道格拉斯·克罗克福德在他的讲座中将其推广开来。另一个趣闻是，如果您曾经玩过雅虎的YUI库，模块模式的一些特性可能会让您感到非常熟悉。原因是在YUI创建其组件时，模块模式对其产生了很大的影响。
- en: Examples
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例
- en: 'Let’s begin looking at implementing the Module pattern by creating a self-contained
    module. We use the `import` and `export` keywords in our implementation. To recap
    our previous discussion, `export` allows you to provide access to module features
    outside the module. At the same time, `import` enables us to import bindings exported
    by a module to our script:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始通过创建一个自包含模块来实现模块模式。在我们的实现中，我们使用`import`和`export`关键字。回顾我们之前的讨论，`export`允许您在模块外部提供对模块功能的访问。同时，`import`使我们能够将模块导出的绑定导入到我们的脚本中：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, the other parts of the code cannot directly read the value of our `incrementCounter()`
    or `resetCounter()`. The `counter` variable is entirely shielded from our global
    scope, so it acts just like a private variable would—its existence is limited
    to within the module’s closure so that the two functions are the only code able
    to access its scope. Our methods are effectively namespaced, so in the test section
    of our code, we need to prefix any calls with the module’s name (e.g., `testModule`).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，代码的其他部分不能直接读取我们的`incrementCounter()`或`resetCounter()`的值。`counter`变量完全被屏蔽在我们的全局作用域之外，因此它的行为就像一个私有变量一样——它的存在仅限于模块的闭包内部，因此只有这两个函数能够访问它的作用域。我们的方法在效果上是命名空间化的，因此在代码的测试部分，我们需要用模块的名称作为前缀来调用任何函数（例如`testModule`）。
- en: 'When working with the Module pattern, we may find it helpful to define a simple
    template we can use to get started with it. Here’s one that covers namespacing,
    public, and private variables:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用模块模式时，定义一个简单的模板可能会有所帮助，以便我们可以用它来开始使用。以下是一个涵盖命名空间、公共和私有变量的示例：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'What follows is another example, where we can see a shopping basket implemented
    using this pattern. The module itself is completely self-contained in a global
    variable called `basketModule`. The `basket` array in the module is kept private,
    so other parts of our application cannot directly read it. It exists only within
    the module’s closure, and so the only methods able to access it are those with
    access to its scope (i.e., `addItem()`, `getItem()`, etc.):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是另一个示例，我们可以看到使用这种模式实现的购物篮。模块本身完全包含在名为`basketModule`的全局变量中。模块中的`basket`数组被保持私有，因此我们应用程序的其他部分无法直接读取它。它仅存在于模块的闭包内部，因此能够访问它的唯一方法是那些能够访问其作用域的方法（即`addItem()`、`getItem()`等）：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Inside the module, you may have noticed that we return an `object`. This gets
    automatically assigned to `basketModule` so that we can interact with it as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块内部，您可能已经注意到我们返回一个`object`。这会自动分配给`basketModule`，以便我们可以像下面这样与其交互：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'These methods are effectively namespaced inside `basketModule`. All our functions
    are wrapped in this module, giving us several advantages, such as:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法在`basketModule`内部有效地命名空间化。我们所有的函数都被封装在这个模块中，给我们带来了几个优势，比如：
- en: The freedom to have private functions that can be consumed only by our module.
    They aren’t exposed to the rest of the page (only our exported API is), so they’re
    considered truly private.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有可以被我们的模块专门使用的私有函数的自由。它们不会暴露给页面的其他部分（只有我们导出的 API 可以），因此它们被认为是真正私有的。
- en: Given that functions are usually declared and named, it can be easier to show
    call stacks in a debugger when we’re attempting to discover what function(s) threw
    an exception.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鉴于函数通常是声明和命名的，当我们尝试查找引发异常的函数时，在调试器中显示调用堆栈可能会更容易。
- en: Module Pattern Variations
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块模式的变体
- en: Over time, designers have introduced different variations of the Module pattern
    suited to their needs.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，设计师们为满足他们的需求，引入了不同的模块模式变体。
- en: Import Mixins
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导入混合
- en: 'This pattern variation demonstrates how you can pass globals (e.g., utility
    functions or external libraries) as arguments to a higher-order function in a
    module. This effectively allows us to import and locally alias them as we wish:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式变体演示了如何将全局变量（例如实用函数或外部库）作为参数传递给模块中的高阶函数。这有效地允许我们根据需要导入并本地别名它们：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Exports
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 出口
- en: 'This next variation allows us to declare globals without consuming them and
    could similarly support the concept of global imports seen in the last example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这种变体允许我们声明全局变量而不消耗它们，并且同样支持在上一个示例中看到的全局导入概念：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Advantages
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优点
- en: We’ve seen why the Constructor pattern can be useful, but why is the Module
    pattern a good choice? For starters, it’s a lot cleaner for developers coming
    from an object-oriented background than the idea of true encapsulation, at least
    from a JavaScript perspective. With import Mixins, developers can manage dependencies
    between modules and pass globals as needed, making the code more maintainable
    and modular.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道构造函数模式为什么有用，但为什么模块模式是一个不错的选择呢？首先，对于来自面向对象背景的开发人员来说，它比真正的封装概念要清晰得多，至少从
    JavaScript 的角度来看是这样。通过导入混入，开发人员可以管理模块之间的依赖关系并根据需要传递全局变量，使代码更易于维护和模块化。
- en: 'Secondly, it supports private data—so, in the Module pattern, we have access
    to only the values that we explicitly exported using the `export` keyword. Values
    we didn’t expressly export are private and available only within the module. This
    reduces the risk of accidentally polluting the global scope. You don’t have to
    fear that you will accidentally overwrite values created by developers using your
    module that may have had the same name as your private value: it prevents naming
    collisions and global scope pollution.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，它支持私有数据——因此，在模块模式中，我们只能访问我们使用 `export` 关键字显式导出的值。我们没有明确导出的值是私有的，仅在模块内部可用。这减少了意外污染全局作用域的风险。你不必担心会意外地覆盖由使用你的模块的开发人员创建的具有相同名称的值：它防止了命名冲突和全局作用域污染。
- en: With the Module pattern, we can encapsulate parts of our code that should not
    be publicly exposed. They make working with multiple dependencies and namespaces
    less risky. Note that a transpiler such as Babel is needed to use ES2015 modules
    in all JavaScript runtimes.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模块模式，我们可以封装不应公开的代码部分。这样可以减少处理多个依赖项和命名空间时的风险。请注意，要在所有 JavaScript 运行时中使用 ES2015
    模块，需要像 Babel 这样的转译器。
- en: Disadvantages
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缺点
- en: The disadvantages of the Module pattern are that we access both public and private
    members differently. When we wish to change the visibility, we must make changes
    to each place we use the member.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 模块模式的缺点在于我们以不同方式访问公共和私有成员。当我们希望改变可见性时，我们必须在每个使用成员的地方进行更改。
- en: We also can’t access private members in methods we added to the object later.
    That said, in many cases, the Module pattern is still quite helpful and, when
    used correctly, certainly has the potential to improve the structure of our application.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们后来添加到对象中的方法中也无法访问私有成员。尽管如此，在许多情况下，模块模式仍然非常有帮助，并且在正确使用时肯定有助于改进应用程序的结构。
- en: Other disadvantages include the inability to create automated unit tests for
    private members and additional complexity when bugs require hot fixes. It’s simply
    not possible to patch privates. Instead, one must override all public methods
    interacting with the buggy privates. Developers can’t easily extend privates either,
    so it’s worth remembering that privates are not as flexible as they may initially
    appear.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 其他缺点包括无法为私有成员创建自动化单元测试以及在出现错误时需要热修复时的额外复杂性。无法简单地修复私有成员。相反，必须重写所有与有 bug 的私有成员交互的公共方法。开发人员也不能轻松扩展私有成员，因此值得记住，私有成员并不像它们最初看起来那样灵活。
- en: For further reading on the Module pattern, see Ben Cherry’s excellent in-depth
    [article](https://oreil.ly/wfX1y).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 欲深入了解模块模式，请参阅本·切里的深入[文章](https://oreil.ly/wfX1y)。
- en: Modern Module Pattern with WeakMap
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 WeakMap 的现代模块模式
- en: Introduced to JavaScript in ES6, the [`WeakMap`](https://oreil.ly/SmKvK) object
    is a collection of key-value pairs in which the keys are weakly referenced. The
    keys must be objects, and the values can be arbitrary. The object is essentially
    a map where keys are held weakly. This means that keys will be a target for garbage
    collection (GC) if there is no active reference to the object. Examples [7-1](#basic_module_definition),
    [7-2](#namespaces_publicprivate_variables), and [7-3](#shopping_basket_implementation)
    look at an implementation of the Module pattern that uses the `WeakMap` object.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES6中引入的[`WeakMap`](https://oreil.ly/SmKvK)对象是一种键值对的集合，其中键是弱引用。键必须是对象，而值可以是任意的。该对象本质上是一个映射，其中键是弱引用的。这意味着如果对象没有活动引用，键将成为垃圾收集（GC）的目标。示例[7-1](#basic_module_definition)，[7-2](#namespaces_publicprivate_variables)和[7-3](#shopping_basket_implementation)展示了使用`WeakMap`对象实现的模块模式的实现。
- en: Example 7-1\. Basic module definition
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 7-1\. 基本模块定义
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Example 7-2\. Namespaces with public/private variables
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 7-2\. 公共/私有变量的命名空间
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Example 7-3\. Shopping basket implementation
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 7-3\. 购物篮实现
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Modules with Modern Libraries
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用现代库的模块
- en: 'You can use the Module pattern when building applications with JavaScript libraries
    such as React. Let’s say you have a large number of custom components created
    by your team. In that case, you can separate each component in its own file, essentially
    creating a module for every component. Here is an example of a button component
    customized from the [*material-ui*](https://oreil.ly/77tjD) button component and
    exported as a module:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建使用JavaScript库（如React）的应用程序时，可以使用模块模式。假设您的团队创建了大量自定义组件。在这种情况下，您可以将每个组件分离到自己的文件中，从而实质上为每个组件创建一个模块。以下是从[*material-ui*](https://oreil.ly/77tjD)按钮组件定制的按钮组件的示例，并将其导出为模块：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The Revealing Module Pattern
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 揭示模块模式
- en: 'Now that we are a little more familiar with the Module pattern, let’s look
    at a slightly improved version: Christian Heilmann’s Revealing Module pattern.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对模块模式稍微熟悉一些了，让我们看看稍微改进的版本：Christian Heilmann 的揭示模块模式。
- en: The Revealing Module pattern came about as Heilmann was frustrated that he had
    to repeat the name of the main object when he wanted to call one public method
    from another or access public variables. He also disliked switching to object
    literal notation for the things he wished to make public.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当Heilmann发现在想要从一个公共方法调用另一个方法或访问公共变量时，他必须重复主对象的名称时，揭示模块模式应运而生。他还不喜欢切换到对象字面量表示法来定义希望公开的内容。
- en: His efforts resulted in an updated pattern where we can simply define all functions
    and variables in the private scope and return an anonymous object with pointers
    to the private functionality we wished to reveal as public.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 他的努力导致了更新的模式，我们可以简单地在私有范围内定义所有函数和变量，并返回一个指向我们希望公开的私有功能的匿名对象。
- en: With the modern way of implementing [modules](https://oreil.ly/eMYvs) in ES2015+,
    the scope of functions and variables defined in the module is already private.
    Also, we use `export` and `import` to reveal whatever needs to be revealed.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ES2015+中现代的模块实现方式，模块中定义的函数和变量的作用域已经是私有的。此外，我们使用`export`和`import`来揭示需要揭示的内容。
- en: 'An example of the use of the Revealing Module pattern with ES2015+ is as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ES2015+的揭示模块模式的一个示例如下：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this example, we reveal the private variable `privateVar` through its public
    get and set methods, `publicSetName` and `publicGetName`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们通过其公共的`publicSetName`和`publicGetName`方法揭示私有变量`privateVar`。
- en: 'You can also use the pattern to reveal private functions and properties with
    a more specific naming scheme:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用此模式来揭示具有更具体命名方案的私有函数和属性：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Advantages
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优点
- en: This pattern allows the syntax of our scripts to be more consistent. It also
    makes it easier to understand at the end of the module which of our functions
    and variables may be accessed publicly, which eases readability.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式使我们脚本的语法更加一致。它还使得在模块的结尾更容易理解哪些函数和变量可以被公开访问，从而提高了可读性。
- en: Disadvantages
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缺点
- en: A disadvantage of this pattern is that if a private function refers to a public
    function, that public function can’t be overridden if a patch is necessary. This
    is because the private function will continue to refer to the private implementation,
    and the pattern doesn’t apply to public members, only to functions.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的一个缺点是，如果私有函数引用了公共函数，那么如果需要补丁，就无法覆盖该公共函数。这是因为私有函数将继续引用私有实现，并且该模式不适用于公共成员，只适用于函数。
- en: Public object members, which refer to private variables, are also subject to
    the no-patch rule.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 公共对象成员，它们引用私有变量，也受到无补丁规则的约束。
- en: As a result, modules created with the Revealing Module pattern may be more fragile
    than those created with the original Module pattern, and you should take care
    when using it.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用揭示模块模式创建的模块可能比使用原始模块模式创建的模块更容易受到破坏，您在使用时应当小心。
- en: The Singleton Pattern
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例模式
- en: The Singleton pattern is a design pattern that restricts the instantiation of
    a class to one object. This is useful when exactly one object is needed to coordinate
    actions across the system. Classically, you can implement the Singleton pattern
    by creating a class with a method that creates a new instance of the class only
    if one doesn’t already exist. If an instance already exists, it simply returns
    a reference to that object.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式是一种设计模式，将类的实例化限制为一个对象。当系统中需要精确一个对象来协调动作时，这是非常有用的。传统上，您可以通过创建一个带有创建类实例的方法的类来实现Singleton模式，只有当不存在实例时才创建该类的新实例。如果已经存在一个实例，则简单地返回对该对象的引用。
- en: Singletons differ from static classes (or objects) in that we can delay their
    initialization because they require certain information that may not be available
    during initialization time. Any code that is unaware of a previous reference to
    the Singleton class cannot easily retrieve it. This is because it is neither the
    object nor “class” that a Singleton returns; it’s a structure. Think of how closured
    variables aren’t actually closures—the function scope that provides the closure
    is the closure.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Singleton与静态类（或对象）不同之处在于，我们可以延迟它们的初始化，因为它们需要某些在初始化时可能不可用的信息。任何不知道对Singleton类的先前引用的代码都不能轻松检索它。这是因为Singleton返回的既不是对象也不是“类”；它是一种结构。想象一下闭包变量实际上并不是闭包——提供闭包的函数作用域才是闭包。
- en: ES2015+ allows us to implement the Singleton pattern to create a global instance
    of a JavaScript class that is instantiated once. You can expose the Singleton
    instance through a module export. This makes access to it more explicit and controlled
    and differentiates it from other global variables. You cannot create a new class
    instance but can read/modify the instance using public get and set methods defined
    in the class.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ES2015+允许我们实现单例模式，以创建一个JavaScript类的全局实例，该实例只实例化一次。您可以通过模块导出公开Singleton实例。这使得访问它更加明确和受控，并将其与其他全局变量区分开来。您不能创建一个新的类实例，但可以使用类中定义的公共获取和设置方法来读取/修改实例。
- en: 'We can implement a Singleton as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按以下方式实现单例模式：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'What makes the Singleton is the global access to the instance. The GoF book
    describes the *applicability* of the Singleton pattern as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使Singleton成为Singleton的是对实例的全局访问。GoF书籍描述了Singleton模式的*适用性*如下：
- en: There must be exactly one instance of a class, and it must be accessible to
    clients from a well-known access point.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须有一个类的确切实例，并且客户端必须能够从一个众所周知的访问点访问它。
- en: The sole instance should be extensible by subclassing, and clients should be
    able to use an extended instance without modifying their code.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 唯一的实例应该可以通过子类扩展，并且客户端应该能够在不修改其代码的情况下使用扩展实例。
- en: 'The second of these points refers to a case where we might need code, such
    as:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这些观点中的第二个是指我们可能需要像这样的代码的情况：
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, the `constructor` becomes a little like a Factory method, and we don’t
    need to update each point in our code accessing it. `FooSingleton` (in this example)
    would be a subclass of `BasicSingleton` and implement the same interface.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`constructor`就有点像工厂方法，我们不需要更新代码中访问它的每个点。`FooSingleton`（在这个例子中）将是`BasicSingleton`的子类，并实现相同的接口。
- en: Why is deferring execution considered significant for a Singleton? In C++, it
    serves as isolation from the unpredictability of the dynamic initialization order,
    returning control to the programmer.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么将执行延迟视为Singleton的重要特性？在C++中，它用于隔离动态初始化顺序的不可预测性，将控制权还给程序员。
- en: It is essential to note the difference between a static instance of a class
    (object) and a Singleton. While you can implement a Singleton as a static instance,
    it can also be constructed lazily, without the need for resources or memory until
    it is needed.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意类（对象）的静态实例与单例之间的区别。虽然可以将单例实现为静态实例，但也可以懒惰地构造它，直到需要资源或内存为止。
- en: Suppose we have a static object that we can initialize directly. In that case,
    we need to ensure the code is always executed in the same order (e.g., in case
    `objCar` needs `objWheel` during its initialization), and this doesn’t scale when
    you have a large number of source files.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个可以直接初始化的静态对象。在这种情况下，我们需要确保代码总是以相同的顺序执行（例如，在初始化过程中 `objCar` 需要 `objWheel`），而当你有大量源文件时，这种方法不具有可扩展性。
- en: Both Singletons and static objects are useful but shouldn’t be overused—the
    same way we shouldn’t overuse other patterns.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 单例和静态对象都很有用，但不应滥用，就像我们不应滥用其他模式一样。
- en: 'In practice, it helps to use the Singleton pattern when exactly one object
    is needed to coordinate others across a system. The following is one example that
    uses the pattern in this context:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，当系统中需要恰好一个对象来协调其他对象时，使用单例模式非常有帮助。以下是一个在这种情况下使用该模式的示例：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'While the Singleton has valid uses, often, when we find ourselves needing it
    in JavaScript, it’s a sign that we may need to reevaluate our design. Unlike C++
    or Java, where you have to define a class to create an object, JavaScript allows
    you to create objects directly. Thus, you can create one such object directly
    instead of defining a Singleton class. In contrast, using Singleton classes in
    JavaScript has some disadvantages:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管单例有其有效的用途，但通常在 JavaScript 中需要使用它时，这表明我们可能需要重新评估我们的设计。不像 C++ 或 Java 需要定义一个类来创建对象，JavaScript
    允许你直接创建对象。因此，你可以直接创建这样的对象而不是定义一个单例类。然而，在 JavaScript 中使用单例类也有一些缺点：
- en: Identifying Singletons can be difficult.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 识别单例可能是困难的。
- en: If you’re importing a large module, you will be unable to recognize that a particular
    class is a Singleton. As a result, you may accidentally use it as a regular class
    to instantiate multiple objects and incorrectly update it instead.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你导入一个大模块，你将无法识别特定的类是否为单例。因此，你可能会错误地将其用作常规类来实例化多个对象并错误地更新它。
- en: Challenging to test.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 测试具有挑战性。
- en: Singletons can be more difficult to test due to issues ranging from hidden dependencies,
    difficulty creating multiple instances, difficulty in stubbing dependencies, and
    so on.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于隐藏依赖项、难以创建多个实例、难以存根依赖项等问题，单例可能更难以测试。
- en: Need for careful orchestration.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 需要仔细协调。
- en: An everyday use case for Singletons would be to store data that will be required
    across the global scope, such as user credentials or cookie data that can be set
    once and consumed by multiple components. Implementing the correct execution order
    becomes essential so that data is always consumed after it becomes available and
    not the other way around. This may become challenging as the application grows
    in size and complexity.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 单例的一个日常用例是存储将在全局范围内需要的数据，例如只需设置一次并由多个组件使用的用户凭据或 cookie 数据。实施正确的执行顺序变得至关重要，以便在数据可用后始终消耗数据，而不是相反。随着应用程序规模和复杂性的增长，这可能变得具有挑战性。
- en: State Management in React
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React 中的状态管理
- en: Developers using React for web development can rely on the global state through
    state management tools such as Redux or React Context instead of Singletons. Unlike
    Singletons, these tools provide a read-only state rather than the mutable state.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 React 进行 Web 开发的开发人员可以通过状态管理工具（如 Redux 或 React Context）依赖全局状态，而不是单例。与单例不同，这些工具提供了一个只读状态而不是可变状态。
- en: Although the downsides to having a global state don’t magically disappear by
    using these tools, we can at least ensure that the global state is mutated the
    way we intend it to because components cannot update it directly.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用这些工具并不能神奇地消除全局状态带来的缺点，但我们至少可以确保全局状态被我们打算的方式进行更改，因为组件不能直接更新它。
- en: The Prototype Pattern
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原型模式
- en: The GoF refers to the Prototype pattern as one that creates objects based on
    a template of an existing object through cloning.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: GoF 将原型模式称为根据现有对象的模板通过克隆创建对象的一种模式。
- en: We can think of the Prototype pattern as being based on prototypal inheritance,
    where we create objects that act as prototypes for other objects. The `prototype`
    object is effectively used as a blueprint for each object the constructor creates.
    For example, if the prototype of the constructor function used contains a property
    called `name` (as per the code sample that follows), then each object created
    by that constructor will also have this same property. Refer to [Figure 7-3](#prototype)
    for an illustration.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将原型模式看作基于原型继承的模式，我们创建的对象充当其他对象的原型。`prototype`对象有效地用作构造函数创建的每个对象的蓝图。例如，如果构造函数的原型包含一个名为`name`的属性（如下面的代码示例所示），那么该构造函数创建的每个对象也将具有相同的属性。请参阅[图 7-3](#prototype)进行说明。
- en: '![ljd2 0703](Images/ljd2_0703.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![ljd2 0703](Images/ljd2_0703.png)'
- en: Figure 7-3\. Prototype pattern
  id: totrans-152
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-3\. 原型模式
- en: Reviewing the definitions for this pattern in existing (non-JavaScript) literature,
    we *may* find references to classes once again. The reality is that prototypal
    inheritance avoids using classes altogether. There isn’t a “definition” object
    nor a core object in theory; we’re simply creating copies of existing functional
    objects.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在现有（非JavaScript）文献中审查该模式的定义时，*可能*再次找到与类相关的引用。事实上，原型继承完全避免了使用类。在理论上并不存在“定义”对象或核心对象；我们只是创建现有函数对象的副本。
- en: One of the benefits of using the Prototype pattern is that we’re working with
    the prototypal strengths JavaScript has to offer natively rather than attempting
    to imitate features of other languages. With other design patterns, this isn’t
    always the case.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用原型模式的好处之一是，我们直接利用JavaScript本身提供的原型优势，而不是试图模仿其他语言的特性。在其他设计模式中，情况并非总是如此。
- en: Not only is the pattern an easy way to implement inheritance, but it can also
    come with a performance boost. When defining functions in an object, they’re all
    created by reference (so all child objects point to the same functions), instead
    of creating individual copies.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式不仅是实现继承的一种简便方法，而且还可以提高性能。在对象中定义函数时，它们都是通过引用创建的（因此所有子对象指向相同的函数），而不是创建各自的副本。
- en: With ES2015+, we can use classes and constructors to create objects. While this
    ensures that our code looks cleaner and follows object-oriented analysis and design
    (OOAD) principles, the classes and constructors get compiled down to functions
    and prototypes internally. This ensures that we are still working with the prototypal
    strengths of JavaScript and the accompanying performance boost.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ES2015+，我们可以使用类和构造函数来创建对象。虽然这确保了我们的代码看起来更干净，并遵循面向对象分析和设计（OOAD）原则，但类和构造函数在内部编译成函数和原型，从而确保我们仍然使用JavaScript的原型优势和相关性能提升。
- en: For those interested, real prototypal inheritance, as defined in the ECMAScript
    5 standard, requires the use of `Object.create` (which we looked at earlier in
    this section). To review, `Object.create` creates an object with a specified prototype
    and optionally contains specified properties (e.g., `Object.create( prototype,
    optionalDescriptorObjects )`).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些感兴趣的人来说，真正的原型继承，正如ECMAScript 5标准中定义的那样，需要使用`Object.create`（我们在本节之前已经介绍过）。回顾一下，`Object.create`创建一个具有指定原型的对象，并且可选地包含指定的属性（例如，`Object.create(
    prototype, optionalDescriptorObjects )`）。
- en: 'We can see this demonstrated in the following example:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下示例中看到这一点：
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`Object.create` also allows us to easily implement advanced concepts such as
    differential inheritance, where objects are able to directly inherit from other
    objects. We saw earlier that `Object.create` allows us to initialize object properties
    using the second supplied argument. For example:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.create`还允许我们轻松实现高级概念，例如差异继承，其中对象能够直接从其他对象继承。我们之前看到，`Object.create`允许我们使用第二个提供的参数初始化对象属性。例如：'
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, you can initialize the properties on the second argument of `Object.create`
    using an object literal with a syntax similar to that used by the `Object.defineProperties`
    and `Object.defineProperty` methods that we looked at previously.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以使用与我们之前查看过的`Object.defineProperties`和`Object.defineProperty`方法类似的语法，通过`Object.create`的第二个参数初始化第二个参数上的属性。
- en: It is worth noting that prototypal relationships can cause trouble when enumerating
    properties of objects and (as Crockford recommends) wrapping the contents of the
    loop in a `hasOwnProperty()` check.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在枚举对象属性时，原型关系可能会导致问题（正如Crockford建议的那样），需要在循环内容中包含`hasOwnProperty()`检查。
- en: 'If we wish to implement the Prototype pattern without directly using `Object.create`,
    we can simulate the pattern as per the previous example as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望在不直接使用 `Object.create` 的情况下实现原型模式，我们可以仿真之前的示例如下：
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-166
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This alternative does not allow the user to define read-only properties in the
    same manner (as the `vehiclePrototype` may be altered if not careful).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不小心，这种替代方法可能不允许用户以相同方式定义只读属性（因为如果不小心，`vehiclePrototype` 可能会被更改）。
- en: 'A final alternative implementation of the Prototype pattern could be the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 原型模式的最终替代实现可能如下所示：
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: One could reference this method from the `vehicle` function. However, note that
    `vehicle` here emulates a constructor since the Prototype pattern does not include
    any notion of initialization beyond linking an object to a prototype.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `vehicle` 函数中可以引用这种方法。然而，请注意，这里的 `vehicle` 模拟了构造函数，因为原型模式除了将对象链接到原型之外没有任何初始化概念。
- en: The Factory Pattern
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂模式
- en: The Factory pattern is another creational pattern for creating objects. It differs
    from the other patterns in its category because it doesn’t explicitly require
    us to use a constructor. Instead, a Factory can provide a generic interface for
    creating objects, where we can specify the type of Factory object we want to create
    ([Figure 7-4](#factory)).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂模式是用于创建对象的另一种创建型模式。它与其类别中的其他模式不同，因为它不要求我们明确使用构造器。相反，工厂可以提供一个通用接口来创建对象，我们可以指定要创建的工厂对象的类型（参见[图 7-4](#factory)）。
- en: '![ljd2 0704](Images/ljd2_0704.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![ljd2 0704](Images/ljd2_0704.png)'
- en: Figure 7-4\. Factory pattern
  id: totrans-174
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-4\. 工厂模式
- en: Imagine a UI factory where we want to create a type of UI component. Rather
    than creating this component directly using the `new` operator or another creational
    constructor, we ask a Factory object for a new component instead. We inform the
    Factory what type of object is required (e.g., “Button”, “Panel”), and it instantiates
    it and returns it to us for use.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个 UI 工厂，我们想要创建一种 UI 组件。与其直接使用 `new` 操作符或其他创建构造器来创建此组件，不如向工厂对象请求一个新的组件。我们告诉工厂需要什么类型的对象（例如，“按钮”，“面板”），它就会实例化并返回给我们使用。
- en: This is particularly useful if the object creation process is relatively complex,
    e.g., if it strongly depends on dynamic factors or application configuration.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象创建过程相对复杂，例如严重依赖于动态因素或应用程序配置时，这种方法特别有用。
- en: 'The following example builds upon our previous snippets using the Constructor
    pattern logic to define cars. It demonstrates how a `VehicleFactory` may be implemented
    using the Factory pattern:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例基于我们之前使用构造器模式逻辑定义汽车的片段。它展示了如何使用工厂模式来实现 `VehicleFactory`：
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We have defined the car and truck classes with constructors that set properties
    relevant to the respective vehicle. The `VehicleFactory` can create a new vehicle
    object, `Car`, or `Truck` based on the `vehicleType` passed.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了汽车和卡车类，它们具有设置与各自车辆相关属性的构造函数。`VehicleFactory` 可以根据传递的 `vehicleType` 创建一个新的车辆对象，`Car`
    或 `Truck`。
- en: There are two possible approaches to building trucks using the `VehicleFactory`
    class.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种可能的方法来使用 `VehicleFactory` 类构建卡车。
- en: 'In Approach 1, we modify a `VehicleFactory` instance to use the `Truck` class:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法 1 中，我们修改了一个 `VehicleFactory` 实例以使用 `Truck` 类：
- en: '[PRE27]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In Approach 2, we subclass `VehicleFactory` to create a factory class that
    builds `Trucks`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法 2 中，我们对 `VehicleFactory` 进行子类化以创建一个构建 `Truck` 的工厂类。
- en: '[PRE28]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When to Use the Factory Pattern
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用工厂模式的情况
- en: 'The Factory pattern can be beneficial when applied to the following situations:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用到以下情况时，工厂模式可以带来益处：
- en: When our object or component setup involves a high level of complexity.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们的对象或组件设置涉及高复杂度时。
- en: When we need a convenient way to generate different instances of objects depending
    on the environment we are in.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们需要一种方便的方式根据我们所处的环境生成不同实例的对象时。
- en: When we’re working with many small objects or components that share the same
    properties.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们处理许多共享相同属性的小对象或组件时。
- en: When composing objects with instances of other objects that need only satisfy
    an API contract (aka, duck typing) to work. This is useful for decoupling.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用其他对象实例来组成对象，这些对象只需要满足 API 合同（也称为鸭子类型）即可工作。这对解耦是有用的。
- en: When Not to Use the Factory Pattern
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不适用工厂模式的情况
- en: When applied to the wrong type of problem, this pattern can introduce a large
    amount of unnecessary complexity to an application. Unless providing an interface
    for object creation is a design goal for the library or framework we are writing,
    I would suggest sticking to explicit constructors to avoid undue overhead.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当这种模式应用于错误类型的问题时，可能会给应用程序引入大量不必要的复杂性。除非提供对象创建的接口是我们编写的库或框架的设计目标，否则我建议坚持使用显式构造函数，以避免不必要的开销。
- en: Since the process of object creation is effectively abstracted behind an interface,
    this can also introduce problems with unit testing, depending on just how complex
    this process might be.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对象创建过程实际上是在接口背后抽象化的，这也可能会在单元测试中引入问题，具体取决于这个过程的复杂性。
- en: Abstract Factories
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象工厂
- en: It’s also worthwhile to be aware of the Abstract Factory pattern, which aims
    to encapsulate a group of individual factories with a common goal. It separates
    the details of implementing a set of objects from their general usage.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 也值得注意的是抽象工厂模式，其旨在封装具有共同目标的一组单独工厂。它将对象的实现细节与其通用使用分离开来。
- en: You can use an Abstract Factory when a system must be independent of how the
    objects it creates are generated, or it needs to work with multiple types of objects.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统需要独立于它创建的对象的生成方式，或者它需要与多种类型的对象一起工作时，可以使用抽象工厂。
- en: 'An example that is both simple and easier to understand is a vehicle factory,
    which defines ways to get or register vehicle types. The Abstract Factory can
    be named `AbstractVehicleFactory`. The Abstract Factory will allow the definition
    of types of vehicles like `car` or `truck`, and concrete factories will implement
    only classes that fulfill the vehicle contract (e.g., `Vehicle.prototype.drive`
    and `Vehicle.prototype.breakDown`):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单且易于理解的例子是车辆工厂，它定义了获取或注册车辆类型的方法。抽象工厂可以命名为 `AbstractVehicleFactory`。抽象工厂将允许定义诸如
    `car` 或 `truck` 等车辆类型，具体工厂将仅实现满足车辆合同的类（例如 `Vehicle.prototype.drive` 和 `Vehicle.prototype.breakDown`）：
- en: '[PRE29]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Structural Patterns
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构模式
- en: Structural patterns deal with class and object composition. For example, the
    concept of inheritance allows us to compose interfaces and objects so that they
    can obtain new functionality. Structural patterns provide the best methods and
    practices to organize classes and objects.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 结构模式涉及类和对象的组合。例如，继承的概念允许我们组合接口和对象，以便它们可以获得新的功能。结构模式提供了组织类和对象的最佳方法和实践。
- en: 'Following are the JavaScript structural patterns that we will discuss in this
    section:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将在本节讨论的 JavaScript 结构模式：
- en: '[“The Facade Pattern”](#the-facade-pattern)'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“外观模式”](#the-facade-pattern)'
- en: '[“The Mixin Pattern”](#the-mixin-pattern)'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“混合模式”](#the-mixin-pattern)'
- en: '[“The Decorator Pattern”](#the-decorator-pattern)'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“装饰器模式”](#the-decorator-pattern)'
- en: '[“Flyweight”](#flyweight)'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“享元模式”](#flyweight)'
- en: The Facade Pattern
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**外观模式**'
- en: When we put up a facade, we present an outward appearance to the world, which
    may conceal a very different reality. This inspired the name for the next pattern
    we’ll review—the Facade pattern. This pattern provides a convenient higher-level
    interface to a larger body of code, hiding its true underlying complexity. Think
    of it as simplifying the API being presented to other developers, a quality that
    almost always improves usability (see [Figure 7-5](#facade)).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们竖起一个外观时，我们向世界展示一个外在的外观，可能掩盖了一个完全不同的现实。这启发了我们将要审查的下一个模式的名称——外观模式。这种模式为更大量的代码提供了一个方便的高级接口，隐藏了其真正的底层复杂性。可以将其看作是简化向其他开发者呈现的
    API，这几乎总是能提高可用性的一个特质（见[图 7-5](#facade)）。
- en: '![ljd2 0705](Images/ljd2_0705.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![ljd2 0705](Images/ljd2_0705.png)'
- en: Figure 7-5\. Facade pattern
  id: totrans-209
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-5\. 外观模式
- en: Facades are a structural pattern that can often be seen in JavaScript libraries
    such as jQuery where, although an implementation may support methods with a wide
    range of behaviors, only a “facade,” or limited abstraction of these methods,
    is presented to the public for use.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Facades 是一种结构模式，在 JavaScript 库（比如 jQuery）中经常能见到，尽管其实现支持多种行为的方法，但公众仅能使用这些方法的“外观”或有限的抽象。
- en: 'This allows us to interact with the Facade directly rather than the subsystem
    behind the scenes. Whenever we use jQuery’s `$(el).css()` or `$(el).animate()`
    methods, we’re using a Facade: the simpler public interface that lets us avoid
    manually calling the many internal methods in jQuery core required to get some
    behavior working. This also circumvents the need to interact manually with DOM
    APIs and maintain state variables.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够直接与外观模式交互，而不是在幕后与子系统交互。每当我们使用 jQuery 的 `$(el).css()` 或 `$(el).animate()`
    方法时，我们都在使用一个外观模式：这是一个简化的公共接口，让我们避免手动调用 jQuery 核心中许多内部方法来使某些行为生效。这也绕过了手动与 DOM API
    交互和维护状态变量的需要。
- en: The jQuery core methods should be considered intermediate abstractions. The
    more immediate burden to developers is that the DOM API and Facades make the jQuery
    library so easy to use.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 核心方法应视为中间抽象。对开发者的更直接的负担是 DOM API 和外观模式使得 jQuery 库如此易于使用。
- en: To build on what we’ve learned, the Facade pattern simplifies a class’s interface
    and decouples the class from the code that uses it. This allows us to interact
    indirectly with subsystems in a way that can sometimes be less error-prone than
    accessing the subsystem directly. A Facade’s advantages include ease of use and
    often a small-sized footprint in implementing the pattern.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加深我们的学习，外观模式简化了类的接口，并将类与使用它的代码解耦。这使我们能够间接地与子系统交互，有时比直接访问子系统更不容易出错。外观模式的优势包括易用性，通常在实现模式时的占用空间较小。
- en: 'Let’s take a look at the pattern in action. This is an unoptimized code example,
    but here we’re using a Facade to simplify an interface for listening to events
    across browsers. We do this by creating a common method that does the task of
    checking for the existence of features so that it can provide a safe and cross-browser-compatible
    solution:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个模式如何实现。这是一个未经优化的代码示例，但在这里，我们使用外观模式来简化在各种浏览器中监听事件的接口。我们通过创建一个通用方法来执行检查功能的任务，从而提供安全且跨浏览器兼容的解决方案：
- en: '[PRE30]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In a similar manner, we’re all familiar with jQuery’s `$(document).ready(…​)`.
    Internally, this is powered by a method called `bindReady()`, which is doing this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们都熟悉 jQuery 的 `$(document).ready(…​)`。在内部，这由一个名为 `bindReady()` 的方法提供支持，其功能如下：
- en: '[PRE31]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This is another example of a Facade where the rest of the world uses the limited
    interface exposed by `$(document).ready(…​)`, and the more complex implementation
    powering it is kept hidden from sight.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个外观模式的例子，其中全球使用的是 `$(document).ready(…​)` 所暴露的有限接口，而更复杂的实现则被隐藏起来。
- en: 'Facades don’t just have to be used on their own, however. You can also integrate
    them with other patterns, such as the Module pattern. As we can see next, our
    instance of the Module pattern contains a number of methods that have been privately
    defined. A Facade is then used to supply a much simpler API for accessing these
    methods:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 外观模式不仅仅可以单独使用。然而，您还可以将它们与其他模式（如模块模式）集成。接下来我们可以看到，我们的模块模式实例包含了一些已私下定义的方法。然后使用外观模式来提供一个更简单的
    API 以访问这些方法：
- en: '[PRE32]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this example, calling `module.facade()` will trigger a set of private behavior
    within the module, but the users aren’t concerned with this. We’ve made it much
    easier for them to consume a feature without worrying about implementation-level
    details.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，调用 `module.facade()` 将触发模块内部的一系列私有行为，但用户并不关心这些细节。我们让用户更轻松地消费一个功能，而不用担心实现层面的细节。
- en: The Mixin Pattern
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混入模式
- en: In traditional programming languages such as C++ and Lisp, Mixins are classes
    that offer functionality that a subclass or group of subclasses can easily inherit
    for function reuse.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的编程语言如 C++ 和 Lisp 中，混入是一种类，它提供了一个子类或一组子类可以轻松继承以进行函数重用的功能。
- en: Subclassing
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子类化
- en: We have already introduced the ES2015+ features that allow us to extend a base
    or superclass and call the methods in the superclass. The child class that extends
    the superclass is known as a subclass.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了 ES2015+ 的功能，允许我们扩展基类或超类，并调用超类中的方法。扩展超类的子类称为子类。
- en: Subclassing refers to inheriting properties for a new object from a base or
    superclass object. A subclass can still define its methods, including those that
    override methods initially defined in the superclass. The method in the subclass
    can invoke an overridden method in the superclass, known as method chaining. Similarly,
    it can invoke the superclass’s constructor, which is known as constructor chaining.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 子类化是指从基类或超类对象继承新对象的属性。子类仍然可以定义自己的方法，包括那些重写最初在超类中定义的方法。子类中的方法可以调用超类中的重写方法，称为方法链。类似地，它可以调用超类的构造函数，这称为构造函数链。
- en: 'To demonstrate subclassing, we first need a base class that can have new instances
    of itself created. Let’s model this around the concept of a person:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要演示子类化，我们首先需要一个基类，可以创建其自身的新实例。让我们围绕一个人的概念来建模这一点：
- en: '[PRE33]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, we’ll want to specify a new class that’s a subclass of the existing `Person`
    class. Let us imagine we want to add distinct properties to distinguish a `Person`
    from a `Superhero` while inheriting the properties of the `Person` superclass.
    As superheroes share many common traits with ordinary people (e.g., name, gender),
    this should ideally adequately illustrate how subclassing works:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要指定一个新的类，该类是现有`Person`类的子类。让我们想象一下，我们希望添加明显的属性来区分`Person`和`Superhero`，同时继承`Person`超类的属性。由于超级英雄与普通人（例如名称、性别）共享许多共同特征，这理应充分说明子类化的工作原理：
- en: '[PRE34]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `Superhero` constructor creates an instance of the `Superhero` class, which
    is an extension of the `Person` class. Objects of this type have attributes of
    the classes above it in the chain. If we had set default values in the `Person`
    class, `Superhero` could override any inherited values with values specific to
    its class.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`Superhero`构造函数创建了一个`Superhero`类的实例，该类是`Person`类的扩展。此类的对象具有其上面链中类的属性。如果我们在`Person`类中设置了默认值，`Superhero`可以使用特定于其类的值覆盖任何继承的值。'
- en: Mixins
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合（Mixins）
- en: In JavaScript, we can look at inheriting from Mixins to collect functionality
    through extension. Each new class we define can have a superclass from which it
    can inherit methods and properties. Classes can also define their own properties
    and methods. We can leverage this fact to promote function reuse, as shown in
    [Figure 7-6](#mixins_pattern).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，我们可以通过从Mixins继承来收集扩展的功能。我们定义的每个新类都可以有一个超类，从中可以继承方法和属性。类还可以定义自己的属性和方法。我们可以利用这一点促进函数的重用，如在[图 7-6](#mixins_pattern)中所示。
- en: '![ljd2 0706](Images/ljd2_0706.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![ljd2 0706](Images/ljd2_0706.png)'
- en: Figure 7-6\. Mixins
  id: totrans-235
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-6\. 混合（Mixins）
- en: Mixins allow objects to borrow (or inherit) functionality from them with minimal
    complexity. Thus, Mixins are classes with attributes and methods that can be easily
    shared across several other classes.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Mixins允许对象以最小的复杂性从它们那里借用（或继承）功能。因此，Mixins是具有属性和方法的类，可以在多个其他类之间轻松共享。
- en: While JavaScript classes cannot inherit from multiple superclasses, we can still
    mix functionality from various classes. A class in JavaScript can be used as an
    expression as well as a statement. As an expression, it returns a new class each
    time it’s evaluated. The extends clause can also accept arbitrary expressions
    that return classes or constructors. These features enable us to define a Mixin
    as a function that accepts a superclass and creates a new subclass from it.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然JavaScript类不能从多个超类继承，但我们仍然可以从各种类中混合功能。JavaScript中的类既可以用作表达式，也可以用作语句。作为表达式时，它每次评估时返回一个新的类。extends子句还可以接受返回类或构造函数的任意表达式。这些功能使我们能够将Mixin定义为一个函数，该函数接受一个超类并从中创建一个新的子类。
- en: 'Imagine that we define a Mixin containing utility functions in a standard JavaScript
    class as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们定义一个包含在标准JavaScript类中的实用函数的Mixin如下所示：
- en: '[PRE35]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here, we created a `MyMixins` function that can extend a dynamic superclass.
    We will now create two classes, `CarAnimator` and `PersonAnimator`, from which
    `MyMixins` can extend and return a subclass with methods defined in `MyMixins`
    and those in the class being extended:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为`MyMixins`的函数，它可以扩展一个动态的超类。现在我们将创建两个类，`CarAnimator`和`PersonAnimator`，`MyMixins`可以从这两个类扩展并返回一个子类，该子类具有`MyMixins`中定义的方法以及被扩展类中的方法：
- en: '[PRE36]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As we can see, this makes mixing similar behavior into classes reasonably trivial.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这使得将类似行为混合到类中变得相当简单。
- en: 'The following example has two classes: a `Car` and a `Mixin`. What we’re going
    to do is augment (another way of saying extend) the `Car` so that it can inherit
    specific methods defined in the `Mixin`, namely `driveForward()` and `driveBackward()`.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例有两个类：一个是`Car`，一个是`Mixin`。我们要做的是增强（另一种说法是扩展）`Car`，以便它可以继承`Mixin`中定义的特定方法，即`driveForward()`和`driveBackward()`。
- en: 'This example will demonstrate how to augment a constructor to include functionality
    without the need to duplicate this process for every constructor function we may
    have:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例将演示如何增强构造函数以包含功能，而无需为每个构造函数重复此过程：
- en: '[PRE37]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Advantages and Disadvantages
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优缺点
- en: Mixins assist in decreasing functional repetition and increasing function reuse
    in a system. Where an application is likely to require shared behavior across
    object instances, we can easily avoid duplication by maintaining this shared functionality
    in a Mixin and thus focusing on implementing only the functionality in our system,
    which is truly distinct.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Mixin有助于减少系统中的功能重复，并增加功能的重用性。在应用程序可能需要跨对象实例共享行为的情况下，通过在Mixin中维护这些共享功能，我们可以轻松避免重复，并集中精力实现系统中真正独特的功能。
- en: That said, the downsides to Mixins are a little more debatable. Some developers
    feel that injecting functionality into a class or an object prototype is a bad
    idea as it leads to both prototype pollution and a level of uncertainty regarding
    the origin of our functions. In large systems, this may well be the case.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，Mixin的缺点还存在一些争议。一些开发人员认为向类或对象原型注入功能是一个坏主意，因为它会导致原型污染和关于函数来源的不确定性。在大型系统中，这可能是事实。
- en: Even with React, Mixins were often used to add functionality to components before
    the introduction of ES6 classes. The React team [discourages Mixins](https://oreil.ly/RCMzS)
    because it adds unnecessary complexity to a component, making it hard to maintain
    and reuse. The React team [encouraged using higher-order components and Hooks
    instead](https://oreil.ly/f1216).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是在React中，在引入ES6类之前，Mixin经常被用来向组件添加功能。React团队[不鼓励使用Mixin](https://oreil.ly/RCMzS)，因为它会给组件增加不必要的复杂性，使得维护和重用变得困难。React团队推荐使用高阶组件和Hooks来代替[（https://oreil.ly/f1216）](https://oreil.ly/f1216)。
- en: I would argue that solid documentation can assist in minimizing the amount of
    confusion regarding the source of mixed-in functions. Still, as with every pattern,
    we should be okay if we take care during implementation.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为，扎实的文档可以帮助减少关于混合函数来源的混淆。但是，就像每种模式一样，我们在实施时应该小心。
- en: The Decorator Pattern
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰者模式
- en: Decorators are a structural design pattern that aims to promote code reuse.
    Like Mixins, you can think of them as another viable alternative to object subclassing.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰者是一种结构设计模式，旨在促进代码重用。与Mixin类似，您可以将它们视为对象子类化的另一种可行替代方法。
- en: Classically, decorators offered the ability to add behavior to existing classes
    in a system dynamically. The idea was that the *decoration* itself wasn’t essential
    to the base functionality of the class. Otherwise, we could bake it into the *superclass*
    itself.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，装饰者提供了动态向现有类添加行为的能力。其核心思想是*装饰*本身对类的基本功能并不是必需的。否则，我们可以将其直接编入*超类*。
- en: We can use them to modify existing systems where we wish to add additional features
    to objects without heavily changing the underlying code that uses them. A common
    reason developers use them is that their applications may contain features requiring
    many distinct types of objects. Imagine defining hundreds of different object
    constructors for, say, a JavaScript game (see [Figure 7-7](#decorator)).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用它们来修改现有系统，以便在不大幅更改使用它们的基础代码的情况下添加对象的附加功能。开发人员经常使用它们的一个常见原因是，他们的应用程序可能包含需要许多不同类型对象的功能。想象一下，为JavaScript游戏定义数百个不同的对象构造函数（见[图7-7](#decorator)）。
- en: '![ljd2 0707](Images/ljd2_0707.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![ljd2 0707](Images/ljd2_0707.png)'
- en: Figure 7-7\. Decorator pattern
  id: totrans-256
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-7\. 装饰者模式
- en: The object constructors could represent distinct player types, each with differing
    capabilities. A *Lord of the Rings* game could require constructors for `Hobbit`,
    `Elf`, `Orc`, `Wizard`, `Mountain Giant`, `Stone Giant`, and so on, but there
    could easily be hundreds of these. If we then factored in capabilities, imagine
    having to create subclasses for each combination of capability types, e.g., `HobbitWithRing`,
    `HobbitWithSword`, `HobbitWithRingAndSword`, and so on. This isn’t practical and
    certainly isn’t manageable when we factor in an increasing number of different
    abilities.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 对象构造函数可以代表不同类型的玩家，每种类型具有不同的能力。*魔戒*游戏可能需要`Hobbit`、`Elf`、`Orc`、`Wizard`、`Mountain
    Giant`、`Stone Giant`等构造函数，但这些可能会有数百种。如果考虑能力，想象一下需要为每种能力类型的组合创建子类，例如`HobbitWithRing`、`HobbitWithSword`、`HobbitWithRingAndSword`等。这种做法既不实际，而且在考虑到不断增加的不同能力时，管理起来也是不可行的。
- en: The Decorator pattern isn’t heavily tied to how objects are created but instead
    focuses on the problem of extending their functionality. Rather than just relying
    on prototypal inheritance, we work with a single base class and progressively
    add decorator objects that provide additional capabilities. The idea is that rather
    than subclassing, we add (decorate) properties or methods to a base object, so
    it’s a little more streamlined.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式并没有与对象创建方式紧密联系，而是专注于扩展它们的功能。与仅仅依赖原型继承不同，我们使用单个基类，并逐步添加提供额外功能的装饰器对象。其核心思想是，与其子类化，我们向基对象添加（装饰）属性或方法，使得流程更加简洁。
- en: We can use JavaScript classes to create the base classes that can be decorated.
    Adding new attributes or methods to object instances of the class in JavaScript
    is a straightforward process. With this in mind, we can implement a simplistic
    decorator, as shown in Examples [7-4](#decorating_constructors_functionality)
    and [7-5](#decorating_objects_multiple).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 JavaScript 类来创建可以装饰的基类。在 JavaScript 中向类的对象实例添加新属性或方法是一个简单的过程。考虑到这一点，我们可以实现一个简单的装饰器，就像例子
    [7-4](#decorating_constructors_functionality) 和 [7-5](#decorating_objects_multiple)
    中展示的那样。
- en: Example 7-4\. Decorating constructors with new functionality
  id: totrans-260
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-4\. 用新功能装饰构造函数
- en: '[PRE38]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, `truck` is an instance of the class `Vehicle`, and we also decorate it
    with additional methods `setColor` and `setModel`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`truck`是`Vehicle`类的一个实例，我们还用额外的方法`setColor`和`setModel`来装饰它。
- en: This type of simplistic implementation is functional, but it doesn’t demonstrate
    all the strengths that decorators offer. For this, we’re going to go through my
    variation of the Coffee example from an excellent book called [*Head First Design
    Patterns*](https://learning.oreilly.com/library/view/head-first-design/0596007124/)
    by Freeman et al., which is modeled around a MacBook purchase.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简化的实现是有效的，但它并不能展示装饰器提供的所有优点。因此，我们将通过《*Head First Design Patterns*》（[链接](https://learning.oreilly.com/library/view/head-first-design/0596007124/)）中关于
    MacBook 购买的例子来演示一下我的变体。
- en: Example 7-5\. Decorating objects with multiple decorators
  id: totrans-264
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-5\. 使用多个装饰器装饰对象
- en: '[PRE39]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In this example, our decorators are overriding the `MacBook` superclass object’s
    `.cost()` function to return the current price of the MacBook plus the cost of
    the upgrade.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们的装饰器重写了`MacBook`超类对象的`.cost()`函数，以返回 MacBook 的当前价格加上升级的费用。
- en: It’s considered decoration because the original `MacBook` objects constructor
    methods that are not overridden (e.g., `screenSize()`), as well as any other properties
    we may define as a part of the `MacBook`, remain unchanged and intact.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这被视为装饰，因为原始的`MacBook`对象的构造方法（例如`screenSize()`）以及我们可能定义为`MacBook`一部分的任何其他属性都保持不变和完整。
- en: There isn’t a defined interface in the previous example. We’re shifting away
    from the responsibility of ensuring an object meets an interface when moving from
    the creator to the receiver.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，并没有定义一个明确的接口。当从创建者转移到接收者时，我们正在摆脱确保对象符合接口的责任。
- en: Pseudoclassical Decorators
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 伪经典装饰器
- en: We’re now going to examine a variation of the Decorator first presented in a
    JavaScript form in *Pro JavaScript Design Patterns* (PJDP) by Dustin Diaz and
    Ross Harmes.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将研究《*Pro JavaScript Design Patterns*》（PJDP）中首次以 JavaScript 形式呈现的装饰器的一个变体。
- en: Unlike some of the previous examples, Diaz and Harmes stick more closely to
    how decorators are implemented in other programming languages (such as Java or
    C++) using the concept of an “interface,” which we will define in more detail
    shortly.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的一些示例不同，Diaz 和 Harmes 更贴近其他编程语言（如 Java 或 C++）中装饰器的实现方式，使用了“接口”这一概念，我们稍后将更详细地定义它。
- en: Note
  id: totrans-272
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This particular variation of the Decorator pattern is provided for reference
    purposes. If you find it overly complex, I recommend opting for one of the straightforward
    implementations covered earlier.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这种装饰器模式的特定变体仅供参考。如果你觉得它过于复杂，我建议选择前面介绍的其中一种简单实现。
- en: Interfaces
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口
- en: PJDP describes the Decorator pattern as one that is used to transparently wrap
    objects inside other objects of the same interface. An interface is a way of defining
    the methods an object *should* have. However, it doesn’t directly specify how
    you should implement those methods. Interfaces can also optionally indicate what
    parameters the methods take.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: PJDP 将装饰器模式描述为一种用于透明地将对象包装在具有相同接口的其他对象内部的模式。接口是定义对象应该具有的方法的一种方式。然而，它并不直接指定你应该如何实现这些方法。接口还可以选择性地指示方法需要什么参数。
- en: So, why would we use an interface in JavaScript? The idea is that they’re self-documenting
    and promote reusability. In theory, interfaces make code more stable by ensuring
    any change to the interface must also be propagated to the objects implementing
    them.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在 JavaScript 中为什么要使用接口呢？这样做的想法是它们是自我描述的，并促进重用。理论上，接口通过确保对接口的任何更改也必须传播到实现它们的对象，使代码更加稳定。
- en: 'What follows is an example of an implementation of interfaces in JavaScript
    using duck-typing. This approach helps determine whether an object is an instance
    of a constructor/object based on the methods it implements:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个使用鸭子类型在 JavaScript 中实现接口的示例。这种方法有助于确定对象是否是基于它实现的方法的构造函数/对象的实例：
- en: '[PRE40]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Both classic JavaScript and ES2015+ do not support interfaces. However, we can
    create our Interface class. In the previous example, `Interface.ensureImplements`
    provides strict functionality checking, and you can [find code for both this and
    the `Interface` constructor](https://oreil.ly/JbbLL).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 经典 JavaScript 和 ES2015+ 都不支持接口。然而，我们可以创建我们自己的 Interface 类。在前面的示例中，`Interface.ensureImplements`
    提供了严格的功能检查，你可以在[这里找到代码](https://oreil.ly/JbbLL)来了解 `Interface` 构造函数。
- en: The main concern with interfaces is that JavaScript does not have built-in support
    for them, which may lead to attempts at emulating features from other languages
    that might not be an ideal fit. However, you can utilize TypeScript if you really
    need interfaces, as it provides built-in support for them. Lightweight interfaces
    can be used without a significant performance cost in JavaScript, and we will
    explore *abstract* decorators using this same concept in the following section.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 接口的主要问题在于 JavaScript 没有内置支持，这可能导致尝试模拟其他语言的特性，这可能不是一个理想的选择。然而，如果你真的需要接口，你可以使用
    TypeScript，因为它提供了对接口的内置支持。在 JavaScript 中，轻量级接口可以在不显著影响性能的情况下使用，我们将在接下来的部分中使用相同的概念来探讨*抽象*装饰器。
- en: Abstract Decorators
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象装饰器
- en: To demonstrate the structure of this version of the Decorator pattern, we’re
    going to imagine we have a superclass that models a `MacBook` once again and a
    store that allows us to “decorate” our MacBook with a number of enhancements for
    an additional fee.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这个版本的装饰器模式的结构，我们假设有一个模拟 `MacBook` 的超类和一个商店，允许我们为额外费用为我们的 MacBook 添加多种增强功能。
- en: 'Enhancements can include upgrades to 4 GB or 8 GB of RAM (this can be much
    higher now, of course!), engraving, Parallels, or a case. Now, if we were to model
    this using an individual subclass for each combination of enhancement options,
    it might look something like this:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 升级可以包括将 RAM 升级到 4 GB 或 8 GB（当然现在可能更高！）、刻字、Parallels 或一个外壳。现在，如果我们为每种升级选项组合建模使用单独的子类，可能会看起来像这样：
- en: '[PRE41]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: …and so on.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: …等等。
- en: This solution would be impractical because a new subclass would be required
    for every possible combination of enhancements that are available. As we would
    prefer to keep things simple, without maintaining a large set of subclasses, let’s
    look at how we can use decorators to solve this problem better.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决方案是不切实际的，因为每种可能的增强组合都需要一个新的子类。由于我们更倾向于保持简单，而不是维护一大堆子类，让我们看看如何使用装饰器更好地解决这个问题。
- en: Rather than requiring all of the combinations we saw earlier, we will create
    only five new decorator classes. Methods called on these enhancement classes would
    be passed on to our `MacBook` class.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 不像我们之前看到的所有组合那样，我们只会创建五个新的装饰器类。在这些增强类上调用的方法将传递给我们的`MacBook`类。
- en: 'In the following example, decorators transparently wrap around their components
    and can be interchanged as they use the same interface. Here’s the interface we’re
    going to define for the MacBook:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，装饰器透明地包裹它们的组件，并且可以通过使用相同的接口进行交换。这是我们将为MacBook定义的接口：
- en: '[PRE42]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To make it easier for us to add many more options as needed later on, an abstract
    decorator class is defined with default methods required to implement the `MacBook`
    interface, which the rest of the options will subclass. Abstract Decorators ensure
    that we can decorate a base class independently with as many decorators as needed
    in different combinations (remember the example earlier?) without needing to derive
    a class for every possible combination:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们以后添加更多选项更容易，我们定义了一个抽象装饰器类，其中包含实现`MacBook`接口所需的默认方法，其余选项将是其子类。抽象装饰器确保我们可以独立地使用尽可能多的装饰器来装饰基类（还记得之前的例子吗？），而无需为每种可能的组合派生一个类：
- en: '[PRE43]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In this sample, the `MacBook` Decorator accepts an object (a `MacBook`) to
    use as our base component. It uses the `MacBook` interface we defined earlier,
    and each method is just calling the same method on the component. We can now create
    our option classes for what can be added by using the `MacBook` Decorator:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`MacBook`装饰器接受一个对象（一个`MacBook`）作为我们的基础组件。它使用我们之前定义的`MacBook`接口，每个方法只是调用组件上的相同方法。现在我们可以使用`MacBook`装饰器创建可以添加的选项类：
- en: '[PRE44]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We are overriding the `addCase()` and `getPrice()` methods that we want to decorate,
    and we’re achieving this by first calling these methods on the original `MacBook`
    and then simply appending a string or numeric value (e.g., `45.00`) to them accordingly.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在重写我们想要装饰的`addCase()`和`getPrice()`方法，并通过首先在原始的`MacBook`上调用这些方法，然后根据需要简单地附加一个字符串或数值（例如，`45.00`）来实现这一点。
- en: 'As there’s been quite a lot of information presented in this section so far,
    let’s try to bring it all together in a single example that will hopefully highlight
    what we have learned:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本节中提供了大量信息，让我们试着在一个单一的示例中将所有内容汇总起来，希望能突出我们学到的内容：
- en: '[PRE45]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As decorators can modify objects dynamically, they’re a perfect pattern for
    changing existing systems. Occasionally, it’s just simpler to create decorators
    around an object instead of maintaining individual subclasses for each object
    type. This makes maintaining applications that may require many subclassed objects
    significantly more straightforward.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 由于装饰器可以动态修改对象，它们是改变现有系统的完美模式。有时，围绕一个对象创建装饰器比为每种对象类型维护单独的子类简单得多。这使得维护可能需要许多子类对象的应用程序变得更加简单。
- en: You can find a functional version of this example on [JSBin](https://oreil.ly/wNgs6).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[JSBin](https://oreil.ly/wNgs6)上找到此示例的功能版本。
- en: Advantages and Disadvantages
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优缺点
- en: Developers enjoy using this pattern as it can be used transparently and is somewhat
    flexible. As we’ve seen, objects can be wrapped or “decorated” with new behavior
    and continue to be used without worrying about the base object being modified.
    In a broader context, this pattern also avoids us needing to rely on large numbers
    of subclasses to get the same benefits.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员喜欢使用这种模式，因为它可以透明地使用，并且相当灵活。正如我们所见，对象可以被包装或“装饰”以添加新的行为，并继续使用而无需担心基本对象被修改。在更广泛的背景下，该模式还避免了我们需要依赖大量子类来获得相同好处。
- en: There are, however, drawbacks that we should be aware of when implementing the
    pattern. It can significantly complicate our application architecture if poorly
    managed, as it introduces many small but similar objects into our namespace. The
    concern is that other developers unfamiliar with the pattern may have difficulty
    grasping why it’s being used, making it hard to manage.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在实现这种模式时，我们应该注意到一些缺点。如果管理不善，它可能会显著复杂化我们的应用架构，因为它会将许多小但相似的对象引入我们的命名空间。问题在于其他不熟悉该模式的开发人员可能难以理解为什么要使用它，这会使得管理变得困难。
- en: Sufficient commenting or pattern research should assist with the latter. However,
    as long as we handle how widely we use the Decorator in our applications, we should
    be fine on both counts.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 充足的注释或模式研究应该有助于后者。然而，只要我们处理好在应用程序中广泛使用装饰者的方式，我们在这两个方面应该都没问题。
- en: Flyweight
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 享元
- en: The Flyweight pattern is a classical structural solution for optimizing code
    that is repetitive, slow, and inefficiently shares data. It aims to minimize the
    use of memory in an application by sharing as much data as possible with related
    objects (e.g., application configuration, state, and so on—see [Figure 7-8](#flyweight_pattern)).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 享元模式是一种经典的结构性解决方案，用于优化重复、缓慢和效率低下的代码。它旨在通过尽可能与相关对象共享数据（例如应用程序配置、状态等）来最小化应用程序中的内存使用（参见[图7-8](#flyweight_pattern)）。
- en: '![ljd2 0708](Images/ljd2_0708.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![ljd2 0708](Images/ljd2_0708.png)'
- en: Figure 7-8\. Flyweight pattern
  id: totrans-306
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-8. 享元模式
- en: Paul Calder and Mark Linton first conceived the pattern in 1990 and named it
    after the boxing weight class that includes fighters weighing less than 112 lb.
    The name Flyweight is derived from this weight classification because it refers
    to the small weight (memory footprint) the pattern aims to help us achieve.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 保罗·卡尔德和马克·林顿于1990年首次构想了这一模式，并以包括体重不足112磅的拳击级别命名。享元这个名称来源于这个体重分类，因为它指的是模式旨在帮助我们实现的小内存占用。
- en: In practice, Flyweight data sharing can involve taking several similar objects
    or data constructs used by many objects and placing this data into a single external
    object. We can pass this object to those depending on this data rather than storing
    identical data across each one.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，享元数据共享可以涉及取出许多对象或数据结构使用的相似数据，并将此数据放入单个外部对象中。我们可以将此对象传递给那些依赖于此数据的对象，而不是在每个对象中存储相同的数据。
- en: Using Flyweights
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用享元模式
- en: There are two ways in which you can apply the Flyweight pattern. The first is
    at the data layer, where we deal with the concept of sharing data between large
    quantities of similar objects stored in memory.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以应用享元模式的两种方式。第一种是在数据层，我们处理内存中大量相似对象之间共享数据的概念。
- en: You can also apply the Flyweight at the DOM layer as a central event manager
    to avoid attaching event handlers to every child element in a parent container
    with similar behavior.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在DOM层应用享元模式作为一个中央事件管理器，以避免将事件处理程序附加到父容器中的每个子元素，这些子元素具有类似的行为。
- en: Traditionally, the Flyweight pattern has been used most at the data layer, so
    we’ll take a look at this first.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，享元模式最常用于数据层，所以我们将首先看看这一点。
- en: Flyweights and Sharing Data
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 享元和数据共享
- en: 'For this application, we need to be aware of a few more concepts around the
    classical Flyweight pattern. In the Flyweight pattern, there’s a concept of two
    states: intrinsic and extrinsic. Intrinsic information may be required by internal
    methods in our objects, without which they absolutely cannot function. Extrinsic
    information can, however, be removed and stored externally.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个应用程序，我们需要了解关于经典享元模式的几个更多概念。在享元模式中，有两种状态的概念：内在的和外部的。内在信息可能被对象内部方法所需，没有这些信息它们绝对无法正常运行。然而，外部信息可以被移除并存储在外部。
- en: You can replace objects with the same intrinsic data with a single shared object
    created by a factory method. This allows us to reduce the overall quantity of
    implicit data being stored quite significantly.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以用由工厂方法创建的单个共享对象替换具有相同内在数据的对象。这使我们能够显著减少存储的隐式数据的总量。
- en: The benefit is that we can keep an eye on objects that have already been instantiated
    so that new copies are only ever created if the intrinsic state differs from the
    object we already have.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 好处在于我们可以监视已经实例化的对象，这样只有在内在状态与我们已经拥有的对象不同的情况下才会创建新副本。
- en: We use a manager to handle the extrinsic states. You can implement this in various
    ways, but one approach is to have the manager object contain a central database
    of the extrinsic states and the flyweight objects to which they belong.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个管理器来处理外部状态。您可以以多种方式实现这一点，但其中一种方法是使管理器对象包含外部状态的中央数据库，以及它们所属的享元对象。
- en: Implementing Classical Flyweights
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现经典的享元模式
- en: The Flyweight pattern hasn’t been heavily used in JavaScript recently, so many
    of the implementations we might use for inspiration come from the Java and C++
    worlds.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 最近JavaScript中并没有广泛使用享元模式，因此我们可能会从Java和C++世界中的许多实现中获得灵感。
- en: Our first look at flyweights in code is my JavaScript implementation of the
    Java sample of the Flyweight pattern from [Wikipedia](https://oreil.ly/6rtiJ).
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们代码中第一次接触享元模式的实现是我从[Wikipedia](https://oreil.ly/6rtiJ)的Java示例中实现的JavaScript样本。
- en: 'This implementation makes use of three types of flyweight components:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现利用了三种类型的享元组件：
- en: Flyweight
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 享元
- en: Corresponds to an interface through which flyweights are able to receive and
    act on extrinsic states.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 对应于享元能够接收和处理外部状态的接口。
- en: Concrete flyweight
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 具体享元
- en: Actually implements the flyweight interface and stores the intrinsic states.
    Concrete flyweights need to be sharable and capable of manipulating the extrinsic
    state.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 实际实现了享元接口并存储了内在状态。具体享元需要可共享并能够操作外部状态。
- en: Flyweight factory
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 享元工厂
- en: Manages flyweight objects and creates them too. It ensures that our flyweights
    are shared and manages them as a group of objects that can be queried if we require
    individual instances. If an object has already been created in the group, it returns
    it. Otherwise, it adds a new object to the pool and returns it.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 管理享元对象并创建它们。它确保我们的享元是共享的，并将它们作为一组对象进行管理，可以在需要单个实例时查询。如果对象已经在组中创建，则返回它。否则，它将添加一个新对象到池中并返回它。
- en: 'These correspond to the following definitions in our implementation:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对应于我们实现中的以下定义：
- en: '`CoffeeOrder`: Flyweight'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CoffeeOrder`: 享元'
- en: '`CoffeeFlavor`: Concrete flyweight'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CoffeeFlavor`: 具体享元'
- en: '`CoffeeOrderContext`: Helper'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CoffeeOrderContext`: 辅助工具'
- en: '`CoffeeFlavorFactory`: Flyweight factory'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CoffeeFlavorFactory`: 享元工厂'
- en: '`testFlyweight`: Utilization of our Flyweights'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testFlyweight`: 利用我们的享元'
- en: Duck punching “implements”
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Duck punching “implements”
- en: Duck punching allows us to extend the capabilities of a language or solution
    without necessarily needing to modify the runtime source. As this next solution
    requires a Java keyword (`implements`) for implementing interfaces and isn’t found
    in JavaScript natively, let’s first duck-punch it.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: Duck punching允许我们扩展语言或解决方案的能力，而无需修改运行时源代码。由于下一个解决方案需要Java关键字（`implements`）来实现接口，并且JavaScript中没有本地支持，因此让我们首先进行鸭子打补丁。
- en: '`Function.prototype.implementsFor` works on an object constructor and will
    accept a parent class (function) or object and either inherit from this using
    normal inheritance (for functions) or virtual inheritance (for objects):'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`Function.prototype.implementsFor`作用于对象构造函数，将接受一个父类（函数）或对象，并使用普通继承（用于函数）或虚拟继承（用于对象）从中继承：'
- en: '[PRE46]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We can use this to patch the lack of an `implements` keyword by explicitly
    having a function inherit an interface. Next, `CoffeeFlavor` implements the `CoffeeOrder`
    interface and must contain its interface methods for us to assign the functionality
    powering these implementations to an object:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个方法来弥补缺少`implements`关键字的问题，通过显式地让函数继承一个接口。接下来，`CoffeeFlavor`实现了`CoffeeOrder`接口，并且必须包含其接口方法，以便我们将这些实现的功能分配给一个对象：
- en: '[PRE47]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Converting Code to Use the Flyweight Pattern
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将代码转换为使用享元模式
- en: 'Next, let’s continue our look at Flyweights by implementing a system to manage
    all books in a library. You could list the essential metadata for each book as
    follows:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们继续实现一个系统来管理图书馆中的所有书籍，你可以列出每本书的基本元数据如下：
- en: ID
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ID
- en: Title
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标题
- en: Author
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作者
- en: Genre
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型
- en: Page count
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 页数
- en: Publisher ID
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 出版商ID
- en: ISBN
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ISBN
- en: 'We’ll also require the following properties to track which member has checked
    out a particular book, the date they’ve checked it out, and the expected return
    date:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要以下属性来跟踪哪位会员借阅了特定的书籍，他们借阅的日期以及预期的归还日期：
- en: '`checkoutDate`'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`checkoutDate`'
- en: '`checkoutMember`'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`checkoutMember`'
- en: '`dueReturnDate`'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dueReturnDate`'
- en: '`availability`'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`availability`'
- en: 'We create a `Book` class to represent each book as follows before any optimization
    using the Flyweight pattern. The constructor takes in all the properties related
    directly to the book and those required for tracking it:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个`Book`类来表示每本书，在使用享元模式进行任何优化之前，构造函数接收与书籍直接相关和跟踪书籍所需的所有属性：
- en: '[PRE48]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This probably works fine initially for small collections of books. However,
    as the library expands to include a more extensive inventory with multiple versions
    and copies of each book, we may find the management system running more slowly.
    Using thousands of book objects may overwhelm the available memory, but we can
    optimize our system using the Flyweight pattern to improve this.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小型书籍集合，这可能起初表现良好。然而，随着图书馆扩展到包含更广泛的库存以及每本书的多个版本和副本，我们可能会发现管理系统运行速度变慢。使用数千个书籍对象可能会耗尽可用内存，但我们可以使用享元模式优化我们的系统以改进这一点。
- en: 'We can now separate our data into intrinsic and extrinsic states: data relevant
    to the book object (`title`, `author`, etc.) is intrinsic, while the checkout
    data (`checkoutMember`, `dueReturnDate`, etc.) is considered extrinsic. Effectively,
    this means that only one `Book` object is required for each combination of book
    properties. It’s still a considerable number of objects, but significantly fewer
    than we had previously.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将数据分为内在状态和外在状态：与书籍对象相关的数据（`title`、`author`等）是内在的，而与借阅相关的数据（`checkoutMember`、`dueReturnDate`等）被视为外在的。实际上，这意味着每个书籍属性组合只需要一个`Book`对象。仍然是相当数量的对象，但比之前少得多。
- en: 'An instance of the following book metadata combination will be created for
    all required copies of the book object with a particular title/ISBN:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 将为具有特定标题/ISBN的书籍对象的所有必需副本创建以下书籍元数据组合的实例：
- en: '[PRE49]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As we can see, the extrinsic states have been removed. Everything to do with
    library checkouts will be moved to a manager, and as the object data is now segmented,
    we can use a factory for instantiation.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，外在状态已被移除。所有与图书馆借阅相关的内容都将移到一个管理器中，而由于对象数据现在被分割了，我们可以使用工厂进行实例化。
- en: A Basic Factory
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本工厂
- en: 'Let’s now define a very basic factory. We will have it check if a book with
    a particular title has been previously created inside the system—if it has, we’ll
    return it; if not, a new book will be created and stored so that it can be accessed
    later. This ensures that we create only a single copy of each unique intrinsic
    piece of data:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义一个非常基本的工厂。我们将检查系统中是否已经创建了一个特定标题的书籍 —— 如果是，我们将返回它；如果没有，将创建并存储一个新书籍，以便稍后访问。这确保我们仅创建每个唯一的内在数据的单个副本：
- en: '[PRE50]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Managing the Extrinsic States
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理外在状态
- en: 'Next, we need to store the states that were removed from the `Book` objects
    somewhere—luckily, a manager (which we’ll be defining as a Singleton) can be used
    to encapsulate them. Combinations of a `Book` object and the library member who’s
    checked it out will be called `Book` record. Our manager will be storing both
    and will include checkout-related logic we stripped out during our Flyweight optimization
    of the `Book` class:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将从`Book`对象中移除的状态存储在某个地方 —— 幸运的是，我们可以使用管理器（我们将其定义为单例）来封装它们。`Book`对象和已借阅它的图书馆成员的组合将被称为`Book`记录。我们的管理器将同时存储这两者，并包括我们在`Book`类的轻量级优化期间剥离的借阅相关逻辑：
- en: '[PRE51]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The result of these changes is that all of the data extracted from the `Book`
    *class* is now being stored in an attribute of the `BookManager` Singleton (`BookDatabase`)—something
    considerably more efficient than the large number of objects we were previously
    using. Methods related to book checkouts are also now based here as they deal
    with extrinsic rather than intrinsic data.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改的结果是，从`Book` *类*提取的所有数据现在都存储在`BookManager`单例（`BookDatabase`）的一个属性中 —— 比我们之前使用的大量对象效率要高得多。与书籍借出相关的方法现在也基于此处，因为它们处理的是外部而不是内在的数据。
- en: This process does add a little complexity to our final solution. However, it’s
    a minor concern compared to the performance issues that we have tackled. Data-wise,
    if we have 30 copies of the same book, we are now storing it only once. Also,
    every function takes up memory. With the Flyweight pattern, these functions exist
    in one place (on the manager) and not on every object, thus saving on memory use.
    For the unoptimized version of Flyweight mentioned previously, we store just a
    link to the function object as we used the `Book` constructor’s prototype. Still,
    if we implemented it another way, functions would be created for every book instance.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程确实给我们的最终解决方案增加了一些复杂性。但是，与我们解决的性能问题相比，这只是一个小问题。数据方面，如果我们有30本相同的书，现在我们只存储一本。此外，每个函数占用内存。使用轻量级模式，这些函数存在于一个地方（管理器上），而不是每个对象上，从而节省了内存使用。对于之前提到的未优化版本的轻量级模式，我们仅存储对函数对象的引用，因为我们使用了`Book`构造函数的原型。尽管如此，如果我们以另一种方式实现它，函数将为每个书本实例创建。
- en: The Flyweight Pattern and the DOM
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 轻量级模式与DOM
- en: The DOM supports two approaches that allow objects to detect events—either top-down
    (event capture) or bottom-up (event bubbling).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: DOM支持两种方法来使对象检测事件——自顶向下（事件捕获）或自底向上（事件冒泡）。
- en: In event capture, the event is first captured by the outer-most element and
    propagated to the inner-most element. In event bubbling, the event is captured
    and given to the inner-most element and then propagated to the outer elements.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件捕获中，事件首先由最外层元素捕获并传播到最内层元素。在事件冒泡中，事件被捕获并传递给最内层元素，然后冒泡到外部元素。
- en: 'Gary Chisholm wrote one of the best metaphors for describing Flyweights in
    this context, and it goes a little like this:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 加里·奇索姆在描述这个背景下的轻量级模式时写了一个最好的隐喻，大致如下：
- en: Try to think of the flyweight in terms of a pond. A fish opens its mouth (the
    event), bubbles rise to the surface (the bubbling), a fly sitting on the top flies
    away when the bubble reaches the surface (the action). In this example we can
    easily transpose the fish opening its mouth to a button being clicked, the bubbles
    as the bubbling effect, and the fly flying away to some function being run.
  id: totrans-373
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尝试将轻量级模式比喻为一个池塘。鱼张开嘴（事件），气泡上升到水面（冒泡），顶上的苍蝇在气泡达到水面时飞走（动作）。在这个例子中，我们可以轻松地将鱼张开嘴转换为按钮被点击，气泡为冒泡效果，苍蝇飞走为某个函数被执行。
- en: Bubbling was introduced to handle situations in which a single event (e.g.,
    a `click`) may be handled by multiple event handlers defined at different levels
    of the DOM hierarchy. Where this happens, event bubbling executes event handlers
    defined for specific elements at the lowest level possible. From there on, the
    event bubbles up to containing elements before going to those even higher up.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 冒泡是为了处理单个事件（例如`click`）可能由DOM层次结构中不同级别定义的多个事件处理程序处理的情况引入的。当发生这种情况时，事件冒泡会执行在最低可能级别为特定元素定义的事件处理程序，然后事件冒泡到包含元素，最终到达更高级别的元素。
- en: 'Flyweights can be used to further tweak the event-bubbling process, as we will
    see in [“Example: Centralized Event Handling”](#example_centralized_event_handling).'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 轻量级模式可以用来进一步调整事件冒泡过程，正如我们将在[“示例：集中式事件处理”](#example_centralized_event_handling)中看到的那样。
- en: 'Example: Centralized Event Handling'
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例：集中式事件处理
- en: For our first practical example, imagine we have several similar elements in
    a document with similar behavior executed when a user action (e.g., click, mouse-over)
    is performed against them.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，假设我们在文档中有几个类似的元素，当用户执行某个操作（例如点击、悬停）时，会执行类似的行为。
- en: Usually, when constructing our accordion component, menu, or other list-based
    widgets, we bind a `click` event to each link element in the parent container
    (e.g., `$('ul li a').on(…​)`). Instead of binding the click to multiple elements,
    we can easily attach a Flyweight to the top of our container, which can listen
    for events coming from below. These can then be handled using logic as simple
    or complex as required.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在构建手风琴组件、菜单或其他基于列表的小部件时，我们会将`click`事件绑定到父容器中每个链接元素上（例如，`$('ul li a').on(…​)`）。而不是将点击事件绑定到多个元素，我们可以轻松地将一个轻量级对象附加到容器顶部，它可以监听来自下方的事件。这些事件可以使用简单或复杂的逻辑来处理。
- en: As the types of components mentioned often have the same repeating markup for
    each section (e.g., each section of an accordion), there’s a good chance the behavior
    of each element clicked will be pretty similar and relative to similar classes
    nearby. We’ll use this information to construct a basic accordion using the Flyweight
    in [Example 7-6](#centralized_event_handling).
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所提到的组件类型通常具有相同的重复标记，例如手风琴的每个部分，因此有很大可能每个元素被点击时的行为将是相似的，并与附近的相似类相关。我们将利用这些信息来使用享元在[示例
    7-6](#centralized_event_handling) 中构建一个基本的手风琴。
- en: A `stateManager` namespace is used here to encapsulate our Flyweight logic,
    while jQuery is used to bind the initial click to a container `div`. An `unbind`
    event is first applied to ensure that no other logic on the page attaches similar
    handles to the container.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用`stateManager`命名空间来封装我们的享元逻辑，同时使用jQuery将初始点击绑定到一个容器`div`上。首先应用`unbind`事件以确保页面上没有其他逻辑将类似的处理程序附加到容器上。
- en: To establish exactly what child element in the container is clicked, we use
    a `target` check, which provides a reference to the element that was clicked,
    regardless of its parent. We then use this information to handle the `click` event
    without actually needing to bind the event to specific children when our page
    loads.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确立点击容器中的哪个子元素，我们使用`target`检查，它提供了对被点击元素的引用，而不管其父元素如何。然后，我们利用这些信息处理`click`事件，而无需在页面加载时将事件绑定到特定的子元素上。
- en: Example 7-6\. Centralized event handling
  id: totrans-382
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-6\. 集中式事件处理
- en: '[PRE52]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The benefit here is that we’re converting many independent actions into shared
    ones (potentially saving on memory).
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的好处在于，我们将许多独立的操作转换为共享的操作（潜在地节省内存）。
- en: Behavioral Patterns
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为模式
- en: Behavioral patterns help define the communication between objects. They help
    to improve or streamline the communication between disparate objects in a system.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 行为模式有助于定义对象之间的通信。它们有助于改进或简化系统中分散对象之间的通信。
- en: 'Following are the JavaScript behavioral patterns that we will discuss in this
    section:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将在本节讨论的JavaScript行为模式：
- en: '[“The Observer Pattern”](#the-observer-pattern)'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“观察者模式”](#the-observer-pattern)'
- en: '[“The Mediator Pattern”](#the-mediator-pattern)'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“中介者模式”](#the-mediator-pattern)'
- en: '[“The Command Pattern”](#the-command-pattern)'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“命令模式”](#the-command-pattern)'
- en: The Observer Pattern
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者模式
- en: The Observer pattern allows you to notify one object when another object changes
    without requiring the object to know about its dependents. Often this is a pattern
    where an object (known as a subject) maintains a list of objects depending on
    it (observers), automatically notifying them of any changes to its state. In modern
    frameworks, the Observer pattern is used to inform components of state changes.
    [Figure 7-9](#observer) illustrates this.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式允许在一个对象改变时通知另一个对象，而无需该对象知道其依赖项。通常，这是一个模式，其中一个对象（称为主题）维护一个依赖于它的对象列表（观察者），自动通知它们其状态的任何更改。在现代框架中，观察者模式用于通知组件状态变化。[图7-9](#observer)
    说明了这一点。
- en: '![ljd2 0709](Images/ljd2_0709.png)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![ljd2 0709](Images/ljd2_0709.png)'
- en: Figure 7-9\. Observer pattern
  id: totrans-395
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-9\. 观察者模式
- en: When a subject needs to notify observers about something interesting happening,
    it broadcasts a notification to the observers (which can include specific data
    related to the topic). When an observer no longer wishes to be notified of changes
    by the subject, they can be removed from the list of observers.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个主题需要通知观察者发生的有趣事件时，它会向观察者广播一个通知（可以包含与主题相关的特定数据）。当观察者不再希望由主题通知其变化时，它们可以从观察者列表中移除。
- en: 'It’s helpful to refer back to published definitions of design patterns that
    are language agnostic to get a broader sense of their usage and advantages over
    time. The definition of the Observer pattern provided in the GoF book, *Design
    Patterns: Elements of Reusable Object-Oriented Software*, is:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 查看发布的与语言无关的设计模式定义有助于更广泛地了解它们的使用和优势。在GoF书籍《设计模式：可复用面向对象软件的元素》中提供的观察者模式的定义是：
- en: One or more observers are interested in the state of a subject and register
    their interest with the subject by attaching themselves. When something changes
    in our subject that the observer may be interested in, a notify message is sent
    which calls the update method in each observer. When the observer is no longer
    interested in the subject’s state, they can simply detach themselves.
  id: totrans-398
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个或多个观察者对主题的状态感兴趣，并通过附加自己来向主题注册他们的兴趣。当我们的主题发生变化时，观察者可能感兴趣的事情，会发送一个通知消息，调用每个观察者的更新方法。当观察者不再对主题的状态感兴趣时，他们可以简单地分离自己。
- en: 'We can now expand on what we’ve learned to implement the Observer pattern with
    the following components:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以扩展我们学到的内容，使用以下组件来实现观察者模式：
- en: Subject
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 主题
- en: Maintains a list of observers, facilitates adding or removing observers
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 维护观察者列表，方便添加或移除观察者。
- en: Observer
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者
- en: Provides an `update` interface for objects that need to be notified of a Subject’s
    changes in state
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了一个`update`接口，用于需要被通知主题状态变化的对象。
- en: '`ConcreteSubject`'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcreteSubject`'
- en: Broadcasts notifications to observers on changes of state, stores the state
    of `ConcreteObservers`
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在状态变化时向观察者广播通知，存储`ConcreteObservers`的状态。
- en: '`ConcreteObserver`'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcreteObserver`'
- en: Stores a reference to the `ConcreteSubject`, implements an `update` interface
    for the observer to ensure the state is consistent with the Subject’s
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 存储对`ConcreteSubject`的引用，为观察者实现`update`接口，以确保状态与主题保持一致。
- en: ES2015+ allows us to implement the Observer pattern using JavaScript classes
    for observers and subjects with methods for `notify` and `update`.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: ES2015+允许我们使用JavaScript类来实现观察者模式，这些类具有用于`notify`和`update`的方法。
- en: 'First, let’s model the list of dependent observers a subject may have using
    the `ObserverList` class:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用`ObserverList`类模型化主题可能具有的依赖观察者列表：
- en: '[PRE54]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Next, let’s model the `Subject` class that can add, remove, or notify observers
    on the observer list:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们模拟可以向观察者列表添加、删除或通知观察者的`Subject`类：
- en: '[PRE55]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We then define a skeleton for creating new observers. We will overwrite the
    `Update` functionality here later with custom behavior:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们定义一个创建新观察者的框架。稍后我们将在这里用自定义行为重写`Update`功能：
- en: '[PRE56]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In our sample application using the previous observer components, we now define:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用之前的观察者组件的示例应用程序中，现在我们定义：
- en: A button for adding new observable checkboxes to the page.
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于向页面添加新可观察复选框的按钮。
- en: A control checkbox will act as a subject, notifying other checkboxes that they
    should update to the checked state.
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制复选框将作为主题，通知其他复选框它们应更新为选中状态。
- en: A container for the new checkboxes added.
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新添加的复选框的容器。
- en: We then define `ConcreteSubject` and `ConcreteObserver` handlers to add new
    observers to the page and implement the updating interface. For this, we use inheritance
    to extend our subject and observer classes. The `ConcreteSubject` class encapsulates
    a checkbox and generates a notification when the main checkbox is clicked. `ConcreteObserver`
    encapsulates each of the observing checkboxes and implements the `Update` interface
    by changing the checked value of the checkboxes. What follows are the inline comments
    on how these work together in the context of our example.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们定义`ConcreteSubject`和`ConcreteObserver`处理程序，以添加新观察者到页面并实现更新接口。为此，我们使用继承来扩展我们的主题和观察者类。`ConcreteSubject`类封装了一个复选框，并在主复选框点击时生成通知。`ConcreteObserver`封装了每个观察复选框，并通过改变复选框的选中值来实现`Update`接口。接下来是关于这些如何在我们的示例中一起工作的内联注释。
- en: 'Here is the HTML code:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是HTML代码：
- en: '[PRE57]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Here is an example:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例：
- en: '[PRE58]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In this example, we looked at how to implement and utilize the Observer pattern,
    covering the concepts of a Subject, Observer, `ConcreteSubject`, and `ConcreteObserver`.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们看了如何实现和利用观察者模式，涵盖了主题、观察者、`ConcreteSubject`和`ConcreteObserver`的概念。
- en: Differences Between the Observer and Publish/Subscribe Pattern
  id: totrans-425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 观察者模式与发布/订阅模式之间的区别
- en: While it’s helpful to be aware of the Observer pattern, quite often in the JavaScript
    world, we’ll find it commonly implemented using a variation known as the Publish/Subscribe
    pattern. Although the two patterns are pretty similar, there are differences worth
    noting.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然了解观察者模式很有帮助，但在JavaScript世界中，我们经常会发现它通常使用一种称为发布/订阅模式的变体来实现。虽然这两种模式非常相似，但有值得注意的区别。
- en: The Observer pattern requires that the observer (or object) wishing to receive
    topic notifications must subscribe this interest to the object firing the event
    (the subject), as seen in [Figure 7-10](#pubsub).
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式要求希望接收主题通知的观察者（或对象）必须向触发事件的对象（主体）订阅此兴趣，如[图 7-10](#pubsub)所示。
- en: '![ljd2 0710](Images/ljd2_0710.png)'
  id: totrans-428
  prefs: []
  type: TYPE_IMG
  zh: '![ljd2 0710](Images/ljd2_0710.png)'
- en: Figure 7-10\. Publish/Subscribe
  id: totrans-429
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-10\. 发布/订阅
- en: The Publish/Subscribe pattern, however, uses a topic/event channel that sits
    between the objects wishing to receive notifications (subscribers) and the object
    firing the event (the publisher). This event system allows code to define application-specific
    events, which can pass custom arguments containing values needed by the subscriber.
    The idea here is to avoid dependencies between the subscriber and publisher.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，发布/订阅模式使用一个位于希望接收通知的对象（订阅者）和触发事件的对象（发布者）之间的主题/事件通道。该事件系统允许代码定义特定于应用程序的事件，这些事件可以传递包含订阅者所需值的自定义参数。这里的想法是避免订阅者和发布者之间的依赖关系。
- en: This differs from the Observer pattern because it allows any subscriber implementing
    an appropriate event handler to register for and receive topic notifications broadcast
    by the publisher.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 这与观察者模式不同，因为它允许任何实现适当事件处理程序的订阅者注册并接收发布者广播的主题通知。
- en: 'Here is an example of how one might use the Publish/Subscribe pattern if provided
    with a functional implementation powering `publish()`, `subscribe()`, and `unsubscribe()`
    behind the scenes:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例，展示了如果提供了功能实现来支持`publish()`、`subscribe()`和`unsubscribe()`，一个可能如何使用发布/订阅模式：
- en: '[PRE59]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The general idea here is the promotion of loose coupling. Rather than single
    objects calling on the methods of other objects directly, they instead subscribe
    to a specific task or activity of another object and are notified when it occurs.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的总体思想是促进松散耦合。与单个对象直接调用其他对象方法不同，它们订阅另一个对象的特定任务或活动，并在其发生时得到通知。
- en: Advantages
  id: totrans-435
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优点
- en: The Observer and Publish/Subscribe patterns encourage us to think hard about
    the relationships between different application parts. They also help us identify
    layers containing direct relationships that could be replaced with sets of subjects
    and observers. This effectively could be used to break down an application into
    smaller, more loosely coupled blocks to improve code management and potential
    for reuse.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者和发布/订阅模式鼓励我们深思不同应用程序部分之间的关系。它们还帮助我们识别包含直接关系的层，可以用一组主体和观察者替换。这实际上可以用来将应用程序分解为更小、更松散耦合的块，以改进代码管理和重用潜力。
- en: Further motivation for using the Observer pattern is in situations where we
    need to maintain consistency between related objects without making classes tightly
    coupled. For example, when an object needs to be able to notify other objects
    without making assumptions regarding those objects.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 使用观察者模式的进一步动机在于在不使类紧密耦合的情况下，需要保持相关对象之间的一致性。例如，当对象需要能够通知其他对象而不对这些对象进行假设时。
- en: Dynamic relationships can exist between observers and subjects when using either
    pattern. This provides excellent flexibility that may not be as easy to implement
    when disparate parts of our application are tightly coupled.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用任一模式时，观察者和主体之间可以存在动态关系。这提供了极大的灵活性，可能在应用程序的不同部分紧密耦合时不容易实现。
- en: While it may not always be the best solution to every problem, these patterns
    remain one of the best tools for designing decoupled systems and should be considered
    an essential tool in any JavaScript developer’s utility belt.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它可能并非每个问题的最佳解决方案，但这些模式仍然是设计解耦系统的最佳工具之一，应被视为任何 JavaScript 开发者工具箱中的重要工具。
- en: Disadvantages
  id: totrans-440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缺点
- en: Consequently, some of the issues with these patterns actually stem from their
    main benefits. In Publish/Subscribe, by decoupling publishers from subscribers,
    it can sometimes become difficult to obtain guarantees that particular parts of
    our applications are functioning as we may expect.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这些模式的一些问题实际上源于它们的主要优势。在发布/订阅中，通过解耦发布者和订阅者，有时可能难以获得我们期望的应用程序特定部分正常运行的保证。
- en: For example, publishers may assume that one or more subscribers are listening
    to them. Say that we’re using such an assumption to log or output errors regarding
    some application process. If the subscriber performing the logging crashes (or
    for some reason fails to function), the publisher won’t have a way of seeing this
    due to the decoupled nature of the system.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，发布者可以假设有一个或多个订阅者在监听它们。假设我们使用这样的假设来记录或输出关于某些应用程序过程的错误。如果执行日志记录的订阅者崩溃（或因某种原因无法正常工作），则由于系统的解耦性质，发布者将无法看到这一点。
- en: Another drawback of the pattern is that subscribers are entirely ignorant of
    the existence of each other and are blind to the cost of switching publishers.
    Due to the dynamic relationship between subscribers and publishers, it can be
    difficult to track an update dependency.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 该模式的另一个缺点是订阅者完全不知道彼此的存在，并且对于切换发布者的成本一无所知。由于订阅者和发布者之间的动态关系，追踪更新依赖关系可能很困难。
- en: Publish/Subscribe Implementations
  id: totrans-444
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布/订阅实现
- en: Publish/Subscribe fits in very well in JavaScript ecosystems, primarily because,
    at the core, ECMAScript implementations are event-driven. This is particularly
    true in browser environments, as the DOM uses events as its main interaction API
    for scripting.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 发布/订阅在JavaScript生态系统中非常适用，主要是因为在核心上，ECMAScript实现是事件驱动的。这在浏览器环境中尤其如此，因为DOM使用事件作为其主要交互API来进行脚本化。
- en: That said, neither ECMAScript nor DOM provides core objects or methods for creating
    custom event systems in implementation code (except for perhaps the DOM3 `CustomEvent`,
    which is bound to the DOM and is thus not generically applicable).
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，ECMAScript和DOM都没有提供用于在实现代码中创建自定义事件系统的核心对象或方法（除了可能是绑定到DOM的DOM3 `CustomEvent`，因此并不普遍适用）。
- en: An example Publish/Subscribe implementation
  id: totrans-447
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个示例的发布/订阅实现
- en: To better appreciate how many of the ordinary JavaScript implementations of
    the Observer pattern might work, let’s take a walkthrough of a minimalist version
    of Publish/Subscribe I released on GitHub under a project called [“pubsubz”](https://oreil.ly/yPPfE).
    This demonstrates the core concepts of subscribe and publish, and the idea of
    unsubscribing.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解观察者模式的普通JavaScript实现可能如何工作，让我们浏览我在GitHub上发布的一个名为“pubsubz”的项目中的一个简化版本。这展示了订阅和发布的核心概念，以及取消订阅的想法。
- en: 'I’ve opted to base our examples on this code as it sticks closely to the method
    signatures and implementation approach I expect to see in a JavaScript version
    of the classic Observer pattern:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择基于这段代码来示范，因为它与我期望在经典观察者模式的JavaScript版本中看到的方法签名和实现方法非常接近。
- en: '[PRE60]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Here we have defined a basic `PubSub` class that contains:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们定义了一个基本的 `PubSub` 类，其中包含：
- en: A list of topics with subscribers who have subscribed to it.
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个带有已订阅的订阅者列表的主题列表。
- en: The `Subscribe` method creates a new subscriber to a topic using the function
    to be called when publishing a topic and a unique token.
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Subscribe` 方法通过使用发布主题时调用的函数和唯一令牌来创建一个新的主题订阅者。'
- en: The `Unsubscribe` method removes a subscriber from the list based on the `token`
    value passed. The `Publish` method publishes content on a given topic to all its
    subscribers by calling the `registered` function.
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Unsubscribe` 方法根据传递的 `token` 值从列表中删除订阅者。`Publish` 方法通过调用 `registered` 函数向给定主题的所有订阅者发布内容。'
- en: Using our implementation
  id: totrans-455
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用我们的实现
- en: We can now use the implementation to publish and subscribe to events of interest,
    as shown in [Example 7-7](#using-our-implementation).
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用该实现来发布和订阅感兴趣的事件，如在[示例 7-7](#using-our-implementation)中所示。
- en: Example 7-7\. Using our implementation
  id: totrans-457
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-7. 使用我们的实现
- en: '[PRE61]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: UI notifications
  id: totrans-459
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UI 通知
- en: Next, let’s imagine we have a web application responsible for displaying real-time
    stock information.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们想象我们有一个负责显示实时股票信息的网络应用程序。
- en: The application might have a grid displaying the stock stats and a counter indicating
    the last update point. The application must update the grid and counter when the
    data model changes. In this scenario, our subject (which will be publishing topics/notifications)
    is the data model, and our subscribers are the grid and counter.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可能有一个显示股票统计数据的网格和一个指示最后更新点的计数器。当数据模型发生变化时，应用程序必须更新网格和计数器。在这种情况下，我们的主题（将发布主题/通知）是数据模型，而我们的订阅者是网格和计数器。
- en: When our subscribers are notified that the model has changed, they can update
    themselves accordingly.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的订阅者收到模型已更改的通知时，它们可以相应地更新自己。
- en: In our implementation, our subscriber will listen to the topic `newDataAvailable`
    to find out if new stock information is available. If a new notification is published
    to this topic, it will trigger `gridUpdate` to add a new row to our grid containing
    this information. It will also update the *last updated* counter to log the last
    time that data was added ([Example 7-8](#user-interface-notifications)).
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的实现中，我们的订阅者将监听主题`newDataAvailable`，以了解是否有新的股票信息可用。如果向此主题发布新通知，它将触发`gridUpdate`以向我们的网格添加包含此信息的新行。它还将更新*上次更新*计数器以记录添加数据的最后时间（[示例 7-8](#user-interface-notifications)）。
- en: Example 7-8\. UI notifications
  id: totrans-464
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例7-8. UI通知
- en: '[PRE62]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Decoupling applications using Ben Alman’s Pub/Sub implementation
  id: totrans-466
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用**Ben Alman**的Pub/Sub实现解耦应用程序
- en: In the following movie rating example, we’ll use [Ben Alman’s jQuery implementation
    of Publish/Subscribe](https://oreil.ly/w9ECl) to demonstrate how we can decouple
    a UI. Notice how submitting a rating only has the effect of publishing the fact
    that new user and rating data is available.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下电影评级示例中，我们将使用[Ben Alman的jQuery发布/订阅实现](https://oreil.ly/w9ECl)演示如何解耦UI。注意，提交评级仅导致发布新用户和评级数据可用的事实。
- en: It’s left up to the subscribers to those topics to delegate what happens with
    that data. In our case, we’re pushing that new data into existing arrays and then
    rendering them using the Lodash library’s `.template()` method for templating.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 由订阅者来委托数据发生了什么。在我们的情况下，我们将新数据推送到现有数组中，然后使用Lodash库的`.template()`方法进行模板化渲染。
- en: '[Example 7-9](#html-templates-code) has the HTML/Templates code.'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 7-9](#html-templates-code)包含HTML/模板代码。'
- en: Example 7-9\. HTML/Templates code for Pub/Sub
  id: totrans-470
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例7-9. Pub/Sub的HTML/模板代码
- en: '[PRE63]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The JavaScript code is in [Example 7-10](#the-javascript-code).
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript代码在[示例 7-10](#the-javascript-code)中。
- en: Example 7-10\. JavaScript code for Pub/Sub
  id: totrans-473
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例7-10. Pub/Sub的JavaScript代码
- en: '[PRE64]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Decoupling an Ajax-based jQuery application
  id: totrans-475
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解耦基于Ajax的jQuery应用程序
- en: In our final example, we’ll take a practical look at how decoupling our code
    using Pub/Sub early in the development process can save us some potentially painful
    refactoring later.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的最后一个例子中，我们将实际看看如何在开发过程的早期使用Pub/Sub解耦我们的代码，这样可以在后期节省一些可能痛苦的重构。
- en: Often in Ajax-heavy applications, we want to achieve more than just one unique
    action once we’ve received a response to a request. We could add all of the post-request
    logic into a success callback, but there are drawbacks to this approach.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ajax密集型应用程序中，我们经常希望在收到请求的响应后执行不止一个独特的操作。我们可以将所有后请求逻辑添加到成功回调中，但这种方法存在缺点。
- en: Highly coupled applications sometimes increase the effort required to reuse
    functionality due to the increased interfunction/code dependency. Keeping our
    post-request logic hardcoded in a callback might be okay if we just try to grab
    a result set once. However, it’s not as appropriate when we want to make further
    Ajax calls to the same data source (and different end behavior) without rewriting
    parts of the code multiple times. Rather than going back through each layer that
    calls the same data source and generalizing them later on, we can use Pub/Sub
    from the start and save time.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 高度耦合的应用程序有时会增加重复使用功能所需的工作量，因为增加了函数/代码依赖性。如果我们只是尝试一次抓取结果集，将我们的后请求逻辑硬编码在回调中可能还可以。但是，当我们希望对相同数据源进行进一步的Ajax调用（和不同的结束行为）而不是多次重写代码的部分时，这种方法就不太合适了。与其稍后回到每个调用相同数据源的层并将它们概括起来，我们可以从一开始就使用Pub/Sub并节省时间。
- en: Using observers, we can also easily separate application-wide notifications
    regarding different events down to whatever level of granularity we’re comfortable
    with—something that can be less elegantly done using other patterns.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 使用观察者，我们还可以轻松地将应用程序范围内关于不同事件的通知分离到我们舒适的任何粒度——这是使用其他模式可能不太优雅的事情。
- en: Notice how in our upcoming sample, one topic notification is made when a user
    indicates that he wants to make a search query. Another is made when the request
    returns and actual data is available for consumption. It’s left up to the subscribers
    to then decide how to use knowledge of these events (or the data returned). The
    benefits of this are that, if we wanted, we could have 10 different subscribers
    using the data returned in different ways, but as far as the Ajax layer is concerned,
    it doesn’t care. Its sole duty is to request and return data and then pass it
    on to whoever wants to use it. This separation of concerns can make the overall
    design of our code a little cleaner.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在我们即将介绍的示例中，当用户表明他想进行搜索查询时，会进行一个主题通知。当请求返回并且实际数据可供使用时，会进行另一个通知。然后，决定如何使用这些事件（或返回的数据）留给订阅者。其中的好处是，如果我们愿意，我们可以有10个不同的订阅者以不同的方式使用返回的数据，但对于
    Ajax 层来说，它并不关心。它唯一的职责是请求和返回数据，然后将其传递给想要使用它的人。这种关注点的分离可以使我们的代码整体设计更加清晰。
- en: The HTML/Templates code is shown in [Example 7-11](#html-templates-ajax).
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: HTML/模板代码显示在[示例 7-11](#html-templates-ajax)中。
- en: Example 7-11\. HTML/Templates code for Ajax
  id: totrans-482
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-11\. Ajax 的 HTML/模板代码
- en: '[PRE65]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[Example 7-12](#javascript-code-ajax) shows the JavaScript code.'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 7-12](#javascript-code-ajax)展示了 JavaScript 代码。'
- en: Example 7-12\. JavaScript code for Ajax
  id: totrans-485
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-12\. Ajax 的 JavaScript 代码
- en: '[PRE66]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Observer pattern in the React ecosystem
  id: totrans-487
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: React 生态系统中的观察者模式
- en: 'A popular library that uses the observable pattern is RxJS. The RxJS [documentation](https://oreil.ly/JH3lY)
    states that:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 使用观察者模式的一个流行库是 RxJS。RxJS 的[文档](https://oreil.ly/JH3lY)指出：
- en: ReactiveX combines the Observer pattern with the Iterator pattern and functional
    programming with collections to fill the need for an ideal way of managing sequences
    of events.
  id: totrans-489
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ReactiveX 将观察者模式与迭代器模式和函数式编程与集合相结合，以填补管理事件序列的理想方式的需求。
- en: 'With RxJS, we can create observers and subscribe to certain events! Let’s look
    at an example from their documentation, which logs whether a user was dragging
    in the document:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 RxJS，我们可以创建观察者并订阅特定事件！让我们看看他们文档中的一个示例，它记录用户是否在文档中拖动：
- en: '[PRE67]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The Observer pattern helps decouple several different scenarios in application
    design. If you haven’t been using it, I recommend picking up one of the prewritten
    implementations mentioned here and giving it a try. It’s one of the easier design
    patterns to get started with but also one of the most powerful.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式有助于解耦应用程序设计中的几种不同场景。如果你还没有使用过，我建议从这里提到的预写实现中选择一个并尝试一下。这是其中一个更容易入门但也是最强大的设计模式之一。
- en: The Mediator Pattern
  id: totrans-493
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中介者模式
- en: The Mediator pattern is a design pattern that allows one object to notify a
    set of other objects when an event occurs. The difference between the Mediator
    and Observer patterns is that the Mediator pattern allows one object to be notified
    of events that occur in other objects. In contrast, the Observer pattern allows
    one object to subscribe to multiple events that occur in other objects.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 中介者模式是一种设计模式，允许一个对象在事件发生时通知一组其他对象。中介者模式与观察者模式的区别在于，中介者模式允许一个对象被通知其他对象中发生的事件。相反，观察者模式允许一个对象订阅其他对象中发生的多个事件。
- en: In the section on the Observer pattern, we discussed a way of channeling multiple
    event sources through a single object. This is also known as Publish/Subscribe
    or Event Aggregation. It’s common for developers to think of mediators when faced
    with this problem, so let’s explore how they differ.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 在观察者模式的部分中，我们讨论了通过单个对象传递多个事件源的方法。这也被称为发布/订阅或事件聚合。当开发人员面对这个问题时，通常会考虑中介者，所以让我们来探讨它们的不同之处。
- en: The dictionary refers to a mediator as a neutral party that assists in negotiations
    and conflict resolution.^([1](ch07.xhtml#idm45017700219792)) In our world, a mediator
    is a behavioral design pattern that allows us to expose a unified interface through
    which the different parts of a system may communicate.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 字典将中介者称为协助协商和冲突解决的中立方。^([1](ch07.xhtml#idm45017700219792)) 在我们的世界中，中介者是一种行为设计模式，允许我们通过一个统一的接口公开系统中的不同部分之间的通信。
- en: If it appears that a system has too many direct relationships between components,
    it may be time to have a central point of control that components communicate
    through instead. The mediator promotes loose coupling by ensuring that interactions
    between components are managed centrally instead of having components refer to
    each other explicitly. This can help us decouple systems and improve the potential
    for component reusability.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个系统中存在过多的组件直接关系，那么有必要通过一个中心控制点来进行通信。中介者通过确保组件之间的交互集中管理，而不是显式地相互引用，来促进松耦合。这可以帮助我们解耦系统并提高组件可重用性的潜力。
- en: A real-world analogy could be a typical airport traffic control system. A tower
    (mediator) handles what planes can take off and land because all communications
    (notifications being listened out for or broadcast) take place from the aircraft
    to the control tower rather than from plane to plane. A centralized controller
    is key to the success of this system, and that’s the role a mediator plays in
    software design ([Figure 7-11](#mediator)).
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 一个现实世界的类比可以是典型的机场交通管制系统。控制塔（中介者）负责决定哪些飞机可以起飞和降落，因为所有通信（监听或广播的通知）都是从飞机到控制塔的，而不是从飞机到飞机。中心化的控制器是该系统成功的关键，这就是中介者在软件设计中扮演的角色（[图7-11](#mediator)）。
- en: '![ljd2 0711](Images/ljd2_0711.png)'
  id: totrans-499
  prefs: []
  type: TYPE_IMG
  zh: '![ljd2 0711](Images/ljd2_0711.png)'
- en: Figure 7-11\. Mediator pattern
  id: totrans-500
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-11\. 中介者模式
- en: Another analogy would be DOM event bubbling and event delegation. If all subscriptions
    in a system are made against the document rather than individual nodes, the document
    effectively serves as a Mediator. Instead of binding to the events of the individual
    nodes, a higher-level object is given the responsibility of notifying subscribers
    about interaction events.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个类比可以是 DOM 事件冒泡和事件委托。如果系统中的所有订阅都针对文档而不是单个节点进行，则文档实际上充当了一个中介者。高级别对象负责通知订阅者有关交互事件的发生，而不是绑定到单个节点的事件。
- en: When it comes to the Mediator and Event Aggregator patterns, sometimes it may
    look like the patterns are interchangeable due to implementation similarities.
    However, the semantics and intent of these patterns are very different.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到中介者模式和事件聚合器模式时，有时由于实现的相似性，这些模式可能看起来可以互换使用。然而，这些模式的语义和意图是非常不同的。
- en: And even if the implementations both use some of the same core constructs, I
    believe there is a distinct difference between them. They should not be interchanged
    or confused in communication because of their differences.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 即使两者的实现都使用了一些相同的核心构造，我相信它们之间存在着明显的差异。它们不应该在交流中互换或混淆，因为它们的差异。
- en: A Simple Mediator
  id: totrans-504
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个简单的中介者
- en: A mediator is an object that coordinates interactions (logic and behavior) between
    multiple objects. It decides when to call which objects based on the actions (or
    inaction) of other objects and input.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 中介者是一个协调多个对象之间交互（逻辑和行为）的对象。它根据其他对象的动作（或不动作）和输入决定何时调用哪些对象。
- en: 'You can write a mediator using a single line of code:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用一行代码编写一个中介者：
- en: '[PRE68]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Yes, of course, this is just an object literal in JavaScript. Once again, we’re
    talking about semantics here. The mediator’s purpose is to control the workflow
    between objects; we really don’t need anything more than an object literal to
    do this.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只是 JavaScript 中的一个对象字面量。再次强调，我们在谈论语义。中介者的目的是控制对象之间的工作流程；我们实际上不需要比一个对象字面量更多的东西来实现这一点。
- en: 'The following example shows a basic implementation of a `mediator` object with
    some utility methods that can trigger and subscribe to events. The `orgChart`
    object here is a mediator that assigns actions to be taken on the occurrence of
    a particular event. Here, a manager is assigned to the employee on completing
    the details of a new employee, and the employee record is saved:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了一个`mediator`对象的基本实现，其中包含一些触发和订阅事件的实用方法。这里的`orgChart`对象是一个中介者，它在发生特定事件时分配要执行的操作。在此，经理在完成新雇员的详细信息时分配给员工，并保存员工记录：
- en: '[PRE69]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: I’ve often referred to this type of object as a “workflow” object in the past,
    but the truth is that it is a mediator. It is an object that handles the workflow
    between many other objects, aggregating the responsibility of that workflow knowledge
    into a single object. The result is a workflow that is easier to understand and
    maintain.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 我过去经常将这种对象称为“工作流”对象，但事实上它是一个中介者。它是一个处理多个其他对象之间工作流的对象，将工作流知识的责任聚合到一个对象中。结果是一个更容易理解和维护的工作流。
- en: Similarities and Differences
  id: totrans-512
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相似性和差异
- en: 'There are, without a doubt, similarities between the event aggregator and mediator
    examples that I’ve shown here. The similarities boil down to two primary items:
    events and third-party objects. These differences are superficial at best, though.
    When we dig into the pattern’s intent and see that the implementations can be
    dramatically different, the nature of the patterns becomes more apparent.'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 无疑，在我展示的事件聚合器和中介者示例之间存在相似之处。这些相似之处归结为两个主要内容：事件和第三方对象。但这些差异充其量只是表面上的。当我们深入研究模式的意图并看到实现可能截然不同时，这些模式的本质就更为明显了。
- en: Events
  id: totrans-514
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件
- en: Both the event aggregator and mediator use events in the examples shown. An
    event aggregator obviously deals with events—it’s in the name, after all. The
    mediator only uses events because it makes life easy when dealing with modern
    JavaScript web app frameworks. There is nothing that says a mediator must be built
    with events. You can build a mediator with callback methods by handing the mediator
    reference to the child object or using several other means.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 展示的示例中，事件聚合器和中介者都使用事件。显然，事件聚合器处理事件——毕竟名字就是这样。中介者只是因为在处理现代JavaScript Web应用程序框架时使用事件会更方便。没有任何东西说中介者必须使用事件构建。您可以通过将中介者引用传递给子对象或使用其他几种方法来使用回调方法构建中介者。
- en: The difference, then, is why these two patterns are both using events. The event
    aggregator, as a pattern, is designed to deal with events. The mediator, though,
    uses them only because it’s convenient.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这两种模式为何都使用事件的差异在于。作为一种模式，事件聚合器设计用于处理事件。尽管如此，中介者仅仅使用它们是因为这样做很方便。
- en: Third-party objects
  id: totrans-517
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第三方对象
- en: By design, the event aggregator and mediator employ a third-party object to
    streamline interactions. The event aggregator itself is a third party to the event
    publisher and the event subscriber. It acts as a central hub for events to pass
    through. The mediator is also a third party to other objects, though. So where
    is the difference? Why don’t we call an event aggregator a mediator? The answer
    primarily depends on where the application logic and workflow are coded.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 按设计，事件聚合器和中介者都利用第三方对象来简化交互。事件聚合器本身是事件发布者和事件订阅者之间的中心枢纽。中介者也是其他对象的第三方，但是差异在哪里呢？为什么我们不把事件聚合器称为中介者？答案主要取决于应用逻辑和工作流程在哪里编码。
- en: In the case of an event aggregator, the third-party object is there only to
    facilitate the pass-through of events from an unknown number of sources to an
    unknown number of handlers. All workflow and business logic that needs to be kicked
    off is put directly into the object that triggers the events and the objects that
    handle the events.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 对于事件聚合器来说，第三方对象仅用于促进事件从未知数量的来源传递到未知数量的处理程序。所有需要启动的工作流程和业务逻辑都直接放入触发事件的对象以及处理事件的对象中。
- en: In the mediator’s case, the business logic and workflow are aggregated into
    the mediator itself. The mediator decides when an object should have its methods
    called and attributes updated based on factors the mediator knows about. It encapsulates
    the workflow and process, coordinating multiple objects to produce the desired
    system behavior. The individual objects involved in this workflow know how to
    perform their task. But the mediator tells the objects when to perform the tasks
    by making decisions at a higher level than the individual objects.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 在中介者的情况下，业务逻辑和工作流程都聚合到中介者本身中。中介者根据自己知道的因素决定何时调用对象的方法和更新属性。它封装了工作流程和流程，协调多个对象以产生所需的系统行为。参与此工作流程的各个对象知道如何执行其任务。但中介者通过在比单个对象更高层次上做出决策来告诉对象何时执行任务。
- en: An event aggregator facilitates a “fire and forget” model of communication.
    The object triggering the event doesn’t care if there are any subscribers. It
    just fires the event and moves on. A mediator might use events to make decisions,
    but it is definitely not “fire and forget.” A mediator pays attention to a known
    set of inputs or activities so that it can facilitate and coordinate other behavior
    with a known set of actors (objects).
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 事件聚合器促进了“发出并忘记”通信模型。触发事件的对象并不在乎是否有任何订阅者。它只是触发事件然后继续执行。中介者可能使用事件来做出决策，但它绝对不是“发出并忘记”。中介者关注已知的一组输入或活动，以便能够协调和协调其他行为与已知的一组参与者（对象）。
- en: 'Relationships: When to use which'
  id: totrans-522
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关系：何时使用哪个
- en: Understanding the similarities and differences between an event aggregator and
    a mediator is essential for semantic reasons. It’s equally important to know when
    to use which pattern. The basic semantics and intent of the patterns inform the
    question of when, but experience in using the patterns will help you understand
    the more subtle points and nuanced decisions that must be made.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 了解事件聚合器和中介者之间的相似性和差异对于语义原因至关重要。同样重要的是要知道何时使用哪种模式。模式的基本语义和意图可以回答何时使用的问题，但是使用模式的经验将帮助您理解必须作出的更微妙的观点和细微的决策。
- en: Event Aggregator Use
  id: totrans-524
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件聚合器使用
- en: In general, an event aggregator is used when you either have too many objects
    to listen to directly or have entirely unrelated objects.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，当你要监听的对象太多或者对象之间没有任何关系时，可以使用事件聚合器。
- en: When two objects already have a direct relationship—for example, a parent view
    and a child view—there may be a benefit in using an event aggregator. Have the
    child view trigger an event, and the parent view can handle the event. This is
    most commonly seen in Backbone’s Collection and Model in JavaScript framework
    terms, where all Model events are bubbled up to and through its parent Collection.
    A Collection often uses model events to modify the state of itself or other models.
    Handling “selected” items in a collection is an excellent example.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个对象已经存在直接关系时——例如父视图和子视图——使用事件聚合器可能会有益处。让子视图触发一个事件，父视图可以处理该事件。在JavaScript框架术语中，Backbone的集合（Collection）和模型（Model）经常使用这种方式，其中所有模型事件都被冒泡到其父集合（Collection）中。集合经常使用模型事件来修改自身或其他模型的状态。处理集合中的“selected”项目是一个很好的例子。
- en: jQuery’s `on()` method as an event aggregator is a great example of too many
    objects to listen to. If you have 10, 20, or 200 DOM elements that can trigger
    a “click” event, it might be a bad idea to set up a listener on all of them individually.
    This could quickly deteriorate the performance of the application and user experience.
    Instead, using jQuery’s `on()` method allows us to aggregate all events and reduce
    the overhead of 10, 20, or 200 event handlers down to 1.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery的`on()`方法作为事件聚合器是监听太多对象的一个很好的例子。如果有10、20或200个DOM元素可以触发“click”事件，逐个设置监听器可能是一个不好的主意。这可能会迅速降低应用程序的性能和用户体验。相反，使用jQuery的`on()`方法可以聚合所有事件，并将10、20或200个事件处理程序的开销减少到1个。
- en: Indirect relationships are also a great time to use event aggregators. In modern
    applications, it is ubiquitous to have multiple view objects that need to communicate
    but have no direct relationship. For example, a menu system might have a view
    that handles the menu item clicks. But we don’t want the menu to be directly tied
    to the content views showing all the details and information when a menu item
    is clicked—having the content and menu coupled together would make the code difficult
    to maintain in the long run. Instead, we can use an event aggregator to trigger
    `menu:click:foo` events and have a “foo” object handle the `click` event to show
    its content on the screen.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 间接关系也是使用事件聚合器的绝佳时机。在现代应用程序中，拥有多个视图对象需要通信但没有直接关系是很普遍的。例如，菜单系统可能有一个处理菜单项点击的视图。但是当我们点击菜单项时，我们不希望菜单直接与显示所有详细信息和内容的内容视图耦合在一起——长期来看，将内容和菜单耦合在一起会使代码难以维护。因此，我们可以使用事件聚合器来触发`menu:click:foo`事件，并让“foo”对象处理`click`事件以在屏幕上显示其内容。
- en: Mediator Use
  id: totrans-529
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中介者使用
- en: A mediator is best applied when two or more objects have an indirect working
    relationship, and business logic or workflow needs to dictate the interactions
    and coordination of these objects. A wizard interface is an excellent example
    of this, as shown in the `orgChart` example. Multiple views facilitate the entire
    workflow of the wizard. Rather than tightly coupling the view together by having
    them reference each other directly, we can decouple them and more explicitly model
    the workflow between them by introducing a mediator.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个或更多对象存在间接工作关系，并且业务逻辑或工作流需要指导这些对象的交互和协调时，中介者是最佳选择。向导界面在这方面是一个很好的例子，正如`orgChart`示例所示。多个视图有助于向导的整个工作流程。与其通过直接引用彼此来紧密耦合视图，我们可以通过引入中介者来解耦它们，并更明确地对它们之间的工作流进行建模。
- en: The mediator extracts the workflow from the implementation details and creates
    a more natural abstraction at a higher level, showing us at a much faster glance
    what that workflow is. We no longer have to dig into the details of each view
    in the workflow to see what the workflow is.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 中介从实现细节中提取工作流，并在更高层次上创建更自然的抽象，通过快速的一瞥就能看出工作流是什么。我们不再需要深入了解工作流中每个视图的细节来了解工作流。
- en: Event Aggregator (Pub/Sub) and Mediator Together
  id: totrans-532
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件聚合器（Pub/Sub）和中介的结合
- en: The crux of the difference between an event aggregator and a mediator, and why
    these pattern names should not be interchanged, is best illustrated by showing
    how they can be used together. The menu example for an event aggregator is the
    perfect place to introduce a mediator.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 显示事件聚合器和中介之间区别的关键，以及为什么这些模式名称不应该互换，最好通过展示它们如何一起使用来说明。事件聚合器的菜单示例是介绍中介的理想场所。
- en: Clicking a menu item may trigger a series of changes throughout an application.
    Some of these changes will be independent of others, and using an event aggregator
    makes sense. Some of these changes may be internally related, though, and may
    use a mediator to enact those changes.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 单击菜单项可能会触发应用程序中的一系列变化。其中一些变化是独立的，使用事件聚合器是有意义的。而有些变化可能是内部相关的，并且可能使用中介来实现这些变化。
- en: 'A mediator could then be set up to listen to the event aggregator. It could
    run its logic and process to facilitate and coordinate many objects related to
    each other but unrelated to the original event source:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以设置一个中介来监听事件聚合器。它可以运行其逻辑和处理，以促进和协调许多相互关联但与原始事件源无关的对象：
- en: '[PRE70]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In this example, when the `MenuItem` with the right model is clicked, the `menu:click:foo`
    event will be triggered. An instance of the `MyWorkflow` class will handle this
    specific event and coordinate all of the objects it knows about to create the
    desired user experience and workflow.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，当点击具有正确模型的`MenuItem`时，将触发`menu:click:foo`事件。`MyWorkflow`类的一个实例将处理这个特定事件，并协调它知道的所有对象，以创建期望的用户体验和工作流程。
- en: We have thus combined an event aggregator and a mediator to create a meaningful
    experience in both code and application. We now have a clean separation between
    the menu and the workflow through an event aggregator, and we are still keeping
    the workflow clean and maintainable through a mediator.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 我们因此将事件聚合器和中介结合起来，以在代码和应用程序中创造有意义的体验。现在，通过事件聚合器在菜单和工作流程之间实现了清晰的分离，而通过中介仍然保持了工作流的清洁和可维护性。
- en: Mediator/Middleware in Modern JavaScript
  id: totrans-539
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现代JavaScript中的中介/中间件
- en: '[Express.js](https://oreil.ly/JFzNB) is a popular web application server framework.
    We can add callbacks to certain routes that the user can access.'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '[Express.js](https://oreil.ly/JFzNB)是一种流行的Web应用程序服务器框架。我们可以为用户可以访问的某些路由添加回调函数。'
- en: 'Say we want to add a header to the request if the user hits the root (/). We
    can add this header in a middleware callback:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望在用户点击根路径（/）时向请求添加一个标头。我们可以在中间件回调中添加这个标头：
- en: '[PRE71]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The `next()` method calls the next callback in the request-response cycle. We’d
    create a chain of middleware functions that sit between the request and the response
    or vice versa. We can track and modify the request object all the way to the response
    through one or multiple middleware functions.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '`next()`方法调用请求-响应周期中的下一个回调函数。我们可以创建一系列中间件函数，它们位于请求和响应之间或者反过来。通过一个或多个中间件函数，我们可以跟踪和修改请求对象一直到响应。'
- en: 'The middleware callbacks will be invoked whenever the user hits a root endpoint
    (/):'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 每当用户访问根端点（/）时，将调用中间件回调：
- en: '[PRE72]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Mediator Versus Facade
  id: totrans-546
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中介与Facade的比较
- en: We will be covering the Facade pattern shortly, but for reference purposes,
    some developers may also wonder whether there are similarities between the Mediator
    and Facade patterns. They both abstract the functionality of existing modules,
    but there are some subtle differences.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快将介绍Facade模式，但是作为参考，一些开发人员可能还想知道中介模式与Facade模式之间是否存在相似之处。它们都抽象了现有模块的功能，但也有一些细微的差别。
- en: The Mediator centralizes communication between modules where these modules explicitly
    reference it. In a sense, this is multidirectional. The Facade, however, defines
    a more straightforward interface to a module or system but doesn’t add any additional
    functionality. Other modules in the system aren’t directly aware of the concept
    of a facade and could be considered unidirectional.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 中介者在模块之间集中通信，这些模块显式地引用它。在某种意义上，这是多方向的。然而，外观模式定义了一个更简单的接口，用于模块或系统，但不添加任何额外的功能。系统中的其他模块并不直接了解外观模式的概念，可以被认为是单向的。
- en: The Command Pattern
  id: totrans-549
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令模式
- en: The Command pattern aims to encapsulate method invocation, requests, or operations
    into a single object and allows us to both parameterize and pass method calls
    that can be executed at our discretion. In addition, it enables us to decouple
    objects invoking the action from the objects that implement them, giving us greater
    flexibility in swapping out concrete *classes* (objects).
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式旨在将方法调用、请求或操作封装到单个对象中，并允许我们对可以在我们自己的决策下执行的方法调用进行参数化和传递。此外，它使我们能够解耦调用操作的对象与实现它们的对象，从而在交换具体*类*（对象）时提供更大的灵活性。
- en: '*Concrete* classes are best explained in terms of class-based programming languages
    and are related to the idea of abstract classes. An *abstract* class defines an
    interface but doesn’t necessarily provide implementations for all its member functions.
    It acts as a base class from which others are derived. A derived class that implements
    the missing functionality is called a *concrete* class (see [Figure 7-12](#command)).
    Base and concrete classes can be implemented in JavaScript (ES2015+) using the
    `extends` keyword applicable to the JavaScript classes.'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '*具体* 类最好通过基于类的编程语言来解释，并与抽象类的概念相关联。*抽象* 类定义了一个接口，但不一定为其所有成员函数提供实现。它充当其他类从中派生的基类。实现缺失功能的派生类称为*具体*
    类（见[图 7-12](#command)）。基类和具体类可以使用适用于 JavaScript 类的 `extends` 关键字进行实现（ES2015+）。'
- en: '![ljd2 0712](Images/ljd2_0712.png)'
  id: totrans-552
  prefs: []
  type: TYPE_IMG
  zh: '![ljd2 0712](Images/ljd2_0712.png)'
- en: Figure 7-12\. Command pattern
  id: totrans-553
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-12\. 命令模式
- en: The general idea behind the Command pattern is that it provides a means to separate
    the responsibilities of issuing commands from anything executing commands, delegating
    this responsibility to different objects instead.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式的一般思想是提供一种方法，将发出命令的责任与执行命令的任何事物分离开来，而是将此责任委托给不同的对象。
- en: Implementation-wise, simple command objects bind the action and the object wishing
    to invoke the action. They consistently include an execution operation (such as
    `run()` or `execute()`). All command objects with the same interface can easily
    be swapped as needed, which is one of the vital benefits of the pattern.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现上，简单的命令对象绑定了动作和希望调用该动作的对象。它们始终包括一个执行操作（如 `run()` 或 `execute()`）。具有相同接口的所有命令对象可以根据需要轻松交换，这是该模式的重要优势之一。
- en: 'To demonstrate the Command pattern, we will create a simple car purchasing
    service:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示命令模式，我们将创建一个简单的汽车购买服务：
- en: '[PRE73]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The `CarManager` object is our command object responsible for issuing commands
    to request information about a car, buy a car, and arrange a viewing. It would
    be trivial to invoke our `CarManager` methods by directly accessing the object.
    It would be forgivable to assume nothing is wrong with this—technically, it’s
    completely valid JavaScript. There are, however, scenarios where this may be disadvantageous.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '`CarManager` 对象是我们的命令对象，负责发出关于汽车信息的请求、购买汽车和安排查看的命令。直接访问该对象以调用 `CarManager`
    方法是微不足道的。假设这样做没有问题——从技术上讲，这是完全有效的 JavaScript。然而，在某些情况下，这可能是不利的。'
- en: For example, imagine if the core API behind the `CarManager` changed. This would
    require all objects directly accessing these methods within our application to
    be modified. It is a type of coupling that effectively goes against the OOP methodology
    of loosely coupling objects as much as possible. Instead, we could solve this
    problem by abstracting the API away further.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，想象一下如果 `CarManager` 背后的核心 API 发生了变化。这将需要修改我们应用程序中直接访问这些方法的所有对象。这种耦合方式实际上违背了尽可能松散耦合对象的面向对象编程方法论。相反，我们可以通过进一步抽象
    API 来解决这个问题。
- en: 'Let’s now expand the `CarManager` so that our Command pattern application results
    in the following: accept any named methods that can be performed on the `CarManager`
    object, passing along any data that might be used, such as the car model and ID.'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们扩展`CarManager`，以便我们的命令模式应用程序能实现以下目标：接受可以在`CarManager`对象上执行的任何命名方法，并传递可能用到的任何数据，例如车型和ID。
- en: 'Here is what we would like to be able to achieve:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们希望能够实现的内容：
- en: '[PRE74]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'As per this structure, we should now add a definition for the `carManager.execute`
    method as follows:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个结构，我们现在应该为`carManager.execute`方法添加定义，如下所示：
- en: '[PRE75]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Our final sample calls would thus look as follows:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们最终的样本调用看起来是这样的：
- en: '[PRE76]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Summary
  id: totrans-567
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: With that, we can conclude our discussion of traditional design patterns you
    can use when designing classes, objects, and modules. I have tried incorporating
    an ideal mix of creational, structural, and behavioral patterns. We have also
    studied patterns created for classic OOP languages such as Java and C++ and adapted
    them for JavaScript.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们可以总结我们对传统设计模式的讨论，这些模式可以在设计类、对象和模块时使用。我尝试整合了创造性、结构性和行为性模式的理想组合。我们还研究了为经典面向对象编程语言如Java和C++创建的模式，并将其调整适用于JavaScript。
- en: These patterns will help us design many domain-specific objects (e.g., shopping
    cart, vehicle, or book) that make up our applications’ business model. In the
    next chapter, we will look at the larger picture of how we can structure applications
    so that this model delivers to the other application layers, such as the view
    or the presenter.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式将帮助我们设计许多特定于领域的对象（例如购物车、车辆或书籍），这些对象构成了我们应用程序业务模型的一部分。在下一章中，我们将探讨如何更大局观地结构化应用程序，使得这个模型能够向其他应用程序层（如视图或展示者）传递信息。
- en: ^([1](ch07.xhtml#idm45017700219792-marker)) [Wikipedia](https://oreil.ly/OUcDc);
    [Dictionary.com](https://oreil.ly/uM9-f).
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch07.xhtml#idm45017700219792-marker)) [维基百科](https://oreil.ly/OUcDc);
    [Dictionary.com](https://oreil.ly/uM9-f).
