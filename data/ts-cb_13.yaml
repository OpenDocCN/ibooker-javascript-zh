- en: Chapter 12\. Type Development Strategies
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章 类型开发策略
- en: All recipes up until now have dealt with specific aspects of the TypeScript
    programming language and its type system. You have learned about effectively using
    basic types in Chapters [2](ch02.html#ch02) and [3](ch03.html#ch03), making your
    code more reusable through generics in [Chapter 4](ch04.html#ch04), and crafting
    advanced types for very delicate situations using conditional types in [Chapter 5](ch05.html#ch05),
    string template literal types in [Chapter 6](ch06.html#ch06), and variadic tuple
    types in [Chapter 7](ch07.html#ch07).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有的配方都处理了 TypeScript 编程语言及其类型系统的特定方面。您已经学习了如何在第[2](ch02.html#ch02)章和第[3](ch03.html#ch03)章中有效地使用基本类型，通过[第 4](ch04.html#ch04)章中的泛型使您的代码更可重用，以及在[第 5](ch05.html#ch05)章中使用条件类型和[第 6](ch06.html#ch06)章中的字符串模板字面量类型，以及[第 7](ch07.html#ch07)章中的可变元组类型，来为非常微妙的情况创建高级类型。
- en: We established a collection of helper types in [Chapter 8](ch08.html#ch08) and
    worked around standard library limitations in [Chapter 9](ch09.html#ch09). We
    learned how to work with JSX as a language extension in [Chapter 10](ch10.html#ch10)
    and how and when to use classes in [Chapter 11](ch11.html#ch11). Every recipe
    discussed in detail the pros and cons of each approach, giving you better tools
    to decide correctly for every situation, creating better types, more robust programs,
    and a stable development flow.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第 8](ch08.html#ch08)章中建立了一组辅助类型，并在[第 9](ch09.html#ch09)章中解决了标准库的限制。我们学习了如何在[第 10](ch10.html#ch10)章中使用
    JSX 作为语言扩展，并了解了何时以及如何使用类在[第 11](ch11.html#ch11)章中。每个配方都详细讨论了每种方法的利弊，为您提供更好的工具，以便在每种情况下做出正确的决策，创建更好的类型，更健壮的程序和稳定的开发流程。
- en: 'That’s a lot! One thing is still missing, though, the final piece that brings
    everything together: how do we approach new type challenges? Where do we start?
    What do we need to look out for?'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 那太多了！然而，还有一件事缺失，这是将所有事情整合在一起的最后一部分：我们如何应对新的类型挑战？我们从哪里开始？我们需要注意什么？
- en: The answers to these questions make up the contents of this chapter. Here you
    will learn about the concept of *low maintenance types*. We will explore a process
    on how you can start with simple types first and gradually get more refined and
    stronger. You will learn about the secret features of the [TypeScript playground](https://www.typescriptlang.org/play)
    and how to deal with libraries that make validation easier. You will find guides
    to help you make hard decisions and learn about workarounds to the most common
    yet tough-to-beat type errors that will definitely hit you in your TypeScript
    journey.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题的答案构成了本章的内容。在这里，您将了解*低维护类型*的概念。我们将探讨一个过程，您可以从简单的类型开始，逐渐变得更加精炼和强大。您将了解到[TypeScript
    playground](https://www.typescriptlang.org/play)的秘密功能以及如何处理使验证更加容易的库。您将找到指南，帮助您做出艰难的决策，并了解如何处理在
    TypeScript 旅程中肯定会遇到的最常见但难以解决的类型错误的解决方法。
- en: If the rest of the book brought you from novice to apprentice, the next recipes
    will lead you to become an expert. Welcome to the last chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果本书的其余部分使您从新手成为学徒，那么接下来的教程将带领您成为专家。欢迎来到最后一章。
- en: 12.1 Writing Low Maintenance Types
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12.1 编写低维护类型
- en: Problem
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Every time your model changes, you need to touch a dozen types throughout your
    codebase. That is tedious, and it’s also easy to miss something.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 每当模型发生变化时，您需要触及代码库中的十几种类型。这很烦人，而且很容易漏掉一些东西。
- en: Solution
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Derive types from others, infer from usage, and create low maintenance types.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 从其他类型中派生类型，通过使用推断，创建低维护的类型。
- en: Discussion
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Throughout this book, we have spent a lot of time creating types from other
    types. The moment we can derive a type from something that already exists means
    we spend less time writing and adapting type information and more time fixing
    bugs and errors in JavaScript.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，我们花了大量时间从其他类型创建类型。一旦我们可以从已经存在的某物中派生出类型，这意味着我们花费更少的时间编写和适应类型信息，而是花更多的时间修复
    JavaScript 中的错误和错误。
- en: 'TypeScript is a layer of metainformation on top of JavaScript. Our goal is
    still to write JavaScript but make it as robust and easy as possible: tooling
    helps you stay productive and doesn’t get in your way.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 是建立在 JavaScript 之上的元信息层。我们的目标仍然是编写 JavaScript，但尽可能使其健壮且易于使用：工具帮助您保持高效，并且不会妨碍您。
- en: 'That’s how I write TypeScript in general: I write regular JavaScript, and where
    TypeScript needs extra information, I happily add some extra annotations. One
    condition: I don’t want to be bothered maintaining types. I’d rather create types
    that can update themselves if their dependencies or surroundings change. I call
    this approach *creating low maintenance types*.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我一般写TypeScript的方式：我写常规的JavaScript，而当TypeScript需要额外的信息时，我很乐意添加一些额外的注释。有一个条件：我不想被打扰去维护类型。我宁愿创建能够在其依赖项或周围发生变化时更新自己的类型。我称这种方法为*创建低维护类型*。
- en: 'Creating low maintenance types is a three-part process:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 创建低维护类型是一个由三个部分组成的过程：
- en: Model your data or infer from existing models.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据您的数据模型或从现有模型中推断。
- en: Define derivates (mapped types, partials, etc.).
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义派生（映射类型，部分类型等）。
- en: Define behavior with conditional types.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用条件类型定义行为。
- en: 'Let’s take a look at this brief and incomplete `copy` function. I want to copy
    files from one directory to another. To make my life easier, I created a set of
    default options so I don’t have to repeat myself too much:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个简短而不完整的`copy`函数。我想把文件从一个目录复制到另一个目录。为了让我的生活更轻松，我创建了一组默认选项，这样我就不必重复自己太多：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: That’s a pattern you might see a lot in JavaScript. What you see immediately
    is that TypeScript misses *some* type information. Especially the `options` argument
    of the `copy` function is `any` at the moment. So let’s add a type for that!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你在JavaScript中经常看到的一种模式。你立即看到的是，TypeScript缺少*某些*类型信息。特别是`copy`函数的`options`参数目前是`any`。所以让我们为其添加一个类型！
- en: 'I could create types explicitly:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以显式地创建类型：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'That’s a reasonable approach. You think about types, then you assign types,
    and then you get all the editor feedback and type-checking you are used to. But
    what if something changes? Let’s assume we add another field to `Options`; we
    would have to adapt our code three times:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个合理的方法。您考虑类型，然后分配类型，然后获得所有您习惯的编辑器反馈和类型检查。但是如果有什么变化呢？假设我们向`Options`添加了另一个字段；我们将不得不三次调整我们的代码：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'But why? The information is already there! In `defaultOptions`, we tell TypeScript
    exactly what we’re looking for. Let’s optimize:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 但是为什么呢？信息已经在那里！在`defaultOptions`中，我们告诉TypeScript确切地我们正在寻找什么。让我们优化：
- en: Drop the `PartialOptions` type and use the utility type `Partial<T>` to get
    the same effect. You might have guessed this one already.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 放弃`PartialOptions`类型，使用实用类型`Partial<T>`可以达到同样效果。你可能已经猜到这一点了。
- en: 'Use the `typeof` operator in TypeScript to create a new type on the fly:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在TypeScript中使用`typeof`运算符即可即时创建新类型：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There you go. Just annotate where we need to tell TypeScript what we’re looking
    for:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。只需在需要告诉TypeScript我们正在寻找什么的地方添加注释：
- en: If we add new fields, we don’t have to maintain anything at all.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们添加新字段，我们根本不需要维护任何内容。
- en: 'If we rename a field, we get *just* the information we care about: all uses
    of `copy` where we have to change the options we pass to the function.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们重命名一个字段，我们就会得到*仅仅*我们关心的信息：所有我们必须更改传递给函数的选项的`copy`的使用。
- en: 'We have one single source of truth: the actual `defaultOptions` object. This
    is the object that counts because it’s the only information we have at runtime.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们只有一个真正的事实来源：实际的`defaultOptions`对象。这是唯一重要的对象，因为它是我们在运行时拥有的唯一信息。
- en: And our code becomes a little bit more concise. TypeScript becomes less intrusive
    and more aligned to how we write JavaScript.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码变得更加简洁。TypeScript变得不那么侵入性，更符合我们编写JavaScript的方式。
- en: 'Another example is one that has accompanied us from the beginning: the toy
    shop that started in [Recipe 3.1](ch03.html#ch03_item_modelling_data), and has
    continued in Recipes [4.5](ch04.html#ch04_new_object_types) and [5.3](ch05.html#ch05_grouping_elements).
    Revisit all three items and think about how we can change only the model to get
    all other types updated.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是从一开始就伴随我们的：在[第3.1节的配方](ch03.html#ch03_item_modelling_data)中开始的玩具店，以及在第[4.5节](ch04.html#ch04_new_object_types)和第[5.3节](ch05.html#ch05_grouping_elements)的配方中继续。重新访问所有三个项目，并考虑如何仅通过更改模型来获取所有其他类型的更新。
- en: 12.2 Refining Types Step by Step
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12.2 逐步细化类型
- en: Problem
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Your API needs elaborate types, using advanced features like generics, conditional
    types, and string template literal types. You don’t know where to start.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您的API需要精心设计的类型，使用泛型、条件类型和字符串模板字面量类型等高级功能。您不知道从哪里开始。
- en: Solution
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Refine your types step by step. Start with basic primitive and object types,
    subset, add generics, and then go all-in advanced. The process described in this
    lesson will help you craft types. It’s also a good way to recap everything you’ve
    learned.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 逐步完善您的类型。从基本的原始类型和对象类型开始，逐步添加泛型，然后深入高级类型。本课程描述的过程将帮助您制作类型。这也是回顾您学到的所有内容的好方法。
- en: Discussion
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Take a look at the following example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的例子：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We have an [Express-style server](https://expressjs.com) that allows us to define
    a route (or path) and executes a callback if the URL is requested.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个 [Express 风格的服务器](https://expressjs.com)，它允许我们定义一个路由（或路径），并在请求该 URL 时执行回调。
- en: 'The callback takes two arguments:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数接受两个参数：
- en: The request object
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 请求对象
- en: Here we get information on the [HTTP method used](https://oreil.ly/zcoUS)—for
    example, `GET`, `POST`, `PUT`, `DELETE`—and additional parameters that come in.
    In this example `userID` should be mapped to a parameter `userID` that, well,
    contains the user’s identifier!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们获取使用的 [HTTP 方法的信息](https://oreil.ly/zcoUS) — 例如 `GET`、`POST`、`PUT`、`DELETE`
    — 以及传入的附加参数。在这个示例中，`userID` 应该映射到包含用户标识符的参数 `userID`！
- en: The response or reply object
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 响应或回复对象
- en: Here we want to prepare a proper response from the server to the client. We
    want to send correct status codes (method `status`) and send JSON output over
    the wire.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们希望为客户端准备一份适当的服务器响应。我们希望发送正确的状态码（使用 `status` 方法）并通过网络发送 JSON 输出。
- en: 'What we see in this example is heavily simplified, but it gives a good idea
    of what we are up to. The previous example is also riddled with errors! Take a
    look:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例中显示的内容大大简化，但很好地展示了我们要做的事情。前一个示例也充满了错误！看看：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Three lines of implementation code and three errors? What happened?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 三行实现代码和三个错误？到底发生了什么？
- en: The first error is nuanced. While we tell our app that we want to listen to
    `GET` requests (hence `app.get`), we do something only if the request method is
    `POST`. At this particular point in our application, `req.method` can’t be `POST`.
    So we would never send any response, which might lead to unexpected timeouts.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个错误有些微妙。虽然我们告诉我们的应用程序我们想监听 `GET` 请求（因此使用 `app.get`），但我们只有在请求方法是 `POST` 时才做某事。在我们应用程序的这个特定点上，`req.method`
    不可能是 `POST`。因此我们永远不会发送任何响应，这可能导致意外的超时。
- en: It’s great that we explicitly send a status code! `20` isn’t a valid status
    code, though. Clients might not understand what’s happening here.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显式发送状态码是个好习惯！`20` 并不是一个有效的状态码。客户端可能无法理解发生了什么。
- en: This is the response we want to send back. We access the parsed arguments but
    have a typo. It’s `userID`, not `userId`. All our users would be greeted with
    “Welcome, user undefined!” Something you definitely have seen in the wild!
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是我们想要发送的响应。我们访问解析的参数，但出现了拼写错误。应该是 `userID`，而不是 `userId`。我们所有的用户都会看到“欢迎，用户未定义！”这是您一定在现实中看到过的内容！
- en: Solving issues like this is TypeScript’s main purpose. TypeScript wants to understand
    your JavaScript code better than you do. And where TypeScript can’t figure out
    what you mean, you can assist by providing extra type information. The problem
    is that it’s often hard to start adding types. You might have the most puzzling
    edge cases in your mind but don’t know how to get to them.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这类问题是 TypeScript 的主要目的。TypeScript 希望比您更好地理解您的 JavaScript 代码。而在 TypeScript
    无法理解您的意图时，您可以通过提供额外的类型信息来帮助它。问题在于开始添加类型通常很困难。您可能心中有最棘手的边缘案例，但不知道如何入手。
- en: I want to propose a process that may help you get started and also shows you
    where there’s a good place to stop. You can increase the strengths of your types
    step by step. It gets better with each refinement, and you can increase type safety
    over a longer period of time. Let’s start!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望提出一个可能帮助您入门的过程，同时也向您展示了一个停下来的好时机。您可以逐步增强类型的能力。每次细化都会有所改善，并且您可以在较长时间内提高类型安全性。让我们开始吧！
- en: 'Step 1: Basic typing'
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 1：基本类型化
- en: 'We start with some basic type information. We have an `app` object that points
    to a `get` function. The `get` function takes a `path`, which is a string, and
    a callback:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一些基本的类型信息开始。我们有一个指向 `get` 函数的 `app` 对象。`get` 函数接受一个字符串类型的 `path` 和一个回调函数：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`CallbackFn` is a function type that returns `void` and takes two arguments:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`CallbackFn` 是一个返回 `void` 并接受两个参数的函数类型：'
- en: '`req`, which is of type `ServerRequest`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`req`，类型为 `ServerRequest`'
- en: '`reply`, which is of type `ServerReply`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reply`，类型为 `ServerReply`'
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`ServerRequest` is a pretty complex object in most frameworks. We do a simplified
    version for demonstration purposes. We pass in a `method` string, for `"GET"`,
    `"POST"`, `"PUT"`, `"DELETE"`, and so on. It also has a `params` record. Records
    are objects that associate a set of keys with a set of properties. For now, we
    want to allow every `string` key to be mapped to a `string` property. We’ll refactor
    this one later:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数框架中，`ServerRequest` 是一个非常复杂的对象。我们为演示目的做了一个简化版本。我们传入一个 `method` 字符串，例如 `"GET"`、`"POST"`、`"PUT"`、`"DELETE"`
    等等。它还有一个 `params` 记录。记录是将一组键与一组属性关联的对象。目前，我们希望允许每个 `string` 键映射到一个 `string` 属性。稍后我们会重构这个对象：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For `ServerReply`, we lay out some functions, knowing that a real `ServerReply`
    object has many more. A `send` function takes an optional argument `obj` with
    the data we want to send. We have the possibility to set a status code with the
    `status` function using a fluent interface:^([1](ch12.html#id971))
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `ServerReply`，我们列出了一些函数，知道一个真实的 `ServerReply` 对象有更多。一个 `send` 函数带有一个可选参数
    `obj`，包含我们要发送的数据。我们可以使用流畅的接口设置状态码，使用 `status` 函数：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With some very basic compound types and a simple primitive type for paths,
    we already added a lot of type safety to our project. We can rule out a couple
    of errors:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一些非常基本的复合类型和路径的简单原始类型，我们已经为我们的项目增加了很多类型安全性。我们可以排除一些错误：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: That’s great, but there’s still a lot to do. We can still send wrong status
    codes (any number is possible) and have no clue about the possible HTTP methods
    (any string is possible). So let’s refine our types.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这很棒，但还有很多事情要做。我们仍然可以发送错误的状态码（任何数字都可能），并且对于可能的 HTTP 方法一无所知（任何字符串都可能）。因此，让我们细化我们的类型。
- en: 'Step 2: Subset primitive types'
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第二步：子集原始类型
- en: You can see primitive types as a set of all possible values of that certain
    category. For example, `string` includes all possible strings that can be expressed
    in JavaScript, `number` includes all possible numbers with double float precision,
    and `boolean` includes all possible Boolean values, which are `true` and `false`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将原始类型视为特定类别的所有可能值的集合。例如，`string` 包括 JavaScript 中可以表达的所有可能字符串，`number` 包括具有双浮点精度的所有可能数值，`boolean`
    包括可能的布尔值，即 `true` 和 `false`。
- en: 'TypeScript allows you to refine those sets to smaller subsets. For example,
    we can create a type `Methods` that includes all possible strings we can receive
    for HTTP methods:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 允许您将这些集合细化为更小的子集。例如，我们可以创建一个类型 `Methods`，包括我们可以接收到的所有可能的字符串作为 HTTP
    方法：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`Methods` is a smaller set of the bigger `string` set. `Methods` is also a
    union type of literal types, the smallest unit of a given set. A literal string.
    A literal number. There is no ambiguity: it’s just `"GET"`. You put them in a
    union with other literal types, creating a subset of whatever bigger types you
    have. You can also do a subset with literal types of both `string` and `number`,
    or different compound object types. There are lots of possibilities to combine
    and put literal types into unions.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`Methods` 是更大的 `string` 集合的一个较小子集。`Methods` 也是字面类型的联合类型，是给定集合的最小单元。一个字面字符串。一个字面数值。没有歧义：它只是
    `"GET"`。你可以将它们与其他字面类型组合成联合类型，创建一个给定较大类型的子集。你还可以通过字面类型的组合来创建 `string` 和 `number`
    的子集，或者不同的复合对象类型。有很多可能性可以结合和放置字面类型到联合中。'
- en: This has an immediate effect on our server callback. Suddenly, we can differentiate
    between those four methods (or more if necessary) and can exhaust all possibilities
    in code. TypeScript will guide us.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们的服务器回调产生了直接影响。突然之间，我们可以区分这四种方法（或更多，如果需要的话），并且可以在代码中穷尽所有可能性。TypeScript 将指导我们。
- en: 'That’s one less category of errors. We now know exactly which possible HTTP
    methods are available. We can do the same for HTTP status codes, by defining a
    subset of valid numbers that `statusCode` can take:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这减少了一类错误。现在我们确切地知道可用的 HTTP 方法是哪些。我们可以对 HTTP 状态码做同样的事情，通过定义 `statusCode` 可以取的有效数字的子集：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Type `StatusCode` is again a union type. And with that, we exclude another
    category of errors. Suddenly, code like that fails:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 类型 `StatusCode` 再次是一个联合类型。有了它，我们排除了另一类错误。突然之间，像这样的代码会失败：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: And our software becomes a lot safer. But we can do more!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的软件变得更安全了。但我们可以做得更多！
- en: 'Step 3: Adding generics'
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第三步：添加泛型
- en: When we define a route with `app.get`, we implicitly know that the only HTTP
    method possible is `"GET"`. But with our type definitions, we still have to check
    for all possible parts of the union.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `app.get` 定义路由时，我们隐含地知道唯一可能的 HTTP 方法是 `"GET"`。但是通过我们的类型定义，我们仍然需要检查联合类型的所有可能部分。
- en: The type for `CallbackFn` is correct, as we could define callback functions
    for all possible HTTP methods, but if we explicitly call `app.get`, it would be
    nice to save some extra steps, which are only necessary to comply with typings.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`CallbackFn`的类型是正确的，因为我们可以为所有可能的HTTP方法定义回调函数，但是如果我们显式调用`app.get`，那么保存一些额外步骤并且符合类型是很好的：'
- en: 'TypeScript generics can help. We want to define `ServerRequest` in a way that
    we can specify a part of `Methods` instead of the entire set. For that, we use
    the generic syntax where we can define parameters as we would do with functions:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript泛型可以帮助。我们希望以一种可以指定`Methods`的一部分而不是整个集合的方式定义`ServerRequest`。为此，我们使用泛型语法，就像我们在函数中定义参数一样：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here is what happens:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是发生的事情：
- en: '`ServerRequest` becomes a generic type, as indicated by the angle brackets.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ServerRequest`变成了一个泛型类型，如尖括号所示。'
- en: We define a generic parameter called `Met`, which is a subset of type `Methods`.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义了一个名为`Met`的泛型参数，它是`Methods`类型的子集。
- en: We use this generic parameter as a generic variable to define the method.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用这个泛型参数作为定义方法的泛型变量。
- en: 'With that change, we can specify different `ServerRequest` variants without
    duplicating:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种改变，我们可以指定不同的`ServerRequest`变体而不重复定义：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Since we changed the interface of `ServerRequest`, we have to change all our
    other types that use `ServerRequest`, like `CallbackFn` and the `get` function:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们改变了`ServerRequest`的接口，我们必须改变所有使用`ServerRequest`的其他类型，如`CallbackFn`和`get`函数：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With the `get` function, we pass an actual argument to our generic type. We
    know that this won’t be just a subset of `Methods`; we know exactly which subset
    we are dealing with.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`get`函数，我们向我们的泛型类型传递了一个实际的参数。我们知道这不仅仅是`Methods`的一个子集；我们确切知道我们正在处理的是哪个子集。
- en: 'Now, when we use `app.get`, we only have one possible value for `req.method`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们使用`app.get`时，`req.method`只有一种可能的值：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This ensures we don’t assume HTTP methods like `"POST"` or similar are available
    when we create an `app.get` callback. We know exactly what we are dealing with
    at this point, so let’s reflect that in our types.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了我们在创建`app.get`回调时不会假设像`"POST"`或类似的HTTP方法是可用的。此时我们确切知道我们正在处理的内容，所以让我们在类型中反映这一点。
- en: 'We already did a lot to make sure that `request.method` is reasonably typed
    and represents the actual state of affairs. One nice benefit of subsetting the
    `Methods` union type is that we can create a general-purpose callback function
    *outside* of `app.get` that is type safe:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经做了很多工作，以确保`request.method`合理地类型化并表示实际情况。通过对`Methods`联合类型进行子集处理的一个好处是，我们可以创建一个在`app.get`之外的通用回调函数，它是类型安全的：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Step 4: Advanced types to type-check'
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤4：高级类型进行类型检查
- en: What we haven’t touched yet is typing the `params` object. So far, we get a
    record that allows accessing every `string` key. It’s our task now to make that
    a little more specific!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尚未涉及的是对`params`对象进行类型化。到目前为止，我们得到了一个允许访问每个`string`键的记录。现在我们的任务是使其更加具体！
- en: 'We do so by adding another generic variable, one for methods and one for the
    possible keys in our `Record`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过添加另一个泛型变量来实现，一个用于方法，一个用于我们`Record`中可能的键：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The generic type variable `Par` can be a subset of type `string`, and the default
    value is every string. With that, we can tell `ServerRequest` which keys we expect:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通用类型变量`Par`可以是`string`类型的子集，默认值是每个字符串。通过这样做，我们可以告诉`ServerRequest`我们期望的键：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let’s add the new argument to our `get` function and the `CallbackFn` type,
    so we can set the requested parameters:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向我们的`get`函数和`CallbackFn`类型中添加新参数，以便设置请求的参数：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we don’t set `Par` explicitly, the type works like we are accustomed to,
    since `Par` defaults to `string`. If we set it, though, we suddenly have a proper
    definition for the `req.params` object:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有显式设置`Par`，类型会像我们习惯的那样工作，因为`Par`默认为`string`。但是，如果我们设置了，我们就突然有了对`req.params`对象的正确定义：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: That’s great! One little thing can be improved, though. We still can pass *every*
    string to the `path` argument of `app.get`. Wouldn’t it be better if we could
    reflect `Par` in there as well? We can! This is where *string template literal
    types* (see [Chapter 6](ch06.html#ch06)) come into play.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这太棒了！不过有一件小事可以改进。尽管如此，我们仍然可以将*任何*字符串传递给`app.get`的`path`参数。如果我们也能在那里反映`Par`，岂不是更好？我们可以！这就是*字符串模板文字类型*（见[第6章](ch06.html#ch06)）发挥作用的地方。
- en: 'Let’s create a type called `IncludesRouteParams` to make sure that `Par` is
    properly included in the Express-style way of adding a colon in front of the parameter
    name:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`IncludesRouteParams`的类型，以确保在参数名称前面添加冒号的Express风格中正确包含`Par`：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The generic type `IncludesRouteParams` takes one argument, which is a subset
    of `string`. It creates a union type of two template literals:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型类型 `IncludesRouteParams` 接受一个 `string` 的子集作为参数。它创建了两个模板字面量的联合类型：
- en: The first template literal starts with *any* `string`, then includes a `/` character
    followed by a `:` character, followed by the parameter name. This ensures that
    we catch all cases where the parameter is at the end of the route string.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个模板字面量以 *任意* `string` 开头，然后包含 `/` 字符，后跟 `:` 字符，再后面是参数名。这确保我们捕捉到参数在路由字符串末尾的所有情况。
- en: The second template literal starts with *any* `string`, followed by the same
    pattern of `/`, `:`, and the parameter name. Then we have another `/` character,
    followed by *any* string. This branch of the union type makes sure we catch all
    cases where the parameter is somewhere within a route.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个模板字面量以 *任意* `string` 开头，然后是 `/`、`:` 和参数名相同的模式。然后我们有另一个 `/` 字符，后面是 *任意* 字符串。联合类型的这一分支确保我们捕捉到参数在路由中的所有情况。
- en: 'This is how `IncludesRouteParams` with the parameter name `userID` behaves
    with different test cases:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是带有参数名 `userID` 的 `IncludesRouteParams` 的行为在不同测试用例中的表现：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let’s include our new utility type in the `get` function declaration:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `get` 函数声明中包含我们的新实用类型：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Great! We get another safety mechanism to ensure that we don’t miss out on adding
    the parameters to the actual route. That’s powerful.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们获得了另一个安全机制，确保我们不会忽略向实际路由添加参数。这非常强大。
- en: 'Step 5: Locking literal types'
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤5：锁定文字类型
- en: 'But guess what: I’m still not happy with it. A few issues with that approach
    become apparent the moment your routes get a little more complex:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 但猜猜：我仍然对此不满意。在你的路由变得稍微复杂时，这种方法的几个问题就显而易见了：
- en: The first issue is that we need to explicitly state our parameters in the generic
    type parameter. We have to bind `Par` to `"userID"`, even though we would specify
    it anyway in the `path` argument of the function. This is not JavaScript-y!
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个问题是，我们需要在泛型类型参数中明确声明我们的参数。即使我们在函数的 `path` 参数中也会指定它，我们仍然必须将 `Par` 绑定到 `"userID"`。这不符合
    JavaScript 的风格！
- en: This approach handles only one route parameter. The moment we add a union—for
    example, `"userID" | "orderId"`—the fail-safe check is satisfied with only *one*
    of those arguments being available. That’s how sets work. It can be one or the
    other.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种方法只处理一个路由参数。一旦我们添加一个联合类型，例如 `"userID" | "orderId"`，只要有一个参数可用，故障安全检查就会满足。这就是集合的工作原理。可以是其中一个或另一个。
- en: There must be a better way. And there is. Otherwise, this recipe would end on
    a very bitter note.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 必须有更好的方法。确实有。否则，这个方案会以非常糟糕的方式结束。
- en: 'Let’s inverse the order! Instead of defining the route params in a generic
    type variable, we extract the variables from the `path` passed as the first argument
    of `app.get`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们颠倒顺序！不再在泛型类型变量中定义路由参数，而是从作为 `app.get` 第一个参数传递的 `path` 中提取变量：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We remove the `Par` generic type and add `Path`, which can be a subset of any
    `string`. When we set `path` to this generic type `Path`, the moment we pass a
    parameter to `get`, we catch its string literal type. We pass `Path` to a new
    generic type `ParseRouteParams` that we haven’t created yet.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们移除 `Par` 泛型类型并添加 `Path`，它可以是任意 `string` 的子集。当我们将 `path` 设置为这个泛型类型 `Path` 时，一旦将参数传递给
    `get`，我们就捕捉到它的字符串文字类型。我们将 `Path` 传递给一个我们尚未创建的新泛型类型 `ParseRouteParams`。
- en: Let’s work on `ParseRouteParams`. Here, we switch the order of events again.
    Instead of passing the requested route params to the generic to make sure the
    path is all right, we pass the route path and extract the possible route params.
    For that, we need to create a conditional type.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来处理 `ParseRouteParams`。在这里，我们再次调整事件的顺序。不再将请求的路由参数传递给通用程序来确保路径正确，而是传递路由路径并提取可能的路由参数。为此，我们需要创建一个条件类型。
- en: 'Step 6: Adding conditional types'
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤6：添加条件类型
- en: 'Conditional types are syntactically similar to the ternary operator in JavaScript.
    You check for a condition, and if the condition is met, you return branch A; otherwise,
    you return branch B. For example:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 条件类型在语法上类似于 JavaScript 中的三元运算符。您检查一个条件，如果条件满足，则返回分支 A；否则，返回分支 B。例如：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here, we check if `Route` is a subset of every path that ends with the parameter
    at the end Express-style (with a preceding `"/:"`). If so, we infer this string,
    which means we capture its contents into a new variable. If the condition is met,
    we return the newly extracted string; otherwise, we return `never`, as in: “there
    are no route parameters.”'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们检查 `Route` 是否是以 Express 风格结尾的每个路径的子集（具有前置 `"/:""`）。如果是这样，我们推断这个字符串，这意味着我们将其内容捕获到一个新变量中。如果条件满足，我们返回新提取的字符串；否则，我们返回
    `never`，如：“没有路由参数。”
- en: 'If we try it, we get something like:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试一下，我们得到了这样的结果：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'That’s already much better than we did earlier. Now, we want to catch all other
    possible parameters. For that, we have to add another condition:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这比我们之前做得要好得多了。现在，我们想要捕获所有其他可能的参数。为此，我们必须添加另一个条件：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Our conditional type now works as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的条件类型现在的工作方式如下：
- en: In the first condition, we check if there is a route parameter somewhere in
    between the route. If so, we extract both the route parameter and everything else
    that comes after. We return the newly found route parameter `P` in a union where
    we call the same generic type recursively with the rest `R`. For example, if we
    pass the route `"/api/users/:userID/orders/:orderID"` to `ParseRouteParams`, we
    infer `"userID"` into `P` and `"orders/:orderID"` into `R`. We call the same type
    with `R`.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个条件中，我们检查路由中间是否有路由参数。如果是这样，我们提取路由参数和其后的所有内容。我们将新发现的路由参数 `P` 返回为一个联合，其中我们用剩余的
    `R` 递归调用相同的泛型类型。例如，如果我们将路由 `"/api/users/:userID/orders/:orderID"` 传递给 `ParseRouteParams`，我们将
    `"userID"` 推断为 `P`，将 `"orders/:orderID"` 推断为 `R`。我们使用 `R` 调用相同的类型。
- en: This is where the second condition comes in. Here we check if there is a type
    at the end. This is the case for `"orders/:orderID"`. We extract `"orderID"` and
    return this literal type.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是第二个条件发挥作用的地方。在这里，我们检查是否有类型在末尾。对于 `"orders/:orderID"`，就是这种情况。我们提取 `"orderID"`
    并返回这个文字类型。
- en: 'If there are no more route parameters left, we return `never`:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有更多的路由参数，我们返回 `never`：
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let’s apply this new type and see what our final usage of `app.get` looks like:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们应用这种新类型，看看我们对 `app.get` 的最终使用是什么样的：
- en: '[PRE31]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And that’s it! Let’s recap. The types we just created for one function `app.get`
    make sure that we exclude a ton of possible errors:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！让我们回顾一下。我们刚刚为一个函数 `app.get` 创建的类型确保了排除了大量可能的错误：
- en: We can only pass proper numeric status codes to `res.status()`.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们只能将适当的数值状态码传递给 `res.status()`。
- en: '`req.method` is one of four possible strings, and when we use `app.get`, we
    know it can only be `"GET"`.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`req.method` 是四个可能字符串之一，当我们使用 `app.get` 时，我们知道它只能是 `"GET"`。'
- en: We can parse route params and make sure we don’t have any typos inside our callback
    parameters.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以解析路由参数并确保在回调参数中没有任何拼写错误。
- en: 'If we look at the example from the beginning of this recipe, we get the following
    error messages:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下这个食谱开头的示例，我们得到了以下错误消息：
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: And all that before we actually run our code! Express-style servers are a perfect
    example of the dynamic nature of JavaScript. Depending on the method you call
    and the string you pass for the first argument, a lot of behavior changes inside
    the callback. Take another example and all your types look entirely different.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都发生在我们实际运行代码之前！Express 风格的服务器是 JavaScript 动态性的完美例子。根据您调用的方法和传递的第一个参数字符串，回调内的行为发生了很多变化。再举一个例子，你的所有类型看起来都完全不同。
- en: 'The great thing about this approach is that every step added more type safety:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的伟大之处在于每一步都增加了更多的类型安全性：
- en: You can easily stop at basic types and get more out of it than having no types
    at all.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以轻松停止在基本类型上，并且比根本没有类型要好。
- en: Subsetting helps you get rid of typos by reducing the number of valid values.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 子集帮助您通过减少有效值的数量来消除拼写错误。
- en: Generics help you tailor behavior to use case.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 泛型帮助您定制行为以使用案例。
- en: Advanced types like string template literal types give your app more meaning
    in a stringly-typed world.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像字符串模板文本类型这样的高级类型在字符串类型的世界中为您的应用程序增添了更多的含义。
- en: Locking in generics allows you to work with literals in JavaScript and treat
    them as types.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在泛型中锁定允许您在 JavaScript 中处理文字并将其视为类型。
- en: Conditional types make your types as flexible as your JavaScript code.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 条件类型使得您的类型像您的 JavaScript 代码一样灵活。
- en: The best thing? Once you added your types, people will just write plain JavaScript
    and still get all the type information. That’s a win for everybody.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的事情？一旦添加了类型，人们将只需编写普通的 JavaScript 代码，仍然可以获得所有的类型信息。这对每个人都是一种胜利。
- en: 12.3 Checking Contracts with satisfies
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12.3 使用 `satisfies` 检查合约
- en: Problem
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to work with literal types but need an annotation type-check to make
    sure you fulfill a contract.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您想使用字面类型，但需要一个注释类型检查以确保您履行合同。
- en: Solution
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `satisfies` operator to do annotation-like type-checking while retaining
    the literal types.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`satisfies`运算符执行类似注释的类型检查，同时保留字面类型。
- en: Discussion
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Mapped types are great, as they allow for the flexibility in object structures
    JavaScript is known for. But they have some crucial implications for the type
    system. Take this example from a generic messaging library, which takes a “channel
    definition” where multiple channel tokens can be defined:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 映射类型非常棒，因为它们允许JavaScript中已知的对象结构的灵活性。但它们对类型系统有一些关键影响。来看一个来自通用消息库的示例，该库接受“通道定义”，在其中可以定义多个通道令牌：
- en: '[PRE33]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The keys from this channel definition object are what the user wants them to
    be. So this is a valid channel definition:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 此通道定义对象的键是用户希望它们是什么。因此这是一个有效的通道定义：
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We have a problem, however: when we want to access the keys we defined so flexibly.
    Let’s say we have a function that opens a channel. We pass the whole channel definition
    object, as well as the channel we want to open:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们有一个问题：当我们想要访问我们灵活定义的键时。假设我们有一个打开通道的函数。我们传递整个通道定义对象，以及我们想要打开的通道：
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'So what are the keys of `ChannelDefinition`? Well, it’s every key: `[key: string]`.
    So the moment we assign a specific type, TypeScript treats `impl` as this specific
    type, ignoring the actual implementation. The contract is fulfilled. Moving on.
    This allows for wrong keys to be passed:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '那么`ChannelDefinition`的键是什么呢？嗯，它是每个键：`[key: string]`。因此，一旦我们指定了具体类型，TypeScript会将`impl`视为这个特定类型，而忽略实际的实现。合同得到满足。继续。这允许传递错误的键：'
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: So we are more interested in the actual implementation, not the type we assign
    to our constant. This means we have to get rid of the `ChannelDefinition` type
    and make sure we care about the actual type of the object.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们更感兴趣的是实际的实现，而不是我们为常量分配的类型。这意味着我们必须摆脱`ChannelDefinition`类型，并确保我们关心对象的实际类型。
- en: 'First, the `openChannel` function should take any object that is a subtype
    of `Ch⁠ann⁠el​De⁠fi⁠ni⁠tion` but work with the concrete subtype:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`openChannel`函数应该接受任何作为`Ch⁠ann⁠el​De⁠fi⁠ni⁠tion`子类型的对象，但是与具体的子类型一起工作：
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'TypeScript now works on two levels:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript现在在两个层面上工作：
- en: It checks if `T` actually extends `ChannelDefinition`. If so, we work with type
    `T`.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它检查`T`是否实际上扩展了`ChannelDefinition`。如果是这样，我们就使用类型`T`。
- en: All our function parameters are typed with the generic `T`. This also means
    we get the *real* keys of `T` through `keyof T`.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有我们的函数参数都用通用的`T`类型。这也意味着我们通过`keyof T`获取`T`的*真实*键。
- en: 'To benefit from that, we have to get rid of the type definition for `impl`.
    The explicit type definition overrides all actual types. From the moment we explicitly
    specify the type, TypeScript treats it as `ChannelDefinition`, not the actual
    underlying subtype. We also have to set *const context*, so we can convert all
    strings to their unit type (and thus be compliant with `Messages`):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要从中受益，我们必须摆脱`impl`的类型定义。显式类型定义会覆盖所有实际类型。从我们明确指定类型的那一刻起，TypeScript将其视为`ChannelDefinition`，而不是实际的底层子类型。我们还必须设置*const
    context*，这样我们可以将所有字符串转换为它们的单位类型（从而与`Messages`兼容）：
- en: '[PRE38]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Without *const context*, the inferred type of `impl` is:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 没有*const context*，`impl`的推断类型是：
- en: '[PRE39]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'With *const context*, the actual type of `impl` is now:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 有了*const context*，`impl`的实际类型现在是：
- en: '[PRE40]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '*Const context* allows us to satisfy the contract made by `ChannelDefinition`.
    Now `openChannel` works correctly:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*Const context*允许我们满足`ChannelDefinition`所做的合同。现在`openChannel`可以正常工作：'
- en: '[PRE41]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This works but comes with a caveat. The only point where we can check if `impl`
    is actually a valid subtype of `ChannelDefinition` is when we are using it. Sometimes
    we want to annotate early to figure out potential breaks in our contract. We want
    to see if this specific implementation *satisfies* a contract.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法有效，但有一个注意事项。我们唯一可以检查`impl`是否实际上是`ChannelDefinition`的有效子类型的点是在我们使用它的时候。有时候我们想要提前注释以找出合同可能出现的问题。我们想要看看这个具体实现*是否满足*合同。
- en: 'Thankfully, there is a keyword for that. We can define objects and do a type-check
    to see if this implementation satisfies a type, but TypeScript will treat it as
    a literal type:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个关键字可以做到这一点。我们可以定义对象并进行类型检查，以查看这个实现是否满足类型，但是TypeScript会将其视为字面类型：
- en: '[PRE42]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'With that, we can make sure that we fulfill contracts but have the same benefits
    as with *const context*. The only difference is that the fields are not set to
    `readonly`, but since TypeScript takes the literal type of everything, there is
    no way to set fields to anything else after a satisfaction type-check:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以确保我们履行了合同，但是与*const上下文*一样具有相同的好处。唯一的区别是字段不被设置为`readonly`，但由于TypeScript获取了所有内容的文字类型，因此在满足类型检查后无法将字段设置为其他任何值：
- en: '[PRE43]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'With that, we get the best of both worlds: proper type-checks at annotation
    time as well as the power of narrowed types for specific situations.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们同时得到了两全其美的好处：在注解时进行正确的类型检查，以及在特定情况下使用狭窄类型的能力。
- en: 12.4 Testing Complex Types
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12.4 测试复杂类型
- en: Problem
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You have written very elaborate and complex types, and you want to make sure
    that they behave correctly.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你写了非常复杂和精细的类型，你想确保它们的行为是正确的。
- en: Solution
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Some commonly known helper types work like a test framework. Test your types!
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常见的辅助类型的工作方式就像一个测试框架。测试你的类型！
- en: Discussion
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: In dynamically typed programming languages people always circle around the discussion
    of if you need types when you can have a proper test suite. This is at least what
    one camp says; the other thinks, why should we test so much when we can have types?
    The answer is probably somewhere in the middle.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在动态类型的编程语言中，人们总是围绕着是否需要类型当你可以有一个合适的测试套件进行讨论。至少一个阵营会这么说；另一些人则认为，为什么我们要进行那么多测试，当我们可以有类型呢？答案可能处于中间某个地方。
- en: It is true that types can solve a lot of test cases. Is the result a number?
    Is the result an object with certain properties of certain types? This is something
    we can easily check via types. Does my function produce correct results? Are the
    values what I expect them to be? This belongs to tests.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 类型确实可以解决很多测试案例。结果是一个数字吗？结果是一个具有某些特定类型属性的对象吗？这是我们可以通过类型轻松检查的事情。我的函数产生了正确的结果吗？值是否符合我的预期？这属于测试。
- en: 'Throughout this book, we learned a lot about very complex types. With conditional
    types, we opened up the metaprogramming capabilities of TypeScript, where we could
    craft new types based on certain features of previous types. Powerful, Turing
    complete, and very advanced. This leads to the question: how do we ensure that
    those complex types actually do what they should do? Maybe we should *test our
    types*?'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们学到了关于非常复杂的类型的很多知识。通过条件类型，我们打开了TypeScript的元编程能力，我们可以根据先前类型的某些特征制作新类型。强大、图灵完备且非常先进。这引出了一个问题：我们如何确保这些复杂类型确实做到了它们应该做的？也许我们应该*测试我们的类型*？
- en: 'We actually can. There are a few helper types known within the community that
    can serve as some sort of testing framework. The following types come from the
    excellent [Type Challenges repository](https://tsch.js.org), which allows you
    to test your TypeScript type system skills to an extreme. They include very challenging
    tasks: some that have relevance to real-world use cases and others that are just
    for fun.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上我们可以。社区内有一些已知的辅助类型可以充当某种测试框架。以下类型来自于优秀的[Type Challenges存储库](https://tsch.js.org)，它允许你极限测试你的TypeScript类型系统技能。它们包括非常具有挑战性的任务：一些与现实用例相关，另一些则只是为了好玩。
- en: 'Their testing library starts with a few types that expect a truthy or a falsy
    value. They are pretty straightforward. By using generics and literal types, we
    can check if this one Boolean is true or false:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 他们的测试库从一些期望真值或假值的类型开始。它们非常直接了当。通过使用泛型和文字类型，我们可以检查这个布尔值是true还是false：
- en: '[PRE44]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'They don’t do much on their own but are fantastic when being used with `Equal<X,
    Y>` and `NotEqual<X, Y>`, which return either `true` or `false`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 它们单独使用时并没有多大作用，但是当与`Equal<X, Y>`和`NotEqual<X, Y>`一起使用时就非常棒，它们会返回`true`或者`false`：
- en: '[PRE45]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`Equal<X, Y>` is interesting as it creates generic functions and checks them
    against both types that should be compared with each other. Since there is no
    resolution on each conditional type, TypeScript compares both conditional types
    and can see if there is compatibility. It’s a step within TypeScript’s conditional
    type logic that is masterfully explained by [Alex Chashin on Stack Overflow](https://oreil.ly/ywWd4).'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`Equal<X, Y>`很有趣，因为它创建了通用函数并将它们与应该进行比较的两种类型进行检查。由于每个条件类型都没有解决方案，TypeScript比较了两个条件类型并可以看到它们是否兼容。这是TypeScript条件类型逻辑中的一步，由[Stack
    Overflow上的Alex Chashin精彩解释](https://oreil.ly/ywWd4)。'
- en: 'The next batch allows us to check if a type is `any`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的一批允许我们检查类型是否为`any`：
- en: '[PRE46]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: It’s a simple conditional type that checks `0` against `1 & T`, which should
    always narrow down to `1` or `never`, which always yields the `false` branch of
    the conditional type. Except when we intersect with `any`. An intersection with
    `any` is always `any`, and `0` is a subset of `any`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种简单的条件类型，将`0`与`1 & T`进行比较，应该始终缩小为`1`或`never`，这总是会得出条件类型的`false`分支，除非我们与`any`相交。与`any`相交总是`any`，而`0`是`any`的子集。
- en: 'The next batch is reinterpretations of `Remap` and `DeepRemap` we saw in [Recipe
    8.3](ch08.html#ch08_remapping), along with `Alike` as a way to compare types that
    are equal in structure but not construction:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 下一批是对我们在[食谱 8.3](ch08.html#ch08_remapping)中看到的`Remap`和`DeepRemap`的重新解释，以及`Alike`作为一种比较结构相同但构造不同的类型的方法：
- en: '[PRE47]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `Equal` check before should theoretically be able to understand that `{
    x : number, y: string }` is equal to `{ x: number } & { y: string }`, but implementation
    details of the TypeScript type-checker don’t see them as equal. That’s where `Alike`
    comes into play.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '在之前的`Equal`检查理论上应该能够理解`{ x : number, y: string }`等同于`{ x: number } & { y: string
    }`，但 TypeScript 类型检查器的实现细节并不认为它们相等。这就是`Alike`发挥作用的地方。'
- en: 'The last batch of the type challenges testing file does two things:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 类型挑战测试文件的最后一批做了两件事：
- en: It does subset checks with a simple conditional type.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用   它使用简单的条件类型进行子集检查。
- en: 'It checks if a tuple you have constructed can be seen as a valid argument for
    a function:'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它检查你构建的元组是否可以被视为函数的有效参数：
- en: '[PRE48]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Having a small helper type library like this for type testing and debugging
    is really helpful when your types get more complex. Add them to your global type
    definition files (see [Recipe 9.7](ch09.html#ch09_augmenting_globals)) and use
    them.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的类型变得更复杂时，拥有这样的一个小型辅助类型库用于类型测试和调试是非常有帮助的。将它们添加到你的全局类型定义文件中（参见[食谱 9.7](ch09.html#ch09_augmenting_globals)）并使用它们。
- en: 12.5 Validating Data Types at Runtime with Zod
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12.5 使用 Zod 在运行时验证数据类型
- en: Problem
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You rely on data from external sources and can’t trust them to be correct.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你依赖于外部数据源，并不能信任它们是正确的。
- en: Solution
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Define schemas using a library called *Zod* and use it to validate data from
    external sources.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个名为*Zod*的库定义模式，并使用它来验证外部数据。
- en: Discussion
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Congratulations! We’re almost at the end. If you have followed along from start
    to finish, you have been constantly reminded that TypeScript’s type system follows
    a couple of goals. First and foremost, it wants to give you excellent tooling
    so you can be productive when developing applications. It also wants to cater
    to all JavaScript frameworks and make sure they are fun and easy to use. It sees
    itself as an add-on to JavaScript, as a syntax for static types. There are also
    some non-goals or trade-offs. It prefers productivity over correctness, it allows
    developers to bend the rules to their needs, and it has no claim of being provably
    sound.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你！我们几乎到达了终点。如果你从头到尾跟随，你一直被提醒 TypeScript 的类型系统遵循几个目标。首先也是最重要的是，它希望为你提供优秀的工具，使你在开发应用程序时能够提高生产力。它还希望能够支持所有
    JavaScript 框架，并确保它们既有趣又易于使用。它将自己视为 JavaScript 的一个附加组件，作为静态类型的语法。还有一些非目标或权衡。它更倾向于生产力而非正确性，允许开发者根据需要弯曲规则，并且没有声称是可证明正确的。
- en: In [Recipe 3.9](ch03.html#ch03_item_assertions) we learned that we can influence
    TypeScript if we think that types should be something different through *type
    assertions*, and in [Recipe 9.2](ch09.html#ch09_unsafe_operations) we learned
    how we can make *unsafe operations* more robust and easier to spot. Since TypeScript’s
    type system is compile-time only, all our safeguards evaporate once we run JavaScript
    in our selected runtime.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在[食谱 3.9](ch03.html#ch03_item_assertions)中，我们学到通过*类型断言*可以影响 TypeScript 的类型定义，认为类型应该是不同的；在[食谱
    9.2](ch09.html#ch09_unsafe_operations)中，我们学习了如何使*不安全操作*更加稳健且易于发现。由于 TypeScript
    的类型系统仅在编译时有效，一旦在我们选择的运行时环境中运行 JavaScript，所有的安全措施都会消失。
- en: 'Usually, compile-time type-checks are good enough. As long as we are within
    the *inner world* where we write our own types, let TypeScript check that everything
    is OK, and our code is good to go. In JavaScript applications, however, we also
    deal with a lot of things beyond our control: user input, for example. APIs from
    third parties that we need to access and process. Inevitably, we reach a point
    in our development process where we need to leave the boundaries of our well-typed
    application and deal with data that we can’t trust.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，编译时类型检查就足够了。只要我们在编写自己类型的*内部世界*内，让 TypeScript 检查一切是否正常，我们的代码就可以正常运行。然而，在 JavaScript
    应用程序中，我们还需要处理许多超出我们控制范围的事物：例如用户输入。我们需要访问和处理的第三方 API。无可避免地，我们在开发过程中会达到一个需要离开严格类型化应用程序边界并处理我们无法信任的数据的时刻。
- en: While developing, working with external sources or user input might work well
    enough, but to make sure that the data we use stays the same when running in production
    requires extra effort. You may want to validate that your data adheres to a certain
    scheme.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，与外部来源或用户输入合作可能效果不错，但在生产环境中确保我们使用的数据保持一致需要额外的努力。您可能希望验证您的数据是否符合某种方案。
- en: Thankfully, there are libraries that deal with that kind of task. One library
    that has gained popularity in recent years is [Zod](https://zod.dev). Zod is TypeScript-first,
    which means it makes sure not only that the data you consume is valid and what
    you expect but also that you get TypeScript types you can use throughout your
    program. Zod sees itself as the guard between the outer world outside of your
    control and the inner world where everything is well-typed and also type-checked.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一些库可以处理这种任务。近年来获得广泛认可的一个库是[Zod](https://zod.dev)。Zod 是以 TypeScript 为先导的，这意味着它不仅确保您消费的数据有效且符合您的期望，还能为您的整个程序提供可用的
    TypeScript 类型。Zod 视自己为您无法控制的外部世界与一切严格类型化和类型检查的内部世界之间的卫士。
- en: 'Think of an API that gives you data for the `Person` type we’ve seen throughout
    the book. A `Person` has a name and age, a profession that is optional, and also
    a status: in our system, they can be either active, inactive, or only registered,
    waiting for confirmation.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，一个 API 给了您这本书中看到的 `Person` 类型的数据。一个 `Person` 有一个名字和年龄，一个可选的职业，还有一个状态：在我们的系统中，他们可以是活跃的、不活跃的或仅注册等待确认的。
- en: 'The API also packs a couple of `Person` objects in an array contained within
    a `Result` type. In short, it’s an example for a classic response type for HTTP
    calls:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: API 还在 `Result` 类型中的数组中打包了几个 `Person` 对象。简而言之，这是 HTTP 调用的经典响应类型的示例：
- en: '[PRE49]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You know how to type models like this. By now, you are fluent in recognizing
    and applying both syntax and patterns. We want to have the same type, but at runtime
    for data outside our control, we use Zod. And writing the same type in JavaScript
    (the value namespace) looks very familiar:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 您知道如何为这样的模型编写类型。到目前为止，您可以流利地识别和应用语法和模式。我们希望在运行时使用 Zod 处理我们无法控制的数据外，我们希望有相同的类型。并且在
    JavaScript 中编写相同类型（值命名空间）看起来非常熟悉：
- en: '[PRE50]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: As you see, we are in JavaScript, and we add names to the *value* namespace,
    not the *type* namespace (see [Recipe 2.9](ch02.html#ch02_item_namespaces)), but
    the tools we get from Zod’s fluent interface are very familiar to us TypeScript
    developers. We define objects, strings, numbers, and arrays. We can also define
    union types and literals. All the building blocks for defining models are here,
    and we can also nest types, as we see by defining `Person` first and reusing it
    in `Results`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用 JavaScript，并向*值*命名空间添加名称，而不是*类型*命名空间（参见[Recipe 2.9](ch02.html#ch02_item_namespaces)）。但是，Zod
    流畅接口提供的工具对于我们 TypeScript 开发人员非常熟悉。我们可以定义对象、字符串、数字和数组。我们还可以定义联合类型和文字类型。所有定义模型的构建块都在这里，我们还可以嵌套类型，如我们首先定义
    `Person` 并在 `Results` 中重用它所示。
- en: The fluent interface also allows us to make certain properties optional. All
    things that we know from TypeScript. Furthermore, we can set validation rules.
    We can say that age should be above or equal to 0 and below 100\. Things that
    we can’t do reasonably within the type system.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 流畅的接口还允许我们使某些属性可选。这些都是我们从 TypeScript 中了解的东西。此外，我们还可以设置验证规则。我们可以说年龄应该大于或等于 0
    并且小于 100。这些在类型系统内部我们无法合理做到的事情。
- en: 'Those objects are not types that we can use like we would use TypeScript types.
    They are *schemas*, waiting for data they can parse and validate. Since Zod is
    TypeScript-first, we have helper types that allow us to cross the bridge from
    the value space to the type space. With `z.infer` (a type, not a function), we
    can extract the type we defined through Zod’s schema functions:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 那些对象并不是我们可以像使用 TypeScript 类型那样使用的类型。它们是*模式*，等待可以解析和验证的数据。由于 Zod 是以 TypeScript
    为先导，我们有辅助类型，允许我们从值空间过渡到类型空间。通过 `z.infer`（一个类型，不是函数），我们可以提取我们通过 Zod 的模式函数定义的类型：
- en: '[PRE51]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'So, how do we apply Zod’s validation techniques? Let’s talk about a function
    called `fetchData`, which calls an API that gets entries of type `ResultType`.
    We just don’t know if the values we receive actually adhere to the types we’ve
    defined. So, after fetching data as `json`, we use the `Results` schema to parse
    the data we’ve received. If this process is successful, we get data that is of
    type `ResultType`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何应用 Zod 的验证技术呢？让我们谈谈一个名为 `fetchData` 的函数，该函数调用获取 `ResultType` 类型的条目的 API。我们不知道我们收到的值是否实际符合我们定义的类型。因此，在将数据作为
    `json` 获取后，我们使用 `Results` 模式来解析我们收到的数据。如果此过程成功，我们将得到 `ResultType` 类型的数据：
- en: '[PRE52]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note that we already had our first safeguard in how we defined the function
    interface. `Promise<ResultType>` is based on what we get from `z.infer`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在如何定义函数接口时已经有了我们的第一个保护措施。`Promise<ResultType>` 基于我们从 `z.infer` 获取的内容。
- en: '`Results.parse(data)` is of the inferred type but without a name. The structural
    type system makes sure that we return the right thing. There might be errors,
    and we can `catch` them using the respective `Promise.catch` methods or `try`-`catch`
    blocks.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`Results.parse(data)` 是推断类型但没有名称。结构类型系统确保我们返回正确的东西。可能会有错误，我们可以使用相应的 `Promise.catch`
    方法或 `try`-`catch` 块来捕获它们。'
- en: 'Usage with `try`-`catch`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `try`-`catch`：
- en: '[PRE53]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'While we can ensure that we continue only if we have correct data, we are not
    forced to do error checking. If we want to make sure that we look at the parsing
    result first before we continue with our program, `safeParse` is the way to go:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在我们拥有正确的数据时，我们才能确保继续进行，我们并没有被迫进行错误检查。如果我们想确保在继续我们的程序之前先查看解析结果，`safeParse`
    是最好的选择：
- en: '[PRE54]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This already makes Zod a valuable asset if you need to rely on external data.
    Furthermore, it allows you to adapt to API changes. Let’s say that your program
    can work only with active and inactive states of `Person`; it does not know how
    to handle `registered`. It’s easy to apply a transform where, based on the data
    you get, you modify the `"registered"` state to be actually `"active"`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要依赖外部数据，这已经使得 Zod 成为一个有价值的资产。此外，它允许您适应 API 的变化。假设您的程序仅能处理 `Person` 的活动和非活动状态，而不知道如何处理
    `registered`。您可以轻松应用一个转换，根据您接收到的数据，将 `"registered"` 状态修改为实际的 `"active"`：
- en: '[PRE55]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'You then work with two different types: the *input* type represents what the
    API is giving you, and the *output* type is the data you have after parsing. Thankfully,
    we can get both types from the respective Zod helper types `z.input` and `z.output`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您将使用两种不同的类型：*输入* 类型代表 API 给您的内容，*输出* 类型是解析后的数据。幸运的是，我们可以从相应的 Zod 辅助类型 `z.input`
    和 `z.output` 获取这两种类型：
- en: '[PRE56]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Zod’s typings are clever enough to understand that you removed one of the three
    literals from `status`. So there are no surprises and you actually deal with the
    data you’ve been expecting.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Zod 的类型推断足够聪明，可以理解您从 `status` 中移除了三个文字之一。因此没有任何意外，您实际上处理了您预期的数据。
- en: 'Zod’s API is elegant, easy to use, and closely aligned with TypeScript’s features.
    For data at the boundaries that you can’t control, where you need to rely on third
    parties to provide the expected shape of data, Zod is a lifesaver without you
    having to do too much work. It comes at a cost, though: runtime validation takes
    time. The bigger the dataset, the longer it takes. Also, at 12KB it’s big. Be
    certain that you need this kind of validation for data at your boundaries.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Zod 的 API 非常优雅、易于使用，并且与 TypeScript 的特性紧密对齐。对于您无法控制的边界数据，需要依赖第三方提供预期数据形状的情况，Zod
    是一个救命稻草，而您几乎不需要做太多工作。然而，这是有代价的：运行时验证需要时间。数据集越大，验证时间越长。此外，它的大小为 12KB。请确保您需要在边界数据上进行此类验证。
- en: If the data you request comes from some other team within your company, maybe
    the person sitting next to you, no library, not even Zod, beats talking with each
    other and collaborating toward the same goals. Types are a way to guide collaboration,
    not a means to get rid of it.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你请求的数据来自公司内的其他团队，也许就坐在你旁边的人，没有任何库，甚至是Zod，能比互相交流和朝着相同目标合作更胜一筹。类型是引导协作的一种方式，而不是摆脱它的手段。
- en: 12.6 Working Around Index Access Restrictions
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12.6 解决索引访问限制
- en: Problem
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: When accessing an object’s property using index access, TypeScript complains
    that the type you want to assign is not assignable to `never`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用索引访问对象属性时，TypeScript抱怨要分配的类型不能赋给`never`。
- en: Solution
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: TypeScript looks for the lowest common denominator of possible values. Use a
    generic type to lock in specific keys so TypeScript doesn’t assume the rule needs
    to apply for all.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript寻找可能值的最低公共分母。使用泛型类型锁定特定键，以便TypeScript不会假定该规则适用于所有情况。
- en: Discussion
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Sometimes when writing TypeScript, actions you’d usually do in JavaScript work
    a little differently and cause some weird and puzzling situations. Sometimes you
    just want to assign a value to an object property via index access and get an
    error like “Type `'string | number'` is not assignable to type `'never'`. Type
    `'string'` is not assignable to type `'never'`.(2322).”
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在编写TypeScript时，你通常在JavaScript中执行的操作会有所不同，引起一些奇怪和令人费解的情况。有时你只想通过索引访问操作将值分配给对象属性，并获得像“类型`'string
    | number'`不可分配给类型`'never'`。类型`'string'`不可分配给类型`'never'`。(2322).”这样的错误。
- en: This isn’t out of the ordinary; it’s just where “unexpected intersection types”
    make you think a little bit more about the type system.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是什么特别的事情；这只是“意外的交集类型”让你更多地思考类型系统。
- en: 'Let’s look at this example. We create a function that lets us update from one
    object `anotherPerson` to object `person` via providing a key. Both `person` and
    `an⁠oth⁠er​Pe⁠rs⁠on` have the same type `Person`, but TypeScript throws errors:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子。我们创建一个函数，允许我们通过提供一个键从一个对象`anotherPerson`更新到对象`person`。`person`和`an⁠oth⁠er​Pe⁠rs⁠on`都是类型为`Person`的相同类型，但是TypeScript报错了：
- en: '[PRE57]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Property assignments via the index access operator are hard for TypeScript to
    track down. Even if you narrow all possible access keys via `keyof Person`, the
    possible values that can be assigned are `string` or `number` (for name and age,
    respectively). While this is fine if you have index access on the righthand side
    of a statement (reading), it gets a little interesting if you have index access
    on the lefthand side of a statement (writing).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 通过索引访问操作符进行属性赋值对TypeScript来说是困难的。即使你通过`keyof Person`缩小了所有可能访问键的范围，也可以赋予的可能值是`string`或`number`（分别用于名称和年龄）。如果在语句的右侧进行索引访问（读取）是没问题的，但如果在语句的左侧进行索引访问（写入），情况就会有些有趣。
- en: 'TypeScript can’t guarantee that the value you pass along is actually correct.
    Look at this function signature:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript不能保证你传递的值实际上是正确的。看看这个函数签名：
- en: '[PRE58]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Nothing prevents me from adding a falsely typed value to every key. Except for
    TypeScript, which throws an error. But why does TypeScript tell us the type is
    `never`?
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 除了TypeScript会报错外，没有什么能阻止我在每个键上添加错误类型的值。但为什么TypeScript告诉我们类型是`never`呢？
- en: 'To allow for *some* assignments TypeScript compromises. Instead of not allowing
    *any* assignments at all on the righthand side, TypeScript looks for the lowest
    common denominator of possible values, for example:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许*某些*赋值，TypeScript做出了妥协。与其完全不允许右侧的*任何*赋值，TypeScript寻找可能值的最低公共分母，例如：
- en: '[PRE59]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Here, both keys are subsets of `number`. `address` is the entire set of numbers;
    `on` on the other side is either `0` or `1`. It’s absolutely possible to set `0`
    or `1` to both fields! And this is what you get with TypeScript as well:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，两个键都是`number`的子集。`address`是所有数字的集合；而`on`则是`0`或`1`。完全可以将`0`或`1`设置给这两个字段！这也是你在使用TypeScript时会得到的结果：
- en: '[PRE60]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: TypeScript gets to the possible assignable values by doing an *intersection
    type* of all property types. In the case of the `Switch`, it’s `number & (0 |
    1)`, which boils down to `0 | 1`. In the case of all `Person` properties, it’s
    `string & number`, which has no overlap; therefore it’s `never`. Hah! There’s
    the culprit!
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript通过对所有属性类型进行*交集类型*来获取可能的可赋值值。对于`Switch`，它是`number & (0 | 1)`，简化为`0
    | 1`。对于所有`Person`属性，它是`string & number`，它们没有重叠；因此是`never`。哈！问题就在这里！
- en: 'One way to get around this strictness (which is for your own good) is by using
    generics. Instead of allowing all `keyof Person` values to access, we *bind* a
    specific subset of `keyof Person` to a generic variable:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 绕过这种严格性（这是为了你好的）的一种方法是使用泛型。我们不允许所有 `keyof Person` 值访问，而是将 `keyof Person` 的特定子集*绑定*到一个泛型变量：
- en: '[PRE61]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: When I `update("age")`, `K` is bound to the literal type of `"age"`. No ambiguity
    there!
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当我 `update("age")` 时，`K` 绑定到字面类型 `"age"`。没有任何歧义！
- en: 'There is a theoretical loophole since we could instantiate `update` with a
    much broader generic value:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个理论上的漏洞，因为我们可以使用一个更广泛的泛型值来实例化 `update`：
- en: '[PRE62]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This is something the TypeScript team allows, for now. See also [this comment](https://oreil.ly/0Fetp)
    by Anders Hejlsberg. Note that he asks to see use cases for such a scenario, which
    perfectly details how the TypeScript team works. The original assignment via index
    access on the righthand side has so much potential for error that they give you
    enough safeguards until you make it very intentional what you want to do. This
    is ruling out entire classes of errors without getting too much in the way.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 TypeScript 团队目前允许的。另请参阅 [这条评论](https://oreil.ly/0Fetp) 由 Anders Hejlsberg。请注意，他要求看到此类情景的用例，这完美地说明了
    TypeScript 团队的工作方式。在右手边的索引访问上的原始分配具有很高的错误潜力，因此他们为您提供了足够的保障，直到您非常明确地表达您想要做的事情。这排除了整个类别的错误，而不会给您带来太多阻碍。
- en: 12.7 Deciding Whether to Use Function Overloads or Conditional Types
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12.7 决定是使用函数重载还是条件类型
- en: Problem
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: With conditional types, you have more possibilities to define function signatures
    than before. You wonder if you still need function overloads or if they’re obsolete.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 使用条件类型，您比以前有更多可能定义函数签名的方式。您是否仍然需要函数重载或者它们已经过时了呢？
- en: Solution
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Function overloads provide better readability and an easier way to define expectations
    from your type than conditionals. Use them when the situation requires.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 函数重载提供了比条件更好的可读性，并且更容易定义您的类型的期望。在情况需要时使用它们。
- en: Discussion
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'With type system features like conditional types or variadic tuple types, one
    technique to describe a function’s interface has faded into the background: function
    overloads. And for good reason. Both features have been implemented to deal with
    the shortcomings of regular function overloads.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 使用诸如条件类型或变长元组类型之类的类型系统功能，描述函数接口的技术已经淡出背景：函数重载。而且理由充分。这两个特性都已实施以解决常规函数重载的缺陷。
- en: 'See this concatenation example directly from the TypeScript 4.0 release notes.
    This is an array `concat` function:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 直接查看 TypeScript 4.0 发布说明中的此连接示例。这是一个数组 `concat` 函数：
- en: '[PRE63]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'To correctly type a function like this so it takes all possible edge cases
    into account, we would end up in a sea of overloads:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 要正确地对这样一个函数进行类型化，以便考虑到所有可能的边缘情况，我们将陷入一片重载的海洋中：
- en: '[PRE64]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'And this only takes into account arrays that have up to six elements. Variadic
    tuple types help greatly with these situations:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅考虑了最多有六个元素的数组。变长元组类型在这些情况下非常有帮助：
- en: '[PRE65]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The new function signature requires a lot less effort to parse and is very
    clear on what types it expects to get as arguments and what it returns. The return
    value also maps to the return type. No extra assertions: TypeScript can make sure
    that you are returning the correct value.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 新的函数签名需要更少的解析工作，并且非常清楚它期望获取哪些类型作为参数，并返回什么。返回值也映射到返回类型。没有额外的断言：TypeScript 可以确保您返回正确的值。
- en: 'It’s a similar situation with conditional types. This example is very similar
    to [Recipe 5.1](ch05.html#ch05_function_signatures). Think of software that retrieves
    orders based on customer, article, or order ID. You might want to create something
    like this:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 条件类型也有类似的情况。这个例子与 [Recipe 5.1](ch05.html#ch05_function_signatures) 非常相似。考虑基于客户、文章或订单
    ID 检索订单的软件。您可能想创建类似这样的东西：
- en: '[PRE66]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'But this is just half the truth. What if you end up with ambiguous types where
    you don’t know exactly if you get *only* a `Customer` or only a `Product`? You
    need to take care of all possible combinations:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 但这只是事实的一半。如果您最终面临模糊的类型，您不确定是否仅获得*仅仅*一个 `Customer` 或仅仅一个 `Product`？您需要考虑所有可能的组合：
- en: '[PRE67]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Add more possibilities, and you end up with more combinations. Here, conditional
    types can reduce your function signature tremendously:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 添加更多可能性，您最终会得到更多的组合。在这里，条件类型可以大大减少您的函数签名：
- en: '[PRE68]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Since conditional types distribute a union, `FetchReturn` returns a union of
    return types.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 由于条件类型分布一个联合，`FetchReturn` 返回一个返回类型的联合。
- en: 'So there is good reason to use those techniques instead of drowning in too
    many function overloads. So, to return to the question: do we still need function
    overloads?'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，有充分的理由使用这些技术，而不是陷入太多的函数重载中。所以，回到问题：我们仍然需要函数重载吗？
- en: Yes, we do.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们需要。
- en: Different function shapes
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不同的函数形状
- en: One scenario where function overloads remain handy is if you have different
    argument lists for your function variants. This means not only the arguments (parameters)
    themselves can have some variety (this is where conditionals and variadic tuples
    are fantastic) but also the number and position of arguments.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 函数重载仍然很方便的一个场景是，如果你的函数变体有不同的参数列表。这意味着不仅参数本身可以有一些变化（这就是条件和可变元组的地方很棒），而且参数的数量和位置也可以有所不同。
- en: 'Imagine a search function that has two different ways of being called:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个搜索函数，有两种不同的调用方式：
- en: Call it with the search query. It returns a `Promise` you can await.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用搜索查询调用它。它返回一个`Promise`，你可以等待。
- en: Call it with the search query and a callback. In this scenario, the function
    does not return anything.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用搜索查询和回调函数来调用。在这种情况下，函数不返回任何内容。
- en: 'This *can* be done with conditional types but is very unwieldy:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用条件类型完成，但非常笨重：
- en: '[PRE69]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Here’s what we did:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们所做的：
- en: We defined our argument list using tuple types. Since TypeScript 4.0, we can
    name tuple fields just like we would objects. We create a union because we have
    two different variants of our function signature.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用元组类型定义我们的参数列表。自 TypeScript 4.0 以来，我们可以像对象一样为元组字段命名。我们创建一个联合类型，因为我们的函数签名有两种不同的变体。
- en: The `ReturnSearch` type selects the return type based on the argument list variant.
    If it’s just a string, return a `Promise`. Otherwise return `void`.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ReturnSearch` 类型根据参数列表的变体选择返回类型。如果只是一个字符串，返回一个`Promise`。否则返回`void`。'
- en: We add our types by constraining a generic variable to `SearchArguments` so
    that we can correctly select the return type.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过将一个泛型变量限制为`SearchArguments`来添加我们的类型，以便我们可以正确选择返回类型。
- en: 'That is a lot! And it features a ton of complex features we love to see in
    TypeScript’s feature list: conditional types, generics, generic constraints, tuple
    types, union types! We get *some* nice autocomplete, but it’s nowhere near the
    clarity of a simple function overload:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 那是很多啊！而且它展示了 TypeScript 功能列表中许多复杂功能：条件类型、泛型、泛型约束、元组类型、联合类型！我们得到了一些不错的自动完成，但与简单的函数重载相比，它远没有那么清晰：
- en: '[PRE70]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We use a union type only for the implementation part. The rest is very explicit
    and clear. We know our arguments, and we know what to expect in return. No ceremony,
    just simple types. The best part of function overloads is that the *actual* implementation
    does not pollute the type space. You can go for a round of `any` and just not
    care.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仅在实现部分使用联合类型。其余部分非常明确和清晰。我们知道我们的参数，也知道预期的返回值。没有繁文缛节，只有简单的类型。函数重载最好的部分是*实际*实现不会污染类型空间。你可以使用`any`一圈，完全不用担心。
- en: Exact arguments
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确切的参数
- en: 'Another situation where function overloads can make things easier is when you
    need exact arguments and their mapping. Let’s look at a function that applies
    an event to an event handler. For example, we have a `MouseEvent` and want to
    call a `Mo⁠use⁠Eve⁠nt​Ha⁠nd⁠ler` with it. Same for keyboard events and so on.
    If we use conditionals and union types to map event and handler, we might end
    up with something like this:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个函数重载可以简化事情的情况是，当您需要确切的参数及其映射时。让我们看一个应用事件到事件处理程序的函数。例如，我们有一个`MouseEvent`并希望用它调用一个`MouseEvent​Handler`。键盘事件等等也一样。如果我们使用条件和联合类型来映射事件和处理程序，我们可能会得到这样的东西：
- en: '[PRE71]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: At first glance, this looks fine. It might be a bit cumbersome, though, if you
    think about all the variants you need to keep track of.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这看起来还不错。但是如果你考虑到所有你需要跟踪的变体，可能会有点累赘。
- en: 'But there’s a bigger problem. The way TypeScript deals with all possible variants
    of the event is causing an *unexpected intersection*, as we see in [Recipe 12.6](#ch12_unexpected_intersections).
    This means that, in the function body, TypeScript can’t tell what kind of handler
    you are passing. Therefore, it also can’t tell which kind of event we’re getting.
    So TypeScript says the event can be both: a mouse event and a keyboard event.
    You need to pass handlers that can deal with both, which is not how we intend
    our function to work.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 但还有一个更大的问题。 TypeScript 处理事件的所有可能变体的方式导致了一个*意外的交集*，正如我们在[Recipe 12.6](#ch12_unexpected_intersections)中看到的那样。这意味着，在函数体中，TypeScript
    无法确定您正在传递哪种类型的处理程序。因此，它也无法确定我们得到的是哪种类型的事件。因此，TypeScript 表示事件可以同时是鼠标事件和键盘事件。您需要传递能够处理这两种事件的处理程序，这不符合我们函数的预期工作方式。
- en: 'The actual error message is “TS 2345: Argument of type `*Ke⁠ybo⁠ard⁠Eve⁠nt<H⁠TML⁠Bu⁠tt⁠on​El⁠em⁠en⁠t>
    | MouseEvent<HTMLButtonElement, MouseEvent>*` is not assignable to parameter of
    type `*Mo⁠us⁠eEv⁠ent⁠<HT⁠MLB⁠utt⁠onE⁠lem⁠ent⁠, Mo⁠use⁠Eve⁠nt> ⁠& Key⁠boa⁠rd ​Eve⁠nt<H⁠TML⁠But⁠ton⁠Ele⁠me⁠nt>*`.”'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的错误消息是：“TS 2345：类型参数`*Ke⁠ybo⁠ard⁠Eve⁠nt<H⁠TML⁠Bu⁠tt⁠on​El⁠em⁠en⁠t> | MouseEvent<HTMLButtonElement,
    MouseEvent>*`不能赋给类型参数`*Mo⁠us⁠eEv⁠ent⁠<HT⁠MLB⁠utt⁠onE⁠lem⁠ent⁠, Mo⁠use⁠Eve⁠nt>
    ⁠& Key⁠boa⁠rd ​Eve⁠nt<H⁠TML⁠But⁠ton⁠Ele⁠me⁠nt>*`。”
- en: This is why we need an `as any` type assertion to make it possible to actually
    call the handler with the event.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们需要一个`as any`类型断言，以确保实际上可以用事件调用处理程序。
- en: 'The function signature works in a lot of scenarios:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 函数签名在很多场景下都适用：
- en: '[PRE72]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'But once there’s ambiguity, things don’t work out as they should:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 但一旦存在歧义，事情就不会按预期进行：
- en: '[PRE73]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'When `mouseOrKeyboardHandler` is a keyboard handler, we can’t reasonably pass
    a mouse event. Wait: this is exactly what the TS2345 error from before tried to
    tell us! We just shifted the problem to another place and made it silent with
    an `as any` assertion.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 当`mouseOrKeyboardHandler`是键盘处理程序时，我们无法合理地传递鼠标事件。等等：这正是之前的 TS2345 错误尝试告诉我们的！我们只是把问题移到另一个地方，并通过`as
    any`断言使其无声。
- en: 'Explicit, exact function signatures make *everything* easier. The mapping becomes
    clearer, the type signatures are easier to understand, and there’s no need for
    conditionals or unions:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 明确、精确的函数签名使*所有事情*变得更容易。映射变得更清晰，类型签名更易于理解，而无需条件或联合：
- en: '[PRE74]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Function overloads help us with all possible scenarios. We make sure there
    are no ambiguous types:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 函数重载帮助我们处理所有可能的情况。我们确保没有歧义的类型：
- en: '[PRE75]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: For the implementation, we can even use `any`. Since you can make sure that
    you won’t run into a situation that implies ambiguity, you can rely on the happy-go-lucky
    type and don’t need to bother.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实现，我们甚至可以使用`any`。由于您可以确保不会遇到暗示歧义的情况，您可以依赖于随心所欲的类型，而不必费心。
- en: The catch-all function body
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数的全能处理体
- en: 'Last but not least, there’s the combination of conditional types *and* function
    overloads. Remember the example from [Recipe 5.1](ch05.html#ch05_function_signatures):
    we saw that conditional types gave the function body a hard time to map values
    to the respective generic return types. Moving the conditional type to a function
    overload and using a very broad function signature for implementation helps both
    the users of the function as well as the implementers:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，条件类型*和*函数重载的组合。记住来自[Recipe 5.1](ch05.html#ch05_function_signatures)的例子：我们看到条件类型使函数体难以将值映射到相应的泛型返回类型。将条件类型移动到函数重载中，并对实现使用非常广泛的函数签名，这对函数的使用者和实现者都有帮助：
- en: '[PRE76]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Function overloads are still very useful and, for a lot of scenarios, the way
    to go. They’re easier to read, easier to write, and, in a lot of cases, more exact
    than what we get with other means.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 函数重载仍然非常有用，并且对于许多场景来说是一个好选择。它们更易读，更易写，并且在许多情况下比其他方法更精确。
- en: But it’s not either-or. You can happily mix and match conditionals and function
    overloads if your scenario needs it.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 但这不是非此即彼的情况。如果您的场景需要，您可以愉快地混合和匹配条件和函数重载。
- en: 12.8 Naming Generics
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12.8 命名泛型
- en: Problem
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: '`T` and `U` don’t tell you anything about generic type parameters.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`T` 和 `U` 并未告诉您关于泛型类型参数的任何信息。'
- en: Solution
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Follow a naming pattern.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循命名模式。
- en: Discussion
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: TypeScript’s generics are arguably one of the most powerful features of the
    language. They open a door to TypeScript’s own metaprogramming language, which
    allows for a very flexible and dynamic generation of types. It comes close to
    being its own functional programming language.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript的泛型可以说是该语言最强大的特性之一。它们打开了通往TypeScript自身元编程语言的大门，允许非常灵活和动态地生成类型。它几乎成为自己的函数式编程语言。
- en: 'Especially with the arrival of *string literal types* and *recursive conditional
    types* in the most recent TypeScript versions, we can craft types that do astonishing
    things. This type from [Recipe 12.2](#ch12_refining_types) parses Express-style
    from route information and retrieves an object with all its parameters:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是在最新的TypeScript版本中引入了*字符串字面类型*和*递归条件类型*之后，我们可以创建做出惊人事情的类型。来自[Recipe 12.2](#ch12_refining_types)的这种类型解析Express风格的路由信息，并检索出所有参数的对象：
- en: '[PRE77]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'When we define a *generic type*, we also define *generic type parameters*.
    They can be of a certain type (or more correctly, be a certain subtype):'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义*泛型类型*时，我们也定义了*泛型类型参数*。它们可以是某种类型（或更正确地说，是某种子类型）：
- en: '[PRE78]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'They can have default values:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可以有默认值：
- en: '[PRE79]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: And when using default values, *order* is important. This is just one of many
    similarities to regular JavaScript functions! So since we are almost talking functions,
    why are we using single-letter names for generic type parameters?
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用默认值时，*顺序*很重要。这只是与常规JavaScript函数的许多相似之处之一！所以既然我们几乎在讨论函数，为什么我们要为通用类型参数使用单字母名称呢？
- en: Most generic type parameters start with the letter `T`. Subsequent parameters
    go along the alphabet (`U`, `V`, `W`) or are abbreviations like `K` for `key`.
    This can lead to highly unreadable types, however. If I look at `Extract<T, U>`,
    it is hard to tell if we extract `T` from `U`, or the other way around.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数通用类型参数以字母`T`开头。后续参数按字母表（`U`、`V`、`W`）或缩写如`K`表示`key`的方式进行。然而，这可能导致类型非常难读。例如看`Extract<T,
    U>`，很难确定我们是从`U`中提取`T`，还是反过来。
- en: 'Being a bit more elaborate helps:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 更加精心设计有所帮助：
- en: '[PRE80]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Now we know that we want to extract *from* the first parameter everything that
    is assignable to `Union`. Furthermore, we understand that we want to have a union
    type.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们要从第一个参数中提取*可赋值给`Union`*的所有内容。此外，我们理解我们想要一个联合类型。
- en: 'Types are documentation, and our type parameters can have speaking names, just
    like you would do with regular functions. Go for a naming scheme, like this one:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 类型是文档，我们的类型参数可以有口语化的名称，就像处理常规函数一样。采用像这样的命名方案：
- en: All type parameters start with an uppercase letter, like you would name all
    other types!
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有类型参数都以大写字母开头，就像您命名所有其他类型一样！
- en: Only use single letters if the usage is completely clear. For example, `ParseRouteParams`
    can have only one argument, the route.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有在使用完全清晰时才使用单个字母。例如，`ParseRouteParams`只能有一个参数，即路由。
- en: Don’t abbreviate to `T` (that’s way too …​ generic!) but to something that clarifies
    what we are dealing with. For example, `ParseRouteParams<R>`, where `R` stands
    for `Route`.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要缩写为`T`（那太……通用了！），而是用能够明确我们在处理什么的东西来命名。例如，`ParseRouteParams<R>`，其中`R`代表`Route`。
- en: 'Rarely use single letters; stick to short words or abbreviations: `Elem` for
    `Element`, `Route` can stand as is.'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很少使用单个字母；坚持使用短词或缩写：`Elem`表示`Element`，`Route`可以保持原样。
- en: Use prefixes to differentiate from built-in types. For example, `Element` is
    taken, so use `GElement` (or stick with `Elem`).
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用前缀来区别于内置类型。例如，`Element`已被占用，因此使用`GElement`（或坚持使用`Elem`）。
- en: 'Use prefixes to make generic names clearer: `URLObj` is clearer than `Obj`,
    for instance.'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用前缀使通用名称更清晰：`URLObj`比`Obj`更清晰。
- en: Same patterns apply to inferred types within a generic type.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样的模式适用于通用类型中的推断类型。
- en: 'Let’s look at `ParseRouteParams` again and be more explicit with our names:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 再次看看`ParseRouteParams`，并对我们的名称更加明确：
- en: '[PRE81]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: It becomes a lot clearer what each type is meant to be. We also see that we
    need to iterate over all `Entry`s in `Param`, even if `Param` is just a set of
    one type.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 每种类型意图明确多了。我们还看到，即使`Param`只是一个类型的集合，我们也需要迭代所有`Entry`。
- en: Arguably, it’s a lot more readable than before!
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说，这比以前要可读性强得多！
- en: 'There is one caveat: it’s almost impossible to distinguish type parameters
    from actual types. There’s another scheme that has been heavily popularized by
    [Matt Pocock](https://oreil.ly/Y1i-Q): using a `T` prefix:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个注意事项：几乎不可能区分类型参数和实际类型。还有另一种方案由[Matt Pocock](https://oreil.ly/Y1i-Q)广泛推广：使用`T`前缀：
- en: '[PRE82]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This comes close to a [Hungarian Notation](https://oreil.ly/c23gW) for types.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 [匈牙利命名法](https://oreil.ly/c23gW) 类似，用于类型。
- en: Whatever variation you use, making sure that generic types are readable to you
    and your colleagues, and that their parameters speak for themselves, is as important
    as in other programming languages.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您使用何种变体，确保泛型类型对您和您的同事易读，并且它们的参数清晰明了，与其他编程语言一样重要。
- en: 12.9 Prototyping on the TypeScript Playground
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12.9 在 TypeScript Playground 上进行原型设计
- en: Problem
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Your project is so big, it’s hard for you to properly fix bugs in typings.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 由于项目过大，难以正确修复类型错误。
- en: Solution
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Move your types to the TypeScript playground and develop them in isolation.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的类型移至 TypeScript Playground 并在隔离环境中开发它们。
- en: Discussion
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: '[The TypeScript playground](https://www.typescriptlang.org/play) as shown in
    [Figure 12-1](#img-playground) is a web application that has been with TypeScript
    since its first release, showcasing how TypeScript syntax is compiled to JavaScript.
    Its capabilities were originally limited and focused on “breaking the ice” for
    new developers, but in recent years it has become a powerhouse of online development,
    rich in features and indispensable for TypeScript development. The TypeScript
    team asks people to submit issues including a re-creation of the bug using the
    playground. They also test new and upcoming features by allowing the nightly version
    to be loaded into the application. In short: the TypeScript playground is essential
    for TypeScript development.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '[TypeScript Playground](https://www.typescriptlang.org/play) 如 [图 12-1](#img-playground)
    所示，这是一个自 TypeScript 首次发布以来一直存在的 Web 应用程序，展示了 TypeScript 语法如何编译为 JavaScript。它最初的能力有限，专注于帮助新开发者入门，但近年来已成为在线开发的强大工具，功能丰富且对
    TypeScript 开发至关重要。TypeScript 团队要求人们提交问题，并使用 Playground 重现 Bug。他们还通过允许加载夜间版本来测试新功能。简而言之，TypeScript
    Playground 对于 TypeScript 开发至关重要。'
- en: '![tscb 1201](assets/tscb_1201.png)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![tscb 1201](assets/tscb_1201.png)'
- en: Figure 12-1\. The TypeScript playground showing one of the built-in examples
  id: totrans-383
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-1\. TypeScript Playground 展示的一个内置示例
- en: For your regular development practices, the TypeScript playground is a great
    way to develop types in isolation, independent from your current project. As TypeScript
    configurations grow, they become confusing, and it becomes hard to understand
    which types contribute to your actual project. If you encounter weird or unexpected
    behavior in your types, try re-creating them in the playground, in isolation,
    without the rest of your project.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 对于您的常规开发实践，TypeScript Playground 是在与当前项目独立无关的环境中开发类型的绝佳方式。随着 TypeScript 配置的增长，它们变得混乱，很难理解哪些类型对您的实际项目有贡献。如果在类型中遇到奇怪或意外的行为，请尝试在
    Playground 中隔离地重新创建它们。
- en: 'The playground doesn’t feature a full *tsconfig.json*, but you can define the
    important pieces of your configuration via a user interface, as seen in [Figure 12-2](#img-tsconfig-panel).
    Alternatively, you can set compiler flags using annotations directly in the source
    code:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: Playground 并不包含完整的 *tsconfig.json*，但您可以通过用户界面定义配置的重要部分，如 [图 12-2](#img-tsconfig-panel)
    中所示。或者，您可以直接在源代码中使用注解来设置编译器标志：
- en: '[PRE83]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Not as comfortable but highly ergonomic as it allows you to share compiler flags
    much more easily.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管不太方便，但高度符合人体工程学，因为它可以更轻松地共享编译器标志。
- en: '![tscb 1202](assets/tscb_1202.png)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![tscb 1202](assets/tscb_1202.png)'
- en: Figure 12-2\. Instead of writing an actual tsconfig.json, you set compiler flags
    using the TSConfig panel
  id: totrans-389
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-2\. 而不是编写一个实际的 tsconfig.json 文件，你可以使用 TSConfig 面板来设置编译器标志。
- en: You also can compile TypeScript, get extracted type information, run small pieces
    of code to see how they behave, and export everything to various destinations,
    including other popular online editors and IDEs.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以编译 TypeScript，获取提取的类型信息，运行小段代码以查看其行为，并将所有内容导出到各种目的地，包括其他流行的在线编辑器和 IDE。
- en: You can select various versions to ensure that your bug isn’t dependent on version
    updates, and you can run various, well-documented examples to learn the basics
    of TypeScript while trying out actual source code.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择各种版本来确保您的错误不依赖于版本更新，并且您可以运行各种详细记录的示例，以便在尝试实际源代码时学习 TypeScript 的基础知识。
- en: 'As noted in [Recipe 12.10](#ch12_multiple_library_versions), developing JavaScript
    would be nothing without using dependencies. In the TypeScript playground, it’s
    possible to fetch type information for dependencies directly from NPM. If you
    import, for example, React within the TypeScript playground, the playground will
    try to acquire types:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [Recipe 12.10](#ch12_multiple_library_versions) 中所述，在 TypeScript playground
    中，无法离开依赖项的支持开发 JavaScript。在 TypeScript playground 中，可以直接从 NPM 获取依赖项的类型信息。例如，在
    TypeScript playground 中导入 React，该 playground 将尝试获取类型：
- en: First, it will look at the respective package on NPM and check if there are
    types defined or *.d.ts* files somewhere in its contents.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它将查看 NPM 上的相应包，并检查其内容中是否定义了类型或 *.d.ts* 文件。
- en: If not, it will check on NPM if Definitely Typed type information exists and
    will download the respective `@types` package.
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有，则会在 NPM 上检查是否存在 Definitely Typed 的类型信息，并将下载相应的 `@types` 包。
- en: 'This is recursive, meaning that if some types require types from other packages,
    type acquisition will also go through the type dependencies. For some packages,
    you can even define which version to load:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这是递归的，意味着如果某些类型需要来自其他包的类型，类型获取也将通过类型依赖进行。对于某些包，甚至可以定义加载哪个版本：
- en: '[PRE84]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Here, `types` is set to `legacy`, which loads the respective legacy version
    from NPM.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`types` 设置为 `legacy`，加载来自 NPM 的相应旧版本。
- en: There’s more to the ecosystem. An important tool of the TypeScript playground
    is *Twoslash*. Twoslash is a markup format for TypeScript files that lets you
    highlight code, handle multiple files, and show the files the TypeScript compiler
    creates. It’s fantastic for blogs and websites—you basically have an inline TypeScript
    compiler for code examples—but it’s also fantastic if you need to create complex
    debugging scenarios.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 生态系统还有更多。TypeScript playground 的重要工具是 *Twoslash*。Twoslash 是 TypeScript 文件的标记格式，允许您突出显示代码、处理多个文件，并显示
    TypeScript 编译器创建的文件。它非常适合博客和网站——基本上，您拥有了内联的 TypeScript 编译器用于代码示例——但如果您需要创建复杂的调试场景，它也非常棒。
- en: 'The compiler flag annotations are handled by Twoslash, but you can also get
    inline hints on current types by adding a marker in a comment directly under a
    variable name:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: Twoslash 处理编译器标志注解，但您还可以通过在变量名直接下方的注释中添加标记来获取当前类型的内联提示：
- en: '[PRE85]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: You can see the result in [Figure 12-3](#img-twoslash).
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [图 12-3](#img-twoslash) 中看到结果。
- en: '![tscb 1203](assets/tscb_1203.png)'
  id: totrans-402
  prefs: []
  type: TYPE_IMG
  zh: '![tscb 1203](assets/tscb_1203.png)'
- en: 'Figure 12-3\. Twoslash in action: setting compiler flags via annotations'
  id: totrans-403
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-3\. Twoslash 的应用：通过注释设置编译器标志
- en: 'Twoslash is also part of the [bug workbench](https://oreil.ly/jVU3u), which
    is a fork of the playground with an emphasis on creating and displaying complex
    reproductions of bugs. Here, you can also define multiple files to see how imports
    and exports work:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: Twoslash 还是 [bug workbench](https://oreil.ly/jVU3u) 的一部分，这是 playground 的一个分支，重点是创建和显示
    bug 的复杂重现。在这里，您还可以定义多个文件，以查看导入和导出的工作方式：
- en: '[PRE86]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Multifile support is triggered by the first `@filename` annotation. Everything
    before this line becomes a file called *input.tsx*, basically your main entry
    point.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 多文件支持由第一个 `@filename` 注解触发。此行之前的所有内容都成为一个名为 *input.tsx* 的文件，基本上是您的主入口点。
- en: Last but not least, the playground can work as your entire demo suite for workshops
    and trainings. Using Twoslash, you can create multiple files in a GitHub Gist
    repository and load the TypeScript files along with documentation as part of a
    Gist docset, as seen in [Figure 12-4](#img-docsets).
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，playground 可以作为工作坊和培训的整个演示套件。使用 Twoslash，您可以在 GitHub Gist 存储库中创建多个文件，并加载
    TypeScript 文件以及作为 Gist 文档集的一部分的文档，如 [图 12-4](#img-docsets) 所示。
- en: This is immensely powerful for immersive learning. From mere reproductions to
    full-fledged demo suites, the TypeScript playground is the one-stop source for
    TypeScript developers—whether you need to file bugs, try out something new, or
    work on types in isolation. It’s a great resource to start with, and from there
    you can easily migrate to “real” IDEs and tools.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 对于沉浸式学习来说，这非常强大。从简单的重现到完整的演示套件，TypeScript playground 是 TypeScript 开发人员的一站式资源——无论您是需要报告
    bug、尝试新功能还是独立工作于类型之上。这是一个很好的起点资源，从那里您可以轻松迁移到“真正”的 IDE 和工具。
- en: '![tscb 1204](assets/tscb_1204.png)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![tscb 1204](assets/tscb_1204.png)'
- en: Figure 12-4\. A Gist docset in the playground
  id: totrans-410
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-4\. 在 playground 中的 Gist 文档集
- en: 12.10 Providing Multiple Library Versions
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12.10 提供多个库版本
- en: Problem
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You write external types for a library and want to maintain type updates relative
    to library version updates.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 您为库编写外部类型，并希望相对于库版本更新保持类型更新。
- en: Solution
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use reference triple-slash directives, as well as modules, namespaces, and interfaces
    for declaration merging.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 使用三斜杠引用指令，以及模块、命名空间和接口用于声明合并。
- en: Discussion
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Programming would be tough without external libraries that take care of a lot
    of work for you. JavaScript’s ecosystem is arguably one of the richest when it
    comes to third-party dependencies, mainly through [NPM](https://npmjs.org). Also,
    most of them come with TypeScript support, either through built-in types or through
    types from Definitely Typed. According to the TypeScript team, almost [80% of
    NPM is typed](https://oreil.ly/G2Ktl). However, there is still the odd holdout:
    for example, libraries are not written in TypeScript, or legacy code from your
    own company that you still need to make compatible with today’s software.'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 编程如果没有处理很多工作的外部库会变得很困难。在第三方依赖方面，JavaScript 生态系统可以说是最丰富之一，主要通过[NPM](https://npmjs.org)实现。大多数库都支持
    TypeScript，要么通过内置类型，要么通过 Definitely Typed 提供的类型。根据 TypeScript 团队的说法，几乎[80% 的 NPM
    包是有类型定义的](https://oreil.ly/G2Ktl)。然而，仍然有一些例外情况：例如，某些库不是用 TypeScript 编写的，或者是你公司的遗留代码，你仍然需要使其兼容今天的软件。
- en: 'Think of a library called *“lib”*, which exposes a `Connector` class that you
    can use to target internal systems. This library exists in multiple versions,
    and features have been added constantly:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个名为 *"lib"* 的库，它公开了一个 `Connector` 类，你可以用它来访问内部系统。这个库存在多个版本，并且功能不断添加：
- en: '[PRE87]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: It’s worth noting that this library can be used by multiple projects within
    your organization, with varying versions. Your task is to write types so your
    teams get proper autocomplete and type information.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，这个库可以被你组织内的多个项目使用，并且版本可能各不相同。你的任务是编写类型，以便你的团队能够得到正确的自动补全和类型信息。
- en: In TypeScript, you can provide multiple versions of a library’s types by creating
    an ambient module declaration for each version of the library. An ambient module
    declaration is a file with a *.d.ts* extension that provides TypeScript with the
    types for a library not written in TypeScript.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 中，你可以通过为每个库版本创建一个环境模块声明来提供多个版本的类型定义。环境模块声明是一个带有 *.d.ts* 扩展名的文件，为
    TypeScript 提供了非 TypeScript 编写的库的类型。
- en: 'By default, TypeScript is greedy: it includes type definitions and *globs*
    everything it can. If you want to limit TypeScript’s file access, make sure to
    use the `"exclude"` and `"include"` properties in *tsconfig.json*:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，TypeScript 是贪婪的：它包括类型定义并且 *全面包含* 所有它能找到的内容。如果要限制 TypeScript 的文件访问，请确保在
    *tsconfig.json* 中使用 `"exclude"` 和 `"include"` 属性：
- en: '[PRE88]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'We create a folder *next to* the folders we included in *tsconfig.json*. Here,
    we create a file called *lib.v1.d.ts*, where we store the basic information on
    how objects are created:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 *tsconfig.json* 包含的文件夹旁边创建一个名为 *lib.v1.d.ts* 的文件，在这里，我们存储有关如何创建对象的基本信息：
- en: '[PRE89]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Note that we use modules to define the name of the module and that we also use
    interfaces for most of our types. Both modules and interfaces are open to declaration
    merging, which means we can add new types in different files and TypeScript merges
    them together. This is crucial if we want to define multiple versions.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们使用模块来定义模块的名称，并且我们也使用接口来定义大多数类型。模块和接口都可以进行声明合并，这意味着我们可以在不同文件中添加新的类型，并且 TypeScript
    会将它们合并在一起。如果我们想定义多个版本，这一点至关重要。
- en: 'Also note that we use the constructor interface pattern (see [Recipe 11.3](ch11.html#ch11_constructor_interfaace))
    for `Connector`:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，我们使用构造函数接口模式（参见[Recipe 11.3](ch11.html#ch11_constructor_interfaace)）来定义
    `Connector`：
- en: '[PRE90]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: In doing so, we can change the signature of the constructor and make sure that
    an instantiable class is being recognized by TypeScript.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们可以改变构造函数的签名，并确保 TypeScript 能识别出可实例化的类。
- en: 'In another file called *lib.v2.d.ts*, next to *lib.v1.d.ts*, we redeclare `"lib"`
    and add more methods to `Connection`. Through declaration merging, the `close`
    method gets added to the `Connection` interface:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在名为 *lib.v2.d.ts* 的另一个文件中，旁边是 *lib.v1.d.ts*，我们重新声明 `"lib"` 并向 `Connection` 添加更多方法。通过声明合并，`close`
    方法被添加到 `Connection` 接口中：
- en: '[PRE91]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Using triple-slash directives, we refer from *lib.v2.d.ts* to *lib.v1.d.ts*,
    signaling that everything from version 1 is to be included in version 2.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 使用三斜杠引用指令，我们从 *lib.v2.d.ts* 引用到 *lib.v1.d.ts*，表示版本 2 中包含版本 1 的所有内容。
- en: 'All those files exist in a folder called *@lib*. Using the configuration we
    declared earlier, TypeScript won’t pick them up. We can, however, write a new
    file *lib.d.ts* and put it in *@types*, and from there, refer to the version we
    want to include:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些文件存在于一个名为 *@lib* 的文件夹中。根据我们之前声明的配置，TypeScript 不会将它们拾取起来。然而，我们可以编写一个新文件 *lib.d.ts*
    并将其放在 *@types* 中，并从那里引用我们想要包含的版本：
- en: '[PRE92]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: A simple change from *“../@lib/lib.v2.d.ts”* to *“../@lib/lib.v1.d.ts”* will
    change the version we target, while we still maintain all library versions independently.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地从 *“../@lib/lib.v2.d.ts”* 改为 *“../@lib/lib.v1.d.ts”* 将会改变我们目标的版本，同时仍然独立地维护所有库版本。
- en: If you are curious, try looking into the included library files from TypeScript.
    They are a treasure trove of external type definitions, and there is a lot to
    learn. If you use your editor to find references, for example, to `Object.keys`,
    you will see that this function exists in multiple locations, and based on your
    TypeScript configuration, the right file will be included. [Figure 12-5](#img-object-keys)
    shows how Visual Studio Code displays various file locations for `Object.keys`.
    TypeScript is so flexible that you can use the same techniques for your project,
    even extending TypeScript’s built-in types themselves (see [Recipe 9.7](ch09.html#ch09_augmenting_globals)).
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您感兴趣，可以尝试查看 TypeScript 的包含库文件。它们是外部类型定义的宝库，有很多可以学习的地方。例如，如果您使用编辑器查找对 `Object.keys`
    的引用，您将看到此函数存在于多个位置，并且根据您的 TypeScript 配置，将包含适当的文件。[图 12-5](#img-object-keys) 展示了
    Visual Studio Code 如何显示 `Object.keys` 的各个文件位置。TypeScript 如此灵活，您可以为您的项目使用相同的技术，甚至扩展
    TypeScript 的内置类型本身（参见[食谱 9.7](ch09.html#ch09_augmenting_globals)）。
- en: '![tscb 1205](assets/tscb_1205.png)'
  id: totrans-437
  prefs: []
  type: TYPE_IMG
  zh: '![tscb 1205](assets/tscb_1205.png)'
- en: Figure 12-5\. Finding references to built-in types in Visual Studio Code shows
    you how TypeScript manages multiple versions of ECMAScript and the DOM
  id: totrans-438
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-5\. 在 Visual Studio Code 中查找内置类型的引用显示了 TypeScript 如何管理多个 ECMAScript 和 DOM
    的版本
- en: In conclusion, providing multiple versions of a library’s types in TypeScript
    can be done by creating ambient module declarations for each version of the library
    and referencing the appropriate declaration in your TypeScript code. Hopefully,
    you will be able to use package managers in your project to manage different versions
    of libraries and their corresponding types, making it easier to handle dependencies
    and avoid conflicts.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，在 TypeScript 中为库的多个版本提供多个类型可以通过为每个库版本创建环境模块声明并在 TypeScript 代码中引用适当的声明来完成。希望您能够在项目中使用包管理器来管理不同版本的库及其相应的类型，从而更轻松地处理依赖关系并避免冲突。
- en: 12.11 Knowing When to Stop
  id: totrans-440
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12.11 停止的时机
- en: Problem
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Writing elaborate and complicated types is exhausting!
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 编写复杂和复杂的类型是令人筋疲力尽的！
- en: Solution
  id: totrans-443
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Don’t write elaborate and complicated types. TypeScript is gradual; use what
    makes you productive.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 不要编写复杂和复杂的类型。 TypeScript 是渐进式的；使用让您高效的内容。
- en: Discussion
  id: totrans-445
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: I want to end this book with some general advice on how to stop at the right
    time. If you have read through the entire book and ended up here, you have read
    through more than one hundred recipes with a lot of advice about everyday TypeScript
    problems. Be it project setup, complicated situations where you need to find the
    right type, or workarounds when TypeScript runs into a situation where it’s too
    strict for its own good, we have covered it all.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 我想以一些关于如何在正确的时间停止的一般建议结束本书。如果您已经阅读了整本书并且最终到达这里，您已经阅读了一百多个关于日常 TypeScript 问题的建议。无论是项目设置、需要找到正确类型的复杂情况，还是在
    TypeScript 对其自身的好处过于严格时的变通方法，我们都已经覆盖了一切。
- en: Solutions can get very complex, especially when we enter the area of conditional
    types and everything around them, like helper types, variadic tuple types, and
    string template literal types. TypeScript’s type system is undoubtedly powerful,
    especially if you understand that every decision, every feature, has its roots
    in the fact that JavaScript lies underneath it all. Creating a type system that
    gives you strong, static types for a programming language that is so inherently
    dynamic is an amazing achievement. I have nothing but the deepest admiration for
    the bright minds in Redmond who made all of this possible.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案可能变得非常复杂，特别是当我们涉及条件类型及其周围的一切时，如辅助类型、可变元组类型和字符串模板字面类型。 TypeScript 的类型系统无疑非常强大，特别是如果您理解每一个决策、每一个特性都源于
    JavaScript 潜在的事实。为一门如此内在动态的编程语言创建一个提供强大、静态类型的类型系统是一个了不起的成就。我对那些在 Redmond 做出这一切可能的聪明头脑深表敬意。
- en: However, undeniably, things can get very complicated at times. Types can be
    hard to read or create, and the fact that the type system is its own Turing-complete
    meta-programming system that needs testing libraries doesn’t help. And developers
    take pride in understanding every aspect of their craft and tools, often preferring
    a complex type solution over simpler types that don’t give the same type safety
    but are ultimately easier to read and understand.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，不可否认，有时情况可能会变得非常复杂。类型可能难以阅读或创建，而类型系统本身又是一个图灵完备的元编程系统，需要测试库的支持也并不帮助。开发者们以理解他们工具和技能的每一个方面为荣，通常更倾向于复杂的类型解决方案，而不是简单的类型，尽管简单类型可能不提供相同的类型安全性，但更容易阅读和理解。
- en: A project that goes into the nitty-gritty of the type system is called [Type
    Challenges](https://tsch.js.org). It’s a fantastic project of brainteasers that
    show what’s possible with the type system. I fiddle around with some of the more
    challenging riddles, getting great ideas for how to explain the type system better.
    And while puzzles are fantastic for training a developer’s mind, most of them
    lack a significant grasp of real-world, everyday situations.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 一个深入研究类型系统的项目被称为 [Type Challenges](https://tsch.js.org)。这是一个展示类型系统可能性的精彩项目。我喜欢尝试一些更具挑战性的谜题，从中获得如何更好地解释类型系统的好主意。虽然这些谜题对培养开发者的思维非常有帮助，但大多数情况下它们缺乏对真实世界日常情况的重要把握。
- en: 'And those are the situations where we often overlook TypeScript’s wonderful
    capability that you don’t often see in mainstream programming languages: its gradual
    adoption of types. Tools like `any`, generic type parameters, and type assertions
    and the fact that you can write simple JavaScript with a couple of comments make
    the barrier to entry so much lower. The latest effort from the TypeScript team
    and TC39 is to lower the barrier even more by adding [type annotations to JavaScript](https://oreil.ly/yQnIO),
    a proposal currently in discussion. The goal of this proposal is not to make JavaScript
    type safe but to remove compile steps if we want to have simple, easy-to-understand
    type annotations. JavaScript engines can treat them as comments, and type-checkers
    can get real information on the program’s semantics.'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 而这些情况下，我们经常忽视 TypeScript 的一个了不起的功能，这在主流编程语言中并不常见：它对类型的渐进采纳。像 `any`、泛型类型参数和类型断言以及你可以用几个注释编写简单的
    JavaScript 的事实，降低了进入门槛。TypeScript 团队和 TC39 的最新努力是通过在 JavaScript 中添加 [类型注解](https://oreil.ly/yQnIO)
    来进一步降低这个门槛，这个提案目前正在讨论中。该提案的目标不是使 JavaScript 类型安全，而是在我们想要简单、易于理解的类型注解时，移除编译步骤。JavaScript
    引擎可以将其视为注释，并且类型检查器可以获取程序语义的真实信息。
- en: 'As developers, project leaders, engineers, and architects, we should use this
    feature. Simple types are always better types: easier to understand and much easier
    to consume.'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者、项目负责人、工程师和架构师，我们应该使用这个特性。简单的类型总是更好的类型：更容易理解，也更容易使用。
- en: 'The [TypeScript website](https://typescriptlang.org) changed its claim from
    “JavaScript that scales” to “JavaScript with syntax for types,” which should give
    you an idea of how to approach TypeScript in projects: write JavaScript, annotate
    where necessary, write simple but comprehensive types, and use TypeScript as a
    way to document, understand, and communicate your software.'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '[TypeScript 网站](https://typescriptlang.org) 将其宣称从 “JavaScript that scales”
    更改为 “JavaScript with syntax for types”，这应该让你了解如何在项目中使用 TypeScript：编写 JavaScript，在必要时注释，编写简单但全面的类型，并将
    TypeScript 作为记录、理解和传达软件的一种方式。'
- en: 'I think TypeScript follows the [Pareto principle](https://oreil.ly/smytJ):
    80% of type safety comes from 20% of its features. This doesn’t mean the rest
    of it is bad or unnecessary. We just spent one hundred recipes to understand situations
    where we effectively need TypeScript’s more advanced features. It should just
    give you an idea of where to put effort. Don’t run into advanced TypeScript trickery
    on every occasion. Monitor if loser types are a problem. Estimate the effort to
    change types in your program, and make well-informed decisions. Also know that
    in a refinement process (see [Recipe 12.2](#ch12_refining_types)), the reason
    for multiple steps is to easily be able to stop.'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为 TypeScript 遵循 [帕累托法则](https://oreil.ly/smytJ)：80% 的类型安全性来自其 20% 的特性。这并不意味着其余部分是不好或不必要的。我们只是花了一百个场景来理解在哪些情况下我们实际上需要
    TypeScript 的更高级特性。这应该只是一个指导方向。不要在每个场合都使用高级的 TypeScript 技巧。监控一下是否 loser types 是一个问题。估计一下在你的程序中更改类型的工作量，并做出明智的决策。另外，请注意，在一个细化的过程中（见
    [Recipe 12.2](#ch12_refining_types)），多个步骤的原因在于可以轻松地停止。
- en: ^([1](ch12.html#id971-marker)) Fluent interfaces allow for chainable operations
    by returning the instance with every method call.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch12.html#id971-marker)) 流畅接口通过在每次方法调用时返回实例来实现可链接操作。
