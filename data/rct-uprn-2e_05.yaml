- en: Chapter 5\. JSX
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章 JSX
- en: 'You’ve already seen JSX in action in the previous chapters. You know it’s all
    about writing JavaScript expressions containing XML that looks very much like
    HTML. For example:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，你已经看到 JSX 的运行效果。你知道它完全是关于编写包含 XML 的 JavaScript 表达式，看起来非常像 HTML。例如：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And you know you can always “interrupt the flow” of XML by including more JavaScript
    expressions wrapped in curly braces:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 并且你知道你总是可以通过包含更多用花括号括起来的 JavaScript 表达式来“打断” XML 的流程：
- en: '[PRE1]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'That’s true even if the expressions happen to be conditions, loops, or more
    JSX:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 就算这些表达式恰好是条件、循环或更多的 JSX：
- en: '[PRE2]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this chapter, you’ll to learn more about JSX and explore some features that
    may surprise and/or delight you.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习更多关于 JSX 的知识，并探索一些可能令你惊喜和/或喜爱的功能。
- en: Note
  id: totrans-8
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: To see the examples above in action, load *05.01.hellojsx.html* from the book’s
    repo. The file is also an illustration of how you can have several React applications
    on the same page.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看上述示例的实际效果，请从本书的仓库加载 *05.01.hellojsx.html*。该文件还说明了如何在同一页上拥有多个 React 应用程序。
- en: A Couple Tools
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 几个工具
- en: To experiment and get familiar with the JSX transforms, you can play with the
    live editor at [*https://babeljs.io/repl*](https://babeljs.io/repl) (shown in
    [Figure 5-1](#FIG0501)). Make sure you check the “Prettify” option for better
    readability of the result.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试并熟悉 JSX 转换，你可以在 [*https://babeljs.io/repl*](https://babeljs.io/repl) 上使用实时编辑器（显示在
    [图 5-1](#FIG0501)）。确保选中 “Prettify” 选项以获得更好的结果可读性。
- en: '![rur2 0501](Images/rur2_0501.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![rur2 0501](Images/rur2_0501.png)'
- en: Figure 5-1\. Babel as a live JSX transformation tool
  id: totrans-13
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-1\. Babel 作为一个实时 JSX 转换工具
- en: 'As you can see in [Figure 5-2](#FIG0502), the JSX transform is lightweight
    and simple: the JSX source of “Hello world!” from [Chapter 1](ch01.xhtml#ch1)
    becomes a series of calls to `React​.crea⁠teElement()`, using the function syntax
    React works with. It’s just JavaScript, so it’s easy to read and understand.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在 [图 5-2](#FIG0502) 中所见，JSX 转换是轻量且简单的：来自 [第 1 章](ch01.xhtml#ch1) 的 “Hello
    world!” 的 JSX 源代码成为了一系列对 `React.createElement()` 的调用，使用了 React 工作的函数语法。它只是 JavaScript，所以很容易阅读和理解。
- en: '![rur2 0502](Images/rur2_0502.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![rur2 0502](Images/rur2_0502.png)'
- en: Figure 5-2\. “Hello World” transformed
  id: totrans-16
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-2\. “Hello World” 转换
- en: Another online tool you may find helpful when learning JSX or transitioning
    an existing app’s markup from HTML is the [HTML-to-JSX compiler](https://magic.reactjs.net/htmltojsx.htm)
    (shown in [Figure 5-3](#FIG0503)).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当你学习 JSX 或者将现有应用程序的标记从 HTML 过渡到 JSX 时，另一个在线工具可能会对你有帮助，即 [HTML 到 JSX 编译器](https://magic.reactjs.net/htmltojsx.htm)（显示在
    [图 5-3](#FIG0503)）。
- en: '![rur2 0503](Images/rur2_0503.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![rur2 0503](Images/rur2_0503.png)'
- en: Figure 5-3\. HTML-to-JSX tool
  id: totrans-19
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-3\. HTML 到 JSX 工具
- en: Now, on to some of the particularities of JSX.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一些 JSX 的特殊之处。
- en: Whitespace in JSX
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSX 中的空白
- en: 'Whitespace in JSX is similar to HTML but not identical. For example, if you
    have this JSX:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: JSX 中的空白与 HTML 类似但并非完全相同。例如，如果你有以下的 JSX：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When React renders it in the browser (you can inspect the resulting HTML in
    the browser’s dev tools), the generated HTML looks like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当 React 在浏览器中渲染它时（你可以在浏览器的开发工具中检查生成的 HTML），生成的 HTML 如下所示：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is effectively an `h1` DOM node with five children, which are text element
    nodes with content: “1”, “plus”, “2”, “is” and “3”, which renders as “1 plus 2
    is 3.” Exactly as you’d expect in HTML, multiple spaces become one when rendered
    in the browser, as depicted in [Figure 5-4](#FIG0504).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是一个具有五个子节点的 `h1` DOM 节点，这些子节点是文本元素节点，内容分别是：“1”，“plus”，“2”，“is” 和 “3”，在浏览器中渲染为
    “1 plus 2 is 3。” 正如在 HTML 中所预期的那样，多个空格在浏览器中渲染时会变成一个，如 [图 5-4](#FIG0504) 所示。
- en: '![rur2 0504](Images/rur2_0504.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![rur2 0504](Images/rur2_0504.png)'
- en: Figure 5-4\. Rendering whitespace (see *05.02.whitespace.html* in the repo)
  id: totrans-28
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-4\. 渲染空白（参见仓库中的 *05.02.whitespace.html*）
- en: 'However, in this next example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在下一个例子中：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '…you end up with:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: …你最终会得到：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see, all the whitespace is trimmed, so the end result displayed
    in the browser is “1plus2is3.” You can always add space where you need it with
    `{'' ''}` or turn the literal strings into expressions and add the space there.
    In other words, any of these work:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，所有的空白都被修剪掉了，所以在浏览器中显示的最终结果是 “1plus2is3。” 你可以随时在需要的地方添加 `{' '}` 来增加空格，或者将字面字符串转换为表达式并在那里添加空格。换句话说，这些都可以工作：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Comments in JSX
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSX 中的注释
- en: In the preceding examples, you see how a new concept sneaked in—adding comments
    to JSX markup.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，你看到一个新概念悄悄进入了——在 JSX 标记中添加注释。
- en: 'Because the expressions wrapped in `{}` are just JavaScript, you can easily
    add multiline comments using `/* comment */`. You can also add single-line comments
    using `// comment`, but you have to make sure the closing `}` of the expression
    is on a separate line so it’s not considered part of the comment:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因为用 `{// comment}` 作为单行注释不起作用（`}` 现在被注释掉了），使用单行注释几乎没有好处。您可以保持评论的一致性，并在所有情况下坚持使用多行注释。
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Because `{// comment}` is not working (the `}` is now commented out), there’s
    little benefit to using single-line comments. You can keep your comments consistent
    and stick to multiline comments in all cases.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `{// comment}` 不起作用（`}` 现在被注释掉了），使用单行注释几乎没有好处。您可以保持您的评论一致，并在所有情况下坚持使用多行注释。
- en: HTML Entities
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML实体（HTML Entities）
- en: 'You can use HTML entities in JSX like so:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在JSX中像这样使用HTML实体：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This example produces a “double right angle quote,” as shown in [Figure 5-5](#FIG0505).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例生成一个“双右角引号”，如[图 5-5](#FIG0505)所示。
- en: '![rur2 0505](Images/rur2_0505.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![rur2 0505](Images/rur2_0505.png)'
- en: Figure 5-5\. HTML entity in JSX
  id: totrans-46
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-5\. JSX中的HTML实体
- en: 'However, if you use the entity as part of an expression, you will run into
    double-encoding issues. In this example, the HTML gets encoded:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您将实体用作表达式的一部分，将会遇到双重编码问题。在此示例中，HTML被编码：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can see the result in [Figure 5-6](#FIG0506).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[图 5-6](#FIG0506)中看到结果。
- en: '![rur2 0506](Images/rur2_0506.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![rur2 0506](Images/rur2_0506.png)'
- en: Figure 5-6\. Double-encoded HTML entity
  id: totrans-51
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-6\. 双重编码的HTML实体
- en: 'To prevent the double-encoding, you can use the Unicode version of the HTML
    entity, which in this case is `\u00bb` (see [*https://dev.w3.org/html5/html-author/charref*](https://dev.w3.org/html5/html-author/charref)):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止双重编码，您可以使用HTML实体的Unicode版本，例如 `\u00bb`（请参阅[*https://dev.w3.org/html5/html-author/charref*](https://dev.w3.org/html5/html-author/charref)）：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'For convenience, you can define a constant somewhere at the top of your module
    together with any common spacing. For example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为方便起见，您可以在模块顶部的某处定义一个常量，以及任何常见的间距。例如：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then use the constant anywhere you need, for example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后您可以在需要的任何地方使用该常量，例如：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Anti-XSS
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反跨站脚本攻击（Anti-XSS）
- en: 'You may be wondering why you have to jump through hoops to use HTML entities.
    There’s a good reason that outweighs the drawbacks: you need to fight cross-site
    scripting (XSS).'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想知道为什么您必须绕过许多障碍才能使用HTML实体。有一个重要的原因超过了缺点：您需要对抗跨站脚本攻击（XSS）。
- en: 'React escapes all strings to prevent a class of XSS attacks. So when you ask
    the user to give you some input and they provide a malicious string, React protects
    you. Take this user input, for example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: React会转义所有字符串以防止一类XSS攻击。因此，当您要求用户提供输入并且他们提供了一个恶意字符串时，React会保护您。例如，接受用户输入：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Under some circumstances, you may end up writing this into the DOM. For example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能会将此写入DOM中。例如：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is a disaster, because the page reads “John,” but the `<script>` tag loads
    a potentially malicious JavaScript from a third-party web site, likely owned by
    a criminal. This compromises your app and, in turn, the users that trust you.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个灾难，因为页面上显示“John”，但`<script>`标签加载了一个潜在恶意的第三方网站的JavaScript，很可能由犯罪分子拥有。这会危及您的应用程序，进而危害信任您的用户。
- en: 'React protects you in cases like this out of the box. React escapes the content
    of `firstname` when you do the following (as shown in [Figure 5-7](#FIG0507)):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: React在开箱即用的情况下为您提供了保护机制。当您执行以下操作时，React会转义`firstname`的内容（如[图 5-7](#FIG0507)所示）：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![rur2 0507](Images/rur2_0507.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![rur2 0507](Images/rur2_0507.png)'
- en: Figure 5-7\. Escaping strings (see *05.05.antixss.html* in the repo)
  id: totrans-68
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-7\. 转义字符串（请参阅*05.05.antixss.html*在代码库中）
- en: Spread Attributes
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展属性（Spread Attributes）
- en: JSX borrows a feature from ECMAScript called the *spread operator* and adopts
    it as a convenience when defining properties.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: JSX从ECMAScript借用了一项称为*扩展运算符*的功能，并将其作为定义属性的便利方法采纳。
- en: 'Imagine you have a collection of attributes you want to pass to an `<a>` component:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一组要传递给`<a>`组件的属性：
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can always do it like so:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您始终可以这样做：
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'But this feels like a lot of boilerplate code. By using spread attributes,
    you can accomplish this in just one line:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 但这感觉像是大量的样板代码。通过使用扩展属性，您可以在一行中完成此操作：
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the example above (see *05.06.spread.html* in the repo), you have an object
    of attributes you want to define ahead of time, maybe some of them conditionally.
    Another common use for spread attributes is when you get this object of attributes
    from the outside—often from a parent component. Let’s see how that case plays
    out.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中（参见仓库中的 *05.06.spread.html*），您有一个要预先定义的属性对象，也许其中一些是有条件的。展开属性的另一个常见用法是当您从外部获取这个属性对象时——通常是从父组件获取。让我们看看这种情况是如何发生的。
- en: Parent-to-Child Spread Attributes
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 父到子的展开属性
- en: 'Imagine you’re building a `FancyLink` component that uses a regular `<a>` behind
    the scenes. You want your component to accept all the attributes that `<a>` does
    (`href`, `target`, `rel`, etc.) plus some more that are not part of HTML proper
    (say, `variant`). People can use your component like so:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在构建一个 `FancyLink` 组件，它在幕后使用常规的 `<a>`。您希望您的组件接受所有 `<a>` 所具有的属性（`href`、`target`、`rel`
    等）以及一些不属于 HTML 标准的属性（例如 `variant`）。人们可以像这样使用您的组件：
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How can your component take advantage of spread attributes and avoid redefining
    all the properties of `<a>`?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您的组件如何利用展开属性并避免重新定义所有 `<a>` 的属性？
- en: 'Here’s one approach where your app may allow only 3 sizes for links and you
    let the users of the component specify the desired size via the custom `variant`
    property. You do the sizing magic with the help of a `switch` statement and CSS
    classes. Then you pass all of the other properties to `<a>`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一种方法，您的应用程序可能仅允许链接有 3 种尺寸，并允许组件的用户通过自定义 `variant` 属性指定所需的尺寸。您可以借助 `switch`
    语句和 CSS 类来实现大小调整。然后将所有其他属性传递给 `<a>`：
- en: '[PRE22]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-84
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Did you notice the use of `props.children`? This is a convenient way of allowing
    any number of children to be passed over to your component, which you can access
    when composing your UI. In the case of the `FancyLink` component, the following
    is perfectly valid:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您注意到使用了 `props.children` 吗？这是允许传递任意数量子元素到您的组件中的便捷方式，您可以在组合 UI 时访问这些子元素。对于 `FancyLink`
    组件，以下内容是完全有效的：
- en: '[PRE23]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding snippet, you do your custom work based on the value of the
    `variant` property, then simply carry over all the properties to `<a>`. This includes
    the `variant` property, which will appear in the resulting DOM, although the browser
    has no use for it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，您可以根据 `variant` 属性的值进行自定义处理，然后将所有属性简单地传递给 `<a>`。这包括 `variant` 属性，它将出现在生成的
    DOM 中，尽管浏览器对其无用。
- en: 'You can do a little better and not pass around unnecessary properties by cloning
    the props passed to you and removing the ones the browser will ignore anyway.
    Something like:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以更好地避免传递不必要的属性，通过克隆传递给您的 props，并删除浏览器无法忽略的属性。像这样：
- en: '[PRE24]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Another way to do the shallow cloning is to use the JavaScript spread operator:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种浅克隆的方法是使用 JavaScript 展开运算符：
- en: '[PRE25]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Additionally, you can clone only the props you’ll pass to the browser and at
    the same time assign the other ones to local variables (thus removing the need
    to delete them afterward), all in a single line:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以仅克隆您将传递给浏览器的 props，并同时将其他 props 分配给本地变量（从而无需后续删除），这一切可以在一行内完成：
- en: '[PRE26]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'So the end result for the `FancyLink` could look like so (see *05.07.fancylink.html*
    in the repo):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`FancyLink` 的最终结果可能如下所示（参见仓库中的 *05.07.fancylink.html*）：
- en: '[PRE27]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Returning Multiple Nodes in JSX
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 JSX 中返回多个节点
- en: 'You always have to return a single node (or an array) from your render function.
    Returning two nodes is not allowed. In other words, this is an error:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您总是需要从渲染函数返回单个节点（或数组）。不允许返回两个节点。换句话说，以下内容是错误的：
- en: '[PRE28]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: A Wrapper
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个包装器
- en: 'The fix is trivial—just wrap all the nodes in another component such as a `<div>`
    (and add a space between the “Hello” and “World” while you’re at it):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 修复方法很简单——只需将所有节点包装在另一个组件中，比如 `<div>`（同时在 "Hello" 和 "World" 之间添加一个空格）：
- en: '[PRE29]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: A Fragment
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个片段
- en: To remove the need for an extra wrapper element, newer versions of React added
    *fragments*, which are wrappers that do not add additional DOM nodes when the
    component is rendered.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了消除额外的包装器元素的需要，React 的更新版本添加了 *fragments*，它们是包装器，在组件渲染时不会添加额外的 DOM 节点。
- en: '[PRE30]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Furthermore, the `React.Fragment` part can be omitted and these empty elements
    also work:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可以省略 `React.Fragment` 部分，这些空元素也可以工作：
- en: '[PRE31]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note
  id: totrans-107
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of writing this `<></>` syntax is not supported by the in-browser
    version of Babel and you need to spell out `React​.Frag⁠ment`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，浏览器版本的 Babel 不支持 `<></>` 语法，您需要明确写出 `React.Frag⁠ment`。
- en: An Array
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个数组
- en: Another option is to return an *array* of nodes, as long as the nodes in the
    array have proper `key` attributes. Note the required commas after every element
    of the array.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是返回一个*数组*的节点，只要数组中的节点有适当的 `key` 属性即可。请注意，在数组的每个元素后面都需要逗号。
- en: '[PRE32]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As you see, you can also sneak in whitespace and other strings in the array,
    and these don’t need a `key`. In a way, this is similar to accepting any number
    of children passed from the parent and propagating them over in your render function:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，您还可以在数组中插入空格和其他字符串，而这些不需要 `key`。在某种程度上，这类似于从父组件传递任意数量的子节点并在渲染函数中传播它们：
- en: '[PRE33]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Differences Between JSX and HTML
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSX 和 HTML 的区别
- en: JSX should look familiar—it’s just like HTML, except it’s stricter as it’s XML.
    And it has the added benefits of providing an easy way to add dynamic values,
    loops, and conditions (just wrap them in `{}`).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: JSX 应该看起来很熟悉 —— 它就像 HTML，只是更严格，因为它是 XML。它还有额外的好处，可以轻松添加动态值、循环和条件（只需用 `{}` 包裹它们）。
- en: To start with JSX, you can always use the [HTML-to-JSX compiler](https://magic.reactjs.net/htmltojsx.htm),
    but the sooner you start typing your very own JSX, the better. Let’s consider
    the few differences between HTML and JSX that may surprise you.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 JSX，您可以始终使用 [HTML-to-JSX 编译器](https://magic.reactjs.net/htmltojsx.htm)，但是越早开始键入您自己的
    JSX，效果越好。让我们考虑一下可能会让您感到惊讶的几个 HTML 和 JSX 之间的区别。
- en: Some of these differences were touched upon in previous chapters, but let’s
    quickly review them again.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一些这些差异在前面的章节中已经提到过，但让我们快速回顾一下它们。
- en: No class, What for?
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 没有班级，为什么？
- en: 'Instead of the `class` and `for` attributes (both reserved words in ECMAScript),
    you need to use `className` and `htmlFor`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是 `class` 和 `for` 属性（在 ECMAScript 中都是保留字），您需要使用 `className` 和 `htmlFor`：
- en: '[PRE34]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: style Is an Object
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 样式是一个对象
- en: 'The `style` attribute takes an object value, not a semicolon-separated string
    as in regular HTML. And the names of the CSS properties are camelCase, not dash-delimited:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`style` 属性接受一个对象值，而不是常规 HTML 中用分号分隔的字符串。CSS 属性的名称使用驼峰命名法，而不是破折号分隔：'
- en: '[PRE35]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Closing Tags
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关闭标签
- en: 'In HTML some tags don’t need to be closed; in JSX (XML) they all do:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTML 中，有些标签不需要关闭；在 JSX（XML）中，所有标签都需要关闭：
- en: '[PRE36]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: camelCase Attributes
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 驼峰命名法属性
- en: 'Did you spot the `charset` versus `charSet` in the preceding snippet? All attributes
    in JSX need to be camelCase. This is a common source of confusion when starting
    out—you might type `onclick` and notice that nothing happens until you go back
    and change it to `onClick`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否注意到前面片段中的 `charset` 与 `charSet`？JSX 中的所有属性都需要使用驼峰命名法。这是刚开始时常见的混淆来源 —— 您可能会输入
    `onclick`，但直到将其改为 `onClick` 才注意到没有任何操作：
- en: '[PRE37]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Exceptions to this rule are all `data-` and `aria-` prefixed attributes, for
    which JSX does not require camelCase.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 例外的规则是所有 `data-` 和 `aria-` 前缀的属性，JSX 不要求使用驼峰命名法。
- en: Namespaced Components
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名空间组件
- en: 'Sometimes you may want to have a single object that returns several components.
    This can be used to accomplish what is sometimes referred to as *namespacing*,
    where all components of a library have the same prefix. For example a `Library`
    object can contain a `Reader` and `Book` components:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您可能希望有一个返回多个组件的单个对象。这可以用于实现所谓的*命名空间*，其中库的所有组件具有相同的前缀。例如，`Library` 对象可以包含 `Reader`
    和 `Book` 组件：
- en: '[PRE38]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'These are then referred to using a *dot notation*:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以使用*点表示法*来引用这些：
- en: '[PRE39]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: JSX and Forms
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSX 和表单
- en: There are some differences between JSX and HTML when working with forms. Let’s
    take a look.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理表单时，JSX 和 HTML 有一些区别。让我们来看看。
- en: onChange Handler
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: onChange 处理程序
- en: When using form elements, users change the values of the input elements when
    interacting with them. In React, you can subscribe to such changes via the `onChange`
    attribute. This is much more convenient than dealing with the various form elements
    in pure DOM. Also when typing in `textarea`s and `<input type="text">` fields,
    `onChange` fires as the user types, which is easier to work with rather than firing
    when the element loses focus. This means no more subscribing to all sorts of mouse
    and keyboard events just to monitor typing changes.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用表单元素时，用户与其交互时会更改输入元素的值。在 React 中，您可以通过 `onChange` 属性订阅此类更改。这比在纯 DOM 中处理各种表单元素更方便。当在
    `textarea` 和 `<input type="text">` 字段中键入时，`onChange` 在用户键入时触发，这比在元素失去焦点时触发更易于处理。这意味着不再需要订阅各种鼠标和键盘事件来监视键入更改。
- en: Consider an example form that has a text input and two radio buttons. A change
    handler simply logs where the change happens and what the element’s new value
    is. As you see you can also have an overall form handler that fires when anything
    in the form changes. You can use this if you want to handle all the form’s changes
    in one central location.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个包含文本输入框和两个单选按钮的表单示例。更改处理程序简单地记录更改发生的位置及其元素的新值。正如你所见，你还可以有一个处理整个表单的更改的总体表单处理程序。如果希望在一个中心位置处理所有表单的更改，可以使用此功能。
- en: '[PRE40]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You can play live with the example *05.11.forms.onchange.html* in the book’s
    repo. When you type `**x**` in the text input, the change handler is called twice
    because it’s assigned once to the input and once to the form. In the console you’ll
    see:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在书籍仓库中的 *05.11.forms.onchange.html* 示例中实时测试。当你在文本输入框中输入 `**x**` 时，更改处理程序将调用两次，因为它一次分配给输入框，一次分配给表单。在控制台中，你将看到：
- en: '[PRE41]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Same for the radio buttons. Clicking “Option 1” logs to the console:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单选按钮也是如此。点击“选项 1”会在控制台中记录：
- en: '[PRE42]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: value Versus defaultValue
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: value 与 defaultValue
- en: 'In HTML, if you have `<input id="i" value="hello" />` and then change the value
    by typing “bye,” you have:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTML 中，如果你有 `<input id="i" value="hello" />`，然后通过输入“bye”更改值，你会得到：
- en: '[PRE43]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In React, the `value` property (accessible via `event.target.value` in an event
    handler) always has the up-to-date content of the text input. If you want to specify
    an initial default value, you can use the `defaultValue` prop.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 中，`value` 属性（通过事件处理程序中的 `event.target.value` 访问）始终具有文本输入的最新内容。如果你想指定初始默认值，可以使用
    `defaultValue` 属性。
- en: 'In the following snippet, you have an `<input>` component with a prefilled
    “hello” content and `onChange` handler. Appending “!” to the end of “hello” results
    in `value` being “hello!” and `defaultValue` remaining “hello” (see *05.12.forms.value.html*
    in the repo):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的片段中，你有一个带有预填充内容“hello”和 `onChange` 处理程序的 `<input>` 组件。在“hello”末尾添加“!”后，`value`
    是 “hello!”，而 `defaultValue` 保持为 “hello”（请参见书籍仓库中的 *05.12.forms.value.html*）：
- en: '[PRE44]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: <textarea> Value
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`<textarea>` 的值'
- en: For consistency with text inputs, React’s version of `<textarea>` also takes
    a `defaultValue` property. It keeps `target.value` up to date while `defaultValue`
    remains the original. If you go HTML-style and use a child of the `textarea` to
    define a value (not recommended and React will give you a warning), it will be
    treated as if it was a `defaultValue`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与文本输入保持一致，React 的 `<textarea>` 版本也接受 `defaultValue` 属性。它保持 `target.value`
    的最新状态，而 `defaultValue` 保持原始值不变。如果你按照 HTML 的方式，并使用 `textarea` 的子元素定义值（不推荐，React
    会给出警告），它将被视为 `defaultValue`。
- en: The whole reason HTML `<textarea>` (as defined by W3C) takes a child as its
    value is so that developers can use new lines in the input. However React, being
    all JavaScript, doesn’t suffer from this limitation. When you need a new line,
    you just use `\n`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: HTML `<textarea>`（由 W3C 定义）接受一个子元素作为其值的原因是，开发人员可以在输入中使用换行符。但是 React 作为全 JavaScript，不受此限制。当你需要换行时，只需使用
    `\n`。
- en: '[PRE45]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note that you need to use a JavaScript literal `{'hello\nworld'}`. Otherwise
    if you use a literal string property value (e.g., `defaultValue="hello\nworld"`)
    you don’t have access to the special newline meaning of `\n`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你需要使用 JavaScript 字面量 `{'hello\nworld'}`。否则，如果使用字面字符串属性值（例如 `defaultValue="hello\nworld"`），你无法访问
    `\n` 的特殊换行含义。
- en: <select> Value
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`<select>` 的值'
- en: 'When you use a `<select>` input in HTML, you specify preselected entries using
    `<option selected>`, like so:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 HTML 中使用 `<select>` 输入时，可以通过 `<option selected>` 指定预选条目，如下所示：
- en: '[PRE46]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In React, you specify `value` or `defaultValue` property of the `<select>`
    element:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 中，你需要指定 `<select>` 元素的 `value` 或 `defaultValue` 属性：
- en: '[PRE47]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note
  id: totrans-162
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: React warns you if you get mixed up and set the `selected` attribute of an `<option>`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: React 会在你混淆并设置 `<option>` 的 `selected` 属性时发出警告。
- en: 'Working with multiselects is similar, only you provide an array of preselected
    values:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 处理多选项类似，只需提供预选值的数组：
- en: '[PRE48]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Note that when working with multiselects—you don’t get `event.target.value`
    in your change handlers. Instead, just as in HTML, you iterate over the `event.tar⁠get​.selectedOptions`.
    For example, a handler that logs the selected values to the console could look
    like:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在处理多选项时，你无法在更改处理程序中获取 `event.target.value`。与 HTML 类似，你需要迭代 `event.tar⁠get​.selectedOptions`。例如，记录所选值到控制台的处理程序可能如下所示：
- en: '[PRE49]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Controlled and Uncontrolled Components
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 受控组件与非受控组件
- en: In the non-React world, the browser maintains the state of form elements such
    as the text in a text input. This state may even be restored if you navigate away
    from a page and then come back. React supports this behavior but also allows you
    to step in and take over the control of the form elements’ state.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在非React世界中，浏览器会维护表单元素的状态，例如文本输入框中的文本。即使你离开页面再回来，状态可能也会恢复。React支持这种行为，但也允许你接管表单元素状态的控制。
- en: When you leave the form elements to behave as the browser wishes, they are known
    as *uncontrolled components* because React does not control them. The opposite—when
    you take over with the help of React—results in *controlled* components.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当你让表单元素按照浏览器的意愿行事时，它们被称为*不受控组件*，因为React不控制它们。相反，当你使用React接管时，它们就成为*受控组件*。
- en: How do you create one versus the other? A component is *controlled* when you
    set the `value` property (of text inputs, `textarea`s, and selects) or the `checked`
    property (of radio inputs and checkboxes).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如何区分它们？当你设置文本输入框、`textarea`和选择框的`value`属性，或者单选按钮和复选框的`checked`属性时，组件就是*受控的*。
- en: When you don’t set these properties, the components are *uncontrolled*. You
    can still initialize (prefill) the form element with a default value by using
    the property `defaultValue` as you saw in several examples in this chapter. Or
    `defaultChecked` in case of radio elements and checkboxes.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当你不设置这些属性时，组件将变为*不受控制*。你仍然可以使用`defaultValue`属性（正如本章节的几个示例所示）为表单元素设置默认值。对于单选按钮和复选框，可以使用`defaultChecked`。
- en: Let’s clarify these concepts with a few examples.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过几个例子澄清这些概念。
- en: Uncontrolled example
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不受控组件示例
- en: 'Here’s an uncontrolled text input:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个不受控文本输入框的示例：
- en: '[PRE50]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'If you want to have prefilled text in the input, use `defaultValue`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要在输入框中预填文本，请使用`defaultValue`：
- en: '[PRE51]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'When you want to get the value the user has typed, you can have the `onChange`
    handler on the input or the whole form, as demonstrated in a previous example.
    Let’s consider a more complete example. Imagine you’re creating a profile editing
    form. Your data is:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想获取用户输入的值时，可以在输入框或整个表单上使用`onChange`处理程序，正如之前的示例所示。让我们考虑一个更完整的例子。想象一下，你正在创建一个配置文件编辑表单。你的数据是：
- en: '[PRE52]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The form needs two text inputs, two radio inputs, and a checkbox:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 表单需要两个文本输入框，两个单选按钮和一个复选框：
- en: '[PRE53]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note
  id: totrans-183
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The radio inputs do have `value` properties, but that does not make them controlled.
    Radio buttons (and checkboxes) become controlled when their `checked` property
    is set.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 单选按钮确实有`value`属性，但这并不使它们成为受控组件。当设置它们的`checked`属性时，单选按钮（以及复选框）才会成为受控组件。
- en: The `updateProfile()` event handler should update the `profile` object. It can
    be fairly simple and generic. For checkboxes (`event.target.type === 'checkbox'`)
    you look for the `target.checked` property. In all other cases, you need the `target.value`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`updateProfile()`事件处理程序应该更新`profile`对象。这可以非常简单和通用。对于复选框（`event.target.type
    === ''checkbox''`），你需要查看`target.checked`属性。在其他所有情况下，你需要获取`target.value`。'
- en: '[PRE54]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[Figure 5-8](#FIG0508) shows how the profile is updated after you change the
    gender, accept the terms, and update the first name (see *05.13.uncontrolled.html*
    in the repo).'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5-8](#FIG0508)展示了在更改性别、接受条款并更新名字后如何更新配置文件（请参见存储库中的*05.13.uncontrolled.html*）。'
- en: Why is it important to treat checkboxes differently (look for `checked` property)
    but not radio inputs? The radio inputs are special in HTML given that you have
    several inputs with the same name and different values, and you get the value
    by referring to the name. You can still access `target.checked` on radio buttons
    if desired, but in this case it’s not necessary. And it’s always `true,` because
    the `onChange` callback is called when you click an element, and when you click
    a radio input, it’s always checked.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要区别对待复选框（查看`checked`属性），但不是单选按钮？HTML中的单选按钮很特殊，因为你可以有多个名称相同但值不同的输入，通过名称获取值。如果需要，你仍然可以访问单选按钮的`target.checked`，但在这种情况下并不是必需的。它总是`true`，因为在点击元素时会调用`onChange`回调，在点击单选按钮时总是选中的。
- en: '![rur2 0508](Images/rur2_0508.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![rur2 0508](Images/rur2_0508.png)'
- en: Figure 5-8\. Uncontrolled component in action
  id: totrans-190
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-8。操作中的不受控组件
- en: Uncontrolled example with an onSubmit handler
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用onSubmit处理程序的不受控组件示例
- en: 'What if you don’t want to (over)react on every change? You want to let the
    users play with the form and you worry about the data only when they submit the
    form. In this case you have two options:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想对每一次更改做出(过度)反应呢？你想让用户在表单上玩耍，只有在他们提交表单时才担心数据。在这种情况下，你有两个选择：
- en: Use built-in DOM collections
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内置的DOM集合
- en: Use React-created references
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用React创建的引用
- en: 'Let’s see how to use the DOM collections (refer to *05.14.uncontrolled.onsubmit.html*
    in the repo). The form is essentially the same, except for the `onSubmit` event
    handler and a new submit button:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 看看如何使用DOM集合（请参阅存储库中的*05.14.uncontrolled.onsubmit.html*）。表单本质上是相同的，除了`onSubmit`事件处理程序和一个新的提交按钮：
- en: '[PRE55]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Here’s what the newly updated `updateProfile()` could look like:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这是新更新的`updateProfile()`的示例：
- en: '[PRE56]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: First, `preventDefault()` kills the propagation of the event and avoids the
    browser’s default behavior of reloading the page. Then it’s a question of looping
    over the profile’s fields and finding the corresponding form element with the
    same name.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`preventDefault()`阻止事件传播并避免浏览器默认的重新加载页面行为。然后只需循环遍历profile的字段，并找到具有相同名称的相应表单元素。
- en: 'The DOM provides access to the collection of form elements by various means,
    one of them being by name. For example:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: DOM提供了通过各种方式访问表单元素集合的方法之一，其中之一是通过名称。例如：
- en: '[PRE57]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: It’s the last variant of this DOM form access that `updateProfile()` uses in
    its loop.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`updateProfile()`在其循环中使用的这种DOM表单访问的最后一种变体。
- en: Controlled example
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 受控组件示例
- en: 'Once you assign a `value` property (to a `text` input, `textarea`, or `select`)
    or `checked` (to a `radio` input or `checkbox`), it’s your responsibility to control
    the component. You need to maintain the state of the inputs as part of your component
    state. So now, the whole form needs to be a *stateful* component. Let’s see how,
    using a class component:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您分配了`value`属性（对于`text`输入、`textarea`或`select`）或`checked`（对于`radio`输入或`checkbox`），那么您就需要负责控制该组件。您需要将输入的状态作为组件状态的一部分进行维护。因此，现在整个表单都需要成为*有状态的*组件。让我们看看如何通过类组件实现：
- en: '[PRE58]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Assuming there’s no other state to maintain but the form itself, you can clone
    the `profile` object as part of the initial state of the component inside the
    constructor. You also need to bind the `updateForm()` method:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 假设除了表单本身外没有其他状态需要维护，您可以将`profile`对象作为组件初始状态的一部分进行克隆。您还需要绑定`updateForm()`方法：
- en: '[PRE59]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The form elements now set `value` instead of `defaultValue` and all the values
    are maintained in `this.state`. Additionally, all inputs now need to have an `onChange`
    handler because they are now being *controlled*. For example, the first name input
    becomes:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在表单元素设置`value`而不是`defaultValue`，并且所有值都在`this.state`中维护。此外，现在所有输入都需要有一个`onChange`处理程序，因为它们现在是*受控*的。例如，第一个名字输入变成了：
- en: '[PRE60]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: It will be a similar situation for the other elements except the submit button,
    as users don’t change its value.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 对于除提交按钮之外的其他元素，情况将类似，因为用户不会更改其值。
- en: Finally, the `updateForm()`. Using dynamic property names (the `target.name`
    in square brackets), it can be simple. All it needs to do is read the form element
    value and assign it to the state.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`updateForm()`。使用动态属性名称（方括号中的`target.name`），它可以很简单。它所需做的就是读取表单元素的值并将其分配给状态。
- en: '[PRE61]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: After the `setState()` call, the form is rerendered and the new form element
    values are read from the updated state (e.g., `value={this.state.firstname}`).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在`setState()`调用之后，将重新呈现表单，并从更新后的状态中读取新的表单元素值（例如，`value={this.state.firstname}`）。
- en: And this is it for the controlled component. As you can see, you need a bit
    of code just to get off the ground. This is the bad news. The good news is that
    now you can update the form values from your state, which is the single source
    of truth. You’re in control.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是受控组件的全部内容。正如您所见，您需要一些代码来起步。这是坏消息。好消息是，现在您可以从您的状态中更新表单值，这是唯一的真相源泉。您掌控局面。
- en: 'So which is better: controlled or uncontrolled? It depends on your use case.
    There isn’t really a “better” option. Also consider that at the time of writing,
    the official React documentation reads, “*In most cases*, we recommend using controlled
    components to implement forms.”'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 那么哪种更好：受控还是非受控？这取决于您的用例。实际上并没有“更好”的选择。还要考虑到，在撰写本文时，官方的React文档中写道：“*在大多数情况下*，我们建议使用受控组件来实现表单。”
- en: 'Can you mix and match controlled and uncontrolled components? Sure. In the
    last two examples, the “Save” button is always uncontrolled (`<input type="submit"
    value="Save" />`) as there’s nothing *to* control; its `value` cannot be changed
    by the user. You can always opt for a mix: control the components you need to
    and leave the others to the browser.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以混合和匹配受控和非受控组件吗？当然可以。在最后两个示例中，“保存”按钮始终是非受控的（`<input type="submit" value="Save"
    />`），因为没有*东西*可供控制；其`value`不能被用户更改。您始终可以选择混合：控制您需要的组件，其余交给浏览器处理。
