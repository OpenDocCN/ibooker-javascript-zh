- en: Chapter 3\. Functional Programming with JavaScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章。JavaScript函数式编程
- en: When you start to explore React, you’ll likely notice that the topic of functional
    programming comes up a lot. Functional techniques are being used more and more
    in JavaScript projects, particularly React projects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开始探索React时，您可能会注意到函数式编程这个话题经常被提及。函数式技术在JavaScript项目中被越来越多地使用，特别是在React项目中。
- en: It’s likely that you’ve already written functional JavaScript code without thinking
    about it. If you’ve mapped or reduced an array, then you’re already on your way
    to becoming a functional JavaScript programmer. Functional programming techniques
    are core not only to React but to many of the libraries in the React ecosystem
    as well.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能您已经在不知不觉中编写了函数式JavaScript代码。如果您对数组进行了映射或减少操作，那么您已经在成为函数式JavaScript程序员的路上了。函数式编程技术不仅是React的核心，也是React生态系统中许多库的核心。
- en: If you’re wondering where this functional trend came from, the answer is the
    1930s, with the invention of *lambda calculus*, or λ-calculus.^([1](ch03.html#idm45901652156344))
    Functions have been a part of calculus since it emerged in the 17th century. Functions
    can be sent to functions as arguments or returned from functions as results.  More
    complex functions, called *higher-order functions*, can manipulate functions and
    use them as either arguments or results or both. In the 1930s, Alonzo Church was
    at Princeton experimenting with these higher-order functions when he invented
    lambda calculus.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想知道这种函数式趋势是从哪里来的，答案是20世纪30年代，随着*lambda演算*或λ-演算的发明^([1](ch03.html#idm45901652156344))。函数自17世纪以来一直是微积分的一部分。函数可以作为参数传递给函数，或者作为函数的结果返回。更复杂的函数，称为*高阶函数*，可以操作函数并将它们用作参数或结果，或者两者兼而有之。在20世纪30年代，阿隆佐·丘奇在普林斯顿大学进行这些高阶函数的实验时发明了λ-演算。
- en: In the late 1950s, John McCarthy took the concepts derived from λ-calculus and
    applied them to a new programming language called Lisp. Lisp implemented the concept
    of higher-order functions and functions as *first-class members* or *first-class
    citizens*. A function is considered a first-class member when it can be declared
    as a variable and sent to functions as an argument. These functions can even be
    returned from functions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪50年代末，约翰·麦卡锡将从λ-演算中得出的概念应用到了一种名为Lisp的新编程语言中。Lisp实现了高阶函数的概念和作为*一等公民*的函数。当函数可以像变量一样被声明并作为参数传递给函数时，该函数被认为是一等公民。这些函数甚至可以从函数中返回。
- en: In this chapter, we’re going to go over some of the key concepts of functional
    programming, and we’ll cover how to implement functional techniques with JavaScript.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍函数式编程的一些关键概念，并讨论如何在JavaScript中实现函数式技术。
- en: What It Means to Be Functional
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是函数式编程意味着
- en: JavaScript supports functional programming because JavaScript functions are
    first-class citizens. This means that functions can do the same things that variables
    can do. The latest JavaScript syntax adds language improvements that can beef
    up your functional programming techniques, including arrow functions, promises,
    and the spread operator.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript支持函数式编程，因为JavaScript函数是一等公民。这意味着函数可以像变量一样执行相同的操作。最新的JavaScript语法增加了语言改进，可以增强您的函数式编程技术，包括箭头函数、Promise和展开操作符。
- en: 'In JavaScript, functions can represent data in your application. You may have
    noticed that you can declare functions with the `var`, `let`, or `const` keywords
    the same way you can declare strings, numbers, or any other variables:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，函数可以表示应用程序中的数据。您可能已经注意到，您可以使用`var`、`let`或`const`关键字声明函数，就像可以声明字符串、数字或任何其他变量一样：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can write the same function using an arrow function. Functional programmers
    write a lot of small functions, and the arrow function syntax makes that much
    easier:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用箭头函数来编写相同的函数。函数式程序员编写许多小函数，箭头函数语法使这一过程变得更加容易：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Since functions are variables, we can add them to objects:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 既然函数是变量，我们可以将它们添加到对象中：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Both of these statements do the same thing: they store a function in a variable
    called `log`. Additionally, the `const` keyword was used to declare the second
    function, which will prevent it from being overwritten.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个语句都执行同样的操作：它们将一个函数存储在名为`log`的变量中。此外，使用`const`关键字声明了第二个函数，这将防止它被覆盖。
- en: 'We can also add functions to arrays in JavaScript:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在JavaScript中向数组添加函数：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Functions can be sent to other functions as arguments, just like other variables:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以像其他变量一样作为参数传递给其他函数：
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'They can also be returned from other functions, just like variables:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 它们也可以像变量一样从其他函数中返回：
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The last two examples were of higher-order functions: functions that either
    take or return other functions. We could describe the same `createScream` higher-order
    function with arrows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个例子是高阶函数：可以接受或返回其他函数的函数。我们可以用箭头描述同样的`createScream`高阶函数：
- en: '[PRE6]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you see more than one arrow used during a function declaration, this means
    that you’re using a higher-order function.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在函数声明过程中看到多个箭头使用，这意味着你在使用高阶函数。
- en: We can say that JavaScript supports functional programming because its functions
    are first-class citizens. This means that functions are data. They can be saved,
    retrieved, or flow through your applications just like variables.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说 JavaScript 支持函数式编程，因为它的函数是一等公民。这意味着函数是数据。它们可以像变量一样被保存、检索或在你的应用程序中流动。
- en: Imperative Versus Declarative
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令式与声明式
- en: 'Functional programming is a part of a larger programming paradigm: *declarative
    programming*. Declarative programming is a style of programming where applications
    are structured in a way that prioritizes describing *what* should happen over
    defining *how* it should happen.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程是更大编程范式的一部分：*声明式编程*。声明式编程是一种编程风格，其结构化应用程序优先描述*发生了什么*而不是定义*如何发生*。
- en: 'In order to understand declarative programming, we’ll contrast it with *imperative
    programming*, or a style of programming that’s only concerned with how to achieve
    results with code. Let’s consider a common task: making a string URL-friendly.
    Typically, this can be accomplished by replacing all of the spaces in a string
    with hyphens, since spaces are not URL-friendly. First, let’s examine an imperative
    approach to this task:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解声明式编程，我们将其与*命令式编程*进行对比，后者仅关注如何使用代码实现结果。让我们考虑一个常见任务：使字符串符合 URL 规范。通常，这可以通过用连字符替换字符串中的所有空格来完成，因为空格不符合
    URL 规范。首先，让我们查看这个任务的命令式方法：
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, we loop through every character in the string, replacing spaces
    as they occur. The structure of this program is only concerned with how such a
    task can be achieved. We use a `for` loop and an `if` statement and set values
    with an equality operator. Just looking at the code alone does not tell us much.
    Imperative programs require lots of comments in order to understand what’s going
    on.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们循环遍历字符串中的每个字符，替换空格。这个程序的结构只关心如何实现这样的任务。我们使用`for`循环和`if`语句，并用等号操作符设置值。仅仅看代码本身并不能告诉我们太多信息。命令式程序需要大量注释才能理解正在发生的事情。
- en: 'Now let’s look at a declarative approach to the same problem:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看相同问题的声明式方法：
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here we are using `string.replace` along with a regular expression to replace
    all instances of spaces with hyphens. Using `string.replace` is a way of describing
    what’s supposed to happen: spaces in the string should be replaced. The details
    of how spaces are dealt with are abstracted away inside the `replace` function.
    In a declarative program, the syntax itself describes what should happen, and
    the details of how things happen are abstracted away.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`string.replace`和正则表达式来替换字符串中所有空格的实例为连字符。使用`string.replace`描述了应该发生的事情：字符串中的空格应该被替换。如何处理空格的细节被抽象在`replace`函数内部。在声明式程序中，语法本身描述了应该发生什么，如何发生的细节被抽象了起来。
- en: 'Declarative programs are easy to reason about because the code itself describes
    what is happening. For example, read the syntax in the following sample. It details
    what happens after members are loaded from an API:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于代码本身描述了正在发生的事情，声明式程序易于推理。例如，阅读以下示例中的语法。它详细描述了从 API 加载成员后发生的事情：
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The declarative approach is more readable and, thus, easier to reason about.
    The details of how each of these functions is implemented are abstracted away.
    Those tiny functions are named well and combined in a way that describes how member
    data goes from being loaded to being saved and printed on a map, and this approach
    does not require many comments. Essentially, declarative programming produces
    applications that are easier to reason about, and when it’s easier to reason about
    an application, that application is easier to scale. Additional details about
    the declarative programming paradigm can be found at the [Declarative Programming
    wiki](https://oreil.ly/7MbkB).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式方法更易读，因此更容易推理。如何实现每个函数的细节都被抽象化了。这些小函数命名良好，并以描述数据成员如何从加载到保存并打印在地图上的方式组合在一起，这种方法不需要太多注释。基本上，声明式编程产生了更易于推理的应用程序，当一个应用程序更容易推理时，它就更容易扩展。有关声明式编程范式的更多详细信息，请参阅[声明式编程wiki](https://oreil.ly/7MbkB)。
- en: 'Now, let’s consider the task of building a document object model, or [DOM](https://www.w3.org/DOM).
    An imperative approach would be concerned with how the DOM is constructed:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑构建文档对象模型（DOM）的任务，或者[DOM](https://www.w3.org/DOM)。命令式方法关注DOM如何构建：
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code is concerned with creating elements, setting elements, and adding
    them to the document. It would be very hard to make changes, add features, or
    scale 10,000 lines of code where the DOM is constructed imperatively.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码关注创建元素，设置元素并将它们添加到文档中。在构建DOM的10,000行代码中进行更改，添加功能或扩展将非常困难。
- en: 'Now let’s take a look at how we can construct a DOM declaratively using a React
    component:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何使用React组件声明性地构建DOM：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: React is declarative. Here, the `Welcome` component describes the DOM that should
    be rendered. The `render` function uses the instructions declared in the component
    to build the DOM, abstracting away the details of how the DOM is to be rendered.
    We can clearly see that we want to render our `Welcome` component into the element
    with the ID of `target`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: React 是声明性的。在这里，`Welcome`组件描述了应该渲染的DOM。`render`函数使用组件中声明的指令构建DOM，抽象出DOM如何被渲染的细节。我们可以清楚地看到我们想要将`Welcome`组件渲染到ID为`target`的元素中。
- en: Functional Concepts
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Functional Concepts
- en: 'Now that you’ve been introduced to functional programming and what it means
    to be “functional” or “declarative,” we’ll move on to introducing the core concepts
    of functional programming: immutability, purity, data transformation, higher-order
    functions, and recursion.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了函数式编程及其“功能性”或“声明性”含义，我们将介绍函数式编程的核心概念：不可变性、纯度、数据转换、高阶函数和递归。
- en: Immutability
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变性
- en: To mutate is to change, so to be *immutable* is to be unchangeable. In a functional
    program, data is immutable. It never changes.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 变异是改变的意思，所以*不可变*意味着不可改变。在功能性程序中，数据是不可变的。它永远不会改变。
- en: 'If you need to share your birth certificate with the public but want to redact
    or remove private information, you essentially have two choices: you can take
    a big Sharpie to your original birth certificate and cross out your private data,
    or you can find a copy machine. Finding a copy machine, making a copy of your
    birth certificate, and writing all over that copy with that big Sharpie would
    be preferable. This way you can have a redacted birth certificate to share and
    your original that’s still intact.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要与公众分享您的出生证明，但又想删除或遮盖私人信息，您基本上有两个选择：您可以拿一支大尖笔在原始出生证明上涂抹并划掉您的私人数据，或者您可以找一台复印机。找到一台复印机，复印您的出生证明，并用大尖笔在复印件上写字会更可取。这样，您就可以有一个被遮盖的出生证明可以分享，而您的原件则完好无损。
- en: This is how immutable data works in an application. Instead of changing the
    original data structures, we build changed copies of those data structures and
    use them instead.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是应用程序中不可变数据的工作方式。我们不改变原始数据结构，而是构建这些数据结构的更改副本并使用它们。
- en: 'To understand how immutability works, let’s take a look at what it means to
    mutate data. Consider an object that represents the color `lawn`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解不可变性如何工作，让我们看看什么是数据变异。考虑一个代表颜色`lawn`的对象：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We could build a function that would rate colors and use that function to change
    the rating of the `color` object:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以构建一个函数来评估颜色，并使用该函数来更改`color`对象的评级：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In JavaScript, function arguments are references to the actual data. Setting
    the color’s rating like this changes or mutates the original color object. (Imagine
    if you tasked a business with redacting and sharing your birth certificate and
    they returned your original birth certificate with black marker covering the important
    details. You’d hope that a business would have the common sense to make a copy
    of your birth certificate and return the original unharmed.) We can rewrite the
    `rateColor` function so that it does not harm the original goods (the `color`
    object):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，函数参数是对实际数据的引用。像这样设置颜色的评分会改变或突变原始颜色对象。 （想象一下，如果你让一家企业涂黑重要细节并分享你的出生证明，他们返回的是原件，你会希望企业有常识复印你的出生证明并将原件无损返回。）我们可以重写`rateColor`函数，使其不会损害原始物品（`color`对象）：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we used `Object.assign` to change the color rating. `Object.assign` is
    the copy machine. It takes a blank object, copies the color to that object, and
    overwrites the rating on the copy. Now we can have a newly rated color object
    without having to change the original.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`Object.assign`来更改颜色评分。`Object.assign`就像复印机。它获取一个空对象，将颜色复制到该对象中，并在副本上覆盖评分。现在我们可以得到一个新评分的颜色对象，而无需更改原始对象。
- en: 'We can write the same function using an arrow function along with the object
    spread operator. This `rateColor` function uses the spread operator to copy the
    color into a new object and then overwrite its rating:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用箭头函数和对象扩展运算符来编写相同的函数。这个`rateColor`函数使用扩展运算符将颜色复制到一个新对象中，然后覆盖其评分：
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This version of the `rateColor` function is exactly the same as the previous
    one. It treats color as an immutable object, does so with less syntax, and looks
    a little bit cleaner. Notice that we wrap the returned object in parentheses.
    With arrow functions, this is a required step since the arrow can’t just point
    to an object’s curly braces.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`rateColor`函数的版本与之前的完全相同。它将颜色视为不可变对象，语法更少，看起来更清晰一些。请注意，我们用括号包裹返回的对象。使用箭头函数时，这是一个必需的步骤，因为箭头不能简单地指向对象的花括号。
- en: 'Let’s consider an array of color names:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个颜色名称的数组：
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We could create a function that will add colors to that array using `Array.push`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个使用`Array.push`将颜色添加到该数组的函数：
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'However, `Array.push` is not an immutable function. This `addColor` function
    changes the original array by adding another field to it. In order to keep the
    `colors` array immutable, we must use `Array.concat` instead:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`Array.push`并非是一个不可变函数。这个`addColor`函数通过向其添加另一个字段来改变原始数组。为了保持`colors`数组的不可变性，我们必须改用`Array.concat`。
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`Array.concat` concatenates arrays. In this case, it takes a new object with
    a new color title and adds it to a copy of the original array.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.concat`用于连接数组。在这种情况下，它获取一个带有新颜色标题的新对象，并将其添加到原始数组的副本中。'
- en: 'You can also use the spread operator to concatenate arrays in the same way
    it can be used to copy objects. Here’s the emerging JavaScript equivalent of the
    previous `addColor` function:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用扩展运算符来连接数组，就像它用于复制对象一样。这是先前`addColor`函数的新兴JavaScript等效版本：
- en: '[PRE19]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This function copies the original list to a new array and then adds a new object
    containing the color’s title to that copy. It is immutable.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将原始列表复制到一个新数组中，然后将包含颜色标题的新对象添加到该副本中。它是不可变的。
- en: Pure Functions
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纯函数
- en: A *pure function* is a function that returns a value that’s computed based on
    its arguments. Pure functions take at least one argument and always return a value
    or another function. They do not cause side effects, set global variables, or
    change anything about application state. They treat their arguments as immutable
    data.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*纯函数*是根据其参数计算值并返回的函数。纯函数至少接受一个参数并始终返回一个值或另一个函数。它们不会引起副作用，不会设置全局变量，也不会改变应用程序状态的任何内容。它们将其参数视为不可变数据。'
- en: 'In order to understand pure functions, let’s first take a look at an impure
    function:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解纯函数，让我们先看一个不纯的函数：
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `selfEducate` function is not a pure function. It does not take any arguments,
    and it does not return a value or a function. It also changes a variable outside
    of its scope: `Frederick`. Once the `selfEducate` function is invoked, something
    about the “world” has changed. It causes side effects:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`selfEducate`函数不是一个纯函数。它不接受任何参数，也不返回值或函数。它还在其范围之外更改了一个变量：`Frederick`。一旦调用`selfEducate`函数，某些关于“世界”的东西就会改变。它引起了副作用：'
- en: '[PRE21]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Pure Functions Are Testable
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纯函数是可测试的
- en: 'Pure functions are naturally *testable*. They do not change anything about
    their environment or “world,” and therefore do not require a complicated test
    setup or teardown. Everything a pure function needs to operate it accesses via
    arguments. When testing a pure function, you control the arguments, and thus you
    can estimate the outcome. This `selfEducate` function is also impure: it causes
    side effects. Invoking this function mutates the objects that are sent to it.
    If we could treat the arguments sent to this function as immutable data, then
    we would have a pure function.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数自然是*可测试*的。它们不改变其环境或“世界”的任何内容，因此不需要复杂的测试设置或拆卸。纯函数运行所需的一切都通过参数访问。测试纯函数时，您可以控制参数，从而可以估计结果。此`selfEducate`函数也是不纯的：它会引起副作用。调用此函数会改变发送到它的对象。如果我们能将发送到此函数的参数视为不可变数据，则会得到纯函数。
- en: 'Let’s have this function take an argument:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们让这个函数接受一个参数：
- en: '[PRE22]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, this version of `selfEducate` is a pure function. It computes a value
    based on the argument that was sent to it: the `person`. It returns a new `person`
    object without mutating the argument sent to it and therefore has no side effects.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，此版本的`selfEducate`是一个纯函数。它根据发送到它的参数——`person`来计算一个值。它返回一个新的`person`对象，而不是改变发送到它的参数，因此没有副作用。
- en: 'Now let’s examine an impure function that mutates the DOM:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一个会改变DOM的不纯函数的例子：
- en: '[PRE23]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `Header` function creates a heading—one element with specific text—and
    adds it to the DOM. This function is impure. It does not return a function or
    a value, and it causes side effects: a changed DOM.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`Header`函数创建一个标题——一个具有特定文本的元素，并将其添加到DOM中。此函数是不纯的。它不返回函数或值，并且引起副作用：更改的DOM。'
- en: 'In React, the UI is expressed with pure functions. In the following sample,
    `Header` is a pure function that can be used to create `h1` elements just like
    in the previous example. However, this function on its own does not cause side
    effects because it does not mutate the DOM. This function will create an `h1`
    element, and it’s up to some other part of the application to use that element
    to change the DOM:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中，UI是用纯函数表示的。在以下示例中，`Header`是一个纯函数，可以用来创建`h1`元素，就像前面的示例中一样。但是，此函数本身不会引起副作用，因为它不会改变DOM。此函数将创建一个`h1`元素，应用程序的其他部分将使用该元素来更改DOM：
- en: '[PRE24]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Pure functions are another core concept of functional programming. They will
    make your life much easier because they will not affect your application’s state.
    When writing functions, try to follow these three rules:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数是函数式编程的另一个核心概念。它们将极大地简化您的生活，因为它们不会影响应用程序的状态。编写函数时，请尝试遵循以下三条规则：
- en: The function should take in at least one argument.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该函数应至少接受一个参数。
- en: The function should return a value or another function.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该函数应返回一个值或另一个函数。
- en: The function should not change or mutate any of its arguments.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该函数不应更改或改变其任何参数。
- en: Data Transformations
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据转换
- en: How does anything change in an application if the data is immutable? Functional
    programming is all about transforming data from one form to another. We’ll produce
    transformed copies using functions. These functions make our code less imperative
    and thus reduce complexity.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据是不可变的，应用程序中的任何内容如何变化？函数式编程完全是关于将数据从一种形式转换为另一种形式。我们将使用函数生成转换后的副本。这些函数使我们的代码更少命令式，从而减少了复杂性。
- en: 'You do not need a special framework to understand how to produce one dataset
    that is based upon another. JavaScript already has the necessary tools for this
    task built into the language. There are two core functions that you must master
    in order to be proficient with functional JavaScript: `Array.map` and `Array.reduce`.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要特殊的框架来理解如何生成基于其他数据集的数据集。JavaScript已经内置了执行此任务所需的工具。有两个核心函数必须掌握以精通函数式JavaScript：`Array.map`和`Array.reduce`。
- en: In this section, we’ll take a look at how these and some other core functions
    transform data from one type to another.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看看这些和其他一些核心函数如何将数据从一种类型转换为另一种类型。
- en: 'Consider this array of high schools:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个高中数组：
- en: '[PRE25]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can get a comma-delimited list of these and some other strings by using
    the `Array.join` function:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Array.join`函数获得这些和其他一些字符串的逗号分隔列表：
- en: '[PRE26]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`Array.join` is a built-in JavaScript array method that we can use to extract
    a delimited string from our array. The original array is still intact; `join`
    simply provides a different take on it. The details of how this string is produced
    are abstracted away from the programmer.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.join` 是一个内置的 JavaScript 数组方法，我们可以使用它从数组中提取一个带有分隔符的字符串。原始数组仍然完好无损；`join`
    只是提供了不同的视角。产生此字符串的具体细节对程序员来说是抽象的。'
- en: 'If we wanted to create a function that creates a new array of the schools that
    begin with the letter “W,” we could use the `Array.filter` method:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想创建一个函数，用于创建一个以字母“W”开头的学校的新数组，我们可以使用 `Array.filter` 方法：
- en: '[PRE27]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`Array.filter` is a built-in JavaScript function that produces a new array
    from a source array. This function takes a *predicate* as its only argument. A
    predicate is a function that always returns a Boolean value: `true` or `false`.
    `Array.filter` invokes this predicate once for every item in the array. That item
    is passed to the predicate as an argument, and the return value is used to decide
    if that item will be added to the new array. In this case, `Array.filter` is checking
    every school to see if its name begins with a “W.”'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.filter` 是 JavaScript 中的内置函数，可以从源数组生成一个新数组。这个函数接受一个 *谓词* 作为其唯一参数。谓词是一个始终返回布尔值（`true`
    或 `false`）的函数。`Array.filter` 对数组中的每个项目调用一次这个谓词。该项目作为参数传递给谓词，返回值用于决定是否将该项目添加到新数组中。在这种情况下，`Array.filter`
    正在检查每个学校是否以“W”开头的名字。'
- en: 'When it’s time to remove an item from an array, we should use `Array.filter`
    over `Array.pop` or `Array.splice` because `Array.filter` is immutable. In this
    next sample, the `cutSchool` function returns new arrays that filter out specific
    school names:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要从数组中删除项目时，应该使用 `Array.filter` 而不是 `Array.pop` 或 `Array.splice`，因为 `Array.filter`
    是不可变的。在下一个示例中，`cutSchool` 函数返回新的数组，过滤掉特定的学校名称：
- en: '[PRE28]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this case, the `cutSchool` function is used to return a new array that does
    not contain “Washington & Liberty.” Then, the `join` function is used with this
    new array to create a string out of the remaining two school names. `cutSchool`
    is a pure function. It takes a list of schools and the name of the school that
    should be removed and returns a new array without that specific school.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`cutSchool` 函数用于返回一个不包含“Washington & Liberty”的新数组。然后，使用这个新数组与 `join`
    函数一起创建包含剩余两个学校名称的字符串。`cutSchool` 是一个纯函数。它接受学校列表和应该删除的学校名称，然后返回一个不包含特定学校的新数组。
- en: 'Another array function that is essential to functional programming is `Array.map`.
    Instead of a predicate, the `Array.map` method takes a function as its argument.
    This function will be invoked once for every item in the array, and whatever it
    returns will be added to the new array:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程中另一个关键的数组函数是 `Array.map`。`Array.map` 方法不像谓词那样接受一个谓词，而是接受一个函数作为其参数。这个函数将为数组中的每个项目调用一次，并将其返回值添加到新数组中：
- en: '[PRE29]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this case, the `map` function was used to append “High School” to each school
    name. The `schools` array is still intact.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`map` 函数用于在每个学校名称后附加“High School”。`schools` 数组仍然完好无损。
- en: 'In the last example, we produced an array of strings from an array of strings.
    The `map` function can produce an array of objects, values, arrays, other functions—any
    JavaScript type. Here’s an example of the `map` function returning an object for
    every school:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后的例子中，我们从一个字符串数组生成了一个字符串对象数组。`map` 函数可以生成对象、值、数组、其他函数——任何 JavaScript 类型的数组。这是
    `map` 函数为每个学校返回一个对象的示例：
- en: '[PRE30]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: An array containing objects was produced from an array that contains strings.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从包含字符串的数组生成了一个包含对象的数组。
- en: 'If you need to create a pure function that changes one object in an array of
    objects, `map` can be used for this, too. In the following example, we’ll change
    the school with the name of “Stratford” to “HB Woodlawn” without mutating the
    `schools` array:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要创建一个纯函数，用于更改对象数组中的一个对象，也可以使用 `map`。在下面的例子中，我们将名为“Stratford”的学校改名为“HB Woodlawn”，而不会改变
    `schools` 数组：
- en: '[PRE31]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `schools` array is an array of objects. The `updatedSchools` variable calls
    the `editName` function and we send it the school we want to update, the new school,
    and the `schools` array. This changes the new array but makes no edits to the
    original:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`schools` 数组是一个包含对象的数组。`updatedSchools` 变量调用 `editName` 函数，我们向其发送要更新的学校、新学校和
    `schools` 数组。这会更改新数组，但不会编辑原始数组：'
- en: '[PRE32]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Within `editName`, the `map` function is used to create a new array of objects
    based upon the original array. The `editName` function can be written entirely
    in one line. Here’s an example of the same function using a shorthand `if/else`
    statement:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `editName` 中，使用 `map` 函数基于原始数组创建一个新对象数组。 `editName` 函数可以完全在一行中编写。 下面是使用简写
    `if/else` 语句的相同函数示例：
- en: '[PRE33]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If you need to transform an array into an object, you can use `Array.map` in
    conjunction with `Object.keys`. `Object.keys` is a method that can be used to
    return an array of keys from an object.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要将数组转换为对象，可以结合使用 `Array.map` 和 `Object.keys`。 `Object.keys` 是一个方法，用于从对象中返回键数组。
- en: 'Let’s say we needed to transform the `schools` object into an array of schools:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要将 `schools` 对象转换为一个学校数组：
- en: '[PRE34]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this example, `Object.keys` returns an array of school names, and we can
    use `map` on that array to produce a new array of the same length. The `name`
    of the new object will be set using the key, and `wins` is set equal to the value.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Object.keys` 返回一个学校名称数组，我们可以对该数组使用 `map` 来生成一个相同长度的新数组。新对象的 `name` 将使用键设置，而
    `wins` 则设置为相应的值。
- en: So far, we’ve learned that we can transform arrays with `Array.map` and `Array.filter`.
    We’ve also learned that we can change arrays into objects by combining `Object.keys`
    with `Array.map`. The final tool that we need in our functional arsenal is the
    ability to transform arrays into primitives and other objects.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何使用 `Array.map` 和 `Array.filter` 转换数组。 我们还学习了如何通过组合 `Object.keys`
    和 `Array.map` 将数组转换为对象。 在我们的功能工具中，还需要一个工具，即将数组转换为基本类型和其他对象的能力。
- en: The `reduce` and `reduceRight` functions can be used to transform an array into
    any value, including a number, string, boolean, object, or even a function.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce` 和 `reduceRight` 函数可以用于将数组转换为任何值，包括数字、字符串、布尔值、对象，甚至是函数。'
- en: 'Let’s say we need to find the maximum number in an array of numbers. We need
    to transform an array into a number; therefore, we can use `reduce`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要在一个数字数组中找到最大数。 我们需要将数组转换为一个数字，因此可以使用 `reduce`：
- en: '[PRE35]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `ages` array has been reduced into a single value: the maximum age, `64`.
    `reduce` takes two arguments: a callback function and an original value. In this
    case, the original value is `0`, which sets the initial maximum value to `0`.
    The callback is invoked once for every item in the array. The first time this
    callback is invoked, `age` is equal to `21`, the first value in the array, and
    `max` is equal to `0`, the initial value. The callback returns the greater of
    the two numbers, `21`, and that becomes the `max` value during the next iteration.
    Each iteration compares each `age` against the `max` value and returns the greater
    of the two. Finally, the last number in the array is compared and returned from
    the previous callback.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`ages` 数组已被减少为单个值：最大年龄 `64`。 `reduce` 接受两个参数：回调函数和原始值。 在本例中，原始值为 `0`，将最初的最大值设置为
    `0`。 每个数组项都会调用回调函数一次。 第一次调用此回调时，`age` 等于数组中的第一个值 `21`，`max` 等于初始值 `0`。 回调返回两个数中较大的那个，`21`
    将成为下一次迭代期间的 `max` 值。 每次迭代都会将每个 `age` 与 `max` 值进行比较，并返回两者中较大的值。 最后，比较并返回数组中的最后一个数字。'
- en: 'If we remove the `console.log` statement from the preceding function and use
    a shorthand `if/else` statement, we can calculate the max value in any array of
    numbers with the following syntax:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从前面的函数中移除 `console.log` 语句，并使用简写 `if/else` 语句，则可以使用以下语法计算任何数字数组中的最大值：
- en: '[PRE36]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Array.reduceRight
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Array.reduceRight`'
- en: '`Array.reduceRight` works the same way as `Array.reduce`; the difference is
    that it starts reducing from the end of the array rather than the beginning.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.reduceRight` 的工作方式与 `Array.reduce` 相同；区别在于它从数组末尾开始减少，而不是从开头开始。'
- en: 'Sometimes we need to transform an array into an object. The following example
    uses `reduce` to transform an array that contains colors into a hash:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要将数组转换为对象。 以下示例使用 `reduce` 将包含颜色的数组转换为哈希：
- en: '[PRE37]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this example, the second argument sent to the `reduce` function is an empty
    object. This is our initial value for the hash. During each iteration, the callback
    function adds a new key to the hash using bracket notation and sets the value
    for that key to the `id` field of the array. `Array.reduce` can be used in this
    way to reduce an array to a single value—in this case, an object.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，发送给`reduce`函数的第二个参数是一个空对象。这是我们的哈希的初始值。在每次迭代中，回调函数使用方括号表示法向哈希添加一个新的键，并将该键的值设置为数组的`id`字段。`Array.reduce`可以这样使用，将数组减少为一个单一值，即在本例中是一个对象。
- en: 'We can even transform arrays into completely different arrays using `reduce`.
    Consider reducing an array with multiple instances of the same value to an array
    of unique values. The `reduce` method can be used to accomplish this task:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以使用`reduce`将数组转换为完全不同的数组。考虑将一个包含多个相同值实例的数组减少为一个唯一值数组。可以使用`reduce`方法完成这个任务：
- en: '[PRE38]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this example, the `colors` array is reduced to an array of distinct values.
    The second argument sent to the `reduce` function is an empty array. This will
    be the initial value for `distinct`. When the `distinct` array does not already
    contain a specific color, it will be added. Otherwise, it will be skipped, and
    the current `distinct` array will be returned.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`colors`数组被减少为一个包含不同值的数组。发送给`reduce`函数的第二个参数是一个空数组。这将是`distinct`的初始值。当`distinct`数组中还没有包含特定颜色时，它将被添加进去。否则，它将被跳过，并返回当前的`distinct`数组。
- en: '`map` and `reduce` are the main weapons of any functional programmer, and JavaScript
    is no exception. If you want to be a proficient JavaScript engineer, then you
    must master these functions. The ability to create one dataset from another is
    a required skill and is useful for any type of programming paradigm.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`和`reduce`是任何函数式程序员的主要工具，JavaScript也不例外。如果你想成为一名熟练的JavaScript工程师，那么你必须掌握这些函数。从一个数据集创建另一个数据集的能力是一项必备技能，对任何类型的编程范式都有用。'
- en: Higher-Order Functions
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高阶函数
- en: The use of *higher-order functions* is also essential to functional programming.
    We’ve already mentioned higher-order functions, and we’ve even used a few in this
    chapter. Higher-order functions are functions that can manipulate other functions.
    They can take functions in as arguments or return functions or both.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*高阶函数*对于函数式编程也是必不可少的。我们已经提到过高阶函数，甚至在本章中使用了一些。高阶函数是可以操作其他函数的函数。它们可以接受函数作为参数，或者返回函数，或者两者兼而有之。
- en: The first category of higher-order functions are functions that expect other
    functions as arguments. `Array.map`, `Array.filter`, and `Array.reduce` all take
    functions as arguments. They are higher-order functions.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 第一类高阶函数是期望其他函数作为参数的函数。`Array.map`、`Array.filter`和`Array.reduce`都接受函数作为参数。它们都是高阶函数。
- en: 'Let’s take a look at how we can implement a higher-order function. In the following
    example, we create an `invokeIf` callback function that will test a condition
    and invoke a callback function when it’s true and another callback function when
    the condition is false:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何实现一个高阶函数。在下面的例子中，我们创建了一个`invokeIf`回调函数，它将测试一个条件，并在条件为真时调用一个回调函数，在条件为假时调用另一个回调函数：
- en: '[PRE39]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`invokeIf` expects two functions: one for true and one for false. This is demonstrated
    by sending both `showWelcome` and `showUnauthorized` to `invokeIf`. When the condition
    is true, `showWelcome` is invoked. When it’s false, `showUnauthorized` is invoked.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`invokeIf`期望两个函数：一个用于真，一个用于假。通过将`showWelcome`和`showUnauthorized`都发送到`invokeIf`来演示这一点。当条件为真时，将调用`showWelcome`。当条件为假时，将调用`showUnauthorized`。'
- en: Higher-order functions that return other functions can help us handle the complexities
    associated with asynchronicity in JavaScript. They can help us create functions
    that can be used or reused at our convenience.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 返回其他函数的高阶函数可以帮助我们处理JavaScript中的异步复杂性。它们可以帮助我们创建可以在我们方便时使用或重复使用的函数。
- en: '*Currying* is a functional technique that involves the use of higher-order
    functions.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*柯里化*是一种涉及高阶函数使用的函数式技术。'
- en: 'The following is an example of currying. The `userLogs` function hangs on to
    some information (the username) and returns a function that can be used and reused
    when the rest of the information (the message) is made available. In this example,
    log messages will all be prepended with the associated username. Notice that we’re
    using the `getFakeMembers` function that returns a promise from [Chapter 2](ch02.html#javascript-for-react):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是柯里化的一个例子。`userLogs` 函数保存了一些信息（用户名），并返回一个函数，当其他信息（消息）可用时可以使用和重复使用该函数。在这个例子中，所有的日志消息都将以相关的用户名作为前缀。请注意，我们在这里使用了`getFakeMembers`函数，它从[第2章](ch02.html#javascript-for-react)返回一个承诺：
- en: '[PRE40]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`userLogs` is the higher-order function. The `log` function is produced from
    `userLogs`, and every time the `log` function is used, “grandpa23” is prepended
    to the message.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`userLogs` 是高阶函数。`log` 函数是从 `userLogs` 生成的，每次使用 `log` 函数时，“grandpa23”都会被添加到消息前面。'
- en: Recursion
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归
- en: 'Recursion is a technique that involves creating functions that recall themselves.
    Often, when faced with a challenge that involves a loop, a recursive function
    can be used instead. Consider the task of counting down from 10\. We could create
    a `for` loop to solve this problem, or we could alternatively use a recursive
    function. In this example, `countdown` is the recursive function:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 递归是一种涉及创建函数并调用自身的技术。通常，在面对需要循环的挑战时，可以使用递归函数代替。考虑从10开始倒数的任务。我们可以创建一个`for`循环来解决这个问题，或者我们可以使用递归函数。在这个例子中，`countdown`就是递归函数：
- en: '[PRE41]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`countdown` expects a number and a function as arguments. In this example,
    it’s invoked with a value of `10` and a callback function. When `countdown` is
    invoked, the callback is invoked, which logs the current value. Next, `countdown`
    checks the value to see if it’s greater than `0`. If it is, `countdown` recalls
    itself with a decremented value. Eventually, the value will be `0`, and `countdown`
    will return that value all the way back up the call stack.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`countdown` 函数期望一个数字和一个函数作为参数。在这个例子中，它被调用时传入了一个值为`10`和一个回调函数。当调用`countdown`时，会调用回调函数，该函数记录当前值。接下来，`countdown`检查该值是否大于`0`。如果是，则`countdown`使用递减后的值重新调用自身。最终，值将为`0`，并且`countdown`将该值返回到调用堆栈的顶部。'
- en: Recursion is a pattern that works particularly well with asynchronous processes.
    Functions can recall themselves when they’re ready, like when the data is available
    or when a timer has finished.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 递归是一种特别适合异步过程的模式。当数据可用或计时器完成时，函数可以在准备好时重新调用自身。
- en: 'The `countdown` function can be modified to count down with a delay. This modified
    version of the `countdown` function can be used to create a countdown clock:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`countdown` 函数可以修改为带有延迟的倒计时。这个修改后的`countdown`函数可以用来创建一个倒计时时钟：'
- en: '[PRE42]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In this example, we create a 10-second countdown by initially invoking `countdown`
    once with the number `10` in a function that logs the countdown. Instead of recalling
    itself right away, the `countdown` function waits one second before recalling
    itself, thus creating a clock.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们通过最初使用数字`10`调用`countdown`一次，并在一个记录倒计时的函数中创建了一个10秒的倒计时。而不是立即重新调用自身，`countdown`函数等待一秒钟再重新调用自身，从而创建一个时钟。
- en: 'Recursion is a good technique for searching data structures. You can use recursion
    to iterate through subfolders until a folder that contains only files is identified.
    You can also use recursion to iterate though the HTML DOM until you find an element
    that does not contain any children. In the next example, we’ll use recursion to
    iterate deeply into an object to retrieve a nested value:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 递归是搜索数据结构的一个好技术。你可以使用递归来迭代子文件夹，直到找到只包含文件的文件夹为止。你也可以使用递归来迭代 HTML DOM，直到找到不包含任何子元素的元素为止。在下一个例子中，我们将使用递归深入迭代对象，以检索嵌套的值：
- en: '[PRE43]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`deepPick` can be used to access `Dan`’s type, stored immediately in the first
    object, or to dig down into nested objects to locate `Dan`’s first name. Sending
    a string that uses dot notation, we can specify where to locate values that are
    nested deep within an object:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`deepPick` 可以用来访问 `Dan` 的类型，在第一个对象中立即存储，或者深入到嵌套对象中查找 `Dan` 的名字。通过发送使用点符号表示法的字符串，我们可以指定在对象中查找嵌套值的位置：'
- en: '[PRE44]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `deepPick` function is either going to return a value or recall itself until
    it eventually returns a value. First, this function splits the dot-notated fields
    string into an array and uses array destructuring to separate the first value
    from the remaining values. If there are remaining values, `deepPick` recalls itself
    with slightly different data, allowing it to dig one level deeper.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`deepPick` 函数要么返回一个值，要么反复调用自身，直到最终返回一个值。首先，该函数将点符号字段字符串拆分为数组，并使用数组解构将第一个值与剩余值分开。如果有剩余值，`deepPick`
    会使用略有不同的数据重新调用自身，从而使其深入挖掘一层。'
- en: 'This function continues to call itself until the fields string no longer contains
    dots, meaning that there are no more remaining fields. In this sample, you can
    see how the values for `first`, `remaining`, and `object[first]` change as `deepPick`
    iterates through:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数继续调用自身，直到字段字符串不再包含点号，这意味着没有更多的剩余字段。在此示例中，您可以看到 `deepPick` 迭代时 `first`、`remaining`
    和 `object[first]` 的值如何变化：
- en: '[PRE45]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Recursion is a powerful functional technique that’s fun to implement.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 递归是一种强大的函数技术，实现起来很有趣。
- en: Composition
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合
- en: Functional programs break up their logic into small, pure functions that are
    focused on specific tasks. Eventually, you’ll need to put these smaller functions
    together. Specifically, you may need to combine them, call them in series or parallel,
    or compose them into larger functions until you eventually have an application.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式程序将其逻辑分解为小的纯函数，这些函数专注于特定的任务。最终，您需要将这些较小的函数组合在一起。具体来说，您可能需要将它们组合、按顺序或并行调用，或者将它们组合成更大的函数，直到最终形成一个应用程序。
- en: When it comes to composition, there are a number of different implementations,
    patterns, and techniques. One that you may be familiar with is chaining. In JavaScript,
    functions can be chained together using dot notation to act on the return value
    of the previous function.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在组合方面，有许多不同的实现、模式和技术。您可能熟悉的其中一种是链式调用。在 JavaScript 中，可以使用点符号将函数链接在一起，以在前一个函数的返回值上执行操作。
- en: 'Strings have a replace method. The replace method returns a template string,
    which will also have a replace method. Therefore, we can chain together replace
    methods with dot notation to transform a string:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串有一个替换方法。替换方法返回一个模板字符串，该模板字符串也将有一个替换方法。因此，我们可以使用点符号将替换方法链在一起，以转换字符串：
- en: '[PRE46]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In this example, the template is a string. By chaining replace methods to the
    end of the template string, we can replace hours, minutes, seconds, and time of
    day in the string with new values. The template itself remains intact and can
    be reused to create more clock time displays.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，模板是一个字符串。通过将替换方法链接到模板字符串的末尾，我们可以用新值替换字符串中的小时、分钟、秒和时间。模板本身保持不变，可以重复使用以创建更多时钟时间显示。
- en: 'The `both` function is one function that pipes a value through two separate
    functions. The output of civilian hours becomes the input for `appendAMPM`, and
    we can change a date using both of these functions combined into one:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`both` 函数是一个将值传递到两个单独函数的管道函数。平民小时的输出成为 `appendAMPM` 的输入，并且我们可以将这两个函数结合成一个来改变日期：'
- en: '[PRE47]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: However, this syntax is hard to comprehend and therefore tough to maintain or
    scale. What happens when we need to send a value through 20 different functions?
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种语法难以理解，因此难以维护或扩展。当我们需要将值通过 20 个不同的函数时会发生什么？
- en: 'A more elegant approach is to create a higher-order function we can use to
    compose functions into larger functions:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 更优雅的方法是创建一个高阶函数，我们可以用它来将函数组合成更大的函数：
- en: '[PRE48]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This approach looks much better. It’s easy to scale because we can add more
    functions at any point. This approach also makes it easy to change the order of
    the composed functions.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法看起来好多了。它易于扩展，因为我们可以在任何时候添加更多函数。这种方法还使得更改组合函数的顺序变得容易。
- en: 'The `compose` function is a higher-order function. It takes functions as arguments
    and returns a single value:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`compose` 函数是一个高阶函数。它接受函数作为参数并返回单个值：'
- en: '[PRE49]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '`compose` takes in functions as arguments and returns a single function. In
    this implementation, the spread operator is used to turn those function arguments
    into an array called `fns`. A function is then returned that expects one argument,
    `arg`. When this function is invoked, the `fns` array is piped starting with the
    argument we want to send through the function. The argument becomes the initial
    value for `compose`, then each iteration of the reduced callback returns. Notice
    that the callback takes two arguments: composed and a function `f`. Each function
    is invoked with `compose`, which is the result of the previous function’s output.
    Eventually, the last function will be invoked and the last result returned.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`compose`接受函数作为参数并返回一个单一函数。在这个实现中，展开运算符用于将这些函数参数转换为一个名为`fns`的数组。然后返回一个函数，该函数期望一个参数`arg`。当调用此函数时，`fns`数组从我们想要通过函数发送的参数开始进行管道传输。参数成为`compose`的初始值，然后每个缩减回调的迭代返回。请注意，回调函数接受两个参数：组合的值和一个函数`f`。每个函数都使用`compose`调用，这是前一个函数输出的结果。最终，将调用最后一个函数并返回最后的结果。'
- en: This is a simple example of a `compose` function designed to illustrate composition
    techniques. This function becomes more complex when it’s time to handle more than
    one argument or deal with arguments that are not functions.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的`compose`函数示例，旨在说明组合技术。当处理超过一个参数或处理非函数参数时，该函数变得更加复杂。
- en: Putting It All Together
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 把一切放在一起
- en: Now that we’ve been introduced to the core concepts of functional programming,
    let’s put those concepts to work for us and build a small JavaScript application.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了函数式编程的核心概念，让我们将这些概念付诸实践，并为我们构建一个小型JavaScript应用程序。
- en: Our challenge is to build a ticking clock. The clock needs to display hours,
    minutes, seconds, and time of day in civilian time. Each field must always have
    double digits, meaning leading zeros need to be applied to single-digit values
    like 1 or 2\. The clock must also tick and change the display every second.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的挑战是构建一个滴答作响的时钟。时钟需要以民用时间显示小时、分钟、秒和上午/下午时间。每个字段必须始终有两位数，这意味着需要为类似于1或2的单个数字值应用前导零。时钟必须每秒滴答一次并更改显示。
- en: 'First, let’s review an imperative solution for the clock:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们回顾一下时钟的命令式解决方案：
- en: '[PRE50]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This solution works, and the comments help us understand what’s happening. However,
    these functions are large and complicated. Each function does a lot. They’re hard
    to comprehend, they require comments, and they’re tough to maintain. Let’s see
    how a functional approach can produce a more scalable application.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案有效，注释帮助我们理解发生了什么。然而，这些函数很大且复杂。每个函数做了很多事情。它们难以理解，需要注释，并且难以维护。让我们看看函数式方法如何产生一个更可扩展的应用程序。
- en: 'Our goal will be to break the application logic up into smaller parts: functions.
    Each function will be focused on a single task, and we’ll compose them into larger
    functions that we can use to create the clock.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是将应用程序逻辑分解为更小的部分：函数。每个函数将专注于一个单一任务，并将它们组合成更大的函数，以便我们可以用来创建时钟。
- en: 'First, let’s create some functions that give us values and manage the console.
    We’ll need a function that gives us one second, a function that gives us the current
    time, and a couple of functions that will log messages on a console and clear
    the console. In functional programs, we should use functions over values wherever
    possible. We’ll invoke the function to obtain the value when needed:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一些给出值并管理控制台的函数。我们需要一个给出一秒的函数，一个给出当前时间的函数，以及几个将在控制台上记录消息并清除控制台的函数。在函数式程序中，我们应该尽可能使用函数而不是值。在需要时，我们将调用函数来获取值：
- en: '[PRE51]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Next, we’ll need some functions for transforming data. These three functions
    will be used to mutate the `Date` object into an object that can be used for our
    clock:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一些用于转换数据的函数。这三个函数将用于将`Date`对象变异为一个可用于我们时钟的对象：
- en: '`serializeClockTime`'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`serializeClockTime`'
- en: Takes a date object and returns an object for clock time that contains hours,
    minutes, and seconds.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 获取一个日期对象并返回一个包含小时、分钟和秒的时钟时间对象。
- en: '`civilianHours`'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`civilianHours`'
- en: 'Takes the clock time object and returns an object where hours are converted
    to civilian time. For example: 1300 becomes 1:00.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 获取时钟时间对象并返回一个对象，其中小时转换为民用时间。例如：1300变为1:00。
- en: '`appendAMPM`'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`appendAMPM`'
- en: Takes the clock time object and appends time of day (AM or PM) to that object.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 接收时钟时间对象并将上午或下午时间附加到该对象。
- en: '[PRE52]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: These three functions are used to transform data without changing the original.
    They treat their arguments as immutable objects.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个函数用于在不改变原始数据的情况下转换数据。它们将其参数视为不可变对象。
- en: 'Next, we’ll need a few higher-order functions:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要几个高阶函数：
- en: '`display`'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`display`'
- en: Takes a target function and returns a function that will send a time to the
    target. In this example, the target will be `console.log`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 采取一个目标函数，并返回一个函数，该函数将时间发送到目标。在这个例子中，目标是`console.log`。
- en: '`formatClock`'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`formatClock`'
- en: Takes a template string and uses it to return clock time formatted based on
    the criteria from the string. In this example, the template is “hh:mm:ss tt”.
    From there, `formatClock` will replace the placeholders with hours, minutes, seconds,
    and time of day.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 采取一个模板字符串，并使用它根据字符串中的标准返回格式化的时钟时间。在这个例子中，模板是“hh:mm:ss tt”。从那里，`formatClock`将用小时、分钟、秒和日间时间替换占位符。
- en: '`prependZero`'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`prependZero`'
- en: Takes an object’s key as an argument and prepends a zero to the value stored
    under that object’s key. It takes in a key to a specific field and prepends values
    with a zero if the value is less than 10.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 采取一个对象的键作为参数，并在该对象键下存储的值前加零。如果值小于10，它将键入一个特定字段并在值前加零。
- en: '[PRE53]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: These higher-order functions will be invoked to create the functions that will
    be reused to format the clock time for every tick. Both `formatClock` and `prependZero`
    will be invoked once, initially setting up the required template or key. The inner
    functions they return will be invoked once every second to format the time for
    display.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这些高阶函数将被调用来创建用于格式化每次滴答的时钟时间的函数。`formatClock`和`prependZero`将在一开始时调用，设置所需的模板或关键字。它们返回的内部函数将每秒调用一次，用于格式化显示时间。
- en: 'Now that we have all of the functions required to build a ticking clock, we’ll
    need to compose them. We’ll use the `compose` function that we defined in the
    last section to handle composition:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了构建滴答时钟所需的所有函数，我们需要将它们组合在一起。我们将使用在上一节定义的`compose`函数来处理组合：
- en: '`convertToCivilianTime`'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`convertToCivilianTime`'
- en: A single function that takes clock time as an argument and transforms it into
    civilian time by using both civilian hours.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 一个单独的函数，接受时钟时间作为参数，并使用平民时间的两个小时将其转换为平民时间。
- en: '`doubleDigits`'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`doubleDigits`'
- en: A single function that takes civilian clock time and makes sure the hours, minutes,
    and seconds display double digits by prepending zeros where needed.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 一个单独的函数，接收平民时钟时间，并确保小时、分钟和秒显示为双位数字，在需要的位置前加零。
- en: '`startTicking`'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`startTicking`'
- en: Starts the clock by setting an interval that invokes a callback every second.
    The callback is composed using all our functions. Every second the console is
    cleared, `currentTime` is obtained, converted, civilianized, formatted, and displayed.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置一个间隔，每秒调用一个回调函数来启动时钟。回调函数由我们所有的函数组成。每秒钟，控制台将被清空，`currentTime`将被获取、转换、平民化、格式化并显示。
- en: '[PRE54]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This declarative version of the clock achieves the same results as the imperative
    version. However, there quite a few benefits to this approach. First, all of these
    functions are easily testable and reusable. They can be used in future clocks
    or other digital displays. Also, this program is easily scalable. There are no
    side effects. There are no global variables outside of functions themselves. There
    could still be bugs, but they’ll be easier to find.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这个声明式版本的时钟实现了与命令式版本相同的结果。然而，这种方法有许多好处。首先，这些函数都易于测试和重用。它们可以用于未来的时钟或其他数字显示器。此外，这个程序易于扩展。没有副作用。除了函数本身之外，没有全局变量。仍然可能存在bug，但它们会更容易找到。
- en: In this chapter, we’ve introduced functional programming principles. Throughout
    the book when we discuss best practices in React, we’ll continue to demonstrate
    how many React concepts are based in functional techniques. In the next chapter,
    we’ll dive into React officially with an improved understanding of the principles
    that guided its development.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了函数式编程的原则。整本书在讨论React的最佳实践时，我们将继续演示许多React概念是基于函数技术的。在下一章，我们将带着对指导其开发的原则有了更深入的理解，正式深入React。
- en: '^([1](ch03.html#idm45901652156344-marker)) Dana S. Scott, [“λ-Calculus: Then
    & Now”](https://oreil.ly/k0EpX).'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '^([1](ch03.html#idm45901652156344-marker)) Dana S. Scott, [“λ-Calculus: Then
    & Now”](https://oreil.ly/k0EpX).'
