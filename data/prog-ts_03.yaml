- en: Chapter 3\. All About Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章：关于类型的一切
- en: In the last chapter I introduced the idea of type systems, but I never defined
    what the *type* in type system really means.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我介绍了类型系统的概念，但我从未真正定义过类型系统中的*类型*意味着什么。
- en: 'If that sounds confusing, let me give a few familiar examples:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这听起来令人困惑，让我举几个熟悉的例子：
- en: 'The `boolean` type is the set of all booleans (there are just two: `true` and
    `false`) and the operations you can perform on them (like `||`, `&&`, and `!`).'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean` 类型是所有布尔值的集合（只有 `true` 和 `false`），以及您可以对它们执行的操作（如 `||`、`&&` 和 `!`）。'
- en: The `number` type is the set of all numbers and the operations you can perform
    on them (like `+`, `-`, *, `/`, `%`, `||`, `&&`, and `?`), including the methods
    you can call on them like `.toFixed`, `.toPrecision`, `.toString`, and so on.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`number` 类型是所有数字的集合及其操作（如 `+`、`-`、`*`、`/`、`%`、`||`、`&&` 和 `?`），包括您可以调用的方法，如
    `.toFixed`、`.toPrecision`、`.toString` 等。'
- en: The `string` type is the set of all strings and the operations you can perform
    on them (like `+`, `||`, and `&&`), including the methods you can call on them
    like `.concat` and `.toUpperCase`.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string` 类型是所有字符串的集合及其操作（如 `+`、`||` 和 `&&`），包括您可以调用的方法，如 `.concat` 和 `.toUpperCase`。'
- en: When you see that something is of type `T`, not only do you know that it’s a
    `T`, but you also know *exactly what you can do* with that `T` (and what you can’t).
    Remember, the whole point is to use the typechecker to stop you from doing invalid
    things. And the way the typechecker knows what’s valid and what’s not is by looking
    at the types you’re using and how you’re using them.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当你看到某些东西是类型 `T` 时，你不仅知道它是 `T` 类型，而且还*确切知道*你可以对该 `T` 类型做什么（以及不能做什么）。记住，整个目的是利用类型检查器阻止您执行无效操作。类型检查器知道什么是有效的，什么是无效的方法是通过查看您使用的类型及其使用方式。
- en: In this chapter we’ll take a tour of the types available in TypeScript and cover
    the basics of what you can do with each of them. [Figure 3-1](#ch03-type-hierarchy)
    gives an overview.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍 TypeScript 中可用的类型，并介绍每种类型的基本用法。[图 3-1](#ch03-type-hierarchy) 提供了一个概述。
- en: '![prts 0301](assets/prts_0301.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![prts 0301](assets/prts_0301.png)'
- en: Figure 3-1\. TypeScript’s type hierarchy
  id: totrans-9
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-1\. TypeScript 的类型层级结构
- en: Talking About Types
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于类型的讨论
- en: When programmers talk about types, they share a precise, common vocabulary to
    describe what they mean. We’re going to use this vocabulary throughout this book.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序员谈论类型时，他们使用精确的共同词汇来描述他们的意思。我们将在本书中始终使用这种词汇。
- en: 'Say you have a function that takes some value and returns that value multiplied
    by itself:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一个函数，它接受某个值并返回该值乘以它自己：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Clearly, this function will only work for numbers—if you pass anything besides
    a number to `squareOf`, the result will be invalid. So what we do is explicitly
    *annotate* the parameter’s type:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这个函数只对数字有效——如果您将除数字以外的任何内容传递给 `squareOf`，结果将是无效的。因此，我们明确*注释*参数的类型：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now if we call `squareOf` with anything but a number, TypeScript will know
    to complain right away. This is a trivial example (we’ll talk a lot more about
    functions in the next chapter), but it’s enough to introduce a couple of concepts
    that are key to talking about types in TypeScript. We can say the following things
    about the last code example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们使用除了数字以外的任何东西调用 `squareOf`，TypeScript 将立即发出警告。这是一个简单的示例（我们将在下一章节详细讨论函数），但已足以介绍
    TypeScript 中几个关键概念。关于最后一个代码示例，我们可以说以下几点：
- en: '`squareOf`’s parameter `n` is *constrained to* `number`.'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`squareOf` 的参数 `n` 受限于 `number`。'
- en: 'The type of the value `2` is *assignable to* (equivalently: *compatible with*)
    `number`.'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 值 `2` 的类型可以*分配给*（同样地：*兼容于*）`number`。
- en: Without a type annotation, `squareOf` is unconstrained in its parameter, and
    you can pass any type of argument to it. Once we constrain it, TypeScript goes
    to work for us verifying that every place we call our function, we call it with
    a compatible argument. In this example the type of `2` is `number`, which is assignable
    to `squareOf`’s annotation `number`, so TypeScript accepts our code; but `'z'`
    is a `string`, which is not assignable to `number`, so TypeScript complains.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有类型注释的情况下，`squareOf` 对其参数没有限制，您可以将任何类型的参数传递给它。一旦我们对其进行限制，TypeScript 就会为我们验证我们调用函数的每个位置时都使用了兼容的参数。在这个例子中，值
    `2` 的类型是 `number`，可以分配给 `squareOf` 的注释 `number`，所以 TypeScript 接受我们的代码；但 `'z'`
    是 `string`，不可分配给 `number`，因此 TypeScript 报错。
- en: 'You can also think of it in terms of *bounds*: we told TypeScript that `n`’s
    *upper bound* is `number`, so any value we pass to `squareOf` has to be at most
    a `number`. If it’s anything more than a `number` (like, if it’s a value that
    might be a `number` or might be a `string`), then it’s not assignable to `n`.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将其视为*边界*：我们告诉 TypeScript，`n`的*上界*是`number`，因此我们传递给`squareOf`的任何值最多只能是一个`number`。如果它超出了`number`（例如，如果它是一个可能是`number`或可能是`string`的值），那么它就不能赋给`n`。
- en: I’ll define assignability, bounds, and constraints more formally in [Chapter 6](ch06.html#advanced-types).
    For now, all you need to know is this is the language that we use to talk about
    whether or not a type can be used in a place where we require a certain type.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在[第 6 章](ch06.html#advanced-types)中更正式地定义可分配性、边界和约束。目前，你只需知道这是我们用来讨论类型是否可以在我们需要特定类型的地方使用的语言。
- en: The ABCs of Types
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型的基础知识
- en: 'Let’s take a tour of the types TypeScript supports, what values they contain,
    and what you can do with them. We’ll also cover a few basic language features
    for working with types: type aliases, union types, and intersection types.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解 TypeScript 支持的各种类型、它们包含的值以及你可以对它们进行的操作。我们还将涵盖一些用于处理类型的基本语言特性：类型别名、联合类型和交叉类型。
- en: any
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任何
- en: '`any` is the Godfather of types. It does anything for a price, but you don’t
    want to ask `any` for a favor unless you’re completely out of options. In TypeScript
    everything needs to have a type at compile time, and `any` is the default type
    when you (the programmer) and TypeScript (the typechecker) can’t figure out what
    type something is. It’s a last resort type, and you should avoid it when possible.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`any`是类型的教父。它可以为了价格而做任何事情，但是除非你已经彻底无路可走，否则不要向`any`求助。在 TypeScript 中，一切都需要在编译时具有类型，而当你（程序员）和
    TypeScript（类型检查器）无法确定某个东西的类型时，`any`就是默认类型。它是最后的备选类型，尽可能避免使用它。'
- en: Why should you avoid it? Remember what a type is? (It’s a set of values and
    the things you can do with them.) `any` is the set of *all* values, and you can
    do *anything* with `any`. That means that if you have a value of type `any` you
    can add to it, multiply by it, call `.pizza()` on it—anything.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么应该避免使用它？记住类型是什么吗？（它是一组值及其可以执行的操作。）`any`是*所有*值的集合，你可以对`any`做*任何*事情。这意味着如果你有一个`any`类型的值，你可以对它进行加法运算，乘法运算，调用`.pizza()`——任何操作都可以。
- en: '`any` makes your value behave like it would in regular JavaScript, and totally
    prevents the typechecker from working its magic. When you allow `any` into your
    code you’re flying blind. Avoid `any` like fire, and use it only as a very, very
    last resort.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`any`使你的值表现得像在常规 JavaScript 中一样，并且完全阻止类型检查器发挥其魔力。当你允许`any`进入你的代码时，你就像闭着眼睛飞行一样。避免像火一样的`any`，只在绝对没有其他选择时使用它。'
- en: 'On the rare occasion that you do need to use it, you do it like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在极少数情况下，当你确实需要使用它时，你可以这样做：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Notice how the third type should report an error (why are you trying to add
    a number and an array?), but doesn’t because you told TypeScript that you’re adding
    two `any`s. If you want to use `any`, you have to be explicit about it. When TypeScript
    infers that some value is of type `any` (for example, if you forgot to annotate
    a function’s parameter, or if you imported an untyped JavaScript module), it will
    throw a compile-time exception and toss a red squiggly at you in your editor.
    By explicitly annotating `a` and `b` with the `any` type (`: any`), you avoid
    the exception—it’s your way of telling TypeScript that you know what you’re doing.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '注意第三种类型应该报告错误（你为什么要尝试将一个数字和一个数组相加？），但是并没有，因为你告诉 TypeScript 你正在添加两个`any`。如果要使用`any`，你必须明确说明。当
    TypeScript 推断出某个值是`any`类型时（例如，如果你忘记了注释函数的参数，或者导入了一个未经类型标注的 JavaScript 模块），它会在编译时抛出异常，并在编辑器中用红色的波浪线提示你。通过显式注释`a`和`b`的类型为`any`（`:
    any`），你可以避免异常——这是告诉 TypeScript 你知道自己在做什么的一种方式。'
- en: 'TSC Flag: noImplicitAny'
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TSC 标志：noImplicitAny
- en: By default, TypeScript is permissive, and won’t complain about values that it
    infers as `any`. To get TypeScript to complain about implicit `any`s, be sure
    to enable the `noImplicitAny` flag in your *tsconfig.json*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，TypeScript 是宽容的，并且不会抱怨它推断出的值为`any`。要让 TypeScript 抱怨隐式的`any`，确保在*tsconfig.json*中启用`noImplicitAny`标志。
- en: '`noImplicitAny` is part of the `strict` family of TSC flags, so if you already
    enabled `strict` in your *tsconfig.json* (as we did in [“tsconfig.json”](ch02.html#tsconfig.json)),
    you’re good to go.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`noImplicitAny`是 TSC 标志的`strict`系列的一部分，因此如果你已经在你的*tsconfig.json*中启用了`strict`（就像我们在[“tsconfig.json”](ch02.html#tsconfig.json)中所做的那样），你就可以开始了。'
- en: unknown
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 未知
- en: 'If `any` is the Godfather, then `unknown` is Keanu Reeves as undercover FBI
    agent Johnny Utah in *Point Break*: laid back, fits right in with the bad guys,
    but deep down has a respect for the law and is on the side of the good guys. For
    the few cases where you have a value whose type you really don’t know ahead of
    time, don’t use `any`, and instead reach for `unknown`. Like `any`, it represents
    any value, but TypeScript won’t let you use an `unknown` type until you refine
    it by checking what it is (see [“Refinement”](ch06.html#refinement)).'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `any` 是教父，那么 `unknown` 就像是基努·里维斯在《终极警探》中扮演的约翰尼·尤塔：悠闲自在，与坏人混在一起，但深藏在心底的尊重法律，站在好人一边。在你确实不知道其类型的值的少数情况下，不要使用
    `any`，而是使用 `unknown`。像 `any` 一样，它表示任何值，但 TypeScript 不会让你使用 `unknown` 类型，直到你通过检查它的类型来细化它（见[“细化”](ch06.html#refinement)）。
- en: 'What operations does `unknown` support? You can compare `unknown` values (with
    `==`, `===`, `||`, `&&`, and `?`), negate them (with `!`), and refine them (like
    you can any other type) with JavaScript’s `typeof` and `instanceof` operators.
    Use `unknown` like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`unknown` 支持哪些操作？你可以比较 `unknown` 值（使用 `==`, `===`, `||`, `&&`, 和 `?`），对它们进行否定（使用
    `!`），并使用 JavaScript 的 `typeof` 和 `instanceof` 运算符来细化它们（就像你可以处理任何其他类型一样）。像这样使用
    `unknown`：'
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This example should give you a rough idea of how to use `unknown`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例应该让你大致了解如何使用 `unknown`：
- en: TypeScript will never infer something as `unknown`—you have to explicitly annotate
    it (`a`).^([1](ch03.html#idm46304992666696))
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TypeScript 永远不会推断出某些东西是 `unknown` ——你必须显式注释它 (`a`)。^([1](ch03.html#idm46304992666696))
- en: You can compare values to values that are of type `unknown` (`b`).
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以将值与 `unknown` 类型的值进行比较 (`b`)。
- en: But, you can’t do things that assume an `unknown` value is of a specific type
    (`c`); you have to prove to TypeScript that the value really is of that type first
    (`d`).
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 但是，你不能做那些假设 `unknown` 值是特定类型的事情 (`c`)；你必须先向 TypeScript 证明该值确实是该类型 (`d`)。
- en: boolean
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: boolean
- en: 'The `boolean` type has two values: `true` and `false`. You can compare them
    (with `==`, `===`, `||`, `&&`, and `?`), negate them (with `!`), and not much
    else. Use `boolean` like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`boolean` 类型有两个值：`true` 和 `false`。你可以比较它们（使用 `==`, `===`, `||`, `&&`, 和 `?`），对它们进行否定（使用
    `!`），除此之外几乎不能做其他事情。像这样使用 `boolean`：'
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This example shows a few ways to tell TypeScript that something is a `boolean`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例展示了几种告诉 TypeScript 某物是 `boolean` 的方法：
- en: You can let TypeScript infer that your value is a `boolean` (`a` and `b`).
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以让 TypeScript 推断出你的值是一个 `boolean` (`a` 和 `b`)。
- en: You can let TypeScript infer that your value is a specific `boolean` (`c`).
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TypeScript 可以让你推断出你的值是特定的 `boolean` (`c`)。
- en: You can tell TypeScript explicitly that your value is a `boolean` (`d`).
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以显式告诉 TypeScript，你的值是一个 `boolean` (`d`)。
- en: You can tell TypeScript explicitly that your value is a specific `boolean` (`e`
    and `f`).
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以显式告诉 TypeScript，你的值是一个特定的 `boolean` (`e` 和 `f`)。
- en: In general, you will use the first or second way in your programs. Very rarely,
    you’ll use the fourth way—only when it buys you extra type safety (I’ll show you
    examples of that throughout this book). You will almost never use the third way.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，你将在你的程序中使用第一种或第二种方式。很少情况下，你会使用第四种方式——只有当它能带来额外的类型安全性时（本书中将为您展示示例）。你几乎不会使用第三种方式。
- en: The second and fourth cases are particularly interesting because while they
    do something intuitive, they’re supported by surprisingly few programming languages
    and so might be new to you. What I did in that example was say, “Hey TypeScript!
    See this variable `e` here? `e` isn’t just any old `boolean`—it’s the specific
    `boolean` `true`.” By using a value as a type, I essentially limited the possible
    values for `e` and `f` from all `booleans` to one specific `boolean` each. This
    feature is called *type literals*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 第二和第四种情况尤其有趣，因为虽然它们做了直觉上的事情，但是它们得到的支持语言很少，所以对你来说可能是新的。在那个示例中，我做的是说，“嘿 TypeScript！看看这个变量
    `e`，`e` 不只是任何旧的 `boolean` ——它是具体的 `boolean` `true`。”通过使用值作为类型，我本质上将 `e` 和 `f`
    的可能值从所有的 `boolean` 限制为每个具体的 `boolean`。这个功能被称为*类型字面量*。
- en: In the fourth case I explicitly annotated my variables with type literals, and
    in the second case TypeScript inferred a literal type for me because I used `const`
    instead of `let` or `var`. Because TypeScript knows that once a primitive is assigned
    with `const` its value will never change, it infers the most narrow type it can
    for that variable. That’s why in the second case TypeScript inferred `c`’s type
    as `true` instead of as `boolean`. To learn more about why TypeScript infers different
    types for `let` and `const`, jump ahead to [“Type Widening”](ch06.html#type-widening).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四种情况下，我明确注释了我的变量类型字面量，在第二种情况下，TypeScript 为我推断了一个字面量类型，因为我使用了`const`而不是`let`或`var`。因为
    TypeScript 知道一旦一个基本类型使用`const`赋值后其值不会改变，它会为该变量推断出最窄的类型。这就是为什么在第二种情况下 TypeScript
    推断`c`的类型为`true`而不是`boolean`的原因。要了解更多关于 TypeScript 为何对`let`和`const`推断不同类型的详细信息，请参阅[“类型扩展”](ch06.html#type-widening)。
- en: We will revisit type literals throughout this book. They are a powerful language
    feature that lets you squeeze out extra safety all over the place. Type literals
    make TypeScript unique in the language world and are something you should lord
    over your Java friends.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书中多次讨论类型字面量。它们是一种强大的语言特性，可以在各个地方提供额外的安全性。类型字面量使 TypeScript 在语言世界中独具一格，并且是你应该向你的
    Java 朋友炫耀的东西。
- en: number
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: number
- en: '`number` is the set of all numbers: integers, floats, positives, negatives,
    `Infinity`, `NaN`, and so on. Numbers can do, well, numbery things, like addition
    (`+`), subtraction (`-`), modulo (`%`), and comparison (`<`). Let’s look at a
    few examples:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`number`是所有数字的集合：整数、浮点数、正数、负数、`Infinity`、`NaN`等等。数字可以进行诸如加法（`+`）、减法（`-`）、取模（`%`）和比较（`<`）等操作。让我们看几个例子：'
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Like in the `boolean` example, there are four ways to type something as a `number`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在`boolean`的示例中一样，有四种方法将某物声明为`number`：
- en: You can let TypeScript infer that your value is a `number` (`a` and `b`).
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以让 TypeScript 推断你的值是一个`number`（`a`和`b`）。
- en: You can use `const` so TypeScript infers that your value is a specific `number`
    (`c`).
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用`const`，这样 TypeScript 就会推断你的值是一个特定的`number`（`c`）。
- en: You can tell TypeScript explicitly that your value is a `number` (`e`).
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以明确告诉 TypeScript 你的值是一个`number`（`e`）。
- en: You can tell TypeScript explicitly that your value is a specific `number` (`f`
    and `g`).
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以明确告诉 TypeScript 你的值是一个特定的`number`（`f`和`g`）。
- en: And just like with `booleans`, you’re usually going to let TypeScript infer
    the type for you (the first way). Once in a while you’ll do some clever programming
    that requires your number’s type to be restricted to a specific value (the second
    or fourth way). There is no good reason to explicitly type something as a `number`
    (the third way).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 就像处理`booleans`一样，通常你会让 TypeScript 自动推断类型（第一种方式）。偶尔你可能会做一些需要将数值类型限制为特定值的 clever
    programming（第二或第四种方式）。没有充分的理由明确将某物类型声明为`number`（第三种方式）。
- en: Tip
  id: totrans-63
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'When working with long numbers, use numeric separators to make those numbers
    easier to read. You can use numeric separators in both type and value positions:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理长数字时，使用数字分隔符使这些数字更易于阅读。数字分隔符可用于类型和值的位置：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: bigint
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: bigint
- en: '`bigint` is a newcomer to JavaScript and TypeScript: it lets you work with
    large integers without running into rounding errors. While the `number` type can
    only represent whole numbers up to 2^(53), `bigint` can represent integers bigger
    than that too. The `bigint` type is the set of all BigInts, and supports things
    like addition (`+`), subtraction (`-`), multiplication (*), division (`/`), and
    comparison (`<`). Use it like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`bigint`是 JavaScript 和 TypeScript 中的新成员：它允许你处理大整数而不会遇到舍入错误。而`number`类型只能表示最多2^(53)的整数，`bigint`可以表示更大的整数。`bigint`类型是所有
    BigInts 的集合，并支持加法（`+`）、减法（`-`）、乘法（*）、除法（`/`）和比较（`<`）。使用方式如下：'
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Like with `boolean` and `number`, there are four ways to declare bigints. Try
    to let TypeScript infer your bigint’s type when you can.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在`boolean`和`number`中一样，有四种方法声明 bigints。尽量在能够的时候让 TypeScript 推断出你的 bigint 类型。
- en: Warning
  id: totrans-70
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: At the time of writing, `bigint` is not yet natively supported by every JavaScript
    engine. If your application relies on `bigint`, be careful to check whether or
    not it’s supported by your target platform.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，`bigint`尚未被每个 JavaScript 引擎原生支持。如果你的应用依赖于`bigint`，请注意检查目标平台是否支持。
- en: string
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: string
- en: '`string` is the set of all strings and the things you can do with them like
    concatenate (`+`), slice (`.slice`), and so on. Let’s see some examples:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`string`是所有字符串及其相关操作的集合，比如拼接（`+`）、切片（`.slice`）等等。让我们看几个例子：'
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Like `boolean` and `number`, there are four ways to declare `string` types,
    and you should let TypeScript infer the type for you whenever you can.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 `boolean` 和 `number`，有四种声明 `string` 类型的方式，你应该尽可能地让 TypeScript 推断类型。
- en: symbol
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 符号
- en: '`symbol` is a relatively new language feature that arrived with one of the
    latest major JavaScript revisions (ES2015). Symbols don’t come up often in practice;
    they are used as an alternative to string keys in objects and maps, in places
    where you want to be extra sure that people are using the right well-known key
    and didn’t accidentally set the key—think setting a default iterator for your
    object (`Symbol.iterator`), or overriding at runtime whether or not your object
    is an instance of something (`Symbol.hasInstance`). Symbols have the type `symbol`,
    and there isn’t all that much you can do with them:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`symbol` 是一个相对较新的语言特性，随着 JavaScript 最新的主要版本（ES2015）而引入。符号在实际中并不经常出现；它们被用作对象和映射中字符串键的替代，在你确信人们使用了正确的已知键而没有意外设置键的地方——比如为对象设置默认迭代器
    (`Symbol.iterator`)，或者在运行时重写对象是否是某个实例 (`Symbol.hasInstance`)。符号的类型是 `symbol`，并且你可以做的事情并不多：'
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The way `Symbol(''a'')` works in JavaScript is by creating a new `symbol` with
    the given name; that `symbol` is unique, and will not be equal (when compared
    with `==` or `===`) to any other `symbol` (even if you create a second `symbol`
    with the same exact name!). Similarly to how the value `27` is inferred to be
    a `number` when declared with `let` but the specific number `27` when you declare
    it with `const`, symbols are inferred to be of type `symbol` but can be explicitly
    typed as `unique symbol`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 中 `Symbol('a')` 的工作方式是创建一个具有给定名称的新 `symbol`；该 `symbol` 是唯一的，并且不会等于任何其他
    `symbol`（即使你使用完全相同的名称创建第二个 `symbol` ！）。类似于当你用 `let` 声明时 `27` 被推断为 `number`，但当你用
    `const` 声明时它是具体的 `27`，符号被推断为 `symbol` 类型但可以显式地标注为 `unique symbol`：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This example shows off a few ways to create unique symbols:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例展示了创建唯一符号的几种方法：
- en: When you declare a new `symbol` and assign it to a `const` variable (not a `let`
    or `var` variable), TypeScript will infer its type as `unique symbol`. It will
    show up as `typeof` *yourVariableName*, not `unique symbol`, in your code editor.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你声明一个新的 `symbol` 并将其赋给一个 `const` 变量（不是 `let` 或 `var` 变量）时，TypeScript 会推断它的类型为
    `unique symbol`。它将在你的代码编辑器中显示为 `typeof` *yourVariableName*，而不是 `unique symbol`。
- en: You can explicitly annotate a `const` variable’s type as `unique symbol`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以显式地注释 `const` 变量的类型为 `unique symbol`。
- en: A `unique symbol` is always equal to itself.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个 `unique symbol` 总是等于它自身。
- en: TypeScript knows at compile time that a `unique symbol` will never be equal
    to any other `unique symbol`.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TypeScript 在编译时知道 `unique symbol` 永远不会等于任何其他 `unique symbol`。
- en: Think of `unique symbols` like other literal types, like `1`, `true`, or `"literal"`.
    They’re a way to create a type that represents a particular inhabitant of `symbol`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `unique symbol` 视为其他文字类型（比如 `1`、`true` 或 `"literal"`）。它们是一种创建代表特定 `symbol`
    的类型的方式。
- en: Objects
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象
- en: 'TypeScript’s object types specify the shapes of objects. Notably, they can’t
    tell the difference between simple objects (like the kind you make with `{}`)
    and more complicated ones (the kind you create with `new Blah`). This is by design:
    JavaScript is generally *structurally typed*, so TypeScript favors that style
    of programming over a *nominally typed* style.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 的对象类型指定了对象的形状。值得注意的是，它们无法区分简单对象（比如你用 `{}` 创建的那种）和更复杂的对象（比如你用 `new
    Blah` 创建的那种）。这是有意设计的：JavaScript 通常是 *结构化类型* 的，因此 TypeScript 更偏向于这种编程风格，而不是 *名义类型*
    的风格。
- en: 'There are a few ways to use types to describe objects in TypeScript. The first
    is to declare a value as an `object`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 中，有几种方法可以用类型来描述对象。第一种方法是将一个值声明为 `object`：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: What happens when you access `b`?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当你访问 `b` 时会发生什么？
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Wait, that’s not very useful! What’s the point of typing something as an `object`
    if you can’t do anything with it?
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 等等，这并不是很有用！如果你不能对 `object` 做任何事情，那么给它加类型有什么意义呢？
- en: Why, that’s a great point, aspiring TypeScripter! In fact, `object` is a little
    narrower than `any`, but not by much. `object` doesn’t tell you a lot about the
    value it describes, just that the value is a JavaScript object (and that it’s
    not `null`).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么，这是一个很重要的观点，有抱负的 TypeScripter！实际上，`object` 比 `any` 稍微窄一些，但差别不大。`object` 并不能告诉你关于它描述的值的很多信息，只是告诉你这个值是一个
    JavaScript 对象（并且它不是 `null`）。
- en: What if we leave off the explicit annotation, and let TypeScript do its thing?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们省略显式的类型标注，让 TypeScript 自行处理会怎样？
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Voilà! You’ve just discovered the second way to type an object: object literal
    syntax (not to be confused with type literals). You can either let TypeScript
    infer your object’s shape for you, or explicitly describe it inside curly braces(`{}`):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！你刚刚发现了第二种对象类型的类型化方法：对象字面量语法（不要与类型文字混淆）。你可以让 TypeScript 自动推断对象的形状，也可以在花括号内显式描述它：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Object literal syntax says, “Here is a thing that has this shape.” The thing
    might be an object literal, or it might be a class:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对象字面量语法表示：“这是一个具有这种形状的东西。” 这个东西可以是对象字面量，也可以是类：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`{firstName: string, lastName: string}` describes the *shape* of an object,
    and both the object literal and the class instance from the last example satisfy
    that shape, so TypeScript lets us assign a `Person` to `c`.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`{firstName: string, lastName: string}` 描述了一个对象的 *形状*，上一个例子中的对象字面量和类实例都满足这个形状，所以
    TypeScript 允许我们将 `Person` 赋给 `c`。'
- en: 'Let’s explore what happens when we add extra properties, or leave out required
    ones:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们添加额外属性或略过必需的属性时会发生什么：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: By default, TypeScript is pretty strict about object properties—if you say the
    object should have a property called `b` that’s a `number`, TypeScript expects
    `b` and only `b`. If `b` is missing, or if there are extra properties, TypeScript
    will complain.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，TypeScript 对对象属性相当严格——如果你说对象应该有一个叫做 `b` 的 `number` 属性，TypeScript 期望只有
    `b` 而不是其他。如果 `b` 缺失或有额外的属性，TypeScript 将会报错。
- en: 'Can you tell TypeScript that something is optional, or that there might be
    more properties than you planned for? You bet:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你能告诉 TypeScript 某物是可选的，或者可能会有比你计划的更多属性吗？当然可以：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[![1](assets/1.png)](#co_all_about_types_CO1-1)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_all_about_types_CO1-1)'
- en: '`a` has a property `b` that’s a `number`.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`a` 有一个叫做 `b` 的 `number` 属性。'
- en: '[![2](assets/2.png)](#co_all_about_types_CO1-2)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_all_about_types_CO1-2)'
- en: '`a` might have a property `c` that’s a `string`. And if `c` is set, it might
    be `undefined`.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`a` 可能有一个叫做 `c` 的 `string` 属性。如果设置了 `c`，它可能是 `undefined`。'
- en: '[![3](assets/3.png)](#co_all_about_types_CO1-3)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_all_about_types_CO1-3)'
- en: '`a` might have any number of numeric properties that are `booleans`.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`a` 可能有任意数量的数值属性，类型为 `boolean`。'
- en: 'Let’s see what types of objects we can assign to `a`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们可以分配给 `a` 的对象类型：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Optional (`?`) isn’t the only modifier you can use when declaring object types.
    You can also mark fields as read-only (that is, you can declare that a field can’t
    be modified after it’s assigned an initial value—kind of like `const` for object
    properties) with the `readonly` modifier:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 可选项 (`?`) 不是声明对象类型时唯一的修饰符。你还可以使用 `readonly` 修饰符来标记字段为只读（即声明字段在赋初值后不能修改，有点像对象属性的
    `const`）：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Object literal notation has one special case: empty object types (`{}`). Every
    type—except `null` and `undefined`—is assignable to an empty object type, which
    can make it tricky to use. Try to avoid empty object types when possible:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对象字面量表示法有一个特殊情况：空对象类型 (`{}`)。除了 `null` 和 `undefined` 之外的所有类型都可以分配给空对象类型，这可能会使其使用起来有些棘手。尽量在可能的情况下避免使用空对象类型：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As a final note on objects, it’s worth mentioning one last way of typing something
    as an object: `Object`. This is pretty much the same as using `{}`, and is best
    avoided. ^([3](ch03.html#idm46304991324152))'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后关于对象，值得一提的是将某物声明为对象的最后一种方式：`Object`。这几乎和使用 `{}` 是一样的，最好避免使用。^([3](ch03.html#idm46304991324152))
- en: 'To summarize, there are four ways to declare objects in TypeScript:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，在 TypeScript 中声明对象有四种方式：
- en: 'Object literal notation (like `{a: string}`), also called a *shape*. Use this
    when you know which fields your object could have, or when all of your object’s
    values will have the same type.'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '对象字面量表示法（如 `{a: string}`），也称为 *形状*。当你知道你的对象可能有哪些字段，或者当你的对象所有值都具有相同类型时使用这个。'
- en: Empty object literal notation (`{}`). Try to avoid this.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 空对象字面量表示法 (`{}`)。尽量避免使用这个。
- en: The `object` type. Use this when you just want an object, and don’t care about
    which fields it has.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`object` 类型。当你只需要一个对象而不关心它有哪些字段时使用。'
- en: The `Object` type. Try to avoid this.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Object` 类型。尽量避免使用这个。'
- en: In your TypeScript programs, you should almost always stick to the first way
    and the third way. Be careful to avoid the second and fourth ways—use a linter
    to warn about them, complain about them in code reviews, print posters—use your
    team’s preferred tool to keep them far away from your codebase.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 TypeScript 程序中，你几乎总是应该使用第一种和第三种方式。要小心避免第二种和第四种方式——使用 linter 进行警告，进行代码审查时进行抱怨，打印海报——使用你团队首选的工具来使它们远离你的代码库。
- en: '[Table 3-1](#table-valid-obj) is a handy reference for options 2–4 in the previous
    list.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 3-1](#table-valid-obj) 是前述列表中选项 2–4 的一个便利参考。'
- en: Table 3-1\. Is the value a valid object?
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-1\. 值是否为有效对象？
- en: '| Value | `{}` | `object` | `Object` |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| Value | `{}` | `object` | `Object` |'
- en: '| --- | --- | --- | --- |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `{}` | Yes | Yes | Yes |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `{}` | 是 | 是 | 是 |'
- en: '| `[''a'']` | Yes | Yes | Yes |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `[''a'']` | 是 | 是 | 是 |'
- en: '| `function () {}` | Yes | Yes | Yes |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `function () {}` | 是 | 是 | 是 |'
- en: '| `new String(''a'')` | Yes | Yes | Yes |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `new String(''a'')` | 是 | 是 | 是 |'
- en: '| `''a''` | Yes | **No** | Yes |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `''a''` | 是 | **不** | 是 |'
- en: '| `1` | Yes | **No** | Yes |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `1` | 是 | **不** | 是 |'
- en: '| `Symbol(''a'')` | Yes | **No** | Yes |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `Symbol(''a'')` | 是 | **不** | 是 |'
- en: '| `null` | **No** | **No** | **No** |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `null` | **不** | **不** | **不** |'
- en: '| `undefined` | **No** | **No** | **No** |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `undefined` | **不** | **不** | **不** |'
- en: 'Intermission: Type Aliases, Unions, and Intersections'
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插曲：类型别名、联合和交集
- en: You are quickly becoming a grizzled TypeScript programmer. You have seen several
    types and how they work, and are now familiar with the concepts of type systems,
    types, and safety. It’s time we go deeper.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你很快就会成为一个经验丰富的 TypeScript 程序员。你已经看过几种类型及其工作方式，并且现在熟悉类型系统、类型和安全性的概念。现在是我们深入的时候了。
- en: As you know, if you have a value, you can perform certain operations on it,
    depending on what its type permits. For example, you can use `+` to add two numbers,
    or `.toUpperCase` to uppercase a string.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，如果你有一个值，你可以根据其类型允许的操作对其进行操作。例如，你可以使用 `+` 来添加两个数字，或者 `.toUpperCase` 来将字符串转换为大写。
- en: If you have a *type*, you can perform some operations on it too. I’m going to
    introduce a few type-level operations here—there are more to come later in the
    book, but these are so common that I want to introduce them as early as possible.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个*类型*，你也可以对其执行一些操作。我将在这里介绍一些类型级操作——在书中稍后还会有更多，但这些是如此常见，我希望尽早介绍它们。
- en: Type aliases
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型别名
- en: 'Just like you can use variable declarations (`let`, `const`, and `var`) to
    declare a variable that aliases a value, you can declare a type alias that points
    to a type. It looks like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你可以使用变量声明（`let`、`const` 和 `var`）来声明一个变量别名值一样，你可以声明一个指向类型的类型别名。它看起来像这样：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`Age` is but a `number`. It can also help make the definition of the `Person`
    shape easier to understand. Aliases are never inferred by TypeScript, so you have
    to type them explicitly:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`Age` 只是一个 `number`。它还有助于更容易理解 `Person` 结构的定义。别名在 TypeScript 中不会被推断，因此你必须明确地为它们设置类型：'
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Because `Age` is just an alias for `number`, that means it’s also assignable
    to `number`, so we can rewrite this as:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `Age` 只是 `number` 的别名，这意味着它也可以赋给 `number`，所以我们可以将其重写为：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Wherever you see a type alias used, you can substitute in the type it aliases
    without changing the meaning of your program.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何处都可以使用类型别名，而不改变程序的含义。
- en: 'Like JavaScript variable declarations (`let`, `const`, and `var`), you can’t
    declare a type twice:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 JavaScript 的变量声明（`let`、`const` 和 `var`）一样，你不能重复声明一个类型：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And like `let` and `const`, type aliases are block-scoped. Every block and
    every function has its own scope, and inner type alias declarations shadow outer
    ones:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 而像 `let` 和 `const` 一样，类型别名是块级作用域的。每个块和每个函数都有自己的作用域，内部的类型别名声明会覆盖外部的声明：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Type aliases are useful for DRYing up repeated complex types,^([4](ch03.html#idm46304991089496))
    and for making it clear what a variable is used for (some people prefer descriptive
    type names to descriptive variable names!). When deciding whether or not to alias
    a type, use the same judgment as when deciding whether or not to pull a value
    out into its own variable.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 类型别名对于简化重复的复杂类型（^([4](ch03.html#idm46304991089496))）很有用，并且可以清楚地说明变量的用途（有些人更喜欢使用描述性的类型名称而不是描述性的变量名称！）。在决定是否给一个类型取别名时，可以使用与决定是否将值拉出到自己的变量中相同的判断标准。
- en: Union and intersection types
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 联合和交集类型
- en: If you have two things `A` and `B`, the *union* of those things is their sum
    (everything in `A` or `B` or both), and the *intersection* is what they have in
    common (everything in both `A` and `B`). The easiest way to think about this is
    with sets. In [Figure 3-2](#ch03-union-intersection) I represent sets as circles.
    On the left is the union, or *sum*, of the two sets; on the right is their intersection,
    or *product*.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有两个事物 `A` 和 `B`，它们的*并集*是它们的总和（`A` 或 `B` 或两者都有的所有内容），而*交集*是它们共有的部分（两者都有的所有内容）。最简单的方式是用集合来理解这一点。在[图 3-2](#ch03-union-intersection)中，我将集合表示为圆圈。左边是两个集合的并集或*和*；右边是它们的交集或*积*。
- en: '![prts 0302](assets/prts_0302.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![prts 0302](assets/prts_0302.png)'
- en: Figure 3-2\. Union (|) and intersection (&)
  id: totrans-159
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-2\. 并集（|）和交集（&）
- en: 'TypeScript gives us special type operators to describe unions and intersections
    of types: `|` for union and `&` for intersection. Since types are a lot like sets,
    we can think of them in the same way:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 给我们提供了特殊的类型运算符来描述类型的并集和交集：`|` 表示并集，`&` 表示交集。由于类型很像集合，我们可以以同样的方式思考它们：
- en: '[PRE26]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If something is a `CatOrDogOrBoth`, what do you know about it? You know that
    it has a `name` property that’s a string, and not much else. On the flip side,
    what can you assign to a `CatOrDogOrBoth`? Well, a `Cat`, a `Dog`, or both:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某物是 `CatOrDogOrBoth`，你知道它有一个 `name` 属性是字符串，除此之外没有什么信息。另一方面，你可以给 `CatOrDogOrBoth`
    分配什么呢？嗯，一个 `Cat`，一个 `Dog`，或者两者都有：
- en: '[PRE27]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This is worth reiterating: a value with a union type (`|`) isn’t necessarily
    one specific member of your union; in fact, it can be both members at once!^([5](ch03.html#idm46304982252728))'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这值得再强调一下：一个具有联合类型 (`|`) 的值不一定是联合中的某一个特定成员；事实上，它可以同时是两个成员！^([5](ch03.html#idm46304982252728))
- en: 'On the other hand, what do you know about `CatAndDog`? Not only does your canine-feline
    hybrid super-pet have a `name`, but it can purr, bark, and wag:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，关于 `CatAndDog`，你知道什么？你的狗猫混血超级宠物不仅有一个 `name`，还能咕噜、吠叫和摇尾巴：
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Unions come up naturally a lot more often than intersections do. Take this
    function, for example:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 并集比交集更自然地出现得多。例如，看看这个函数：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'What is the type of the value this function returns? Well, it might be a `string`,
    or it might be `null`. We can express its return type as:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数返回值的类型是什么？嗯，它可能是一个`string`，或者可能是`null`。我们可以将其返回类型表示为：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How about this one?
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个呢？
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If `a` is truthy then the return type is `string`, and otherwise it’s `number`:
    in other words, `string | number`.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `a` 是真的，那么返回类型是 `string`，否则就是 `number`：换句话说，`string | number`。
- en: The last place where unions come up naturally is in arrays (specifically the
    heterogeneous kind), which we’ll talk about next.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个自然出现并集的地方是数组（特别是异构数组），我们接下来会讨论它。
- en: Arrays
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: 'Like in JavaScript, TypeScript arrays are special kinds of objects that support
    things like concatenation, pushing, searching, and slicing. It’s example time:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在 JavaScript 中一样，TypeScript 中的数组是一种特殊的对象，支持连接、推入、搜索和切片等操作。举个例子：
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note
  id: totrans-178
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'TypeScript supports two syntaxes for arrays: `T[]` and `Array<T>`. They are
    identical both in meaning and in performance. This book uses `T[]` syntax for
    its terseness, but you should pick whichever style you like for your own code.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 支持两种数组的语法：`T[]` 和 `Array<T>`。它们在含义和性能上都是相同的。本书使用 `T[]` 语法是为了简洁性，但你可以选择自己喜欢的风格。
- en: As you read through these examples, notice that everything but `c` and `h` is
    implicitly typed. You’ll also notice that TypeScript has rules about what you
    can and can’t put in an array.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当你阅读这些例子时，注意除了 `c` 和 `h` 之外的一切都是隐式类型化的。你还会注意到 TypeScript 有关于你可以放入数组中的内容的规则。
- en: The general rule of thumb is to keep arrays *homogeneous*. That is, don’t mix
    apples and oranges and numbers in a single array—try to design your programs so
    that every element of your array has the same type. The reason is that otherwise,
    you’re going to have to do more work to prove to TypeScript that what you’re doing
    is safe.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的经验法则是保持数组*同质化*。也就是说，不要在一个数组中混合苹果、橙子和数字 —— 设计你的程序，让数组的每个元素都具有相同的类型。原因是，否则，你将不得不做更多工作来向
    TypeScript 证明你的操作是安全的。
- en: To see why things are easier when your arrays are homogeneous, take a look at
    example `f`. I initialized an array with the string `'red'` (at the point when
    I declared the array it contained just strings, so TypeScript inferred that it
    must be an array of strings). I then pushed `'blue'` onto it; `'blue'` is a string,
    so TypeScript let it pass. Then I tried to push `true` onto the array, but that
    failed! Why? Because `f` is an array of strings, and `true` is not a string.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解当数组同质化时为什么事情变得更容易，看看例子 `f`。我用字符串 `'red'` 初始化了一个数组（在我声明数组时，它只包含字符串，因此 TypeScript
    推断它必须是一个字符串数组）。然后我推入了 `'blue'`；`'blue'` 是一个字符串，所以 TypeScript 让它通过了。接着我尝试将 `true`
    推入数组，但失败了！为什么呢？因为 `f` 是一个字符串数组，而 `true` 不是一个字符串。
- en: 'On the other hand, when I initialized `d` I gave it a `number` and a `string`,
    so TypeScript inferred that it must be an array of type `number | string`. Because
    each element might be either a number or a string, you have to check which it
    is before using it. For example, say you want to map over that array, converting
    every letter to uppercase and tripling every number:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当我初始化`d`时，我给它一个`number`和一个`string`，因此 TypeScript 推断它必须是一个类型为`number | string`的数组。因为每个元素可以是数字或字符串，所以在使用之前必须检查它是哪种类型。例如，假设你想要映射该数组，将每个字母转换为大写并将每个数字乘以三：
- en: '[PRE33]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You have to query the type of each item with `typeof`, checking if it’s a `number`
    or a `string` before you can do anything with it.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在能对它做任何操作之前，你必须用`typeof`查询每个项的类型，检查它是`number`还是`string`。
- en: Like with objects, creating arrays with `const` won’t hint to TypeScript to
    infer their types more narrowly. That’s why TypeScript inferred both `d` and `e`
    to be arrays of `number | string`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 就像对象一样，使用`const`创建的数组不会提示 TypeScript 更精确地推断它们的类型。这就是为什么 TypeScript 推断`d`和`e`都是`number
    | string`数组的原因。
- en: '`g` is the special case: when you initialize an empty array, TypeScript doesn’t
    know what type the array’s elements should be, so it gives you the benefit of
    the doubt and makes them `any`. As you manipulate the array and add elements to
    it, TypeScript starts to piece together your array’s type. Once your array leaves
    the scope it was defined in (for example, if you declared it in a function, then
    returned it), TypeScript will assign it a final type that can’t be expanded anymore:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`g`是特殊情况：当你初始化一个空数组时，TypeScript 不知道数组元素的类型，因此会默认将它们设置为`any`。随着你操作数组并向其中添加元素，TypeScript
    开始推断数组的类型。一旦数组离开了它定义的作用域（例如，如果你在函数中声明它，然后返回它），TypeScript 将为其分配一个不能再扩展的最终类型：'
- en: '[PRE34]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: So as far as uses of `any` go, this one shouldn’t make you sweat too much.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在使用`any`的用途中，这个不应该让你过于担心。
- en: Tuples
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组
- en: 'Tuples are subtypes of `array`. They’re a special way to type arrays that have
    fixed lengths, where the values at each index have specific, known types. Unlike
    most other types, tuples have to be explicitly typed when you declare them. That’s
    because the JavaScript syntax is the same for tuples and arrays (both use square
    brackets), and TypeScript already has rules for inferring array types from square
    brackets:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是`array`的子类型。它们是一种特殊的数组类型，具有固定的长度，每个索引处的值具有特定的已知类型。与大多数其他类型不同，声明元组时必须显式指定它们的类型。这是因为
    JavaScript 的语法对元组和数组是相同的（都使用方括号），并且 TypeScript 已经有规则从方括号中推断数组类型：
- en: '[PRE35]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Tuples support optional elements too. Just like in object types, `?` means
    “optional”:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 元组也支持可选元素。就像对象类型一样，`?`表示“可选”：
- en: '[PRE36]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Tuples also support rest elements, which you can use to type tuples with minimum
    lengths:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 元组还支持剩余元素，你可以使用它们来对具有最小长度的元组进行类型标记：
- en: '[PRE37]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Not only do tuple types safely encode heterogeneous lists, but they also capture
    the length of the list they type. These features buy you significantly more safety
    than plain old arrays—use them often.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅可以安全地编码异构列表，元组类型还捕获了列表的长度。这些特性比普通的旧数组提供了更多的安全性——经常使用它们。
- en: Read-only arrays and tuples
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 只读数组和元组
- en: While regular arrays are mutable (meaning you can `.push` onto them, `.splice`
    them, and update them in place), which is probably what you want most of the time,
    sometimes you want an immutable array—one that you can update to produce a new
    array, leaving the original unchanged.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然常规数组是可变的（意味着你可以`.push`，`.splice`它们，并在原地更新它们），这可能是你大多数时间想要的，但有时你需要一个不可变数组——一个你可以更新以生成新数组，而不更改原始数组的数组。
- en: 'TypeScript comes with a `readonly` array type out of the box, which you can
    use to create immutable arrays. Read-only arrays are just like regular arrays,
    but you can’t update them in place. To create a read-only array, use an explicit
    type annotation; to update a read-only array, use nonmutating methods like `.concat`
    and `.slice` instead of mutating ones like `.push` and `.splice`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 默认支持`readonly`数组类型，你可以使用它来创建不可变数组。只读数组就像普通数组一样，但你不能直接更新它们。要创建只读数组，使用显式类型注解；要更新只读数组，使用非变异方法如`.concat`和`.slice`，而不是`.push`和`.splice`等变异方法：
- en: '[PRE38]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Like `Array`, TypeScript comes with a couple of longer-form ways to declare
    read-only arrays and tuples:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`Array`一样，TypeScript 提供了几种更长的方式来声明只读数组和元组：
- en: '[PRE39]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Which syntax you use—the terser `readonly` modifier, or the longer-form `Readonly`
    or `ReadonlyArray` utilities—is a matter of taste.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用的语法是更简洁的`readonly`修饰符，还是更长的形式`Readonly`或`ReadonlyArray`实用程序，这取决于个人口味。
- en: Note that while read-only arrays can make your code easier to reason about in
    some cases by avoiding mutability, they are backed by regular JavaScript arrays.
    That means even small updates to an array result in having to copy the original
    array first, which can hurt your application’s runtime performance if you’re not
    careful. For small arrays this overhead is rarely noticeable, but for bigger arrays,
    the overhead can become significant.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，尽管只读数组在某些情况下可以通过避免可变性来使代码更易于理解，但它们实际上是由常规 JavaScript 数组支持的。 这意味着即使对数组进行小更新，也需要先复制原始数组，如果不小心的话，这可能会损害应用程序的运行性能。
    对于小型数组，这种开销很少引人注意，但对于较大的数组，开销可能会变得显著。
- en: Tip
  id: totrans-206
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Tip
- en: If you plan to make heavy use of immutable arrays, consider reaching for a more
    efficient implementation, like Lee Byron’s excellent [`immutable`](https://www.npmjs.com/package/immutable).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您计划大量使用不可变数组，请考虑使用效率更高的实现，比如 Lee Byron 的优秀 [`immutable`](https://www.npmjs.com/package/immutable)。
- en: null, undefined, void, and never
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: null、undefined、void 和 never
- en: 'JavaScript has two values to represent an absence of something: `null` and
    `undefined`. TypeScript supports both of these as values, and it also has types
    for them—any guess what they’re called? You got it, the types are called `null`
    and `undefined` too.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 有两个值用于表示缺失的情况：`null` 和 `undefined`。 TypeScript 支持这两者作为值，并为它们提供类型定义——猜猜叫什么？没错，它们的类型也叫
    `null` 和 `undefined`。
- en: They’re both special types, because in TypeScript the only thing of type `undefined`
    is the value `undefined`, and the only thing of type `null` is the value `null`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 中，`undefined` 的唯一值是 `undefined`，`null` 的唯一值是 `null`，因此它们都是特殊类型。
- en: 'JavaScript programmers usually use the two interchangeably, though there is
    a subtle semantic difference worth mentioning: `undefined` means that something
    hasn’t been defined yet, and `null` means an absence of a value (like if you tried
    to compute a value, but ran into an error along the way). These are just conventions
    and TypeScript doesn’t hold you to them, but it can be a useful distinction to
    make.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 程序员通常可以互换使用这两个，尽管其中有一个微妙的语义差异值得一提：`undefined` 意味着尚未定义某事物，而 `null`
    意味着值的缺失（例如，如果您试图计算一个值，但途中遇到错误）。 这些只是约定，TypeScript 不会强制您遵循它们，但区分它们可能是有用的。
- en: 'In addition to `null` and `undefined`, TypeScript also has `void` and `never`.
    These are really specific, special-purpose types that draw even finer lines between
    the different kinds of things that don’t exist: `void` is the return type of a
    function that doesn’t explicitly return anything (for example, `console.log`),
    and `never` is the type of a function that never returns at all (like a function
    that throws an exception, or one that runs forever):'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `null` 和 `undefined`，TypeScript 还有 `void` 和 `never`。 这些是非常特定的、专用的类型，更细致地划分了不同类型不存在的情况：`void`
    是没有显式返回任何内容的函数的返回类型（例如 `console.log`），而 `never` 是根本不会返回的函数的类型（例如抛出异常的函数或永远运行的函数）：
- en: '[PRE40]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: (a) and (b) explicitly return `null` and `undefined`, respectively. (c) returns
    `undefined`, but it doesn’t do so with an explicit `return` statement, so we say
    it returns `void`. (d) throws an exception, and (e) runs forever—neither will
    ever return, so we say their return type is `never`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: （a）和（b）显式返回 `null` 和 `undefined`。 （c）返回 `undefined`，但没有显式使用 `return` 语句，因此我们称其返回类型为
    `void`。 （d）抛出异常，（e）永远运行不会返回，因此我们称它们的返回类型为 `never`。
- en: If `unknown` is the supertype of every other type, then `never` is the subtype
    of every other type. We call it a *bottom type*. That means it’s assignable to
    every other type, and a value of type `never` can be used anywhere safely. This
    has mostly theoretical significance,^([6](ch03.html#idm46304981166104)) but is
    something that will come up when you talk about TypeScript with other language
    nerds.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `unknown` 是每种其他类型的超类型，那么 `never` 是每种其他类型的子类型。 我们称之为 *底部类型*。 这意味着它可以分配给任何其他类型，并且类型为
    `never` 的值可以安全地在任何地方使用。 这在理论上具有重要意义，^([6](ch03.html#idm46304981166104)) 但当您与其他语言爱好者讨论
    TypeScript 时，这是一个会出现的话题。
- en: '[Table 3-2](#table-absence) summarizes how the four absence types are used.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 3-2](#table-absence) 总结了这四种缺失类型的使用方式。'
- en: Table 3-2\. Types that mean an absence of something
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-2\. 表示某种缺失的类型
- en: '| Type | Meaning |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| Type | 含义 |'
- en: '| --- | --- |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `null` | Absence of a value |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| `null` | 缺少值 |'
- en: '| `undefined` | Variable that has not been assigned a value yet |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| `undefined` | 尚未分配值的变量 |'
- en: '| `void` | Function that doesn’t have a `return` statement |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| `void` | 没有 `return` 语句的函数 |'
- en: '| `never` | Function that never returns |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| `never` | 永不返回的函数 |'
- en: Enums
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举
- en: Enums are a way to *enumerate* the possible values for a type. They are unordered
    data structures that map keys to values. Think of them like objects where the
    keys are fixed at compile time, so TypeScript can check that the given key actually
    exists when you access it.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举是一种用于列举类型可能值的方式。它们是无序的数据结构，将键映射到值。可以把它们想象成在编译时键是固定的对象，因此当你访问它时 TypeScript
    可以检查给定的键是否实际存在。
- en: 'There are two kinds of enums: enums that map from strings to strings, and enums
    that map from strings to numbers. They look like this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种枚举类型：将字符串映射到字符串的枚举，以及将字符串映射到数字的枚举。它们看起来像这样：
- en: '[PRE41]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note
  id: totrans-228
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: By convention, enum names are uppercase and singular. Their keys are also uppercase.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 按照约定，枚举名称为大写单数形式。它们的键也是大写的。
- en: 'TypeScript will automatically infer a number as the value for each member of
    your enum, but you can also set values explicitly. Let’s make explicit what TypeScript
    inferred in the previous example:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 将自动推断出枚举的每个成员的数字值，但你也可以显式设置值。让我们明确 TypeScript 在上一个示例中推断出的内容：
- en: '[PRE42]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To retrieve a value from an enum, you access it with either dot or bracket
    notation—just like you would to get a value from a regular object:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要从枚举中检索值，你可以像从常规对象获取值一样，使用点号或方括号表示法：
- en: '[PRE43]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You can split your enum across multiple declarations, and TypeScript will automatically
    merge them for you (to learn more, jump ahead to [“Declaration Merging”](ch10.html#namespace-merging)).
    Beware that when you do split your enum, TypeScript can only infer values for
    one of those declarations, so it’s good practice to explicitly assign a value
    to each enum member:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将枚举分割成多个声明，TypeScript 将自动合并它们（要了解更多，请跳到 [“声明合并”](ch10.html#namespace-merging)）。请注意，当你分割枚举时，TypeScript
    只能为其中一个声明推断值，因此最好为每个枚举成员显式分配一个值：
- en: '[PRE44]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You can use computed values, and you don’t have to define all of them (TypeScript
    will do its best to infer what’s missing):'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用计算值，并且不必定义所有的值（TypeScript 将尽力推断缺失的部分）：
- en: '[PRE45]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You can also use string values for enums, or even mix string and number values:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用字符串值来定义枚举，甚至可以混合使用字符串和数字值：
- en: '[PRE46]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'TypeScript lets you access enums both by value and by key for convenience,
    but this can get unsafe quickly:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 允许你通过值和键来访问枚举，以方便使用，但这可能很快变得不安全：
- en: '[PRE47]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You shouldn’t be able to get `Color[6]`, but TypeScript doesn’t stop you! We
    can ask TypeScript to prevent this kind of unsafe access by opting into a safer
    subset of enum behavior with `const enum` instead. Let’s rewrite our `Language`
    enum from earlier:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你不应该能够获取 `Color[6]`，但 TypeScript 并不会阻止你！我们可以要求 TypeScript 通过选择更安全的 `const enum`
    子集来防止这种不安全访问。让我们重新编写先前的 `Language` 枚举：
- en: '[PRE48]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: A `const enum` doesn’t let you do reverse lookups, and so behaves a lot like
    a regular JavaScript object. It also doesn’t generate any JavaScript code by default,
    and instead inlines the enum member’s value wherever it’s used (for example, TypeScript
    will replace every occurrence of `Language.Spanish` with its value, `1`).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`const enum` 不允许你进行反向查找，因此其行为类似于常规的 JavaScript 对象。它还不会默认生成任何 JavaScript 代码，而是在使用时内联枚举成员的值（例如，TypeScript
    将会用其值 `1` 替换每个 `Language.Spanish` 的出现）。'
- en: 'TSC Flag: preserveConstEnums'
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TSC 标志：preserveConstEnums
- en: '`const enum` inlining can lead to safety issues when you import a `const enum`
    from someone else’s TypeScript code: if the enum author updates their `const enum`
    after you’ve compiled your TypeScript code, then your version of the enum and
    their version might point to different values at runtime, and TypeScript will
    be none the wiser.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当从别人的 TypeScript 代码中导入 `const enum` 时，`const enum` 的内联可能会导致安全问题：如果枚举的作者在你编译
    TypeScript 代码后更新了其 `const enum`，那么你的枚举版本和他们的枚举版本在运行时可能指向不同的值，而 TypeScript 并不会察觉到这一点。
- en: 'If you use `const enum`s, be careful to avoid inlining them and to only use
    them in TypeScript programs that you control: avoid using them in programs that
    you’re planning to publish to NPM, or to make available for others to use as a
    library.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 `const enum`，请注意避免内联它们，并且只在你控制的 TypeScript 程序中使用它们：避免在计划发布到 NPM 或作为库供他人使用的程序中使用它们。
- en: 'To enable runtime code generation for `const enum`s, switch the `preserveConstEnums`
    TSC setting to `true` in your *tsconfig.json*:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 `tsconfig.json` 中打开 `preserveConstEnums` TSC 设置以启用 `const enum` 的运行时代码生成：
- en: '[PRE49]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Let’s see how we use `const enum`s:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 `const enum`：
- en: '[PRE50]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Everything looks great—`Chairs` and `Cups` work exactly as you expect… until
    you realize that all numbers are also assignable to enums! That behavior is an
    unfortunate consequence of TypeScript’s assignability rules, and to fix it you
    have to be extra careful to only use string-valued enums:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 一切看起来都很好——`椅子`和`杯子`的工作正如你所预期的那样…… 直到你意识到所有数字也可以赋值给枚举！这种行为是 TypeScript 可赋值性规则的一个不幸后果，为了修复它，你必须特别小心，只使用字符串值的枚举：
- en: '[PRE51]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: All it takes is one pesky numeric value in your enum to make the whole enum
    unsafe.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 只需一个讨厌的数值枚举，整个枚举就不安全了。
- en: Warning
  id: totrans-255
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Because of all the pitfalls that come with using enums safely, I recommend you
    stay away from them—there are plenty of better ways to express yourself in TypeScript.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 因为安全使用枚举时存在的所有陷阱，我建议您远离它们——在 TypeScript 中有很多更好的表达方式。
- en: And if a coworker insists on using enums and there’s nothing you can do to change
    their mind, be sure to ninja-merge a few TSLint rules while they’re out to warn
    about numeric values and non-`const` enums.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的同事坚持使用枚举，并且你无法改变他们的想法，确保在他们离开时，秘密合并几个 TSLint 规则，以警告数值和非`const`枚举。
- en: Summary
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In short, TypeScript comes with a bunch of built-in types. You can let TypeScript
    infer types for you from your values, or you can explicitly type your values.
    `const` will infer more specific types, `let` and `var` more general ones. Most
    types have general and more specific counterparts, the latter subtypes of the
    former (see [Table 3-3](#table-subtypes)).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，TypeScript 自带一堆内置类型。您可以让 TypeScript 根据值推断类型，或者可以显式地为您的值指定类型。`const` 会推断更具体的类型，`let`
    和 `var` 推断更一般的类型。大多数类型都有一般和更具体的对应类型，后者是前者的子类型（请参见 [表 3-3](#table-subtypes)）。
- en: Table 3-3\. Types and their more specific subtypes
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-3\. 类型及其更具体的子类型
- en: '| Type | Subtype |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 子类型 |'
- en: '| --- | --- |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `boolean` | Boolean literal |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| `boolean` | 布尔字面量 |'
- en: '| `bigint` | BigInt literal |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| `bigint` | BigInt 字面量 |'
- en: '| `number` | Number literal |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| `number` | 数字字面量 |'
- en: '| `string` | String literal |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `string` | 字符串字面量 |'
- en: '| `symbol` | `unique symbol` |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| `symbol` | `unique symbol` |'
- en: '| `object` | Object literal |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `object` | 对象字面量 |'
- en: '| Array | Tuple |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| 数组 | 元组 |'
- en: '| `enum` | `const enum` |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| `enum` | `const enum` |'
- en: Exercises
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: For each of these values, what type will TypeScript infer?
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这些值中的每一个，TypeScript 会推断出什么类型？
- en: '`let a = 1042`'
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`let a = 1042`'
- en: '`let b = ''apples and oranges''`'
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`let b = ''apples and oranges''`'
- en: '`const c = ''pineapples''`'
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`const c = ''pineapples''`'
- en: '`let d = [true, true, false]`'
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`let d = [true, true, false]`'
- en: '`let e = {type: ''ficus''}`'
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`let e = {type: ''ficus''}`'
- en: '`let f = [1, false]`'
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`let f = [1, false]`'
- en: '`const g = [3]`'
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`const g = [3]`'
- en: '`let h = null` (try this out in your code editor, then jump ahead to [“Type
    Widening”](ch06.html#type-widening) if the result surprises you!)'
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`let h = null`（在您的代码编辑器中尝试一下，然后跳到 [“类型扩展”](ch06.html#type-widening) 如果结果让您惊讶！）'
- en: Why does each of these throw the error it does?
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么每个值都会引发它所引发的错误？
- en: '[PRE52]'
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE55]'
- en: ^([1](ch03.html#idm46304992666696-marker)) Almost. When `unknown` is part of
    a union type, the result of the union will be `unknown`. You’ll read more about
    union types in [“Union and intersection types”](#union-intersection).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch03.html#idm46304992666696-marker)) 差不多了。当 `unknown` 是联合类型的一部分时，联合的结果将是
    `unknown`。您将在 [“联合和交叉类型”](#union-intersection) 中进一步了解联合类型。
- en: ^([2](ch03.html#idm46304991456584-marker)) Objects in JavaScript use strings
    for keys; arrays are special kinds of objects that use numerical keys.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch03.html#idm46304991456584-marker)) JavaScript 中的对象使用字符串作为键；数组是一种特殊的对象，它使用数值键。
- en: '^([3](ch03.html#idm46304991324152-marker)) There’s one minor technical difference:
    `{}` lets you define whatever types you want for built-in methods on the `Object`
    prototype, like `.toString` and `.hasOwnProperty` (head over to [MDN](https://mzl.la/2VSuDJz)
    to learn more about prototypes), while `Object` enforces that the types you declare
    are assignable to those on `Object`’s prototype. For example, this code typechecks:
    `let a: {} = {toString() { return 3 }}`. But if you change the type annotation
    to `Object`, TypeScript complains: `let b: Object = {toString() { return 3 }}`
    results in `Error TS2322: Type ''number'' is not assignable to type ''string''`.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '^([3](ch03.html#idm46304991324152-marker)) 有一个小的技术差异：`{}`允许您为 `Object` 原型上的内置方法（如
    `.toString` 和 `.hasOwnProperty`）定义任何类型（请访问[MDN](https://mzl.la/2VSuDJz)了解更多关于原型的信息），而
    `Object` 强制声明的类型必须可赋值给 `Object` 的原型上的类型。例如，这段代码类型检查通过：`let a: {} = {toString()
    { return 3 }}`。但如果您将类型注释更改为 `Object`，TypeScript 将抱怨：`let b: Object = {toString()
    { return 3 }}` 会导致 `Error TS2322: Type ''number'' is not assignable to type ''string''`。'
- en: '^([4](ch03.html#idm46304991089496-marker)) The acronym DRY stands for “Don’t
    Repeat Yourself”—the idea that code shouldn’t be repetitive. It was introduced
    by Andrew Hunt and David Thomas in their book *The Pragmatic Programmer: From
    Journeyman to Master* (Addison-Wesley).'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch03.html#idm46304991089496-marker)) 缩写 DRY 意为“不要重复自己”，即代码不应重复。这一概念由安德鲁·亨特和大卫·托马斯在他们的书籍《程序员修炼之道：通向务实的最高境界》（Addison-Wesley）中首次提出。
- en: ^([5](ch03.html#idm46304982252728-marker)) Jump ahead to [“Discriminated union
    types”](ch06.html#discriminated-unions) to learn how to hint to TypeScript that
    your union is disjoint and a value of that union’s type has to be one or the other,
    and not both.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch03.html#idm46304982252728-marker)) 立即转到[“标记联合类型”](ch06.html#discriminated-unions)，了解如何提示
    TypeScript 您的联合类型是不交叉的，该联合类型的值必须是其中之一，而不是两者兼有。
- en: ^([6](ch03.html#idm46304981166104-marker)) The way to think about a bottom type
    is as a type that has no values. A bottom type corresponds to a mathematical proposition
    that’s always false.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch03.html#idm46304981166104-marker)) 关于底部类型的思考方式是它是一种没有值的类型。底部类型对应于数学命题，总是为假。
