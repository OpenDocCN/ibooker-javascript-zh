- en: Chapter 8\. Incorporating Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第八章。整合数据
- en: Data is the lifeblood of our applications. It flows like water, and it nourishes
    our components with value. The user interface components we’ve composed are vessels
    for data. We fill our applications with data from the internet. We collect, create,
    and send new data to the internet. The value of our applications is not the components
    themselves—it’s the data that flows through those components.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 数据是我们应用的生命线。它像水一样流动，为我们的组件提供营养。我们组合的用户界面组件是数据的容器。我们通过互联网为应用程序注入数据。我们收集、创建并发送新的数据到互联网。我们应用程序的价值不在于组件本身，而是流经这些组件的数据。
- en: When we talk about data, it may sound a little like we’re talking about water
    or food. *The cloud* is the abundantly endless source from which we send and receive
    data. It’s the internet. It’s the networks, services, systems, and databases where
    we manipulate and store zettabytes of data. The cloud *hydrates* our clients with
    the latest and freshest data from the source. We work with this data locally and
    even store it locally. But when our local data becomes out of sync with the source,
    it loses its freshness and is said to be *stale*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论数据时，这听起来有点像在谈论水或食物。*云* 是我们发送和接收数据的丰富无穷的来源。它就是互联网。它是网络、服务、系统和数据库，在这些地方我们操作和存储着赫兹级别的数据。云以最新鲜的数据从源头“**水合**”我们的客户端。我们在本地处理这些数据，甚至本地存储它。但是当我们的本地数据与源头不同步时，它就会失去新鲜度，被称为*陈旧*。
- en: These are the challenges we face as developers working with data. We need to
    keep our applications hydrated with fresh data from the cloud. In this chapter,
    we’re going to take a look at various techniques for loading and working with
    data from the source.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是我们作为开发人员在处理数据时面临的挑战。我们需要确保我们的应用程序通过云中的新鲜数据保持“水合”。在本章中，我们将探讨从源头加载和处理数据的各种技术。
- en: Requesting Data
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求数据
- en: In the movie Star Wars, the droid C-3P0 is a protocol droid. His specialty,
    of course, is communication. He speaks over six million languages. Surely, C-3P0
    knows how to send an HTTP request, because the Hyper Text Transfer Protocol is
    one of the most popular ways to transmit data to and from the internet.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在电影《星球大战》中，机器人 C-3P0 是一个协议机器人。他的专长当然是沟通。他能说六百万种语言。毫无疑问，C-3P0 知道如何发送 HTTP 请求，因为超文本传输协议是互联网上传输数据的最流行方式之一。
- en: HTTP provides the backbone for our internet communication. Every time we load
    *http://www.google.com* into our browser, we’re asking Google to send us a search
    form. The files necessary for us to search are transmitted to the browser over
    HTTP. When we interact with Google by searching for “cat photos,” we’re asking
    Google to find us cat photos. Google responds with data, and images are transferred
    to our browser over HTTP.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 提供了我们互联网通信的支柱。每当我们在浏览器中加载 *http://www.google.com* 时，我们都在请求 Google 发送一个搜索表单。用于我们搜索的文件通过
    HTTP 传输到浏览器。当我们通过搜索“猫照片”与 Google 交互时，我们要求 Google 为我们找到猫照片。Google 以数据形式回应，图像通过
    HTTP 传输到我们的浏览器。
- en: 'In JavaScript, the most popular way to make an HTTP request is to use fetch.
    If we wanted to ask GitHub for information about Moon Highway, we could do so
    by sending a fetch request:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，发起 HTTP 请求的最流行方式是使用 fetch。如果我们想要向 GitHub 请求有关 Moon Highway 的信息，我们可以发送一个
    fetch 请求：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `fetch` function returns a promise. Here, we’re making an asynchronous
    request to a specific URL: *https://api.github.com/users/moonhighway*. It takes
    time for that request to traverse the internet and respond with information. When
    it does, that information is passed to a callback using the `.then(callback)`
    method. The GitHub API will respond with JSON data, but that data is contained
    in the body of the HTTP response, so we call `response.json()` to obtain that
    data and parse it as JSON. Once obtained, we log that data to the console. If
    anything goes wrong, we’ll pass the error to the `console.error` method.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetch` 函数返回一个 promise。在这里，我们正在向特定的 URL 发送一个异步请求：*https://api.github.com/users/moonhighway*。该请求需要一段时间来穿越互联网，并响应相关信息。当响应返回时，将使用
    `.then(callback)` 方法将信息传递给回调函数。GitHub API 将会以 JSON 数据形式响应，但这些数据被包含在 HTTP 响应体中，因此我们调用
    `response.json()` 来获取并解析这些数据。获取到数据后，我们将其记录到控制台中。如果出现任何问题，我们将会通过 `console.error`
    方法输出错误信息。'
- en: 'GitHub will respond to this request with a JSON object:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 将以 JSON 对象形式响应此请求：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'On GitHub, basic information about user accounts is made available by their
    API. Go ahead, try searching for yourself: *https://api.github.com/users/<YOUR_GITHUB_USER_NAME>*.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitHub 上，用户帐户的基本信息可以通过他们的 API 获取。继续尝试搜索您自己：*https://api.github.com/users/<YOUR_GITHUB_USER_NAME>*。
- en: 'Another way of working with promises is to use `async/await`. Since `fetch`
    returns a promise, we can `await` a fetch request inside of an `async` function:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种处理 promises 的方法是使用 `async/await`。由于 `fetch` 返回一个 promise，我们可以在 `async` 函数内
    `await` 一个 fetch 请求：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code achieves the exact same results as the previous fetch request that
    was made by chaining `.then` functions on to the request. When we `await` a promise,
    the next line of code will not be executed until the promise has resolved. This
    format gives us a nice way to work with promises in code. We’ll be using both
    approaches for the remainder of this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码实现与之前使用 `.then` 函数链接到请求的完全相同的结果。当我们 `await` 一个 promise 时，直到 promise 解决后，下一行代码才会执行。这种格式为我们提供了在代码中处理
    promises 的一种良好方式。我们将在本章的剩余部分中使用这两种方法。
- en: Sending Data with a Request
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送请求时发送数据
- en: A lot of requests require us to upload data with the request. For instance,
    we need to collect information about a user in order to create an account, or
    we may need new information about a user to update their account.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 很多请求要求我们在请求中上传数据。例如，我们需要收集有关用户的信息以创建一个帐户，或者我们可能需要新的用户信息来更新他们的帐户。
- en: 'Typically, we use a POST request when we’re creating data and a PUT request
    when we’re modifying it. The second argument of the `fetch` function allows us
    to pass an object of options that `fetch` can use when creating our HTTP request:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们在创建数据时使用 POST 请求，在修改数据时使用 PUT 请求。`fetch` 函数的第二个参数允许我们传递一个选项对象，`fetch` 在创建
    HTTP 请求时可以使用这些选项：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This fetch is using the POST method to create a new user. The `username`, `password`,
    and user’s `bio` are being passed as string content in the `body` of the request.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此 fetch 使用 POST 方法来创建新用户。`username`、`password` 和用户的 `bio` 作为字符串内容传递在请求的 `body`
    中。
- en: Uploading Files with fetch
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 fetch 上传文件
- en: 'Uploading files requires a different type of HTTP request: a `multipart-formdata`
    request. This type of request tells the server that a file or multiple files are
    located in the body of the request. To make this request in JavaScript, all we
    have to do is pass a `FormData` object in the body of our request:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 上传文件需要不同类型的 HTTP 请求：一个 `multipart-formdata` 请求。此类请求告知服务器请求主体中包含一个或多个文件。要在 JavaScript
    中进行此请求，我们只需在请求主体中传递一个 `FormData` 对象：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This time, when we create a user, we’re passing the `username`, `fullname`,
    and `avatar` image along with the request as a `formData` object. Although these
    values are hardcoded here, we could easily collect them from a form.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，当我们创建用户时，我们将 `username`、`fullname` 和 `avatar` 图像作为 `formData` 对象随请求传递。虽然这些值在此处是硬编码的，但我们可以轻松地从表单收集它们。
- en: Authorized Requests
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 授权请求
- en: Sometimes, we need to be authorized to make requests. Authorization is typically
    required to obtain personal or sensitive data. Additionally, authorization is
    almost always required for users to take action on the server with POST, PUT,
    or DELETE requests.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要授权才能进行请求。通常需要授权以获取个人或敏感数据。此外，几乎总是需要授权才能让用户通过 POST、PUT 或 DELETE 请求在服务器上执行操作。
- en: 'Users typically identify themselves with each request by adding a unique token
    to the request that a service can use to identify the user. This token is usually
    added as the `Authorization` header. On GitHub, you can see your personal account
    information if you send a token along with your request:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 用户通常通过向请求添加一个唯一令牌来标识自己，服务可以使用此令牌来识别用户。此令牌通常添加为 `Authorization` 标头。在 GitHub 上，如果您在请求中发送令牌，可以查看您的个人帐户信息：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Tokens are typically obtained when a user signs into a service by providing
    their username and password. Tokens can also be obtained from third parties like
    GitHub or Facebook using with an open standard protocol called OAuth.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌通常在用户通过提供其用户名和密码登录服务时获取。还可以通过第三方如 GitHub 或 Facebook 使用一个称为 OAuth 的开放标准协议来获取令牌。
- en: 'GitHub allows you to generate a Personal User token. You can generate one by
    logging in to GitHub and navigating to: Settings > Developer Settings > Personal
    Access Tokens. From here, you can create tokens with specific read/write rules
    and then use those tokens to obtain personal information from the GitHub API.
    If you generate a Personal Access Token and send it along with the fetch request,
    GitHub will provide additional private information about your account.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub允许您生成个人用户令牌。您可以通过登录GitHub并导航到：设置 > 开发者设置 > 个人访问令牌来生成一个。在这里，您可以创建具有特定读写规则的令牌，然后使用这些令牌从GitHub
    API获取个人信息。如果生成个人访问令牌并在fetch请求中发送它，GitHub将提供有关您帐户的额外私密信息。
- en: 'Fetching data from within a React component requires us to orchestrate the
    `useState` and `useEffect` hooks. The `useState` hook is used to store the response
    in state, and the `useEffect` hook is used to make the fetch request. For example,
    if we wanted to display information about a GitHub user in a component, we could
    use the following code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 从React组件内获取数据需要我们编排`useState`和`useEffect`钩子。`useState`钩子用于将响应存储在状态中，而`useEffect`钩子用于发出fetch请求。例如，如果我们想在组件中显示关于GitHub用户的信息，我们可以使用以下代码：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this code, our `App` renders a `GitHubUser` component and displays JSON data
    about `moonhighway`. On the first render, `GitHubUser` sets up a state variable
    for `data` using the `useState` hook. Then, because `data` is initially `null`,
    the component returns `null`. Returning `null` from a component tells React to
    render nothing. It doesn’t cause an error; we’ll just see a black screen.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们的`App`呈现了一个`GitHubUser`组件，并显示关于`moonhighway`的JSON数据。在第一次渲染时，`GitHubUser`使用`useState`钩子为`data`设置了一个状态变量。然后，因为`data`最初为`null`，组件返回`null`。从组件返回`null`告诉React不要渲染任何内容。这不会导致错误；我们只会看到一个黑屏。
- en: After the component is rendered, the `useEffect` hook is invoked. This is where
    we make the fetch request. When we get a response, we obtain and parse the data
    in that response as JSON. Now we can pass that JSON object to the `setData` function,
    which causes our component to render once again, but this time it will have data.
    This `useEffect` hook will not be invoked again unless the value for `login` changes.
    When it does, we’ll need to request more information about a different user from
    GitHub.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 组件渲染后，将调用`useEffect`钩子。这是我们发出fetch请求的地方。当我们得到响应时，我们获取并解析该响应中的数据为JSON。现在我们可以将该JSON对象传递给`setData`函数，这会导致我们的组件再次渲染，但这次它会有数据。除非`login`的值发生变化，否则不会再次调用此`useEffect`钩子。当它改变时，我们需要从GitHub请求更多关于不同用户的信息。
- en: 'When there is `data`, we’re rendering it as a JSON string in a `pre` element.
    The `JSON.stringify` method takes three arguments: the JSON data to convert to
    a string, a replacer function that can be used to replace properties of the JSON
    object, and the number of spaces to use when formatting the data. In this case,
    we sent `null` as the replacer because we don’t want to replace anything. The
    `2` represents the number of spaces to be used when formatting the code. This
    will indent the JSON string two spaces. Using the `pre` element honors whitespace,
    so readable JSON is what is finally rendered.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当有`data`时，我们将其渲染为`pre`元素中的JSON字符串。`JSON.stringify`方法接受三个参数：要转换为字符串的JSON数据，可以用来替换JSON对象属性的替换函数，以及格式化数据时要使用的空格数。在本例中，我们将`null`作为替换器发送，因为我们不想替换任何内容。`2`表示在格式化代码时要使用的空格数。这将使JSON字符串缩进两个空格。使用`pre`元素保留空格，因此最终呈现的是可读的JSON。
- en: Saving Data Locally
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地保存数据
- en: We can save data locally to the browser using the Web Storage API. Data can
    be saved by either using the `window.localStorage` or `window.sessionStorage`
    objects. The `sessionStorage` API only saves data for the user’s session. Closing
    the tabs or restarting the browser will clear any data saved to `sessionStorage`.
    On the other hand, `localStorage` will save data indefinitely until you remove
    it.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Web Storage API将数据保存在浏览器中。数据可以通过使用`window.localStorage`或`window.sessionStorage`对象来保存。`sessionStorage`
    API仅为用户的会话保存数据。关闭选项卡或重新启动浏览器将清除保存在`sessionStorage`中的任何数据。另一方面，`localStorage`将永久保存数据，直到您删除它为止。
- en: 'JSON data should be saved in browser storage as a string. This means converting
    an object into a JSON string before saving it and parsing that string into JSON
    while loading it. Some function to handle saving and loading JSON data to the
    browser could look like:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: JSON数据应作为字符串保存在浏览器存储中。这意味着在保存之前将对象转换为JSON字符串，并在加载时将该字符串解析为JSON。处理将JSON数据保存和加载到浏览器的函数可能如下所示：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `loadJSON` function loads an item from `localStorage` using the `key`. The
    `localStorage.getItem` function is used to load the data. If the item is there,
    it’s then parsed into JSON before being returned. If it’s not there, the `loadJSON`
    function will return `null`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`loadJSON`使用`key`从`localStorage`加载一个项目。使用`localStorage.getItem`函数加载数据。如果项目存在，则在返回之前将其解析为JSON。如果不存在，则函数`loadJSON`将返回`null`。
- en: The `saveJSON` function will save some data to `localStorage` using a unique
    `key` identifier. The `localStorage.setItem` function can be used to save data
    to the browser. Before saving the data, we’ll need to convert it to a JSON string.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`saveJSON`将使用唯一的`key`标识符将一些数据保存到`localStorage`中。可以使用`localStorage.setItem`函数将数据保存到浏览器中。在保存数据之前，我们需要将其转换为JSON字符串。
- en: Loading data from web storage, saving data to web storage, stringifying data,
    and parsing JSON strings are all synchronous tasks. Both the `loadJSON` and `saveJSON`
    functions are synchronous. So be careful—calling these functions too often with
    too much data can lead to performance issues. It’s typically a good idea to throttle
    or debounce these functions for the sake of performance.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 从Web存储加载数据、保存数据到Web存储、字符串化数据和解析JSON字符串都是同步任务。`loadJSON`和`saveJSON`函数都是同步的。因此要小心——频繁调用这些函数并处理大量数据可能会导致性能问题。通常建议为了性能考虑对这些函数进行节流或防抖处理。
- en: 'We could save the user’s data that we received from our GitHub request. Then
    the next time that same user is requested, we could use the data saved to `localStorage`
    instead of sending another request to GitHub. We’ll add the following code to
    the `GitHubUser` component:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以保存从GitHub请求接收到的用户数据。然后，下次请求同一用户时，我们可以使用保存到`localStorage`的数据，而不是向GitHub发送另一个请求。我们将添加以下代码到`GitHubUser`组件中：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `loadJSON` function is synchronous, so we can use it when we invoke `useState`
    to set the initial value for data. If there was user data saved to the browser
    under `user:moonhighway`, we’ll initially set the data using that value. Otherwise,
    `data` will initially be `null`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`loadJSON`是同步的，因此当我们调用`useState`设置数据的初始值时可以使用它。如果在`user:moonhighway`下保存了用户数据到浏览器中，我们将使用该值来初始化数据。否则，`data`将最初为`null`。
- en: 'When `data` changes here after it has been loaded from GitHub, we’ll invoke
    `saveJSON` to save only those user details that we need: `name`, `login`, `avatar_url`,
    and `location`. No need to save the rest of the user object when we’re not using
    it. We also skip saving the `data` when that object is empty, `!data`. Also, if
    the current login and `data.login` are equal to each other, then we already have
    saved data for that user. We’ll skip the step of saving that data again.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当从GitHub加载数据后，如果`data`在这里变化，我们将调用`saveJSON`仅保存我们需要的用户详细信息：`name`、`login`、`avatar_url`和`location`。当我们不使用其余用户对象时，无需保存其余数据。当对象为空时，我们也跳过保存`data`，即`!data`。此外，如果当前登录和`data.login`相等，则我们已经为该用户保存了数据。我们将跳过再次保存该数据的步骤。
- en: 'Here’s a look at the entire `GitHubUser` component that uses `localStorage`
    to save data in the browser:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用`localStorage`在浏览器中保存数据的整个`GitHubUser`组件的示例：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Notice the `GitHubUser` component now has two `useEffect` hooks. The first
    hook is used to save the data to the browser. It’s invoked whenever the value
    for `data` changes. The second hook is used to request more data from GitHub.
    The fetch request is not sent when there’s already data saved locally for that
    user. This is handled by the second `if` statement in the second `useEffect` hook:
    `if (data && data.login === login) return;`. If there is `data` and the `login`
    for that data matches the `login` property, then there’s no need to send an additional
    request to GitHub. We’ll just use the local data.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`GitHubUser`组件现在有两个`useEffect`钩子。第一个钩子用于将数据保存到浏览器中。每当`data`的值变化时调用它。第二个钩子用于从GitHub请求更多数据。当已经为该用户在本地保存了数据时，不会发送fetch请求。这由第二个`useEffect`钩子中的第二个`if`语句处理：`if
    (data && data.login === login) return;`。如果有`data`并且该数据的`login`与`login`属性匹配，则无需向GitHub发送额外的请求。我们只需使用本地数据。
- en: 'The first time we run the application, if the `login` is set to `moonhighway`,
    the following object will be rendered to the page:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行应用程序时，如果`login`设置为`moonhighway`，将呈现以下对象到页面上：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is the response from GitHub. We can tell because this object contains
    a lot of extra information about the user that we don’t need. The first time we
    run this page we’ll see this lengthy response. But the second time we run the
    page, the response is much shorter:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自GitHub的响应。我们可以知道，因为此对象包含了关于用户的大量额外信息，我们不需要。第一次运行此页面时，我们将看到这个冗长的响应。但第二次运行页面时，响应就会短得多：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This time, the data we saved locally for `moonhighway` is being rendered to
    the browser. Since we only needed four fields of data, we only saved four fields
    of data. We’ll always see this smaller offline object until we clear the storage:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们为`moonhighway`本地保存的数据正在被渲染到浏览器上。由于我们只需要四个字段的数据，因此我们只保存了四个字段的数据。直到我们清除存储之前，我们将始终看到这个较小的离线对象：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Both `sessionStorage` and `localStorage` are essential weapons for web developers.
    We can work with this local data when we’re offline, and they allow us to increase
    the performance of our applications by sending fewer network requests. However,
    we must know when to use them. Implementing offline storage adds complexity to
    our applications, and it can make them tough to work with in development. Additionally,
    we don’t need to work with web storage to cache data. If we’re simply looking
    for a performance bump, we could try letting HTTP handle caching. Our browser
    will automatically cache content if we add `Cache-Control: max-age=<EXP_DATE>`
    to our headers. The `EXP_DATE` defines the expiration date for the content.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`sessionStorage`和`localStorage`都是Web开发者的重要工具。当我们离线时，我们可以处理这些本地数据，并且它们允许我们通过发送更少的网络请求来提高应用程序的性能。然而，我们必须知道何时使用它们。实施离线存储会增加应用程序的复杂性，并且在开发中可能会让它们难以处理。此外，我们不需要使用Web存储来缓存数据。如果我们只是寻求性能提升，我们可以尝试让HTTP处理缓存。如果我们在头部添加`Cache-Control:
    max-age=<EXP_DATE>`，我们的浏览器将自动缓存内容。`EXP_DATE`定义了内容的过期日期。'
- en: Handling Promise States
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理Promise状态
- en: 'HTTP requests and promises both have three states: pending, success (fulfilled),
    and fail (rejected). A request is *pending* when we make the request and are waiting
    for a response. That response can only go one of two ways: success or fail. If
    a response is successful, it means we’ve successfully connected to the server
    and have received data. In the world of promises, a successful response means
    that the promise has been *resolved*. If something goes wrong during this process,
    we can say the HTTP request has failed or the promise has been *rejected*. In
    both cases, we’ll receive an `error` explaining what happened.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP请求和promises都有三种状态：挂起、成功（已完成）和失败（已拒绝）。当我们发出请求并等待响应时，请求处于*挂起*状态。该响应只能以两种方式之一进行：成功或失败。如果响应成功，这意味着我们已成功连接到服务器并收到了数据。在promise的世界中，成功的响应意味着承诺已经*解析*。如果在此过程中出现问题，我们可以说HTTP请求已失败或者promise已被*拒绝*。在这两种情况下，我们将收到一个`error`来解释发生了什么。
- en: 'We really need to handle all three of these states when we make HTTP requests.
    We can modify the GitHub user component to render more than just a successful
    response. We can add a “loading…” message when the request is pending, or we can
    render the `error` details if something goes wrong:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行HTTP请求时，我们真的需要处理这三种状态。我们可以修改GitHub用户组件以渲染不仅仅是成功的响应。我们可以在请求挂起时添加一个“加载中…”消息，或者在出现`error`时渲染错误详情：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When this request is successful, Moon Highway’s information is rendered for
    the user to see on the screen, as shown in [Figure 8-1](#fig0801).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当此请求成功时，Moon Highway的信息将渲染到用户屏幕上，如[图 8-1](#fig0801)所示。
- en: '![Sample Output](assets/lrc2_0801.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![示例输出](assets/lrc2_0801.png)'
- en: Figure 8-1\. Sample output
  id: totrans-63
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-1\. 示例输出
- en: If something goes wrong, we’re simply displaying the `error` object as a JSON
    string. In production, we would do more with the error. Maybe we would track it,
    log it, or try to make another request. While in development, it’s OK to render
    error details, which gives the developer instant feedback.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生了什么问题，我们将简单地将`error`对象显示为一个JSON字符串。在生产环境中，我们可能会对错误进行更多处理。也许我们会追踪它、记录它，或者尝试发出另一个请求。而在开发过程中，渲染错误详情是可以的，这可以为开发者提供即时反馈。
- en: Finally, while the request is pending, we simply display a “loading…” message
    using an `h1`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在请求挂起时，我们只需使用一个`h1`显示“加载中…”消息。
- en: Sometimes an HTTP request can succeed with an error. This happens when the request
    was successful—successfully connected to a server and received a response—but
    the response body contains an error. Sometimes servers pass additional errors
    as successful responses.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有时 HTTP 请求可能会成功但带有错误。这种情况发生在请求成功——成功连接到服务器并收到响应——但响应体包含错误时。有时服务器会将附加错误作为成功响应传递。
- en: Handling all three of these states bloats our code a little bit, but it’s essential
    to do so on every request. Requests take time and a lot could go wrong. Because
    all requests—and promises—have these three states, it makes it possible to handle
    all HTTP requests with a reusable hook, or a component, or even a React feature
    called Suspense. We’ll cover each of these approaches, but first, we must introduce
    the concept of render props.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这三种状态会使我们的代码变得有点臃肿，但在每个请求中这样做是至关重要的。请求需要时间，并且可能会出现很多问题。因为所有请求——和承诺——都有这三种状态，所以可以使用可重用的钩子、组件，甚至是称为
    Suspense 的 React 特性来处理所有 HTTP 请求。我们将涵盖每种方法，但首先必须介绍渲染属性的概念。
- en: Render Props
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染属性
- en: '*Render props* are exactly what they sound like: properties that are rendered.
    This can mean components that are sent as properties that are rendered when specific
    conditions are met, or it can mean function properties that return components
    that will be rendered. In the second case, when they’re functions, data can be
    passed as arguments and used when rendering the returned component.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*渲染属性* 正如其名，即被渲染的属性。这可以是作为属性传递的组件，在满足特定条件时进行渲染，或者可以是返回将被渲染的组件的函数属性。在第二种情况下，当它们是函数时，数据可以作为参数传递，并在渲染返回的组件时使用。'
- en: Render props are useful when maximizing reusability in asynchronous components.
    With this pattern, we can create components that abstract away complex mechanics
    or monotonous boilerplate that’s necessary for application development.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步组件中最大化重用性时，渲染属性非常有用。通过这种模式，我们可以创建抽象复杂机制或单调样板代码，这些对应用程序开发是必要的。
- en: 'Consider the task of displaying a list:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑显示列表的任务：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this example, the four tallest peaks in Tahoe are rendered into an unordered
    list. This code makes sense, but mapping over an array to render each item individually
    does introduce some code complexity. Mapping over an array of items is also a
    pretty common task. We may find ourselves frequently repeating this pattern. We
    could create a `List` component that we can reuse as a solution whenever we need
    to render an unordered list.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，塔霍最高的四个峰被渲染成无序列表。这段代码是有意义的，但是在映射一个数组以单独渲染每个项目时引入了一些代码复杂性。映射数组中的项目也是一个相当常见的任务。我们可能会经常重复这种模式。我们可以创建一个
    `List` 组件，以便在需要渲染无序列表时重复使用这个解决方案。
- en: 'In JavaScript, arrays either contain values or they’re empty. When a list is
    empty, we need to display a message to our users. However, that message may change
    upon implementation. No worries—we can pass a component to render when the list
    is empty:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，数组要么包含值，要么为空。当列表为空时，我们需要向用户显示一条消息。然而，该消息可能会根据实现方式而变化。别担心——我们可以传递一个组件，在列表为空时进行渲染：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `List` component expects two properties: `data` and `renderEmpty`. The
    first argument, `data`, represents the array of items that are to be mapped over.
    Its default value is an empty array. The second argument, `renderEmpty`, is a
    component that will be rendered if the list is empty. So when `data.length` is
    `0`, the `List` component renders whatever was passed as the `renderEmpty` property
    by returning that property.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`List` 组件期望有两个属性：`data` 和 `renderEmpty`。第一个参数 `data` 表示要映射的项目数组。其默认值是一个空数组。第二个参数
    `renderEmpty` 是一个组件，如果列表为空时将进行渲染。所以当 `data.length` 为 `0` 时，`List` 组件通过返回传递的 `renderEmpty`
    属性来进行渲染。'
- en: 'In this case, users would see the following message: `This list is empty`.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，用户会看到以下消息：`This list is empty`。
- en: '`renderEmpty` is a render prop because it contains a component to render when
    a particular condition has been met—in this case, when the list is empty or the
    `data` property has not been provided.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`renderEmpty` 是一个渲染属性，因为它包含一个组件，当特定条件满足时将会渲染——在这种情况下，当列表为空或者 `data` 属性没有提供时。'
- en: 'We can send this component an actual array of `data`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将实际的 `data` 数组发送给这个组件：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Doing so at this point only renders the number of items found within the array:
    `4 items`.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这样做只会渲染在数组中找到的项目数目：`4 items`。
- en: 'We can also tell our `List` component what to render for each item found within
    the array. For example, we can send a `renderItem` property:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以告诉我们的`List`组件在数组中找到的每个项应该渲染什么。例如，我们可以发送一个`renderItem`属性：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This time, the render prop is a function. The data (the item itself) is passed
    to this function as an argument so that it can be used when what to render for
    each Tahoe Peak is decided. In this case, we render a React fragment that displays
    the item’s `name` and `elevation`. If the array is `tahoe_peaks`, we expect the
    `renderItem` property to be invoked four times: once for each of the peaks in
    the array.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，渲染属性是一个函数。数据（即项本身）作为参数传递给此函数，以便在决定为每个塔霍峰渲染什么时使用。在这种情况下，我们渲染一个显示项的`name`和`elevation`的React片段。如果数组是`tahoe_peaks`，我们期望调用`renderItem`属性四次：每次为数组中的一个峰。
- en: 'This approach allows us to abstract away the mechanics of mapping over arrays.
    Now the `List` component will handle the mapping; we just have to tell it what
    to render:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法允许我们抽象化映射数组的机制。现在`List`组件将处理映射；我们只需告诉它要渲染什么：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When the `data` array is not empty, the `List` component renders an unordered
    list, `<ul>`. It maps over each item within the array using the `.map` method
    and renders a list item, `<li>`, for every value within the array. The `List`
    component makes sure each list item receives a unique `key`. Within each `<li>`
    element, the `renderItem` property is invoked and the item itself is passed to
    that function property as an argument. The result is an unordered list that displays
    the name and elevation of each of Tahoe’s tallest peaks.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当`data`数组不为空时，`List`组件会渲染一个无序列表`<ul>`。它使用`.map`方法映射数组中的每个项，并为数组中的每个值渲染一个列表项`<li>`。`List`组件确保每个列表项都收到一个唯一的`key`。在每个`<li>`元素内部，调用`renderItem`属性并将项本身作为参数传递给该函数属性。结果是一个无序列表，显示了每个塔霍最高峰的名称和海拔。
- en: The good news is we have a reusable `List` component that we can use whenever
    we need to render an unordered list. The bad news is our component is a bit bare
    bones. There are better components we can use to handle this task.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是我们有一个可重复使用的`List`组件，可以在需要渲染无序列表时使用。坏消息是我们的组件有点简陋。有更好的组件可以处理这个任务。
- en: Virtualized Lists
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟化列表
- en: If it’s our job to develop a reusable component for rendering lists, there are
    many different use cases to consider and solutions to implement. One of the most
    important things to consider is what happens when the list is very large. Many
    of the data points we work with in production can feel infinite. A Google search
    yields pages and pages of results. Searching for a place to stay in Tahoe on Airbnb
    results in a list of houses and apartments that seems to never end. Production
    applications typically have a lot of data that needs to be rendered, but we can’t
    render it all at once.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的工作是开发一个用于渲染列表的可重用组件，那么需要考虑和实施许多不同的用例和解决方案。其中最重要的一点是当列表非常大时会发生什么。在生产中，我们处理的许多数据点可能会感觉无限。Google搜索会产生一页又一页的结果。在Airbnb上搜索塔霍的住所会产生一个似乎永远不会结束的房屋和公寓列表。生产应用通常有大量需要渲染的数据，但我们不能一次性全部渲染出来。
- en: There’s a limit to what the browser can render. Rendering takes time, processing
    power, and memory, all three of which have eventual limitations. This should be
    taken into consideration when developing a reusable list component. When the `data`
    array is very large, what should we do?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器能够渲染的内容是有限的。渲染需要时间、处理能力和内存，这三者都有各自的限制。在开发可重复使用的列表组件时，应考虑这一点。当`data`数组非常大时，我们应该怎么办？
- en: Even though our search for a place to stay may have yielded one thousand results,
    we cannot possibly look at all those results at the same time—there’s not enough
    screen space for all the images, names, and prices. We might only be able to see
    about five results at a time. When scrolling, we can see more results, but we
    have to scroll down pretty far to see a thousand results. Rendering a thousand
    results in a scrollable layer is asking a lot of the phone.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们寻找住所的搜索可能产生了一千个结果，但我们不可能同时查看所有这些结果——屏幕空间不足以显示所有的图像、名称和价格。我们可能一次只能看到大约五个结果。当滚动时，可以看到更多的结果，但必须向下滚动很远才能看到一千个结果。在可滚动的层中渲染一千个结果对手机来说要求很多。
- en: Instead of rendering 1,000 results at a time, what if we only rendered 11? Remember
    that the user can only see about five results on one screen. So we render the
    five items the user can see and render six items off screen both above and below
    the visible window of items. Rendering items above and below the visible window
    will allow the user to scroll in both directions. We can see that in [Figure 8-2](#fig0802).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 不要一次性渲染1000个结果，如果我们只渲染11个会怎么样？记住用户一次只能看到大约五个结果。所以我们渲染用户能看到的五个项目，并在可见窗口之上和之下渲染六个屏幕外的项目。在可见窗口之上和之下渲染项目可以让用户在两个方向上滚动。我们可以在图[8-2](#fig0802)中看到这一点。
- en: '![Windowing Diagram](assets/lrc2_0802.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![窗口化示意图](assets/lrc2_0802.png)'
- en: Figure 8-2\. Windowing with off-screen content
  id: totrans-95
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-2\. 带有屏幕外内容的窗口化
- en: As the user scrolls, we can unmount the results that have already been viewed
    as well as render new results off screen, ready for the user to reveal via the
    scroll. This resulting solution means that the browser will only render 11 elements
    at a time while the data for the rest of the elements is there waiting to be rendered.
    This technique is called *windowing* or *virtualization*. It allows us to scroll
    very large, sometimes infinite lists of data without crashing our browser.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户滚动时，我们可以卸载已经查看过的结果，并渲染新的在屏幕外的结果，等待用户通过滚动来显示。这种解决方案意味着浏览器一次只会渲染11个元素，而其余元素的数据则等待着被渲染。这种技术被称为*窗口化*或*虚拟化*。它允许我们滚动非常大，甚至无限的数据列表而不会导致浏览器崩溃。
- en: 'There’s a lot to consider when building a virtualized list component. Thankfully,
    we don’t have to start from scratch; the community has already developed many
    virtualized list components for us to use. The most popular of these for the browser
    are `react-window` and `react-virtualized`. Virtualized lists are so important
    that React Native even ships with one: the `FlatList`. Most of us will not have
    to build virtualized list components, but we do need to know how to use them.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建虚拟列表组件时需要考虑很多因素。幸运的是，我们不必从头开始；社区已经为我们开发了许多虚拟列表组件供我们使用。在浏览器中最流行的这些组件包括`react-window`和`react-virtualized`。虚拟列表非常重要，以至于React
    Native甚至默认包含一个：`FlatList`。大多数人不需要自己构建虚拟列表组件，但我们确实需要知道如何使用它们。
- en: 'To implement a virtualized list, we’re going to need a lot of data—in this
    case, fake data:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现虚拟列表，我们需要大量的数据——在这种情况下，是假数据：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Installing faker will allow us to create a large array of fake data. For this
    example, we’ll use fake users. We’ll create five thousand fake users at random:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 安装`faker`将允许我们创建大量的假数据数组。在这个例子中，我们将使用假用户。我们将随机创建五千个假用户：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `bigList` variable was created by mapping over an array of five thousand
    empty values and replacing those empty values with information about a fake user.
    The `name`, `email`, and `avatar` for each user are generated at random using
    functions supplied by `faker`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`bigList`变量是通过映射一个包含五千个空值的数组来创建的，并用`faker`提供的函数将这些空值替换为关于假用户的信息。每个用户的`name`、`email`和`avatar`都是随机生成的。'
- en: 'If we use the `List` component we created in the last section, it will render
    all five thousand users at the same time:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用上一节创建的`List`组件，它会一次性渲染所有五千个用户：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This code creates a `div` element for each user. Within that `div`, an `img`
    element is rendered for that user’s photo, and the user `name` and `email` are
    rendered with a paragraph element, as shown in [Figure 8-3](#fig0803).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码为每个用户创建一个`div`元素。在每个`div`中，会渲染一个用于用户照片的`img`元素，并且用户的`name`和`email`会用段落元素进行渲染，如图[8-3](#fig0803)所示。
- en: '![Performance Results](assets/lrc2_0803.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![性能结果](assets/lrc2_0803.png)'
- en: Figure 8-3\. Performance results
  id: totrans-107
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-3\. 性能结果
- en: The combination of React and modern browsers is already pretty amazing. We’re
    most likely able to render all five thousand users, but it takes a while. In this
    example, it took 52ms to be exact. As the number of users in our list goes up,
    so does this time, until we eventually reach a tipping point.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: React和现代浏览器的结合已经非常惊人了。我们很可能能够渲染所有五千个用户，但这需要一些时间。在这个例子中，确切地说是52毫秒。随着列表中用户数量的增加，这个时间也会增加，直到最终达到一个临界点。
- en: 'Let’s render the same fake user list using `react-window`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`react-window`来渲染同样的假用户列表：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`react-window` is a library that has several components we can use to render
    virtualized lists. In this example, we’ll use the `FixSizeList` component from
    `react-window`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`react-window`是一个库，提供了几个组件用于渲染虚拟列表。在这个例子中，我们将使用`react-window`中的`FixSizeList`组件：'
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`FixedSizeList` is slightly different from our `List` component. It requires
    the total number of items in the list along with the number of pixels each row
    requires as the `itemSize` property. Another big difference in this syntax is
    that the render prop is being passed to `FixedSizeList` as the `children` property.
    This render props pattern is used quite frequently.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`FixedSizeList`与我们的`List`组件稍有不同。它需要列表中的总项目数以及每行需要的像素数作为`itemSize`属性。这种语法中的另一个重大区别是将渲染prop作为`children`属性传递给`FixedSizeList`。这种渲染prop模式经常被使用。'
- en: So, let’s see what happens when five thousand fake users are rendered with the
    `FixSizeList` component (see [Figure 8-4](#fig0804)).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们看看当使用`FixSizeList`组件渲染五千个虚拟用户时会发生什么（见[图 8-4](#fig0804)）。
- en: This time, not all of the users are being rendered at once. Only those rows
    that the user can see or easily scroll to are being rendered. Notice that it only
    takes 2.6ms for this initial render.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，不是所有的用户一次性被渲染出来。只有用户能看到或轻松滚动到的那些行才会被渲染。请注意，这个初始渲染只需要2.6毫秒。
- en: 'As you scroll down to reveal more users, the `FixedSizeList` is hard at work
    rendering more users off screen as well as removing users that have scrolled off
    screen. This component automatically handles scrolling in both directions. This
    component may render quite frequently, but the renders are fast. It also doesn’t
    matter how many users are in our array: the `FixedSizeList` can handle it.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当您向下滚动以显示更多用户时，`FixedSizeList`会辛勤工作，渲染屏幕外的更多用户并移除已经滚动出屏幕的用户。这个组件自动处理双向滚动。这个组件可能会频繁地进行渲染，但是渲染速度很快。而且我们数组中有多少用户都不重要：`FixedSizeList`都能处理。
- en: '![Performance Results](assets/lrc2_0804.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![性能结果](assets/lrc2_0804.png)'
- en: Figure 8-4\. 2.6ms for this render
  id: totrans-118
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-4\. 这次渲染用时2.6毫秒
- en: Creating a Fetch Hook
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个Fetch钩子
- en: 'We know that a request is either pending, successful, or failed. We can reuse
    the logic that’s necessary for making a fetch request by creating a custom hook.
    We’ll call this hook `useFetch`, and we can use it in components across our application
    whenever we need to make a fetch request:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道请求要么是进行中、成功或失败。我们可以通过创建一个自定义钩子来重用进行fetch请求所需的逻辑。我们将称这个钩子为`useFetch`，并且我们可以在应用程序的各个组件中使用它来进行fetch请求：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This custom hook was created by composing the `useState` and `useEffect` hooks.
    The three states of a fetch request are represented in this hook: pending, success,
    and error. When the request is pending, the hook will return `true` for `loading`.
    When the request is successful and `data` is retrieved, it will be passed to the
    component from this hook. If something goes wrong, then this hook will return
    the error.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个自定义钩子是通过组合`useState`和`useEffect`钩子创建的。在这个钩子中，fetch请求的三种状态分别是：pending（进行中）、success（成功）和error（错误）。当请求处于pending状态时，钩子将返回`loading`为`true`。当请求成功并且检索到`data`时，数据将从这个钩子传递给组件。如果出现问题，这个钩子将返回错误。
- en: All three of these states are managed inside of the `useEffect` hook. This hook
    is invoked every time the value for `uri` changes. If there’s no `uri`, the fetch
    request is not made. When there’s a `uri`, the fetch request begins. If the request
    is successful, we pass the resulting JSON to the `setData` function, changing
    the state value for `data`. After that, we then change the state value for `loading`
    to false because the request was successful (i.e., it’s no longer pending). Finally,
    if anything goes wrong, we catch it and pass it to `setError`, which changes the
    state value for `error`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这三种状态都在`useEffect`钩子内管理。每当`uri`的值发生变化时，都会调用这个钩子。如果没有`uri`，则不会进行fetch请求。当有`uri`时，fetch请求开始。如果请求成功，我们将结果JSON传递给`setData`函数，改变`data`的状态值。之后，我们将`loading`的状态值改为false，因为请求成功了（即不再处于pending状态）。最后，如果出现任何问题，我们会捕获并传递给`setError`，从而改变`error`的状态值。
- en: 'Now we can use this hook to make fetch requests within our components. Anytime
    the values for `loading`, `data`, or `error` change, this hook causes the `GitHubUser`
    component to rerender with those new values:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用这个钩子在我们的组件中进行fetch请求。每当`loading`、`data`或`error`的值发生变化时，这个钩子会导致`GitHubUser`组件重新渲染以展示这些新值：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Although the component now has less logic, it still handles all three states.
    Assuming we have a `SearchForm` component ready to collect search strings from
    the user, we can add the `GitHubUser` component to our main `App` component:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然组件现在逻辑更少，但仍处理所有三种状态。假设我们有一个`SearchForm`组件准备好从用户那里收集搜索字符串，我们可以将`GitHubUser`组件添加到我们的主`App`组件中：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The main `App` component stores the username of the GitHub user in state. The
    only way to change this value is to use the search form to search for a new user.
    Whenever the value of `login` changes, the value sent to `useFetch` changes because
    it depends on the login property: *https://api.github.com/users/${login}*. This
    changes the `uri` within our hook and triggers a fetch request for the new user
    login. We’ve created a custom hook and used it to successfully create a small
    application that can be used to look up and display GitHub user details. We’ll
    continue to use this hook as we iterate on this application.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的`App`组件在状态中存储GitHub用户的用户名。改变这个值的唯一方法是使用搜索表单来搜索新用户。每当`login`的值发生变化时，发送给`useFetch`的值也会发生变化，因为它依赖于login属性：*https://api.github.com/users/${login}*。这将改变我们钩子中的`uri`并触发对新用户登录的fetch请求。我们已经创建了一个自定义钩子，并成功地用它创建了一个小应用程序，可以用来查找和显示GitHub用户的详细信息。在迭代这个应用程序时，我们将继续使用这个钩子。
- en: Creating a Fetch Component
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个Fetch组件
- en: Hooks typically allow us to reuse functionality across components. There are
    times when we find ourselves repeating the exact same pattern when it comes to
    rendering within our components. For example, the loading spinner we choose to
    render may be the exact same spinner we want to render across our entire application
    whenever a fetch request is pending. The way we handle errors with our fetch requests
    may also be consistent across our application.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 钩子通常允许我们在组件之间重用功能。在处理我们组件内的渲染时，有时我们会发现自己重复相同的模式。例如，我们选择渲染的加载旋转器可能是我们希望在整个应用程序中每当fetch请求挂起时都渲染的相同旋转器。我们处理fetch请求错误的方式可能也在整个应用程序中保持一致。
- en: 'Instead of replicating the exact same code in multiple components across our
    application, we can create one component to render consistent loading spinners
    and consistently handle all of our errors across our entire domain. Let’s create
    a `Fetch` component:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们可以创建一个组件来渲染一致的加载旋转器，并在整个领域内一致地处理所有错误，而不是在多个组件中复制相同的代码。让我们创建一个`Fetch`组件：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The custom hook, `useFetch`, is one layer of abstraction: it abstracts away
    the mechanics of making a fetch request. The `Fetch` component is an additional
    layer of abstraction: it abstracts away the mechanics of handling what to render.
    When the request is loading, the `Fetch` component will render whatever was passed
    to the optional `loadingFallback` property. When it’s successful, the JSON response
    data is passed to the `renderSuccess` property. If there’s an error, it’s rendered
    using the optional `renderError` property. The `loadingFallback` and `renderError`
    properties provide an optional layer of customization. However, when they’re not
    supplied, they fall back to their default values.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义钩子，`useFetch`，是一层抽象：它抽象了进行fetch请求的机制。`Fetch`组件是另一层抽象：它抽象了处理渲染内容的机制。当请求正在加载时，`Fetch`组件将渲染传递给可选的`loadingFallback`属性。当请求成功时，JSON响应数据将传递给`renderSuccess`属性。如果出现错误，将使用可选的`renderError`属性进行渲染。`loadingFallback`和`renderError`属性提供了一个可选的定制层。然而，当它们未提供时，它们将回退到它们的默认值。
- en: 'With the `Fetch` component in our arsenal, we can really simplify the logic
    in our `GitHubUser` component:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`Fetch`组件，我们可以真正简化我们`GitHubUser`组件中的逻辑：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `GitHubUser` component receives a `login` for a user to look up on GitHub.
    We use that login to construct the `uri` property we send to the `fetch` component.
    If successful, the `UserDetails` component is rendered. When the `Fetch` component
    is loading, the default “loading…” message will be displayed. If something goes
    wrong, the error details are automatically displayed.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`GitHubUser`组件接收一个在GitHub上查找的用户的`login`。我们使用该登录来构建发送给`fetch`组件的`uri`属性。如果成功，将呈现`UserDetails`组件。当`Fetch`组件正在加载时，将显示默认的“加载中…”消息。如果出现问题，则自动显示错误详细信息。'
- en: 'We can provide custom values for these properties. Here’s an example of how
    we can alternatively use our flexible component:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为这些属性提供自定义值。以下是我们如何替代使用我们灵活组件的示例：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This time, the `Fetch` component will render our custom loading spinner. If
    something goes wrong, we hide the error details. When the request is successful,
    we’ve chosen to alternatively render the raw data along with a TODO message for
    ourselves.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`Fetch`组件将渲染我们自定义的加载旋转器。如果出现问题，我们将隐藏错误详细信息。当请求成功时，我们选择替代地呈现原始数据以及一个给我们自己的TODO消息。
- en: 'Be careful: extra layers of abstraction, whether through hooks or components,
    can add complexity to our code. It’s our job to reduce complexity wherever we
    can. However, in this case, we’ve reduced complexity by abstracting away reusable
    logic into a component and a hook.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：无论是通过钩子还是组件，额外的抽象层都可能会增加我们代码的复杂性。我们的工作是在任何可能的地方减少复杂性。然而，在这种情况下，通过将可重复使用的逻辑抽象成组件和钩子，我们已经减少了复杂性。
- en: Handling Multiple Requests
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理多个请求
- en: Once we start making requests for data from the internet, we won’t be able to
    stop. More often than not, we need to make several HTTP requests to obtain all
    the data required to hydrate our application. For example, we’re currently asking
    GitHub to provide information about a user’s account. We’ll also need to obtain
    information about that user’s repositories. Both of these data points are obtained
    by making separate HTTP requests.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们开始从互联网请求数据，就无法停止。往往我们需要发出多个HTTP请求来获取所有需要的数据来满足我们应用的需求。例如，我们目前正在请求GitHub提供关于用户账户的信息。我们还需要获取有关该用户仓库的信息。这两个数据点通过单独的HTTP请求获取。
- en: 'GitHub users typically have many repositories. Information about a user’s repositories
    is passed as an array of objects. We’re going to create a special custom hook
    called `useIterator` that will allow us to iterate through any array of objects:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 用户通常拥有许多仓库。关于用户仓库的信息以对象数组的形式传递。我们将创建一个名为`useIterator`的特殊自定义钩子，允许我们迭代任何对象数组：
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This hook will allow us to cycle through any array. Because it returns items
    inside of an array, we can take advantage of array destructuring to give these
    values names that make sense:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个钩子将允许我们循环遍历任何数组。因为它返回数组内的项目，我们可以利用数组解构为这些值赋予有意义的名称：
- en: '[PRE31]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this case, the initial `letter` is “b.” If the user invokes next, the component
    will rerender, but this time, the value for `letter` will be “b.” Invoke `next`
    two more times, and the value for `letter` will once again be “a” because this
    iterator circles back around to the first item in the array instead of letting
    the `index` go out of bounds.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，初始的`letter`是“b”。如果用户调用`next`，组件将重新渲染，但这次，`letter`的值将是“b”。再调用两次`next`，`letter`的值将再次变为“a”，因为此迭代器会循环回到数组的第一个项，而不是让`index`越界。
- en: 'The `useIterator` hook takes in an array of `items` and an initial index. The
    key value to this iterator hook is the index, `i`, which was created with the
    `useState` hook. `i` is used to identify the current item in the array. This hook
    returns the current item, `item[i]`, as well as functions for iterating through
    that array: `prev` and `next`. Both the `prev` and `next` functions either decrement
    or increment the value of `i` by invoking `setIndex`. This action causes the hook
    to rerender with a new `index`.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`useIterator`钩子接受一个`items`数组和一个初始索引。这个迭代器钩子的关键值是索引`i`，它是用`useState`钩子创建的。`i`用于标识数组中的当前项。此钩子返回当前项`item[i]`，以及用于在数组中进行迭代的函数：`prev`和`next`。`prev`和`next`函数通过调用`setIndex`来减少或增加`i`的值。此操作会导致使用新`index`重新渲染钩子。'
- en: Memozing Values
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存值
- en: 'The `useIterator` hook is pretty cool. But we can do even better by memoizing
    the value for `item` as well as the function for `prev` and `next`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`useIterator`钩子非常酷。但我们可以通过缓存`item`的值以及`prev`和`next`的函数做得更好：'
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, both `prev` and `next` are created with the `useCallback` hook. This ensures
    that the function for `prev` will always be the same until the value for `i` changes.
    Likewise, the `item` value will always point to the same item object unless the
    value for `i` changes.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`prev`和`next`都是使用`useCallback`钩子创建的。这确保了`prev`的函数在`i`的值不变时始终相同。同样，`item`的值将始终指向同一个对象，除非`i`的值发生变化。
- en: Memoizing these values does not give us huge performance gains, or at least
    not enough to justify the code complexity. However, when a consumer uses the `useIterator`
    component, the memoized values will always point to the exact same object and
    function. This makes it easier on our consumers when they need to compare these
    values or use them in their own dependency arrays.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存这些值并不能给我们带来巨大的性能提升，或者至少不足以证明代码复杂性。然而，当消费者使用`useIterator`组件时，缓存的值始终指向完全相同的对象和函数。这使得当消费者需要比较这些值或在他们自己的依赖数组中使用它们时更容易。
- en: 'Now, we’re going to create a repository menu component. Within this component,
    we’ll use the `useIterator` hook to allow the users to cycle through their list
    of repositories:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个存储库菜单组件。在此组件中，我们将使用`useIterator`钩子允许用户循环浏览他们的存储库列表：
- en: '[PRE33]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If they click the Next button, they’ll see the name of the next repository.
    Likewise, if they click the Previous button, they’ll see the name of the previous
    repository. `RepoMenu` is the component we’ll create to provide this feature:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果他们点击“下一个”按钮，他们将看到下一个存储库的名称。同样，如果他们点击“上一个”按钮，他们将看到上一个存储库的名称。`RepoMenu`是我们将创建的组件，提供此功能：
- en: '[PRE34]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`RepoMenu` receives a list of `repositories` as a prop. It then destructures
    the `name` from the current repository object and the `previous` and `next` functions
    from `useIterator`. `&lt;` is an entity for “Less Than,” and a less than sign,
    “<”, is displayed. The same is true for `&gt;`, greater than. These are indicators
    for previous and next, and when the user clicks on either of these indicators,
    the component is rerendered with a new repository name. If the `name` changes,
    then the user has selected a different repository, so we invoke the `onSelect`
    function and pass the `name` of the new repository to that function as an argument.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`RepoMenu`接收一个`repositories`列表作为属性。然后从当前存储库对象中解构`name`，从`useIterator`中解构`previous`和`next`函数。`&lt;`是“小于”的实体，显示为小于号“<”。`&gt;`也是同理，表示大于。这些是上一个和下一个的指示器，当用户点击其中任何一个指示器时，组件将重新渲染为新的存储库名称。如果`name`发生变化，那么用户已选择了不同的存储库，因此我们调用`onSelect`函数，并将新存储库的`name`作为参数传递给该函数。'
- en: Remember, array destructuring allows us to name the items whatever we want.
    Even though we named those functions `prev` and `next` within the hook, here,
    when we use the hook, we can change their names to `previous` and `next`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，数组解构允许我们随意命名项目。尽管我们在钩子中将这些函数命名为`prev`和`next`，但在这里，当我们使用该钩子时，我们可以将它们的名称更改为`previous`和`next`。
- en: 'Now we can create the `UserRepositories` component. This component should request
    a list of a GitHub user’s repositories first, and once received, pass that list
    to the `RepoMenu` component:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建`UserRepositories`组件。该组件应首先请求GitHub用户的存储库列表，一旦收到，将该列表传递给`RepoMenu`组件：
- en: '[PRE35]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `UserRepositories` component requires a `login` to use in order to make
    the fetch request for a list of repositories. That `login` is used to create the
    URI and pass it to the `Fetch` component. Once the fetch has successfully resolved,
    we’ll render the `RepoMenu` along with the list of repositories that was returned
    from the `Fetch` component as `data`. When the user selects a different repository,
    we simply pass the name of that new repository along to the parent object:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserRepositories`组件需要一个`login`来使用，以便发出获取存储库列表的fetch请求。该`login`用于创建URI并将其传递给`Fetch`组件。一旦fetch成功解析，我们将渲染`RepoMenu`以及从`Fetch`组件返回的存储库列表作为`data`。当用户选择不同的存储库时，我们只需将该新存储库的名称传递给父对象：'
- en: '[PRE36]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now we need to add our new component to the `UserDetails` component. When the
    `UserDetails` component is rendered, we’ll also render that user’s repository
    list. Assuming the `login` value is `eveporcello`, the rendered output for the
    above component would look something like [Figure 8-5](#fig0805).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将新组件添加到`UserDetails`组件中。当渲染`UserDetails`组件时，我们还将渲染该用户的存储库列表。假设`login`值为`eveporcello`，上述组件的渲染输出将类似于[图8-5](#fig0805)。
- en: '![repository output](assets/lrc2_0805.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![存储库输出](assets/lrc2_0805.png)'
- en: Figure 8-5\. Repository output
  id: totrans-166
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-5\. 存储库输出
- en: 'In order to get information about Eve’s account along with her list of repositories,
    we need to send two separate HTTP requests. A majority of our lives as React developers
    will be spent like this: making multiple requests for information and composing
    all of the information received into beautiful user interface applications. Making
    two requests for information is just the beginning. In the next section, we’ll
    continue to make more requests of GitHub so we can see the README.md for the selected
    repository.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取Eve账户的信息以及她的存储库列表，我们需要发送两个单独的HTTP请求。作为React开发人员，我们的大部分时间都将花在这里：请求信息并将所有接收到的信息组合成美观的用户界面应用程序。请求两次信息只是个开始。在下一节中，我们将继续向GitHub发出更多请求，以便查看所选存储库的README.md。
- en: Waterfall Requests
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 瀑布请求
- en: In the last section, we made two HTTP requests. The first request was for a
    user’s details, then once we had those details, we made a second request for that
    user’s repositories. These requests happen one at a time, one after the other.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们进行了两个 HTTP 请求。第一个请求是用户详细信息的请求，然后一旦我们有了这些详细信息，我们就会为该用户的存储库进行第二个请求。这些请求依次进行，依次发生。
- en: 'The first request is made when we initially fetch the user’s details:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最初获取用户详细信息时进行第一个请求：
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Once we have that user’s details, the `UserDetails` component is rendered.
    It in turn renders `UserRepositories`, which then sends a fetch request for that
    user’s repositories:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了该用户的详细信息，`UserDetails`组件就会被渲染。它反过来渲染`UserRepositories`，然后发送一个请求以获取该用户的存储库：
- en: '[PRE38]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We call these requests *waterfall* requests because they happen one right after
    the other—they’re dependent on each other. If something goes wrong with the user
    details request, the request for that user’s repositories is never made.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称这些请求为*瀑布*请求，因为它们依次发生——它们彼此依赖。如果用户详细信息请求出现问题，那么用户存储库的请求将不会被发出。
- en: Let’s add some more layers (water?) to this waterfall. First, we request the
    user’s info, then their repository list, then, once we have their repository list,
    we make a request for the first repository’s README.md file. As the user cycles
    through the list of repositories, we’ll make additional requests for the associated
    README to each repository.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为这个瀑布再添加一些层次（水？）。首先，我们请求用户的信息，然后是他们的存储库列表，然后一旦我们有了他们的存储库列表，我们就会请求第一个存储库的
    README.md 文件。随着用户在存储库列表中循环，我们将为每个存储库的相关 README 进行额外的请求。
- en: 'Repository README files are written using Markdown, which is a text format
    that can be easily rendered as HTML with the `ReactMarkdown` component. First,
    let’s install `react-markdown`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库 README 文件使用 Markdown 编写，这是一种可以使用`ReactMarkdown`组件轻松呈现为 HTML 的文本格式。首先，让我们安装`react-markdown`：
- en: '[PRE39]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Requesting the contents of a repository’s README file also requires a waterfall
    of requests. First, we have to make a data request to the repository’s README
    route: *https://api.github.com/repos/${login}/${repo}/readme*. GitHub will respond
    to this route with the details about a repository’s README file but not the contents
    of that file. It does provide us with a `download_url` that we can use to request
    the contents of the README file. But to get the Markdown content, we’ll have to
    make an additional request. Both of these requests can be made within a single
    async function:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 请求存储库 README 文件的内容还需要一系列的请求瀑布。首先，我们必须向存储库的 README 路由发出数据请求：*https://api.github.com/repos/${login}/${repo}/readme*。GitHub
    将通过此路由响应有关存储库 README 文件的详细信息，但不提供该文件的内容。它确实为我们提供了一个`download_url`，我们可以使用它来请求 README
    文件的内容。但是要获取 Markdown 内容，我们需要进行额外的请求。这两个请求可以在单个异步函数内完成：
- en: '[PRE40]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In order to find a repository README, we need the repository owner’s `login`
    and the name of the `repository`. Those values are used to construct a unique
    URL: *https://api.github.com/repos/moonhighway/learning-react/readme*. When this
    request is successful, we destructure the `download_url` from its response. Now
    we can use this value to download the contents of the README; all we have to do
    is fetch the `download_url`. We’ll parse this text as text—`res.text()`—rather
    than JSON because the body of the response is Markdown text.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到存储库的 README，我们需要存储库所有者的`login`和存储库的名称。这些值用于构建一个唯一的网址：*https://api.github.com/repos/moonhighway/learning-react/readme*。当这个请求成功时，我们从其响应中解构出`download_url`。现在，我们可以使用这个值来下载
    README 的内容；我们只需获取`download_url`。我们将此文本解析为文本——`res.text()`——而不是 JSON，因为响应的主体是 Markdown
    文本。
- en: 'Once we have the Markdown, let’s render it by wrapping the `loadReadme` function
    inside of a React component:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了 Markdown，让我们通过将`loadReadme`函数包装在一个 React 组件内来呈现它：
- en: '[PRE41]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: First, we add the `loadReadme` function to the component using the `useCallback`
    hook to memoize the function when the component initially renders. This function
    now changes the loading state to `true` before the fetch request and changes it
    back to `false` after the request. When the Markdown is received, it’s saved in
    state using the `setMarkdown` function.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`useCallback`钩子将`loadReadme`函数添加到组件中，以在组件初始渲染时记忆函数。该函数在进行 fetch 请求之前将加载状态更改为`true`，并在请求完成后将其更改回`false`。接收到
    Markdown 后，使用`setMarkdown`函数将其保存在状态中。
- en: Next, we need to actually call `loadReadme`, so we add a `useEffect` hook to
    load the README file after the component initially renders. If for some reason
    the properties for `repo` and `login` are not present, the README will not be
    loaded. The dependency array in this hook contains `[repo]`. This is because we
    want to load another README if the value for `repo` changes. If anything goes
    wrong while loading the README, it will be caught and sent to the `setError` function.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要实际调用`loadReadme`，因此我们在组件初始渲染后添加了一个`useEffect`钩子来加载README文件。如果因某些原因`repo`和`login`的属性不存在，则README将不会被加载。此钩子中的依赖数组包含`[repo]`。这是因为我们希望在`repo`的值发生变化时加载另一个README。如果在加载README时发生任何错误，它将被捕获并发送到`setError`函数。
- en: 'Notice we have to handle the same three render states that we do for every
    fetch request: pending, success, and fail. Finally, when we have a successful
    response, the Markdown itself is rendered using the `ReactMarkdown` component.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们必须处理与每次获取请求相同的三种渲染状态：挂起，成功和失败。最后，在成功响应时，Markdown本身使用`ReactMarkdown`组件呈现。
- en: 'All there is left to do is render the `RepositoryReadme` component inside of
    the `RepoMenu` component. As the user cycles through repositories using the `RepoMenu`
    component, the README for each repository will also be loaded and displayed:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 所有需要做的就是在`RepoMenu`组件内部呈现`RepositoryReadme`组件。当用户使用`RepoMenu`组件循环浏览仓库时，每个仓库的README也会被加载并显示：
- en: '[PRE42]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now our application is really making multiple requests; initially, it makes
    four requests: one for the user’s details, then one for that user’s repository
    list, then one for information about the selected repository’s README, and finally
    one more request for the text contents of the README. These are all waterfall
    requests because they happen one after another.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序真的正在发起多个请求；最初它会发起四个请求：一个是用户详细信息的请求，然后是该用户的仓库列表的请求，接着是所选仓库README信息的请求，最后还有一次文本内容的README请求。这些都是瀑布式请求，因为它们一个接一个地发生。
- en: Additionally, as the user interacts with the application, more requests are
    made. Two waterfall requests are made to obtain the README file every time the
    user changes the current repository. All four initial waterfall requests are made
    every time the user searches for a different GitHub account.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，随着用户与应用程序的交互，还会发起更多的请求。每当用户更改当前仓库时，都会发起两次瀑布式请求以获取README文件。每当用户搜索不同的GitHub账户时，都会再次发起四次初始瀑布式请求。
- en: Throttling the Network Speed
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 减慢网络速度
- en: All of these requests are visible from the Network tab under your developer
    tools. From this tab, you can see every request, and you can throttle your network
    speed to see how these requests unfold on slow networks. If you want to see how
    the waterfall requests happen one after another you can slow down your network
    speed and see the loading messages as they’re rendered.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些请求都可以在开发者工具的网络选项卡中看到。从这个选项卡中，您可以看到每个请求，并可以通过减缓网络速度来查看这些请求在慢网络上的展开情况。如果您想看到瀑布式请求是如何一个接一个发生的，可以减慢网络速度并查看加载消息。
- en: The Network tab is available under the developer tools of most major browsers.
    To throttle the network speed in Google Chrome, select the arrow next to the word
    “Online,” as demonstrated in [Figure 8-6](#fig0806).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数主流浏览器的开发者工具中都有网络选项卡。要在Google Chrome中减慢网络速度，选择“在线”旁边的箭头，如[图8-6](#fig0806)所示。
- en: '![change speed](assets/lrc2_0806.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![更改速度](assets/lrc2_0806.png)'
- en: Figure 8-6\. Changing the speed of the network request
  id: totrans-194
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-6\. 改变网络请求的速度
- en: This will open a menu where you can choose various speeds, as you can see in
    [Figure 8-7](#fig0807).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开一个菜单，您可以在[图8-7](#fig0807)中看到各种速度选项。
- en: '![select speed](assets/lrc2_0807.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![选择速度](assets/lrc2_0807.png)'
- en: Figure 8-7\. Selecting the speed of the network request
  id: totrans-197
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-7\. 选择网络请求的速度
- en: Selecting “Fast 3G” or “Slow 3G” will significantly throttle your network requests.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 选择“Fast 3G”或“Slow 3G”将显著减慢您的网络请求。
- en: Additionally, the Network tab displays a timeline for all of the HTTP requests.
    You can filter this timeline to only view “XHR” requests. This means it will only
    show the request made using `fetch` ([Figure 8-8](#fig0808)).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，网络选项卡还显示了所有HTTP请求的时间线。您可以将此时间线筛选为仅查看“XHR”请求。这意味着它只会显示使用`fetch`进行的请求（见[图8-8](#fig0808)）。
- en: '![The waterfall of a request](assets/lrc2_0808.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![请求的瀑布图](assets/lrc2_0808.png)'
- en: Figure 8-8\. The waterfall of a request
  id: totrans-201
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-8\. 请求的瀑布图
- en: Here, we see that four requests were made one after the other. Notice that the
    loading graphic is titled “Waterfall.” This shows that each request is made after
    the other is complete.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到连续进行了四次请求。请注意加载图形的标题为“瀑布”。这表明每个请求在前一个请求完成后进行。
- en: Parallel Requests
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行请求
- en: Sometimes, it’s possible to make an application faster by sending all requests
    at once. Instead of having each request occur one after another in a waterfall,
    we can send our requests in *parallel*, or at the same time.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，通过同时发送所有请求，可以使应用程序更快。与瀑布式一次发出每个请求不同，我们可以并行发送请求，即同时进行。
- en: The reason our application is currently making a waterfall of request is that
    the components are rendered inside of one another. `GitHubUser` eventually renders
    `UserRepositories`, which eventually renders `RepositoryReadme`. Requests are
    not made until each component has been rendered.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当前我们应用程序产生请求瀑布的原因是这些组件相互嵌套渲染。`GitHubUser` 最终渲染 `UserRepositories`，后者最终渲染 `RepositoryReadme`。请求直到每个组件被渲染后才会发生。
- en: Making these requests in parallel is going to require a different approach.
    First, we’ll need to remove the `<RepositoryReadme />` from the `RepoMenu`’s render
    function. This is a good move. The `RepoMenu` should only focus on the logistics
    of creating a menu of repositories that the user can cycle through. The `RepositoryReadme`
    component should be handed in a different component.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 进行这些并行请求将需要不同的方法。首先，我们需要从 `RepoMenu` 的渲染函数中删除 `<RepositoryReadme />`。这是一个不错的举措。`RepoMenu`
    应只专注于创建用户可以循环浏览的存储库菜单的逻辑。`RepositoryReadme` 组件应在不同的组件中处理。
- en: Next, we’ll need to remove `<RepoMenu />` from the `renderSuccess` property
    of `UserRepositories`. Likewise, `<UserRepositories />` needs to be removed from
    the `UserDetails` component.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要从 `UserRepositories` 的 `renderSuccess` 属性中删除 `<RepoMenu />`。同样，需要从 `UserDetails`
    组件中删除 `<UserRepositories />`。
- en: 'Instead of nesting these components inside of one another, we’ll place them
    all on the same level next to one another, all within the `App` component:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再将这些组件嵌套在彼此内部，而是将它们全部放置在同一级别并排放置，都在 `App` 组件中：
- en: '[PRE43]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `GitHubUser`, `UserRepositories`, and `RepositoryReadme` components all
    send HTTP requests to GitHub for data. Rending them side-by-side on the same level
    will cause all of these requests to happen at the same time, in parallel.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`GitHubUser`、`UserRepositories` 和 `RepositoryReadme` 组件都会向 GitHub 发送 HTTP 请求以获取数据。将它们并排渲染在同一级别会导致所有这些请求同时进行，即并行进行。'
- en: Each component requires specific information in order to make the request. We
    need a `login` to obtain a GitHub user. We need a `login` to obtain a list of
    user repositories. The `RepositoryReadme` requires both a `login` and a `repo`
    to work properly. To make sure all of the components have what they need to make
    their requests, we initialize the app to display the details for the user “moonhighway”
    and the repository “learning-react.”
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组件需要特定的信息才能发出请求。我们需要一个 `login` 来获取 GitHub 用户。我们需要一个 `login` 来获取用户存储库列表。`RepositoryReadme`
    需要 `login` 和 `repo` 才能正常工作。为了确保所有组件都能获取到发起请求所需的信息，我们初始化应用程序以显示用户“moonhighway”的详细信息和存储库“learning-react”的详细信息。
- en: If the user searches for another `GitHubUser` with the `SearchForm`, the value
    for `login` will change, which will trigger the `useEffect` hooks within our components,
    causing them to make additional requests for data. If the user cycles through
    the list of repositories, then the `onSelect` property for `UserRepositories`
    will be invoked, which causes the `repo` value to change. Changing the `repo`
    value will trigger the `useEffect` hook inside of the `RepositoryReadme` component,
    and a new README will be requested.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户使用 `SearchForm` 搜索另一个 `GitHubUser`，`login` 的值将更改，这将触发组件中的 `useEffect` 钩子，导致它们发出额外的数据请求。如果用户在存储库列表中循环，则将调用
    `UserRepositories` 的 `onSelect` 属性，这将导致 `repo` 值发生变化。更改 `repo` 值将触发 `RepositoryReadme`
    组件内部的 `useEffect` 钩子，并请求新的 README。
- en: 'The `RepoMenu` component always starts with the first repository, no matter
    what. We have to see if there’s a `selectedRepo` property. If there is, we need
    to use it to find the initial index for the repository to be displayed:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`RepoMenu` 组件始终从第一个存储库开始，无论如何。我们必须查看是否有 `selectedRepo` 属性。如果有，我们需要使用它来找到要显示的存储库的初始索引：'
- en: '[PRE44]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The second argument for the `useIterator` hook is the initial index to start
    with. If there’s a `selected` property, then we’ll search for the index of the
    selected repository by `name`. This is required to make sure the repository menu
    displays the correct repository initially. We also need to pass this `selected`
    property to this component from `UserRepositories`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`useIterator`钩子的第二个参数是要从哪里开始的初始索引。如果有`selected`属性，那么我们将根据`name`搜索选定的存储库的索引。这是必需的，以确保存储库菜单最初显示正确的存储库。我们还需要从`UserRepositories`将此`selected`属性传递给该组件：'
- en: '[PRE45]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now that the `repo` property is being passed down to the `RepoMenu`, the menu
    should select the initial repository, which in our case is “learning-react.”
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`repo`属性被传递给`RepoMenu`，菜单应选择初始仓库，即我们的例子中是“learning-react”。
- en: If you take a look at the Network tab, you’ll notice we’ve made three requests
    in parallel, as shown in [Figure 8-9](#fig0809).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看网络选项卡，您将注意到我们已经进行了三个并行请求，如[图 8-9](#fig0809)所示。
- en: '![Creating a parallel request](assets/lrc2_0809.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![创建并行请求](assets/lrc2_0809.png)'
- en: Figure 8-9\. Creating a parallel request
  id: totrans-220
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-9\. 创建并行请求
- en: So each component made its request at the same time. The `RepoReadme` component
    still has to make a waterfall request to obtain the contents of the README file.
    This is OK. It’s hard to make every request right when your app initially renders.
    Parallel and waterfall requests can work in conjunction with each other.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每个组件同时发出其请求。`RepoReadme`组件仍然必须进行串行请求以获取README文件的内容。这没问题。很难使应用程序在初始渲染时立即发出每个请求。并行和串行请求可以结合使用。
- en: Waiting for Values
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 等待值
- en: 'We currently initialize the values for `login` and `repo` to “moonhighway”
    and “learning-react.” We may not always be able to guess which data to render
    first. When that’s the case, we simply don’t render the component until the data
    it requires is present:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当前，我们将`login`和`repo`的值初始化为“moonhighway”和“learning-react”。我们可能无法总是猜测要首先渲染哪些数据。在这种情况下，直到组件所需的数据可用之前，我们才简单地不渲染该组件：
- en: '[PRE46]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In this scenario, none of the components are rendered until their required props
    have values. Initially, the only component rendered is the `SearchForm`. Searching
    for a user will change the value for `login`, causing the `UserRepositories` component
    to render. When this component looks up the repositories, it will select the first
    repository in the list, causing `setRepo` to be invoked. Finally, we have a `login`
    and a `repo`, so the `RepositoryReadme` component will be rendered.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，直到它们所需的props具有值之前，没有一个组件会被渲染。最初，只有`SearchForm`组件被渲染。搜索用户将更改`login`的值，导致`UserRepositories`组件被渲染。当此组件查找存储库时，它将选择列表中的第一个存储库，导致调用`setRepo`。最后，我们有了`login`和`repo`，因此将渲染`RepositoryReadme`组件。
- en: Canceling Requests
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 取消请求
- en: 'Thinking about our application a little bit more, we realize that the user
    could empty the search field and search for no user at all. In this case, we would
    also want to make sure that the value for `repo` is also empty. Let’s add a `handleSearch`
    method that makes sure the `repo` value changes when there’s no value for `login`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 更深思考我们的应用，我们意识到用户可能会清空搜索字段并搜索没有用户。在这种情况下，我们还希望确保`repo`的值也为空。让我们添加一个`handleSearch`方法，确保在`login`没有值时`repo`值发生变化：
- en: '[PRE47]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We’ve added a `handleSearch` method. Now, when the user clears the search field
    and searches for an empty string, the repo value is also set to an empty string.
    If for some reason there’s not a login, we only render one component: the `SearchForm`.
    When we have a value for `login`, we’ll render all four components.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经添加了一个`handleSearch`方法。现在，当用户清除搜索字段并搜索空字符串时，repo值也将设置为空字符串。如果因某种原因没有登录，我们只渲染一个组件：`SearchForm`。当我们有了`login`的值时，我们将渲染所有四个组件。
- en: Now, technically our app has two screens. One screen only displays a search
    form. The other screen only shows when the search form contains a value, in which
    case, it shows all four components. We’ve set ourselves up to mount or unmount
    components based on user interactivity. Let’s say we were looking at the details
    for “moonhighway.” If the user empties the search field, then the `GitHubUser`,
    `UserRepositories`, and `RepositoryReadme` components are unmounted and will no
    longer be displayed. But what if these components were in the middle of loading
    data when they were unmounted?
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从技术上讲，我们的应用程序有两个屏幕。一个屏幕仅显示搜索表单。另一个屏幕仅在搜索表单包含值时显示，此时显示所有四个组件。我们已经设置好了根据用户交互来挂载或卸载组件的条件。假设我们正在查看“moonhighway”的详细信息。如果用户清空搜索字段，那么
    `GitHubUser`、`UserRepositories` 和 `RepositoryReadme` 组件将被卸载，并且不再显示。但是如果在这些组件在加载数据时被卸载会发生什么呢？
- en: 'You can try it out:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以试试：
- en: Throttle the network to “Slow 3G” to have enough time to cause problems
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将网络节流至“慢速 3G”，以便有足够的时间引起问题
- en: Change the value of the search field from “moonhighway” to “eveporcello”
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将搜索字段的值从 “moonhighway” 更改为 “eveporcello”
- en: While the data is loading, search for an empty string, “”
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在数据加载时，搜索一个空字符串，“”
- en: These steps will cause the `GitHubUser`, `UserRepositories`, and `RepositoryReadme`
    to become unmounted while they’re in the middle of making fetch requests. Eventually,
    when there’s a response to the fetch request, these components are no longer mounted.
    Attempting to change state values in an unmounted component will cause the error
    shown in [Figure 8-10](#fig0810).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些步骤中，当它们正在进行 fetch 请求时，`GitHubUser`、`UserRepositories` 和 `RepositoryReadme`
    将会变为未挂载状态。最终，当 fetch 请求有响应时，这些组件将不再挂载。在未挂载的组件中尝试更改状态值将导致 [图 8-10](#fig0810) 中显示的错误。
- en: '![mounted error](assets/lrc2_0810.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![mounted error](assets/lrc2_0810.png)'
- en: Figure 8-10\. Mounted error
  id: totrans-237
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-10\. 挂载错误
- en: 'Whenever our users load data over a slow network, these errors can occur. But
    we can protect ourselves. First, we can create a hook that will tell us whether
    or not the current component is mounted:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们的用户通过慢速网络加载数据时，这些错误可能会发生。但是我们可以保护自己。首先，我们可以创建一个钩子，告诉我们当前的组件是否已挂载：
- en: '[PRE48]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `useMountedRef` hook uses a ref. When the component unmounts, state is wiped
    clean, but refs are still available. The above `useEffect` doesn’t have a dependency
    array; it’s invoked every time a component renders and ensures that the value
    for the ref is `true`. Whenever the component unmounts, the function returned
    from `useEffect` is invoked, which changes the value of the ref to `false`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`useMountedRef` 钩子使用了一个引用。当组件卸载时，状态被清除，但引用仍然可用。上述的 `useEffect` 没有依赖数组；它在每次组件渲染时被调用，并确保引用的值为
    `true`。每当组件卸载时，会调用从 `useEffect` 返回的函数，该函数将引用的值更改为 `false`。'
- en: 'Now we can use this hook inside of the `RepoReadme` component. This will allow
    us to make sure the component is mounted before applying any state updates:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在 `RepoReadme` 组件内使用这个钩子。这将确保在应用任何状态更新之前，检查组件是否已挂载：
- en: '[PRE49]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Now we have a ref that tells us whether or not the component is mounted. It
    will take time for both of these requests to finish. When they do, we check to
    make sure the component is still mounted before calling `setMarkdown` or `setLoading`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个引用，告诉我们组件是否已挂载。这两个请求完成需要时间。完成后，我们检查组件是否仍处于挂载状态，然后调用 `setMarkdown` 或
    `setLoading`。
- en: 'Let’s add the same logic to our `useFetch` hook:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将相同的逻辑添加到我们的 `useFetch` 钩子中：
- en: '[PRE50]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `useFetch` hook is used to make the rest of the fetch requests in our app.
    In this hook, we compose the fetch request using thenables, chainable `.then()`
    functions, instead of `async/await`. When the fetch is complete, we check to see
    if the component is mounted in the first `.then` callback. If the component is
    mounted, the `data` is returned and the rest of the `.then` functions are invoked.
    When the component is not mounted, the first `.then` function throws an error,
    preventing the rest of the `.then` functions from executing. Instead, the `.catch`
    function is invoked and the new error is passed to that function. The `.catch`
    function will check to see if the component is mounted before it tries to invoke
    `setError`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`useFetch` 钩子用于在我们的应用程序中进行其余的 fetch 请求。在这个钩子中，我们使用 thenables，可链式的 `.then()`
    函数来组成 fetch 请求，而不是 `async/await`。当 fetch 完成时，在第一个 `.then` 回调中检查组件是否已挂载。如果组件已挂载，则返回
    `data` 并调用其余的 `.then` 函数。当组件未挂载时，第一个 `.then` 函数会抛出错误，阻止其余的 `.then` 函数执行。相反，会调用
    `.catch` 函数，并将新错误传递给该函数。`.catch` 函数将在尝试调用 `setError` 之前检查组件是否已挂载。'
- en: We’ve successfully canceled our requests. We didn’t stop the HTTP request itself
    from occurring, but we did protect the state calls we make after the request is
    resolved. It’s always a good idea to test your app under slow network conditions.
    These bugs will be revealed and eliminated.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已成功取消了我们的请求。我们并没有阻止 HTTP 请求本身发生，但我们确实保护了请求解决后进行的状态调用。测试你的应用在慢网络条件下总是一个好主意。这些
    bug 将被发现并消除。
- en: Introducing GraphQL
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 GraphQL
- en: Just like React, GraphQL was designed at Facebook. And, just like React is a
    declarative solution for composing user interfaces, GraphQL is a declarative solution
    for communicating with APIs. When we make parallel data requests, we’re attempting
    to get all the data we need immediately at the same time. GraphQL was designed
    to do just that.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 React 一样，GraphQL 是在 Facebook 设计的。而且，就像 React 是一个声明式的用户界面组合解决方案一样，GraphQL
    是用于与 API 通信的声明式解决方案。当我们进行并行数据请求时，我们尝试立即获取所有需要的数据。GraphQL 就是为此而设计的。
- en: In order to get data from a GraphQL API, we still need to make an HTTP request
    to a specific URI. However, we also need to send a query along with the request.
    A GraphQL query is a declarative description of the data we’re requesting. The
    service will parse this description and will package all the data we’re asking
    for into a single response.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 GraphQL API 获取数据，我们仍然需要向特定的 URI 发送 HTTP 请求。但是，我们还需要发送一个查询以及请求。GraphQL 查询是对我们请求的数据的声明性描述。服务将解析此描述，并将我们请求的所有数据打包到一个响应中。
- en: GitHub GraphQL API
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitHub GraphQL API
- en: In order to use GraphQL in your React application, the backend service you’re
    communicating with needs to be built following GraphQL specifications. Fortunately,
    GitHub also exposes a GraphQL API. Most GraphQL services provide a way to explore
    the GraphQL API. At GitHub, this is called the [GraphQL Explorer](https://developer.github.com/v4/explorer).
    In order to use the Explorer, you must sign in with your GitHub account.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的 React 应用程序中使用 GraphQL，您通信的后端服务需要按照 GraphQL 规范构建。幸运的是，GitHub 也提供了一个 GraphQL
    API。大多数 GraphQL 服务提供一种探索 GraphQL API 的方法。在 GitHub，这称为 [GraphQL Explorer](https://developer.github.com/v4/explorer)。要使用
    Explorer，您必须使用您的 GitHub 帐户登录。
- en: 'The left panel of the Explorer is where we draft our GraphQL query. Inside
    of this panel, we could add a query to obtain information about a single GitHub
    user:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Explorer 的左侧面板是我们草拟 GraphQL 查询的地方。在此面板内，我们可以添加一个查询，以获取关于单个 GitHub 用户的信息：
- en: '[PRE51]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This is a GraphQL query. We’re asking for information about the GitHub user
    “moontahoe.” Instead of getting all of the public information available about
    moontahoe, we only get the data we want: `id`, `login`, `avatarUrl`, `name`, and
    `location`. When we press the Play button on this page, we send this query as
    an HTTP POST request to *https://api.github.com/graphql*. All GitHub GraphQL queries
    are sent to this URI. GitHub will parse this query and return only the data we
    asked for:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 GraphQL 查询。我们要获取关于 GitHub 用户“moontahoe”的信息。与其获取所有公开信息不同，我们只获取我们想要的数据：`id`、`login`、`avatarUrl`、`name`
    和 `location`。当我们在此页面按下播放按钮时，我们将此查询作为 HTTP POST 请求发送到 *https://api.github.com/graphql*。所有
    GitHub GraphQL 查询都发送到此 URI。GitHub 将解析此查询并仅返回我们请求的数据：
- en: '[PRE52]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We can formalize this GraphQL query into a reusable operation named `findRepos`.
    Every time we want to find information about a user and their repositories, we
    could do so by sending a `login` variable to this query:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个GraphQL查询正式化为一个名为 `findRepos` 的可重用操作。每当我们想要查找有关用户及其仓库的信息时，我们可以通过向该查询发送一个
    `login` 变量来实现：
- en: '[PRE53]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Now we’ve created a formal `findRepos` query that we can reuse simply by chaining
    the value of the `$login` variable. We set this variable using the Query Variables
    panel shown in [Figure 8-11](#fig0811).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个正式的 `findRepos` 查询，可以通过简单地链式传递 `$login` 变量的值来重用。我们使用查询变量面板中显示的 [图8-11](#fig0811)
    来设置此变量。
- en: '![GitHub GraphQL Explorer](assets/lrc2_0811.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![GitHub GraphQL资源浏览器](assets/lrc2_0811.png)'
- en: Figure 8-11\. GitHub GraphQL Explorer
  id: totrans-261
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-11\. GitHub GraphQL资源浏览器
- en: In addition to obtaining details about a user, we’re also asking for that user’s
    first hundred repositories. We’re asking for the number of repositories returned
    by the query, the `totalCount`, along with the `name` of each repository. GraphQL
    only returns the data we ask for. In this case, we’ll only get the `name` for
    each repository, nothing else.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 除了获取有关用户的详细信息外，我们还要求获取该用户的前100个仓库。我们询问了查询返回的仓库数，即`totalCount`，以及每个仓库的`name`。GraphQL仅返回我们要求的数据。在这种情况下，我们仅获取每个仓库的`name`，而不获取其他任何信息。
- en: 'There’s one more change that we made to this query: we used an alias for the
    `avatarUrl`. The GraphQL field to obtain a user’s avatar is called `avatarUrl`,
    but we want that variable to be named `avatar_url`. The alias tells GitHub to
    rename that field in the data response.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一项我们对此查询所做的更改：我们为`avatarUrl`使用了一个别名。获取用户头像的GraphQL字段称为`avatarUrl`，但我们希望该变量被命名为`avatar_url`。别名告诉GitHub在数据响应中重命名该字段。
- en: 'GraphQL is a huge topic. We wrote a whole book about it: [*Learning GraphQL*](http://shop.oreilly.com/product/0636920137269.do).
    We’re only scratching the surface here, but GraphQL is increasingly becoming more
    of a requirement for any developer. In order to be a successful developer in the
    21st century, it’s important to understand the fundamentals of GraphQL.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL是一个广阔的话题。我们为此撰写了一本整书：[*学习GraphQL*](http://shop.oreilly.com/product/0636920137269.do)。在这里我们只是浅尝辄止，但是对于任何开发者来说，了解GraphQL的基础知识越来越重要。
- en: Making a GraphQL Request
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发起GraphQL请求
- en: A GraphQL request is an HTTP request that contains a query in the body of the
    request. You can use `fetch` to make a GraphQL request. There are also a number
    of libraries and frameworks that can handle the details of making these types
    of requests for you. In this next section, we’ll see how we can hydrate our applications
    with GraphQL data using a library called `graphql-request`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 一个GraphQL请求是一个包含查询的HTTP请求体。您可以使用 `fetch` 来发起GraphQL请求。还有许多库和框架可以帮助您处理这些请求的详细信息。在接下来的部分中，我们将看到如何使用名为
    `graphql-request` 的库来获取GraphQL数据来充实我们的应用程序。
- en: Note
  id: totrans-267
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: GraphQL is not restricted to HTTP. It’s a specification of how data requests
    should be made over a network. It can technically work with any network protocol.
    Additionally, GraphQL is language-agnostic.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL并不限于HTTP。它是一种规范，用于在网络上传递数据请求。从技术上讲，它可以与任何网络协议一起工作。此外，GraphQL与编程语言无关。
- en: 'First, let’s install `graphql-request`:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们安装 `graphql-request`：
- en: '[PRE54]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: GitHub’s GraphQL API requires identification to send requests from client applications.
    In order to complete this next sample, you must obtain a personal access token
    from GitHub, and this token must be sent with every request.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub的GraphQL API要求在客户端应用程序中发送请求时进行身份验证。为了完成下面的示例，您必须从GitHub获取一个个人访问令牌，并且该令牌必须随每个请求一起发送。
- en: 'To obtain a personal access token for GraphQL requests, navigate to Settings
    > Developer Settings > Personal Access Tokens. On this form, you can create an
    access token that has specific rights. The token must have the following read
    access in order to make GraphQL requests:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取用于GraphQL请求的个人访问令牌，请导航至 设置 > 开发者设置 > 个人访问令牌。在这个表单上，您可以创建具有特定权限的访问令牌。为了进行GraphQL请求，该令牌必须具有以下读取权限：
- en: user
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户
- en: public_repo
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public_repo`'
- en: repo
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`repo`'
- en: repo_deployment
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`repo_deployment`'
- en: repo:status
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`repo:status`'
- en: read:repo_hook
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`read:repo_hook`'
- en: read:org
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`read:org`'
- en: read:public_key
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`read:public_key`'
- en: read:gpg_key
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`read:gpg_key`'
- en: 'We can use `graphql-request` to make GraphQL requests from JavaScript:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `graphql-request` 在JavaScript中发出GraphQL请求：
- en: '[PRE55]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We send this request using the `GraphQLClient` constructor from `graphql-request`.
    When we create the client, we use the URI for GitHub’s GraphQL API: *https://api.github.com/graphql*.
    We also send some additional headers that contain our personal access token. This
    token identifies us and is required by GitHub when using their GraphQL API. We
    can now use the `client` to make our GraphQL requests.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `GraphQLClient` 构造函数从 `graphql-request` 发送此请求。在创建客户端时，我们使用 GitHub 的 GraphQL
    API 的 URI：*https://api.github.com/graphql*。我们还发送一些额外的头信息，其中包含我们的个人访问令牌。这个令牌用于识别我们，在使用
    GitHub 的 GraphQL API 时是必需的。现在我们可以使用 `client` 来进行我们的 GraphQL 请求。
- en: In order to make a GraphQL request, we’ll need a `query`. The `query` is simply
    a string that contains the GraphQL query from above. We send the `query` to the
    `request` function along with any variables that the query may require. In this
    case, the `query` requires a variable named `$login`, so we send an object that
    contains a value for `$login` in the `login` field.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 为了发起 GraphQL 请求，我们需要一个 `query`。该 `query` 简单地是包含上述 GraphQL 查询的字符串。我们将 `query`
    与可能需要的任何变量一起发送给 `request` 函数。在这种情况下，`query` 需要一个名为 `$login` 的变量，因此我们发送一个包含在 `login`
    字段中为 `$login` 提供值的对象。
- en: 'Here, we’re simply converting the resulting JSON to a string and logging it
    to the console:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是将生成的 JSON 转换为字符串并记录在控制台中：
- en: '[PRE56]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Just like `fetch`, `client.request` returns a promise. Getting this data inside
    of your React component will feel very similar to fetching data from a route:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `fetch` 一样，`client.request` 也返回一个承诺。在 React 组件内部获取这些数据将感觉非常类似于从路由获取数据：
- en: '[PRE57]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We make the `client.request` inside of a `useEffect` hook. If the `client`,
    `query`, or `login` changes, the `useEffect` hook will make another request. Then
    we’ll render the resulting JSON with React, as shown in [Figure 8-12](#fig0812).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `useEffect` 钩子中执行 `client.request`。如果 `client`、`query` 或 `login` 发生变化，`useEffect`
    钩子将发起另一个请求。然后，我们将使用 React 渲染结果的 JSON，如 [图 8-12](#fig0812) 所示。
- en: '![GraphQL app](assets/lrc2_0812.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![GraphQL 应用](assets/lrc2_0812.png)'
- en: Figure 8-12\. GraphQL app
  id: totrans-292
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-12\. GraphQL 应用
- en: This example doesn’t put care into handling `loading` and `error` states, but
    we can apply everything we learned in the rest of this chapter to GraphQL. React
    doesn’t really care how we get the data. As long as we understand how to work
    with asynchronous objects like promises within our components, we’ll be ready
    for anything.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例并未关注处理 `loading` 和 `error` 状态，但我们可以将本章其余部分学到的内容应用到 GraphQL 中。React 实际上并不关心我们如何获取数据。只要我们理解如何在组件内部处理像承诺这样的异步对象，我们就能应对任何情况。
- en: Loading data from the internet is an asynchronous task. When we request data,
    it takes some time for it to be delivered, and stuff can go wrong. Handling the
    `pending`, `success`, and `fail` states of a promise within a React component
    is an orchestration of stateful hooks with the `useEffect` hook.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 从互联网加载数据是一个异步任务。当我们请求数据时，需要一些时间才能传递，而且可能会出错。在 React 组件中处理承诺的 `pending`、`success`
    和 `fail` 状态是使用 `useEffect` 钩子进行状态管理的协作。
- en: 'We spent much of this chapter covering promises, `fetch`, and HTTP. This is
    because HTTP is still the most popular way to request data from the internet,
    and promises fit nicely with HTTP requests. Sometimes, you may work with a different
    protocol like WebSockets. No worries: this is accomplished by working with stateful
    hooks and `useEffect`.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的大部分内容中，我们讨论了承诺、`fetch` 和 HTTP。这是因为 HTTP 仍然是从互联网请求数据的最流行方式，而承诺与 HTTP 请求非常匹配。有时，您可能会使用不同的协议，如
    WebSockets。不用担心：通过使用状态钩子和 `useEffect`，可以轻松实现这一点。
- en: 'Here’s a brief example of how we can incorporate socket.io into a custom `useChatRoom`
    hook:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个简短的示例，演示了如何将 socket.io 集成到自定义的 `useChatRoom` 钩子中：
- en: '[PRE58]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This hook provides an array of chat `messages`, the websocket `connection` status,
    and a function that can be used to broadcast new messages to the socket. All of
    these values are affected by listeners that are defined in the `useEffect` hook.
    When the socket raises `connection` or `disconnecting` events, the value for `status`
    changes. When new messages are received, they’re appended to the array of messages
    via the `useReducer` hook.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 此钩子提供了一组聊天 `messages` 数组，websocket 的 `connection` 状态，以及一个用于向套接字广播新消息的函数。所有这些值都受到
    `useEffect` 钩子中定义的监听器的影响。当套接字触发 `connection` 或 `disconnecting` 事件时，`status` 的值会发生变化。当接收到新消息时，通过
    `useReducer` 钩子，它们将被追加到消息数组中。
- en: In this chapter, we’ve discussed some techniques for handling asynchronous data
    in applications. This is a hugely important topic, and in the next chapter, we’ll
    show how Suspense might lead to future changes in this area.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了一些处理应用程序中异步数据的技术。这是一个非常重要的话题，在接下来的章节中，我们将展示悬念可能会在这一领域带来未来的变革。
