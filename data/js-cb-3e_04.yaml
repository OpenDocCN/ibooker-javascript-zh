- en: Chapter 3\. Numbers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章 数字
- en: There are few ingredients more essential to everyday programming than numbers.
    Many modern languages have a set of different numeric data types to use in different
    scenarios, like integers, decimals, floating point values, and so on. But when
    it comes to numbers, JavaScript reveals its rushed, slightly improvised creation
    as a loosely-typed scripting language.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在日常编程中，很少有比数字更重要的要素。许多现代语言都有一组不同的数值数据类型，用于不同的场景，如整数、小数、浮点值等。但是当涉及到数字时，JavaScript
    作为一种松散类型的脚本语言，揭示了其匆忙、稍微临时的创建。
- en: 'Until recently, JavaScript had just a single do-everything numeric data type
    called `Number`. Today, it has two: the standard `Number` you use almost all of
    the time, and the very specialized `BigInt` that you only consider when you need
    to deal with huge whole numbers. You’ll use both in this chapter, along with the
    utility methods of the `Math` object.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 直到最近，JavaScript 只有一个称为 `Number` 的全能数值数据类型。如今，它有两种：您几乎所有时候使用的标准 `Number`，以及只在需要处理巨大整数时考虑的非常专业化的
    `BigInt`。在本章中，您将同时使用这两种类型，以及 `Math` 对象的实用方法。
- en: Generating Random Numbers
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成随机数
- en: Problem
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to generate a random whole number that falls in a set range (for example,
    from 1 to 6).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你想生成一个落在一定范围内的随机整数（例如，从1到6）。
- en: Solution
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'You can use the `Math.random()` method to generate a floating-point value between
    0 and 1\. Usually, you’ll scale this fractional value and round it, so you end
    up with an integer in a specific range. Assuming your range spans from some minimum
    number `min` to a maximum number `max`, here’s the statement you need:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `Math.random()` 方法生成介于0和1之间的浮点值。通常，您会缩放这个小数值并四舍五入，这样您就会得到一个特定范围内的整数。假设您的范围从某个最小数
    `min` 到最大数 `max`，这是您需要的语句：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For example, if you want to pick a random number between 1 and 6, the code
    becomes:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您想在1到6之间选择一个随机数，代码如下：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now possible values of `randomNumber` are 1, 2, 3, 4, 5, or 6.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `randomNumber` 的可能值是1、2、3、4、5或6。
- en: Discussion
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The `Math` object is stocked full of static utility methods you can call at
    any time. This recipe uses `Math.random()` to get a random fractional number,
    and `Math.floor()` to truncate the decimal portion, leaving you with an integer.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math` 对象中充满了您随时可以调用的静态实用方法。本示例使用 `Math.random()` 获取一个随机小数，然后使用 `Math.floor()`
    截断小数部分，得到一个整数。'
- en: 'To understand how this works, let’s consider a sample run-through. First, `Math.random()`
    picks a value between 0 and 1, like *0.374324823*:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这是如何工作的，让我们考虑一个示例运行。首先，`Math.random()` 选择一个值介于0和1之间，如 *0.374324823*：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'That number is multiplied by the number of values in your range (in this example,
    6), becoming *2.245948938*:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 该数字乘以您范围内的值的数量（在本例中为6），变为 *2.245948938*：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then the `Math.floor()` function truncates this to just *2*:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然后 `Math.floor()` 函数将其截断为 *2*：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Finally, the starting number of the range is added, giving the final result
    of *3*. Repeat this calculation and you’ll get a different number, but it will
    always be an integer from the range we’ve set of 1 to 6.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将范围的起始数字相加，得到最终结果为 *3*。重复这个计算，你会得到一个不同的数字，但它将始终是我们设置的范围从1到6的整数。
- en: See Also
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The `Math.floor()` method is only one way to round numbers. See [“Rounding to
    a Specific Decimal Place”](#rounding_specific_decimal) for more.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math.floor()` 方法只是一个四舍五入数字的方法之一。更多信息请参见[“四舍五入到特定小数位”](#rounding_specific_decimal)。'
- en: 'It’s important to understand that numbers generated by `Math.random()` are
    *pseudorandom*, which means they can be guessed or reverse engineered. They are
    not random enough for cryptography, lotteries, or complex modelling. For more
    about the difference, see [“Generating Cryptographically Secure Random Numbers”](#generating_secure_random_numbers).
    And if you need a way to generate a repeatable sequence of pseudorandom numbers,
    refer to [“Extra: Building a Repeatable Pseudorandom Number Generator”](ch06.html#repeatable_PRNG).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解 `Math.random()` 生成的数字是*伪随机*的，这意味着它们可以被猜测或逆向工程。它们对于密码学、彩票或复杂建模来说不够随机。有关差异的更多信息，请参见[“生成密码安全的随机数”](#generating_secure_random_numbers)。如果您需要一种生成可重复序列的伪随机数的方法，请参考[“额外：构建可重复的伪随机数生成器”](ch06.html#repeatable_PRNG)。
- en: Generating Cryptographically Secure Random Numbers
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成密码安全的随机数
- en: Problem
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to create a random number that can’t be easily reverse engineered (guessed).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你想创建一个不容易被逆向工程（猜测）的随机数。
- en: Solution
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `window.crypto` property to get an instance of the `Crypto` object.
    Use the `Crypto.getRandomValues()` method to generate random values that have
    more *entropy* than those produced by `Math.random()`. (In other words, they are
    much less likely to be repeated or predicted—see the Discussion section for full
    details.)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`window.crypto`属性来获取`Crypto`对象的一个实例。使用`Crypto.getRandomValues()`方法来生成比`Math.random()`产生的具有更多*熵*的随机值。（换句话说，它们很不可能被重复或预测到—详细内容请参见讨论部分。）
- en: The `Crypto.getRandomValues()` method works differently from `Math.random()`.
    Rather than giving you a floating-point number between 0 and 1, `getRandomValues()`
    fills an array with random integers. You can choose whether these integers are
    8-bit, 16-bit, or 32-bit, and whether they are signed or unsigned. (A signed data
    type can be negative or positive, whereas an unsigned number is only positive.)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`Crypto.getRandomValues()`方法的工作方式与`Math.random()`不同。它不是给您一个在0到1之间的浮点数，而是用随机整数填充一个数组。您可以选择这些整数是8位、16位还是32位，以及它们是有符号还是无符号的。（有符号数据类型可以是负数或正数，而无符号数仅为正数。）'
- en: 'There is an accepted workaround to convert the output of `getRandomValues()`
    to a fractional value between 0 and 1\. The trick is to divide the random value
    by the maximum possible number that data type can contain:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个被接受的解决方案来将`getRandomValues()`的输出转换为0到1之间的分数值。诀窍是将随机值除以数据类型可以包含的最大可能数字：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can now work with `randomFraction` in the same way that you work with the
    number returned from `Math.random()`. For example, you can convert it to a random
    integer in a specific range, as explained in [“Generating Random Numbers”](#generating_random_numbers):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以像处理从`Math.random()`返回的数字一样处理`randomFraction`。例如，您可以将其转换为特定范围内的随机整数，如[“生成随机数”](#generating_random_numbers)中所述：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you’re running your code in the Node.js runtime environment, you won’t have
    access to a `window` object. However, you can get access to a very similar implementation
    of the Web Crypto API using this code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Node.js运行时环境中运行代码，则无法访问`window`对象。但是，您可以使用以下代码访问非常类似的Web Crypto API实现：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Discussion
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'There’s a lot to unpack in this example. First, even if you don’t dig deeper
    into *how* this code works, you need to be aware of a few important details about
    the implementation of `Crypto.getRandomValues()`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例中有很多需要解开的内容。首先，即使您不深入研究这段代码的*工作方式*，您也需要了解关于`Crypto.getRandomValues()`实现的一些重要细节：
- en: Technically, `Crypto` creates pseudorandom numbers that are generated by a mathematical
    formula, like those provided by `Math.random()`. The difference is that these
    numbers are considered *cryptographically strong*, because the random number generator
    is seeded with a truly random value. The benefit of this trade-off is that `getRandomValues()`
    has similar performance to `Math.random()`. (It’s fast.)
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从技术上讲，`Crypto`创建的是由数学公式生成的伪随机数，就像`Math.random()`提供的那样。不同之处在于，这些数字被认为是*密码学强*的，因为随机数生成器的种子是用真正随机的值生成的。这种权衡的好处是`getRandomValues()`的性能类似于`Math.random()`。（它很快。）
- en: There’s no way to know how the `Crypto` object is seeded, because that’s up
    to the implementation (for web page code, that means the browser manufacturer),
    which in turn relies on functionality in the operating system. Usually, the seed
    is created using a combination of recently recorded details about keyboard timings,
    mouse movements, and hardware readings.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于`Crypto`对象的种子是由实现（对于网页代码来说，这意味着浏览器制造商）决定的，因此无法知道它是如何生成的，而这又依赖于操作系统的功能。通常情况下，种子是通过键盘定时、鼠标移动和硬件读数的最近记录细节的组合来创建的。
- en: No matter how good your random numbers are, if your JavaScript code is running
    in a browser, it’s exposed to a great number of attacks. After all, there’s nothing
    to stop a malicious party from seeing your code and creating an altered copy that
    bypasses all random number generation. If your code is running on a server, the
    situation is different.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论您的随机数有多好，如果您的JavaScript代码在浏览器中运行，它都会受到大量攻击的威胁。毕竟，没有什么可以阻止恶意方看到您的代码并创建一个绕过所有随机数生成的修改副本。如果您的代码在服务器上运行，情况就不同了。
- en: 'Now let’s look closer at how `getRandomValues()` works. Before you call `getRandomValues()`,
    you must create a *typed array*, which is an array-like object that can only hold
    values of a specific data type. (We say *array-like* because it behaves like an
    array, but it isn’t an instance of the official `Array` type.) JavaScript provides
    several strongly typed array objects you can use: like `Uint32Array` (for an array
    of unsigned 32-bit integers), `Uint16Array`, `Uint8Array`, and the signed counterparts
    `Int32Array`, `Int16Array`, and `Int8Array`. You create this array to be as big
    as you want, and `getRandomValues()` will fill the whole buffer.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更仔细地看一下`getRandomValues()`的工作原理。在调用`getRandomValues()`之前，您必须创建一个*类型化数组*，它是一个类似数组的对象，只能保存特定数据类型的值。（我们说它是*类数组*，因为它的行为像数组，但它不是`Array`类型的实例。）JavaScript提供了几种强类型化的数组对象供您使用，比如`Uint32Array`（用于存储无符号32位整数的数组），`Uint16Array`，`Uint8Array`，以及有符号的对应物`Int32Array`，`Int16Array`，`Int8Array`。您可以根据需要创建这个数组的大小，`getRandomValues()`将填充整个缓冲区。
- en: 'In this recipe, we make room for just one value in the `Uint32Array`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们只为`Uint32Array`中的一个值留出空间：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The final step is to divide this random value by the maximum possible unsigned
    32-bit integer, which is 4,294,967,295\. This number is cleaner in its hexadecimal
    representation, `0xffffffff`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将这个随机值除以可能的最大无符号32位整数，即4,294,967,295。这个数字在其十六进制表示中更为整洁，为`0xffffffff`：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As this code shows, you also need to add 1 to the maximum value. That’s because
    the random value could theoretically land exactly on the maximum integer value.
    If it did, the `randomFraction` would become 1, which differs from `Math.random()`
    and most other random number generators. (And a tiny unexpected variation from
    the norm is something that can lead to a incorrect assumption, and then a bug
    further down the road.)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这段代码所示，您还需要将最大值加1。这是因为随机值理论上可能恰好落在最大整数值上。如果确实如此，`randomFraction`将变为1，这与`Math.random()`和大多数其他随机数生成器不同。（微小的与规范不符的变化可能导致错误的假设，进而导致后续错误。）
- en: Rounding to a Specific Decimal Place
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数字四舍五入到特定小数位
- en: Problem
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to round a number to a certain precision (for example, 124.793 to 124.80
    or 120).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要将数字四舍五入到特定精度（例如，将124.793四舍五入到124.80或120）。
- en: Solution
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'You can use the `Math.round()` method to round a number to the nearest whole
    number:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`Math.round()`方法将数字四舍五入到最接近的整数：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Oddly enough, the `round()` method doesn’t take an argument that lets you specify
    a number of decimal places to keep. If you want a different degree of precision,
    it’s up to you to multiply your number by the appropriate power of 10, round it,
    and then divide it by the same power of 10 after rounding. Here’s the general
    formula for this operation:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 奇怪的是，`round()`方法没有接受可以指定保留小数位数的参数。如果您想要不同精度的结果，您需要自行将数值乘以适当的10的幂，四舍五入后再除以相同的10的幂。以下是此操作的一般公式：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For example, if you want to round to two decimal places, the code becomes this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您想要将数字四舍五入到两位小数，代码如下：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you want to round *left* of decimal place (for example, to the nearest tens,
    hundreds, and so on), just use a negative number for `numberOfDecimalPlaces`.
    For example, –1 rounds to the nearest 10, –2 rounds to the nearest 100, and so
    on.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要将小数点左边的数字四舍五入（例如，四舍五入到最接近的十位、百位等），只需对`numberOfDecimalPlaces`使用负数即可。例如，-1四舍五入到最接近的十位，-2四舍五入到最接近的百位，依此类推。
- en: Discussion
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The `Math` object has several static methods for turning fractional values into
    integers. The `floor()` method removes all decimal digits, rounding a number down
    to the nearest whole number. The `ceil()` method does the reverse, and always
    rounds a fractional number up to the next whole number. The `round()` method rounds
    to the closest whole number.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math`对象有几个静态方法，用于将分数值转换为整数。`floor()`方法删除所有小数位，将一个数向下舍入到最接近的整数。`ceil()`方法则相反，总是将分数数值向上舍入到最接近的整数。`round()`方法将数值四舍五入到最接近的整数。'
- en: 'There are two important points you need to know about how `round()` works:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`round()`如何工作，有两点重要的内容您需要知道：
- en: An exact value of 0.5 is always rounded up, even though it is equally distant
    from both the next lower and next higher integer. In finance and science, different
    rounding techniques are often used to remove this bias (such as rounding some
    0.5 values up and others down). But if you want that behavior in JavaScript, you
    need to implement it yourself or use a third-party library.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精确值0.5始终四舍五入为最接近的整数，即使它与下一个较低和较高整数的距离相等。在金融和科学中，通常使用不同的舍入技术来消除这种偏差（例如将某些0.5值向上舍入，将其他值向下舍入）。但是，如果你希望JavaScript中有这种行为，你需要自己实现或使用第三方库。
- en: When rounding negative numbers, JavaScript rounds –0.5 up *toward zero*. That
    means that –4.5 is rounded to –4, which is different than the rounding implementation
    in many other programming languages.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在对负数进行舍入时，JavaScript会将–0.5向零*舍入*。这意味着–4.5会被舍入为–4，这与许多其他编程语言的舍入实现不同。
- en: See Also
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Rounding numbers is one way to get a numeric value closer to an appropriate
    display format. If you’re using rounding to prepare a number to show to a user,
    you may also be interested in the `Number` formatting methods described in [“Converting
    a Numeric Value to a Formatted String”](ch02.html#converting_number_to_string).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 舍入数字是将数值接近适当显示格式的一种方法。如果你正在使用舍入准备向用户显示的数字，你可能也对在[“将数值转换为格式化字符串”](ch02.html#converting_number_to_string)中描述的`Number`格式化方法感兴趣。
- en: Preserving Accuracy in Decimal Values
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在十进制值中保持精度
- en: Problem
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: All numbers in JavaScript are floating point values, which suffer minute rounding
    errors with certain operations. In some applications (for example, when dealing
    with amounts of money), these errors may not be acceptable.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的所有数字都是浮点数值，某些操作可能会产生微小的四舍五入误差。在某些应用中（例如处理金额时），这些错误可能是不可接受的。
- en: Solution
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Floating point rounding errors are a well-understood phenomenon that exists
    in almost every programming language. To see it in JavaScript, run the following
    code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数的四舍五入误差是一个众所周知的现象，几乎存在于每一种编程语言中。要在JavaScript中看到它，请运行以下代码：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can’t avoid the rounding error, but you can minimize it. If you’re working
    with a currency type that has two decimal places of precision (like dollars),
    consider multiplying all values by 100 to avoid dealing with decimals. Instead
    of writing code like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你无法避免四舍五入误差，但可以将其最小化。如果你正在处理有两位小数精度的货币类型（如美元），考虑将所有值乘以100以避免处理小数。而不是编写如下代码：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Use currency variables like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样使用货币变量：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This solves the problem for operations that work out to exact whole numbers,
    like adding and subtracting numbers of cents. But what happens when you need to
    calculate tax or interest? In these situations you’ll end up with fractional values
    no matter what, and you need to do what businesses and banks do—round your values
    immediately after your transaction:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这解决了像加减几个分数值得到精确整数时的操作问题。但是，当你需要计算税款或利息时会发生什么？在这些情况下，无论如何都会得到分数值，并且在交易后立即对数值进行四舍五入，这就是企业和银行的做法：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Discussion
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The floating point rounding issue stems from the fact that some decimal values
    can’t be stored in binary representation without rounding. The same problem occurs
    with decimal numbering systems (for example, try to write the result of 1/3).
    The difference with floating point numbers is that the effect is *counterintuitive*.
    We don’t expect to have trouble adding 0.1 and 0.2, because in decimal notation
    both fractions can be represented exactly.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数的四舍五入问题源于某些十进制值无法在二进制表示中存储而不四舍五入的事实。与十进制数系统相同的问题（例如尝试写出1/3的结果）。浮点数的区别在于效果是*反直觉*的。我们不期望在加0.1和0.2时会有问题，因为在十进制表示法中这两个分数都可以被精确表示。
- en: Although other programming languages experience the same phenomenon, many of
    them include an alternate data type for decimal or currency values. JavaScript
    does not. However, there is a proposal for a [new Decimal type](https://github.com/tc39/proposal-decimal),
    which could be incorporated into a future version of the JavaScript language.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管其他编程语言也会经历同样的现象，但其中许多包含了专门的十进制或货币值数据类型。JavaScript则不包括。然而，有一个提案用于[新的十进制类型](https://github.com/tc39/proposal-decimal)，可能会被纳入未来版本的JavaScript语言中。
- en: See Also
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: If you perform a lot of financial calculations, you can simplify your life by
    using a third-party library like [*bignumber.js*](https://github.com/MikeMcl/bignumber.js),
    which provides a customized numeric data type that works a lot like the ordinary
    `Number`, but preserves exact precision for a fixed number of decimal places.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你进行大量的财务计算，可以通过使用像 [*bignumber.js*](https://github.com/MikeMcl/bignumber.js)
    这样的第三方库简化你的生活，它提供了一个定制的数值数据类型，几乎与普通的 `Number` 类似，但保留了固定数量小数位的精确精度。
- en: Converting a String to a Number
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将字符串转换为数字
- en: Problem
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to parse a number in a string and convert it to the number data type.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要解析字符串中的数字并将其转换为数字数据类型。
- en: Solution
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: It’s always safe to convert a number into a string, because that operation can’t
    fail. The reverse task—converting a string into a number, so you can use it in
    calculations—is a more delicate affair.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 将数字转换为字符串是安全的，因为这个操作不会失败。反向任务——将字符串转换为数字，以便在计算中使用——则需要更谨慎。
- en: 'The canonical approach is to use the `Number()` function:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Number()` 函数是最常见的方法：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `Number()` function won’t accept formatting like currency symbols and comma
    separators. It *will* allow extra spaces at the beginning and end of the string.
    The `Number()` function also converts empty strings or strings with only whitespace
    to the number 0\. This might be a reasonable default (for example, if you’re retrieving
    user input from a text box), but it’s not always appropriate. To avoid this case,
    consider testing for a whitespace-only string before you call `Number()`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`Number()` 函数不会接受带有货币符号和逗号分隔符的格式。它允许字符串开头和结尾的额外空格。`Number()` 函数还会将空字符串或仅包含空白字符的字符串转换为数字
    0。这可能是一个合理的默认值（例如，如果你从文本框中获取用户输入），但并非总是合适的。为了避免这种情况，在调用 `Number()` 之前，请考虑检测是否为仅包含空白字符的字符串：'
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If a conversion fails, the `Number()` function assigns the value `NaN` (for
    *not a number*) to your variable. You can test for this failure by calling the
    `Number.isNaN()` method immediately after you use `Number()`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果转换失败，`Number()` 函数会将值 `NaN`（即 *非数*）分配给你的变量。你可以在使用 `Number()` 后立即调用 `Number.isNaN()`
    方法来测试此失败情况：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-93
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `isFinite()` method is almost the same as `isNaN()`, except it avoids strange
    edge cases, like `1/0`, which returns a value of `infinity`. If you use the `isNaN()`
    method on `infinity`, it somewhat dubiously returns `false`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`isFinite()` 方法与 `isNaN()` 几乎相同，但避免了奇怪的边缘情况，例如 `1/0`，它返回一个值为 `infinity`。如果你在
    `infinity` 上使用 `isNaN()` 方法，它会返回 `false`，这有些难以置信。'
- en: An alternate approach is to use the `parseFloat()` method. It’s a slightly looser
    conversion that tolerates text after the number. However, `parseFloat()` is stricter
    with blank strings, which it refuses.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用 `parseFloat()` 方法。它是一种稍微宽松的转换，可以容忍数字后的文本。然而，`parseFloat()` 对空字符串更为严格，它会拒绝这种情况。
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Discussion
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Developers use some conversion tricks that are functionally equivalent to the
    `Number`() function, like multiplying a string by 1 (`numberInString*1`) or using
    the unary operator (`+numberInString`). But using `Number()` or `parseFloat()`
    is preferred for clarity.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者使用一些与 `Number()` 函数功能上等效的转换技巧，例如将字符串乘以 1 (`numberInString*1`) 或使用一元操作符 (`+numberInString`)。但为了清晰起见，推荐使用
    `Number()` 或 `parseFloat()`。
- en: If you have a formatted number (like *2,300*), you need to do more work to convert
    it. The `Number()` method will return `NaN`, and `parseFloat()` will stop at the
    comma and treat it as 2\. Unfortunately, although JavaScript has an `Intl.NumberFormat`
    object that can *create* formatted strings from numbers (see [“Converting a Numeric
    Value to a Formatted String”](ch02.html#converting_number_to_string)), it doesn’t
    provide parsing functionality for the reverse operation.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个格式化的数字（例如 *2,300*），你需要做更多工作来进行转换。`Number()` 方法会返回 `NaN`，而 `parseFloat()`
    会在逗号处停止，并将其视为 2。不幸的是，尽管 JavaScript 有一个 `Intl.NumberFormat` 对象，可以从数字创建格式化字符串（参见
    [“将数值转换为格式化字符串”](ch02.html#converting_number_to_string)），但它并未提供反向操作的解析功能。
- en: You can use regular expressions to take care of tasks like removing commas from
    a string (see [“Replacing All Occurrences of a String”](ch02.html#replacing_all_occurrences_string)).
    But a home brew solution can be risky, because some locales use commas to separate
    thousands, while others use them to separate decimals. In situations like these,
    a well-used, well-tested JavaScript library like [Numeral](http://numeraljs.com)
    is a better choice.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用正则表达式来处理诸如从字符串中删除逗号的任务（参见[“替换字符串的所有出现”](ch02.html#replacing_all_occurrences_string)）。但是自制解决方案可能存在风险，因为某些语言环境使用逗号分隔千位数，而其他语言环境使用逗号分隔小数。在这种情况下，像[Numeral](http://numeraljs.com)这样经过广泛使用和测试的JavaScript库更加合适。
- en: Converting a Decimal to a Hexadecimal Value
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将十进制数转换为十六进制值
- en: Problem
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You have a decimal value, and need to find its hexadecimal equivalent.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您有一个十进制值，需要找到其十六进制等效值。
- en: Solution
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方法
- en: 'Use the `Number.toString()` method, with an argument that specifies the base
    you are converting *to*:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Number.toString()`方法，使用指定转换为的基数参数*：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Discussion
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'By default, numbers in JavaScript are base 10, or decimal. However, they can
    also be converted to a different *radix*, including hexadecimal (16) and octal
    (8). Hexadecimal numbers begin with `0x` (a zero followed by lowercase x). Octal
    numbers used to begin with just a zero (0), but now should begin with a zero and
    then a Latin letter *O* (upper or lowercase):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，JavaScript中的数字是十进制的。但是，它们也可以转换为不同的*基数*，包括十六进制（16）和八进制（8）。十六进制数字以`0x`开头（零后跟小写x）。八进制数字过去以零（0）开头，但现在应该以零开始，然后是拉丁字母*O*（大写或小写）：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'A decimal number can be converted to another radix, in a range from 2 to 36:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 十进制数可以转换为2到36之间的其他基数：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: To complete the octal and hexadecimal presentation, you’ll need to concatenate
    the `0o` to the octal, and the `0x` to the hexadecimal value. But remember, once
    you’ve converted your number into a string, don’t expect to use it in any sort
    of numeric calculation, no matter how it’s formatted.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成八进制和十六进制的表示，您需要将`0o`连接到八进制，并将`0x`连接到十六进制值。但是请记住，一旦您将数字转换为字符串，无论其格式如何，都不要期望可以在任何数值计算中使用它。
- en: Although decimals can be converted to any base number (between a range of 2
    to 36), only the octal, hexadecimal, and decimal numbers can be manipulated directly
    as numbers.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管小数可以转换为任何基数（范围为2到36之间），但只有八进制、十六进制和十进制数字可以直接作为数字进行操作。
- en: Converting Between Degrees and Radians
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在度数和弧度之间进行转换
- en: Problem
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You have an angle in degrees. To use the value in the `Math` object’s trigonometric
    functions, you need to convert the degrees to radians.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您有一个以度数表示的角度。要在`Math`对象的三角函数中使用该值，您需要将度数转换为弧度。
- en: Solution
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方法
- en: 'To convert degrees to radians, multiply the degree value by `(Math.PI/180)`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要将度数转换为弧度，请将度数值乘以`(Math.PI/180)`：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'So if you have a 90 degree angle, the calculation becomes:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您有一个90度的角度，计算如下：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To convert radians to degrees, multiply the radians value by `(180/Math.PI)`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要将弧度转换为度数，请将弧度值乘以`(180/Math.PI)`：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Discussion
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: All the trigonometric methods of the `Math` object (`sin()`, `cos()`, `tan()`,
    `asin()`, `acos()`, `atan()`, and `atan2()`) take values in radians, and return
    radians as a result. Yet it’s not unusual for people to provide values in degrees
    rather than radians, as degrees are the more familiar unit of measure.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math`对象的所有三角函数方法（`sin()`、`cos()`、`tan()`、`asin()`、`acos()`、`atan()`和`atan2()`）接受弧度值，并返回弧度作为结果。然而，人们通常提供度数而不是弧度，因为度数是更熟悉的度量单位。'
- en: Calculating the Length of a Circular Arc
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算圆弧的长度
- en: Problem
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Given the radius of a circle, and the angle of an arc in degrees, find the length
    of the arc.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 给定圆的半径和弧度中的角度，找到弧的长度。
- en: Solution
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方法
- en: 'Use `Math.PI` to convert degrees to radians, and use the result in a formula
    to find the length of the arc:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Math.PI`将度数转换为弧度，并在公式中使用结果以找到弧的长度：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Discussion
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The length of a circular arc is found by multiplying the circle’s radius times
    the angle of the arc, in radians.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 圆弧的长度通过将圆的半径乘以弧度的弧度角来确定。
- en: If the angle is given in degrees, you’ll need to convert the degree to radians
    first, before multiplying the angle by the radius. This calculation is frequently
    used when drawing shapes in SVG, as covered in [Chapter 15](ch15.html#ch15).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果角度以度数给出，则在乘以半径之前，您需要先将度数转换为弧度。这种计算经常用于SVG中绘制形状，如[第15章](ch15.html#ch15)中所述。
- en: Manipulating Very Large Numbers with BigInt
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用BigInt处理非常大的数字
- en: Problem
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to work with very large integers (above 2^(53)), without losing precision.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要处理非常大的整数（超过 2^(53)），而不丢失精度。
- en: Solution
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `BigInt` data type, which can hold integers of any size, limited only
    by system memory (or the `BigInt` implementation of the JavaScript engine you’re
    using).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `BigInt` 数据类型，可以容纳任意大小的整数，仅受系统内存限制（或您使用的 JavaScript 引擎的 `BigInt` 实现）。
- en: 'You can create a `BigInt` in two ways. You use the `BigInt()` function, like
    this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过两种方式创建 `BigInt`。可以使用 `BigInt()` 函数，如下所示：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Or you can add the letter *n* to the end of a number:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 或者您可以在数字末尾添加字母 *n*：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This example shows the difference between an ordinary `Number` and the `BigInt`
    for very large values:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例显示了普通 `Number` 和 `BigInt` 在非常大数值上的差异：
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-146
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When you log a `BigInt` to the developer console, it appears with an *n* appended
    to its value (as in *9007199254740992n*). This convention makes it easy to recognize
    `BigInt` values. But if you just want the numeric value of your `BigInt`, you
    simply need to convert it to text first, with `BigInt.toString()`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当将 `BigInt` 记录到开发者控制台时，它的值会附加 *n*（例如 *9007199254740992n*）。此约定使得 `BigInt` 值易于识别。但如果只想要
    `BigInt` 的数值，只需首先将其转换为文本，使用 `BigInt.toString()`。
- en: Discussion
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: JavaScript’s native `Number` type conforms to the IEEE-754 specification for
    64-bit, double-precision floating-point numbers. The standard has acceptable,
    known limitations and inaccuracies. One practical limitation is that integers
    cannot be accurately represented past 2^(53). Beyond this point, inaccuracies
    in representation which had previously been confined to the right of the decimal
    place (see [“Preserving Accuracy in Decimal Values”](#preserving_decimal_accuracy))
    jump over to the left of the decimal place. Put another way, as the JavaScript
    engine counts higher, the chance for inaccuracy grows. Once we are past 2^(53),
    the inaccuracy is larger than 1 and shows up in calculations with integral numbers,
    not just decimal values.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的原生 `Number` 类型符合 IEEE-754 规范，为 64 位双精度浮点数。该标准具有可接受的已知限制和不准确性。一个实际的限制是，超过
    2^(53) 后无法精确表示整数。超过此点后，之前仅限于小数点右侧的表示不准确性会跳到小数点左侧。换句话说，随着 JavaScript 引擎计数增加，不准确性的可能性增加。一旦超过
    2^(53)，不准确性大于 1，并出现在整数计算中，而不仅仅是小数值计算中。
- en: JavaScript has a partial solution to this problem with the `BigInt` type, introduced
    as part of the ECMAScript 2020 specification. A `BigInt` is an arbitrarily sized
    integer that allows you to represent exceedingly large numbers. Practically speaking,
    there is no upper limit to the bit width of a `BigInt`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 在 ECMAScript 2020 规范中引入了 `BigInt` 类型，部分解决了这个问题。`BigInt` 是一种任意大小的整数，允许您表示极大的数字。实际上，`BigInt`
    的位宽没有上限。
- en: 'Almost all of the operators you are used to using with regular numbers can
    be used on a `BigInt`, including addition (`+`), subtraction (`-`), multiplication
    (`*`), division (`/`), and exponentiation (`**`). However, `BigInt` is an integer
    and does not store fractional values. When you perform a division operation, `BigInt`
    quietly discards the decimal portion:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有常规数字可用的运算符都可以用在 `BigInt` 上，包括加法（`+`）、减法（`-`）、乘法（`*`）、除法（`/`）和指数运算（`**`）。但是，`BigInt`
    是整数类型，不存储小数值。执行除法操作时，`BigInt` 会静默丢弃小数部分：
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`BigInts` and `Numbers` are not interchangeable nor are they interoperable.
    But they can be converted to one another using the `Number()` and `BigInt()` functions:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`BigInt` 和 `Number` 不可互换，也无法互操作。但可以使用 `Number()` 和 `BigInt()` 函数相互转换：'
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You need to perform a conversion if you want to use a `BigInt` with a method
    that expects a `Number`, like the methods of the `Math` object. Similarly, you
    need to perform a conversion if you want to use a `Number` in a calculation with
    another `BigInt`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要使用期望 `Number` 的方法与 `BigInt` 一起使用，或者想要在与另一个 `BigInt` 进行计算时使用 `Number`，则需要进行转换。
- en: 'If you attempt to convert a `Number` that holds a fractional value into a `BigInt`,
    you’ll receive a `RangeError`. You can avoid this possibility by rounding first:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尝试将包含小数值的 `Number` 转换为 `BigInt`，将收到 `RangeError`。可以通过先四舍五入来避免此问题：
- en: '[PRE33]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Remember to keep operations consistent with the type. Sometimes what seems
    like a simple operation can fail because you accidentally combine a `BigInt` with
    an ordinary number:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 记得保持操作与类型一致。有时候看似简单的操作可能会失败，因为你意外地将`BigInt`与普通数字结合在一起：
- en: '[PRE34]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You can compare a `BigInt` value against a `Number` value using the standard
    comparison operators (`<`, `>`, `<=`, `>=`). If you want to test if a `BigInt`
    and a number are equal, use the loose equality operators (`==` and `!=`). Strict
    equality (`===`) will always return `false`, because `BigInt` and `Number` are
    different data types. Or, better yet, explicitly convert your `Number` to a `BigInt`
    and then compare it with `===`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标准比较运算符（`<`、`>`、`<=`、`>=`），可以将`BigInt`值与`Number`值进行比较。如果想要测试`BigInt`和数字是否相等，请使用宽松相等运算符（`==`和`!=`）。严格相等运算符（`===`）总是返回`false`，因为`BigInt`和`Number`是不同的数据类型。或者更好的方法是，将你的`Number`显式转换为`BigInt`，然后使用`===`进行比较。
- en: 'One last thing to consider with `BigInt`: it is not (at publishing time) serializable
    to JSON. Attempts to call `JSON.stringify()` on a `BigInt` yield a syntax error.
    You have several options to consider as a solution. You could monkey-patch your
    `BigInt` implementation with an appropriate `toJSON()` method:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`BigInt`还有一件事需要考虑：在发布时，它不能被序列化为JSON。尝试对`BigInt`调用`JSON.stringify()`会导致语法错误。你有几个解决方案可供考虑。你可以通过适当的`toJSON()`方法对你的`BigInt`实现进行修补：
- en: '[PRE35]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You could also use a library like [granola](https://github.com/kanongil/granola),
    which provides JSON-compatiable stringifiers for a number of values, including
    `BigInt`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用像[granola](https://github.com/kanongil/granola)这样的库，它提供了对多种值（包括`BigInt`）进行JSON兼容字符串化的方法。
