- en: Chapter 13\. Fetching Remote Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 13 章。获取远程数据
- en: The ability to receive and process data in the browser, without refreshing a
    page, is one of JavaScript’s super powers. Real-time data trackers, chat applications,
    social media feed updates, and much more, are all made possible through JavaScript’s
    ability to make a request to a server and update content on the page. In this
    chapter, we’ll cover how to make and process those requests.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中接收和处理数据的能力，无需刷新页面，是 JavaScript 的超级能力之一。实时数据跟踪器、聊天应用程序、社交媒体动态更新等，都是通过 JavaScript
    发出请求到服务器并更新页面内容来实现的。在本章中，我们将介绍如何发出和处理这些请求。
- en: Note
  id: totrans-2
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You may also hear the term “AJAX,” which is an abbreviation for Asynchronous
    JavaScript and XML. Although originally coined in reference to retrieving XML,
    AJAX has become a generalized term for retrieving and sending data to a remote
    server from a web browser.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能也会听到 “AJAX” 这个术语，它是 Asynchronous JavaScript and XML 的缩写。虽然最初是指检索 XML，但 AJAX
    已经成为从 Web 浏览器向远程服务器检索和发送数据的泛化术语。
- en: Requesting Remote Data with Fetch
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Fetch 请求远程数据
- en: Problem
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to request remote data from a server.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要从服务器请求远程数据。
- en: Solution
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use the Fetch API, which allows you to make requests and manipulate the response.
    To make a simple request, pass a URL as a `fetch` parameter, which returns the
    response as a promise. The following example requests the URL, parses the JSON
    response, and logs the response to the console:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Fetch API，允许您发出请求并处理响应。要发出简单请求，请将 URL 作为 `fetch` 参数传递，该方法将返回一个 promise。以下示例请求
    URL，解析 JSON 响应，并将响应记录到控制台：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Alternately, use the `async/await` syntax with `fetch`:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，使用 `fetch` 的 `async/await` 语法：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Discussion
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'The Fetch API provides a means for sending and retrieving data from a remote
    source. When working in a web browser environment, this means that data can be
    retrieved without refreshing the page. As a web user, you may experience these
    types of requests frequently. The Fetch API can be used to:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Fetch API 提供了从远程源发送和检索数据的方法。在 Web 浏览器环境中工作时，这意味着可以在不刷新页面的情况下检索数据。作为 Web 用户，您可能经常遇到这些类型的请求。Fetch
    API 可用于：
- en: Load additional items in a social media feed
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在社交媒体动态中加载额外的条目
- en: Form autocomplete suggestions
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单自动完成建议
- en: “Like” a social media post
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “喜欢” 一个社交媒体帖子
- en: Update form field values based on a previous response
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于先前响应更新表单字段值
- en: Submit a form without navigating away from the page
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不离开页面的情况下提交表单
- en: Add an item to a shopping cart
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将商品添加到购物车
- en: As you may imagine, the list can go on and on.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所想象的那样，列表可以无限延续。
- en: 'The `fetch()` method accepts two parameters:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetch()` 方法接受两个参数：'
- en: '`url` (mandatory)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`url`（必填）'
- en: The URL to which you are making a request
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正在进行请求的 URL
- en: '`options`'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`options`'
- en: An object of options when making the request
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 发出请求时的选项对象
- en: 'The possible `options` include:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的 `options` 包括：
- en: '`body`'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`body`'
- en: The body content of a request
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 请求的请求体内容
- en: '`cache`'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`cache`'
- en: The cache mode of the request (`default`, `no-store`, `reload`, `no-cache`,
    `force-cache`, or `only-if-cached`)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请求的缓存模式 (`default`、`no-store`、`reload`、`no-cache`、`force-cache` 或 `only-if-cached`)
- en: '`credentials`'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`credentials`'
- en: The request credentials of the request (`omit`, `same-origin`, or `include`)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 请求的凭证 (`omit`、`same-origin` 或 `include`)
- en: '`headers`'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`headers`'
- en: Headers included with the request
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 请求中包含的头部信息
- en: '`integrity`'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`integrity`'
- en: A subresource integrity value, used for verify resources
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 用于验证资源的子资源完整性值
- en: '`keepalive`'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`keepalive`'
- en: Set to `true` for the request to outlive the page
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 将其设置为 `true`，使请求在页面生存期内继续存在
- en: '`method`'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`method`'
- en: The request method (`GET`, `POST`, `PUT`, or `DELETE`)
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 请求方法 (`GET`、`POST`、`PUT` 或 `DELETE`)
- en: '`mode`'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`mode`'
- en: The mode of the request (`cors`, `no-cors`, or `same-origin`)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 请求的模式 (`cors`、`no-cors` 或 `same-origin`)
- en: '`redirect`'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`redirect`'
- en: Sets behavior for redirects (`follow`, `error`, or `manual`)
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 设置重定向的行为 (`follow`、`error` 或 `manual`)
- en: '`referrer`'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`referrer`'
- en: Sets the value of the referrer header (`about:client`, the current URL, or an
    empty string)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 设置引用者头部的值 (`about:client`、当前 URL 或空字符串)
- en: '`referrerPolicy`'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`referrerPolicy`'
- en: Specifies the referrer policy (`no-referrer`, `no-referrer-when-downgrade`,
    `same-origin`, `origin`, `strict-origin`, `origin-when-cross-origin`, `strict-origin-when-cross-origin`,
    or `unsafe-url`)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 指定引用者策略 (`no-referrer`、`no-referrer-when-downgrade`、`same-origin`、`origin`、`strict-origin`、`origin-when-cross-origin`、`strict-origin-when-cross-origin`
    或 `unsafe-url`)
- en: '`signal`'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`signal`'
- en: '`AbortController` object to abort request'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbortController` 对象用于中止请求'
- en: 'As shown in the previous example, only the `url` parameter is required. When
    passed only a URL, the `fetch` method will perform a `GET` request. The following
    example demonstrates how to use the options object:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，仅需 `url` 参数即可。当仅传递URL时，`fetch` 方法将执行 `GET` 请求。以下示例演示如何使用选项对象：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`fetch` makes use of JavaScript promises. The initial promise returns a `Response`
    object, which contains the full HTTP response, including the body, headers, status
    code, redirect information, cors type, and URL. With the response returned, you
    can then use an additional parsing method to parse the body of the request. In
    the example, I’m using the `json()` method to parse the body as JSON. Here are
    the possible parsing methods:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetch` 使用JavaScript promises。最初的 promise 返回一个 `Response` 对象，其中包含完整的HTTP响应，包括主体、头部、状态码、重定向信息、cors
    类型和URL。使用返回的响应，然后可以使用额外的解析方法来解析请求的主体。在示例中，我使用 `json()` 方法将响应体解析为 JSON。以下是可能的解析方法：'
- en: '`arrayBuffer()`'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`arrayBuffer()`'
- en: Parse the body as an `ArrayBuffer`
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 将响应体解析为 `ArrayBuffer`
- en: '`blob()`'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`blob()`'
- en: Parse the body as a `Blob`
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 将响应体解析为 `Blob`
- en: '`json()`'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`json()`'
- en: Parse the body as JSON
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 将响应体解析为 JSON
- en: '`text()`'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`text()`'
- en: Parse the body as a UTF-8 string
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 将响应体解析为 UTF-8 字符串
- en: '`formData()`'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`formData()`'
- en: Parse the body as a `FormData()` object
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 将响应体解析为 `FormData()` 对象
- en: 'When using `fetch`, you can handle errors based on the server’s status response.
    In `async/await`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `fetch` 时，可以根据服务器的状态响应处理错误。在 `async/await` 中：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For more robust error handling, you can wrap the entire `fetch` request in
    a `try/catch` block, which will allow you to handle any additional errors:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 若要进行更健壮的错误处理，可以将整个 `fetch` 请求包装在 `try/catch` 块中，以便处理任何其他错误：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Errors can be handled similarly when using the the JavaScript `then` promise
    syntax:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用JavaScript的 `then` promise 语法时，错误处理方式类似：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you’ve worked with AJAX requests in the past, you may have used the `XMLHttpRequest`
    (XHR) method (covered in [“Using XMLHttpRequest”](#xhr)). Due to its promise-based
    syntax, simpler syntax, and broad browser support, the Fetch API is now the recommended
    method for making these requests. `fetch` is supported in all modern browsers
    (Chrome, Edge, Firefox, Safari), however it is not supported in Internet Explorer.
    If your application needs to support older versions of Internet Explorer, you
    may choose to use XHR (`XMLHttpRequest`) or make use of a [fetch polyfill](https://github.com/github/fetch)
    alongside a [promise polyfill](https://github.com/taylorhakes/promise-polyfill).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以前使用过 AJAX 请求，可能已经使用过 `XMLHttpRequest`（XHR）方法（在 [“使用XMLHttpRequest”](#xhr)
    中介绍）。由于其基于promise的语法、简单的语法和广泛的浏览器支持，现在推荐使用Fetch API进行这些请求。`fetch` 在所有现代浏览器（Chrome、Edge、Firefox、Safari）中都受支持，但不支持Internet
    Explorer。如果您的应用程序需要支持较旧版本的Internet Explorer，可以选择使用XHR（`XMLHttpRequest`）或使用 [fetch
    polyfill](https://github.com/github/fetch) 和 [promise polyfill](https://github.com/taylorhakes/promise-polyfill)。
- en: Using XMLHttpRequest
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用XMLHttpRequest
- en: Problem
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Your application needs to request remote data while supporting older browsers.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序需要请求远程数据，同时支持较旧的浏览器。
- en: Solution
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use `XMLHttpRequest` (XHR) in place of `fetch`. The following is an XHR `GET`
    request, which mirrors the example demonstrated in [“Requesting Remote Data with
    Fetch”](#fetch):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `XMLHttpRequest`（XHR）来替代 `fetch`。以下是一个XHR `GET`请求示例，与 [“使用Fetch请求远程数据”](#fetch)
    的示例相似：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Discussion
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: '`XMLHttpRequest` is the original syntax for making remote data requests. Though
    XML is in the name, it can be used to request all sorts of data. In the previous
    example, I’m making a request for JSON data. So how does `XMLHttpRequest` differ
    from `fetch`?'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`XMLHttpRequest` 是发起远程数据请求的原始语法。尽管名称中含有XML，但它可以用于请求各种数据。在前面的示例中，我正在请求JSON数据。那么
    `XMLHttpRequest` 与 `fetch` 有何不同？'
- en: '`fetch` makes heavy use of JavaScript promises, while `XMLHttpRequest` is based
    around the `XMLHttpRequest()` constructor function.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetch` 大量使用JavaScript promises，而 `XMLHttpRequest` 则基于 `XMLHttpRequest()` 构造函数。'
- en: '`XMLHttpRequest` is supported in all browsers, including older versions of
    Internet Explorer. `fetch` will not work without a polyfill (which is based on
    `XMLHttpRequest`) in Internet Explorer 11 or older, as well as some versions of
    modern auto-updating browsers from 2017 or earlier.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XMLHttpRequest` 在所有浏览器中都受支持，包括较旧版本的Internet Explorer。在Internet Explorer 11或更早的某些版本以及2017年或更早的某些版本的现代自动更新浏览器中，`fetch`
    将无法正常工作，除非使用基于 `XMLHttpRequest` 的polyfill。'
- en: '`XMLHttpRequest` defaults to sending cookies to the server with each request,
    while `fetch` requires that the `credentials` option be explicitly set.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XMLHttpRequest` 默认将每个请求发送到服务器的cookie，而 `fetch` 要求明确设置 `credentials` 选项。'
- en: '`XMLHttpRequest` supports tracking upload progress, while, at the time of writing,
    `fetch` only supports download progress.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XMLHttpRequest` 支持跟踪上传进度，而 `fetch` 目前仅支持下载进度。'
- en: '`fetch` does not support timeouts, leaving the length of the request up to
    the user’s browser.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetch` 不支持超时，请求的长度由用户的浏览器决定。'
- en: Though the rest of this chapter will make use of the modern `fetch` syntax,
    `XMLHttpRequest` continues to be a reasonable choice due to its browser support
    and differentiating features, particularly when working with legacy applications.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本章的其余部分将使用现代的 `fetch` 语法，但由于其浏览器支持和不同的特性，`XMLHttpRequest` 仍然是一个合理的选择，特别是在处理传统应用程序时。
- en: Submitting a Form
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提交表单
- en: Problem
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to submit a form from the client.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望从客户端提交一个表单。
- en: Solution
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Make a `POST` request of a `FormData` object, using `fetch`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `fetch` 使一个 `FormData` 对象的 `POST` 请求：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Discussion
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: In the example code, I am selecting an HTML form element using `getElementById`
    and storing the URL to `POST` the form to as a variable. In this case, I am POSTing
    the form to a local development server, as shown in [Example 13-1](#form-server).
    I’ve then added an event listener to the form and prevented the default form submission
    behavior, so that I can instead perform a JavaScript `POST` request using `fetch`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例代码中，我使用 `getElementById` 选择一个HTML表单元素，并将 `POST` 表单的URL存储为一个变量。在这种情况下，我将表单POST到本地开发服务器，如示例
    [13-1](#form-server) 所示。然后我为表单添加了一个事件监听器，并阻止了默认的表单提交行为，以便我可以使用 `fetch` 执行JavaScript的
    `POST` 请求。
- en: 'The complete HTML Markup and JavaScript is as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的HTML标记和JavaScript如下所示：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'JavaScript’s `FormData` provides a means for easily creating key/value pairs
    of all the form data. This works with text-based form elements, as demonstrated
    in the example, as well as with file uploads. First, use the `FormData` constructor:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的 `FormData` 提供了一种简便的方式来创建所有表单数据的键/值对。这适用于基于文本的表单元素，如示例中所示，以及文件上传。首先，使用
    `FormData` 构造函数：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You may also manipulate the data contained in the `FormData` with some helpful
    methods:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用一些有用的方法来操作 `FormData` 中包含的数据：
- en: '`FormData.append(key, value)` or `FormData.append(key, blob, filename)`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormData.append(key, value)` 或 `FormData.append(key, blob, filename)`'
- en: Appends new data to the form
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 向表单添加新数据
- en: '`FormData.delete(key)`'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormData.delete(key)`'
- en: Deletes a field
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 删除一个字段
- en: '`FormData.set(key, value)`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormData.set(key, value)`'
- en: Appends new data, removing a duplicate key, if present
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新数据，如果存在重复键，则删除
- en: 'Here is how you would add an additional field to the previous example:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您如何向上一个示例中添加一个额外字段的方法：
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The body of the `POST` request will now be:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `POST` 请求的主体将是：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It is also possible to work with the form values, using the `get` and `has`
    methods:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用 `get` 和 `has` 方法处理表单值：
- en: '`FormData.get(key)`'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormData.get(key)`'
- en: Gets the value of a specific key
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 获取特定键的值
- en: '`FormData.has(key)`'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormData.has(key)`'
- en: Checks for a value with a given key and returns a Boolean
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 检查给定键的值并返回布尔值
- en: 'While `FormData` is incredibly useful, it is not the only value type of a `POST`
    body. The following types can be sent in a POST request:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `FormData` 非常有用，但它并不是 `POST` 请求体的唯一值类型。以下类型可以通过 `POST` 请求发送：
- en: A string
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个字符串
- en: An encoded string, such as JSON or XML
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个编码的字符串，例如JSON或XML
- en: A `URLSearchParams` object
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `URLSearchParams` 对象
- en: A `Blob` or `BufferSource` of binary data
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制数据的 `Blob` 或 `BufferSource`
- en: In [“Populating a Selection List from the Server”](#selection-list) I will demonstrate
    how to send a JSON `POST` request with `fetch`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [“从服务器填充选择列表”](#selection-list) 中，我将演示如何使用 `fetch` 发送JSON的 `POST` 请求。
- en: 'Finally, [Example 13-1](#form-server) is an example Node.js Express server
    that processes the request:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，[示例 13-1](#form-server) 是一个Node.js Express服务器的示例，用于处理请求：
- en: Example 13-1\. Express form server example
  id: totrans-120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 13-1\. Express表单服务器示例
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-122
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: We cover Express in detail in [Chapter 21](ch21.html#ch21).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [第21章](ch21.html#ch21) 中详细介绍了Express。
- en: Populating a Selection List from the Server
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从服务器填充选择列表
- en: Problem
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Based on a user’s actions with another form element, you want to populate a
    selection list with values.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 基于用户对另一个表单元素的操作，您希望用值填充一个选择列表。
- en: Solution
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Capture the `change` event for the form element:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获表单元素的 `change` 事件：
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the event handler function, make a `fetch` request as a `POST` with the
    form data as JSON:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件处理函数中，以 JSON 格式作为表单数据进行 `POST` 请求：
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Populate the selection list with the result:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 用结果填充选择列表：
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Discussion
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Populating a `select` or other form element based on a choice made by the user
    is a common user interface interaction. Instead of populating a `select` element
    with many options, or building a set of 10 or 20 radio buttons, you can capture
    the user’s choice in another form element, query a server application based on
    the value, and build the other form elements based on the value—all without leaving
    the page.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 基于用户的选择填充 `select` 或其他表单元素是常见的用户界面交互。您可以捕获用户在另一个表单元素中的选择，根据该值查询服务器应用程序，并基于该值构建其他表单元素，而无需离开页面，而不是填充带有许多选项的
    `select` 元素，或者构建一组 10 或 20 个单选按钮。
- en: '[Example 13-2](#creating_an_on-demand_select) demonstrates a simple page that
    captures the change event for a select element, makes a fetch request with the
    value of the selected value, and populates a new selection list by parsing the
    returned data. In the example, the data is returned as an array, and new options
    are created with the returned text having both an option label and option value.
    Before populating the `select` element, its length is set to 0\. This is a quick
    and easy way to truncate the `select` element—removing all existing options and
    starting fresh.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13-2](#creating_an_on-demand_select) 展示了一个简单的页面，捕获了选择元素的变化事件，使用所选值进行 fetch
    请求，并通过解析返回的数据来填充新的选择列表。在示例中，数据作为数组返回，并且新选项的创建使用返回的文本，文本同时作为选项标签和选项值。在填充 `select`
    元素之前，将其长度设置为 0\. 这是截断 `select` 元素的快速简便方法——删除所有现有选项并重新开始。'
- en: Example 13-2\. Creating an on-demand `select` list
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 13-2\. 创建按需 `select` 列表
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The example uses a Node application to populate the selection list, but could
    be written in any server-side programming language. Node is covered in detail
    in [Part III](part03.html#part3).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例使用 Node 应用程序来填充选择列表，但可以使用任何服务器端编程语言编写。有关详细信息，请参阅[第 III 部分](part03.html#part3)中的
    Node 章节。
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Progressively building form elements isn’t necessary in all applications, but
    it is a great way to ensure a more effective form in cases where the data can
    change, or the form is complex.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 逐步构建表单元素并非所有应用都必要，但对于数据可能变化或表单复杂的情况下，这是确保更有效的表单的一个很好的方法。
- en: Parsing Returned JSON
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析返回的 JSON
- en: Problem
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to safely create a JavaScript object from JSON. You also want to replace
    the numeric representation of true and false (1 and 0, respectively) with their
    Boolean counterparts (`true` and `false`).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望安全地从 JSON 创建 JavaScript 对象。您还希望将 true 和 false 的数值表示（分别为 1 和 0）替换为它们的布尔对应值（`true`
    和 `false`）。
- en: Solution
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Parse the object with the `JSON.parse` capability. To transform the numeric
    values to their Boolean counterparts, create a *reviver* function:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `JSON.parse` 功能解析对象。要将数值转换为布尔对应值，创建一个*复苏*函数：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Discussion
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: To figure out how to create JSON, think about how you create an object literal
    and just translate it into a string (with some caveats).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要想知道如何创建 JSON，请考虑如何创建对象字面量，并将其转换为字符串（有一些注意事项）。
- en: 'If the object is an array:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象是一个数组：
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'the JSON notation would be equivalent to the literal notation for the array:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 表示法等同于数组的字面表示法：
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note the use of double quotes (`""`) rather than single, which are not allowed
    in JSON.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用双引号 (`""`) 而不是单引号，因为 JSON 不允许使用单引号。
- en: 'If you’re working with an object:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在处理一个对象：
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'the JSON notation would be:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 表示法为：
- en: '[PRE22]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice in JSON how the property names are in quotes, but the values are only
    quoted when they’re strings. In addition, if the object contains other objects,
    such as an array, it’s also transformed into its JSON equivalent. However, the
    object *cannot* contain methods. If it does, an error is thrown. JSON works with
    data only.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在 JSON 中，属性名用引号括起来，但只有当值是字符串时才用引号括起来。此外，如果对象包含其他对象（如数组），它也会被转换为其 JSON 等效形式。然而，对象*不能*包含方法。如果有方法，则会抛出错误。JSON
    只能处理数据。
- en: 'The JSON static object isn’t complex, as it only provides two methods: `stringify()`
    and `parse()`. The `parse()` method takes two arguments: a JSON-formatted string
    and an optional `reviver` function. This function takes a key/value pair as parameters,
    and returns either the original value or a modified result.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 静态对象并不复杂，因为它只提供两个方法：`stringify()` 和 `parse()`。`parse()` 方法接受两个参数：一个 JSON
    格式的字符串和一个可选的 `reviver` 函数。该函数以键/值对作为参数，并返回原始值或修改后的结果。
- en: 'In the solution, the JSON-formatted string is an object with three properties:
    a string, a numeric, and a third property, which has a numeric value but is really
    a Boolean with a numeric representation—0 is false, 1 is true.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案中，JSON格式的字符串是一个包含三个属性的对象：一个字符串，一个数值，以及第三个属性，其数值为布尔型表示—0为假，1为真。
- en: To transform all 0, 1 values into `false`, `true`, a function is provided as
    the second argument to `JSON.parse()`. It checks each property of the object to
    see if it is a numeric. If it is, the function checks to see if the value is 0
    or 1\. If the value is 0, the return value is set to `false`; if 1, the return
    value is set to `true`; otherwise, the original value is returned.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将所有的0和1值转换为`false`和`true`，第二个参数作为`JSON.parse()`的函数提供。它检查对象的每个属性，看它是否为数值。如果是，函数再检查值是否为0或1。如果值为0，则返回值设为`false`；如果为1，则返回值设为`true`；否则，返回原始值。
- en: The ability to transform incoming JSON-formatted data is essential, especially
    if you’re processing the result of an AJAX request or JSONP response. You can’t
    always control the structure of the data you get from a service.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 能够转换传入的JSON格式数据非常重要，特别是在处理AJAX请求或JSONP响应结果时。您并不总能控制从服务获取的数据结构。
- en: Note
  id: totrans-164
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'There are restrictions on the JSON: strings must be double quoted, and there
    are no hexadecimal values and no tabs in strings.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: JSON有一些限制：字符串必须用双引号括起来，不能包含十六进制值，也不能在字符串中包含制表符。
- en: Fetching and Parsing XML
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取和解析XML
- en: Problem
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to retrieve a remote XML file and parse its contents.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要获取远程XML文件并解析其内容。
- en: Solution
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `fetch` along with the `DomParser` API, which provides the ability to parse
    XML from a string.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`fetch`以及提供从字符串解析XML的`DomParser`API的能力。
- en: 'First, you will need to use `fetch` to request the XML file. In this example
    I’m requesting the XML feed of the *New York Times*'' home page:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要使用`fetch`请求XML文件。在此示例中，我请求的是*纽约时报*主页的XML源：
- en: '[PRE23]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, use `DOMParser` to parse the returned XML string, and then use the DOM
    methods to query the document for data:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用`DOMParser`解析返回的XML字符串，然后使用DOM方法查询文档中的数据：
- en: '[PRE24]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Discussion
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: When using `fetch` to retrieve XML, the document is returned as plain text.
    You can then use the `DOMParser` API to enable DOM methods to query the document
    and process the results.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`fetch`获取XML时，文档作为纯文本返回。然后您可以使用`DOMParser`API启用DOM方法来查询文档并处理结果。
- en: '`DOMParser` enables you to interact with the XML content using DOM querying
    methods such as `getElementsByTagName`. `DOMParser` requires two arguments. The
    first argument is the string to be parsed. The second argument is a `mimeType`,
    which specifies the document type. The `mimeType` options are:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`DOMParser`使您能够使用像`getElementsByTagName`这样的DOM查询方法与XML内容交互。`DOMParser`需要两个参数。第一个参数是要解析的字符串。第二个参数是`mimeType`，指定文档类型。`mimeType`的选项包括：'
- en: '`text/html`'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text/html`'
- en: '`text/xml`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text/xml`'
- en: '`application/xml`'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`application/xml`'
- en: '`applicatiom/xhtml+html`'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`applicatiom/xhtml+html`'
- en: '`image/svg+xml`'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image/svg+xml`'
- en: 'The following example extends the XML parser to use DOM query selectors to
    output the names of the latest articles to a web page:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的例子扩展了XML解析器以使用DOM查询选择器将最新文章的名称输出到网页：
- en: '[PRE25]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Sending Binary Data and Loading into an Image
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送二进制数据并加载为图像
- en: Problem
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to request a server-side image as binary data.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要作为二进制数据请求服务器端的图像。
- en: Solution
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Getting binary data via a `fetch` request is a matter of setting the response
    type to *`blob`* and then manipulating the data when returned. In the solution,
    the data is then converted and loaded into an `img` element:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`fetch`请求获取二进制数据只需将响应类型设置为*`blob`*，然后在返回时操作数据。在解决方案中，数据随后被转换并加载到`img`元素中：
- en: '[PRE26]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Discussion
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'A benefit of the CORS specification is support for binary data (also known
    as *typed arrays*) in fetch requests. The key requirement to a binary request
    is to set the response type to one of the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: CORS规范的一个好处是支持fetch请求中的二进制数据（也称为*类型化数组*）。二进制请求的关键要求是将响应类型设置为以下之一：
- en: '`arraybuffer`'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`arraybuffer`'
- en: Fixed-length raw binary data buffer
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 固定长度的原始二进制数据缓冲区
- en: '`blob`'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`blob`'
- en: File-like immutable raw data
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 类似文件的不可变原始数据
- en: In the solution, I used the `URL.createObjectURL()` method to convert the `blob`
    to a DOMString (generally mapped to JavaScript String) with the URL of the passed
    object. The URL is assigned to the `img` element’s `src` property.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案中，我使用了`URL.createObjectURL()`方法将`blob`转换为DOMString（通常映射为JavaScript字符串），并将该URL赋给`img`元素的`src`属性。
- en: Of course, it would be just as simple to assign the URL of the PNG file to the
    `src` attribute in the first place. However, the ability to manipulate binary
    data is a necessity with various technologies, such as Web Workers and WebGL.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在首次为`src`属性分配PNG文件的URL时也很简单。但是，使用诸如Web Workers和WebGL等各种技术必须能够操作二进制数据。
- en: Sharing HTTP Cookies Across Domains
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在不同域之间共享HTTP Cookies
- en: Problem
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to access a resource from another domain as a *credentialed* request,
    including HTTP cookies and any authentication information.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望作为*带凭证*请求从另一个域访问资源，包括HTTP cookies和任何身份验证信息。
- en: Solution
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Changes have to be made in both the client and the server applications to support
    credentialed requests. In the following example, the client application is served
    at *somedomain.com* while the server is at *api.example.com*. Because these are
    different domains, by default credentialed requests would not be shared from the
    client to the server.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 必须在客户端和服务器应用程序中进行更改以支持带凭证的请求。在以下示例中，客户端应用程序位于*somedomain.com*，而服务器位于*api.example.com*。由于这些是不同的域，默认情况下客户端到服务器的带凭证请求将不会共享。
- en: 'In the client, we have to test the `credentials` property on the `fetch` request:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，必须测试`fetch`请求上的`credentials`属性：
- en: '[PRE27]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the server, the `Access-Control-Allow-Controls` header value must be set
    to `true`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器中，`Access-Control-Allow-Controls`头的值必须设置为`true`：
- en: '[PRE28]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note
  id: totrans-208
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When using Express, I recommend using the [CORS middleware](https://oreil.ly/vNPPC).
    We cover Express in detail in [Chapter 21](ch21.html#ch21).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Express 时，我建议使用[CORS中间件](https://oreil.ly/vNPPC)。我们在[第21章](ch21.html#ch21)中详细讨论了
    Express。
- en: Discussion
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Sharing information across domains is referred to as Cross-Origin Resource Sharing
    or CORS. For security reasons, browsers restrict information shared across domains,
    such as cookies and credential headers. Being able to send HTTP cookies or send
    authentication headers across domains is possible by configuring CORS extension,
    as long as both the client and the server signal agreement.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 跨域资源共享（Cross-Origin Resource Sharing，CORS）是指在不同域之间共享信息，如cookies和凭据头信息，由于安全原因，浏览器对跨域共享信息进行限制。通过配置CORS扩展，可以在不同域之间发送HTTP
    cookies或身份验证头信息，只要客户端和服务器都信号同意。
- en: 'If using `XMLHttpRequest` on the client in place of `fetch`, set the `withCredentials`
    property:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在客户端使用`XMLHttpRequest`替代`fetch`，请设置`withCredentials`属性：
- en: '[PRE29]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Using Websockets to Establish a Two-Way Communication Between Client and Server
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Websockets建立客户端和服务器之间的双向通信
- en: Problem
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to initiate two-way, real-time communication between a server and web
    page client.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望在服务器和网页客户端之间建立双向实时通信。
- en: Solution
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: WebSockets allows you to support bidirectional communication between the client
    and server. The client creates a new WebSockets object, passing in the URI for
    the WebSockets server. Notice that the `ws:` protocol is used in place of `http`
    or `https`. When the client gets a message, it converts the message text to an
    object, retrieves the number counter, increments it, and then uses it in the object’s
    string member.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: WebSockets允许您支持客户端和服务器之间的双向通信。客户端创建一个新的WebSockets对象，传入WebSockets服务器的URI。请注意，使用`ws:`协议代替`http`或`https`。当客户端收到消息时，它将消息文本转换为对象，检索计数器，增加它，然后在对象的字符串成员中使用它。
- en: 'In the following example, the client print outs every other number, starting
    with 2\. State is maintained between the client and server by passing the string
    to be printed out within the message:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，客户端打印出每隔一个数字，从2开始。通过在消息中传递要打印的字符串，客户端和服务器之间保持状态：
- en: '[PRE30]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'For the server, I’m using the `ws` Node module. Once the server is created,
    it starts the communication with the client by sending through a JavaScript object
    with two members: a number counter and a string. The object must first be converted
    to string. The code listens for both an incoming message and a `close` event.
    When it gets an incoming message, it increments the counter and sends the object:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对于服务器，我正在使用`ws` Node模块。一旦创建服务器，它通过发送具有两个成员的JavaScript对象与客户端开始通信：数字计数器和字符串。必须首先将对象转换为字符串。代码监听传入消息和`close`事件。当接收到传入消息时，它增加计数器并发送对象：
- en: '[PRE31]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Discussion
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Bidirectional communication, also known as *full-duplex* communication, is two-way
    communication that can occur at the same time. Think of it as a two-way road,
    with traffic going both ways. All modern browsers support the WebSockets specification,
    and as you can see, it’s extremely easy to use.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 双向通信，也称为*全双工*通信，是可以同时进行的双向通信。将其视为一条双向道路，交通双向流动。所有现代浏览器都支持WebSockets规范，正如您所看到的，它非常容易使用。
- en: The advantage to WebSockets, other than being unbelievably easy to work with
    in browsers, is its ability to traverse both proxies and firewalls, something
    that isn’t trivial or even possible with other bidirectional communication techniques,
    such as long polling. And to ensure that applications are secure, user agents
    such as Chrome and Firefox prohibit mixed content (i.e., using both HTTP and HTTPS).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: WebSockets的优势不仅仅在于在浏览器中使用非常简单，而且它能够穿越代理和防火墙，这是其他双向通信技术（如长轮询）无法轻松实现甚至不可能的。为了确保应用程序的安全性，诸如Chrome和Firefox之类的用户代理禁止混合内容（即同时使用HTTP和HTTPS）。
- en: WebSockets supports binary data, as well as text. And as the examples demonstrated,
    you can transmit JSON by calling `JSON.stringify()` on the object before sending,
    and `JSON.parse()` on the string in the receiving end.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: WebSockets支持二进制数据以及文本。正如示例所示，可以通过在发送之前调用`JSON.stringify()`将JSON对象传输，并在接收端对字符串调用`JSON.parse()`。
- en: See Also
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: See the website for more information on [WebSockets](https://www.websocket.org).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 参见有关[WebSockets](https://www.websocket.org)的更多信息。
- en: Long Polling a Remote Data Source
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 长轮询远程数据源
- en: Problem
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You would like to keep a connection open with a server so that the client is
    immediately updated with new information, but the server does not use WebSockets.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望与服务器保持连接，以便客户端能够立即更新新信息，但服务器不使用WebSockets。
- en: Solution
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use long polling, a technique where the client maintains a connection to the
    server by using an asynchronous `fetch` function that calls itself after a response.
    At its most basic, client-side long polling looks like this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 使用长轮询，这是一种技术，客户端通过使用异步的`fetch`函数来维持与服务器的连接，并在响应后再次调用自身。在其最基本的形式下，客户端端的长轮询看起来像这样：
- en: '[PRE32]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This can be improved by adding some error handling, which when an error is
    received will wait a specified amount of time and then attempt to poll the server:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加一些错误处理，当接收到错误时将等待一定的时间，然后尝试轮询服务器可以改善这一情况：
- en: '[PRE33]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Discussion
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Long polling a server involves making a request and maintaining a connection
    to that server until a response is sent. Once the client receives the response,
    it immediately reconnects to the server and waits for a new response. The process
    can be broken down in this way:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 长轮询服务器涉及向服务器发出请求并保持连接，直到响应被发送。一旦客户端收到响应，它立即重新连接到服务器并等待新的响应。这个过程可以分解如下：
- en: Client sends request to the server.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端向服务器发送请求。
- en: Client stays connected to server while it waits for a response.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端保持与服务器的连接，同时等待响应。
- en: Server sends a response to the client.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器将响应发送给客户端。
- en: Client reconnects to the server and the process repeats itself.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端重新连接到服务器，进程重复。
- en: I find that a chat program is a helpful way to think about long polling. Imagine
    a chat program where we have two users who are chatting with each other, Riley
    and Harlow. Each of them is connected to a the server. When Riley sends a message,
    the server sends a response to Harlow’s browser, which immediately reconnects
    and waits for the next message.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现一个聊天程序是思考长轮询的一个有帮助的方式。想象一个聊天程序，其中有两个用户在彼此聊天，Riley和Harlow。他们每个人都连接到服务器。当Riley发送消息时，服务器将向Harlow的浏览器发送响应，后者立即重新连接并等待下一条消息。
- en: The limitation of long polling is in the number of open connections that the
    server can maintain. Node was designed to handle many concurrent connections,
    while some languages have limitations. All languages are limited by the hardware
    of the server itself. Though long polling is a simple and effective method maintaining
    a connection, WebSockets (as covered in [“Using Websockets to Establish a Two-Way
    Communication Between Client and Server”](#establishing_two_way_communication))
    is a more efficient means of two-way communication between the client and server.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 长轮询的局限性在于服务器能维持的开放连接数量。Node 被设计用来处理许多并发连接，而某些语言有其限制。所有语言都受限于服务器硬件本身。尽管长轮询是一种简单且有效地维持连接的方法，WebSockets（如
    [“使用 Websockets 建立客户端和服务器之间的双向通信”](#establishing_two_way_communication) 中所述）是客户端和服务器之间更高效的双向通信手段。
