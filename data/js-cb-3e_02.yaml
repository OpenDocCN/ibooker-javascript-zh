- en: Chapter 1\. Setting Up a Development Environment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章。设置开发环境
- en: You may have heard it said that the “tools make the developer.” While that’s
    something of an exaggeration, no one wants to be left in front of a wall of JavaScript
    code without their favorite tools to edit, analyze, and debug it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能听说过“工具决定开发者”的说法。虽然这有些夸张，但没有人愿意在一堆JavaScript代码面前没有他们喜欢的工具来编辑、分析和调试它。
- en: When you’re setting up your own development environment, the first tool you’ll
    consider is a code editor. Even the most basic editor adds essentials like autocompletion
    and syntax highlighting—two simple features that prevent piles of potential mistakes.
    Modern code editors add many more features, such as integration with a source
    control service like GitHub, line-by-line debugging, and smart refactoring. Sometimes
    these features will snap into your editor with a plug-in. Sometimes you’ll run
    them from the terminal or as part of a build process. But no matter how you use
    your tools, assembling the right combination to suit your coding style, development
    environment, and project types is part of the fun. It’s like a home improvement
    pro collecting tools, or an aspiring chef investing in just the right cooking
    gear.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置自己的开发环境时，你将首先考虑的工具是代码编辑器。即使是最基本的编辑器也会添加诸如自动完成和语法高亮这样的基本功能，这两个简单的功能可以避免许多潜在的错误。现代代码编辑器还添加了许多其他功能，比如与GitHub等源代码控制服务的集成、逐行调试和智能重构。有时这些功能会通过插件直接嵌入到你的编辑器中。有时你会从终端或作为构建过程的一部分来运行它们。但无论你如何使用你的工具，组装合适的组合来适应你的编码风格、开发环境和项目类型是其中的一部分乐趣。这就像家庭装修专家收集工具，或者有抱负的厨师投资于刚刚合适的烹饪器具。
- en: Tool choices aren’t static. As a developer, your preferences may shift. You’ll
    grow your kit as you evolve and as new tools prove themselves useful. This chapter
    explores the minimum toolset that every JavaScript developer should consider before
    they tackle a project. But there’s plenty of room to choose between different,
    broadly equivalent options. And, as many a wise person has remarked, there’s no
    accounting for taste!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 工具选择并非静态的。作为开发者，你的偏好可能会变化。随着你的成长和新工具证明其有用性，你将扩展你的工具包。本章探讨了每个JavaScript开发者在着手项目之前应考虑的最低工具集。但在不同广义等效选项之间有很大的选择空间。正如许多聪明人所说，品味无法计量！
- en: Note
  id: totrans-4
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In this chapter, we’re putting on our advocacy hat. You’ll see some of our favorite
    tools, and references to other, equally good options. But we don’t attempt to
    cover *every* tool, just some excellent default choices you can start with.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将戴上宣传帽子。你将看到我们喜欢的一些工具，以及其他同样优秀的选择。但我们并不试图覆盖*每一款*工具，只是一些你可以从头开始的优秀默认选择。
- en: Choosing a Code Editor
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择代码编辑器
- en: Problem
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to write code in an editor that understands JavaScript syntax.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要在一个理解JavaScript语法的编辑器中编写代码。
- en: Solution
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: If you’re in a hurry, you won’t go wrong with our favorite choice, Visual Studio
    Code (often shortened to just *VS Code*). You can download this free, open source
    editor for Windows, Macintosh, or Linux.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你赶时间，我们的首选Visual Studio Code（通常简称为*VS Code*）是一个不会错的选择。你可以在Windows、Macintosh或Linux上下载这个免费的开源编辑器。
- en: If you have time to research, there are a number of other editors you might
    consider. The list in [Table 1-1](#code_editors) is far from complete, but shows
    some of the most consistently popular editors.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有时间研究，还有许多其他编辑器可以考虑。表1-1中的列表远非完整，但显示了一些最受欢迎的编辑器。
- en: Table 1-1\. Desktop code editors
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 表1-1。桌面代码编辑器
- en: '| Editor | Supported platforms | Open source | Cost | Notes |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 编辑器 | 支持的平台 | 开源 | 成本 | 备注 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| [Visual Studio Code](https://code.visualstudio.com) | Windows, Macintosh,
    Linux | Yes | Free | A great choice for any language, and our first choice for
    JavaScript development |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| [Visual Studio Code](https://code.visualstudio.com) | Windows, Macintosh,
    Linux | 是 | 免费 | 任何语言的极佳选择，也是我们在JavaScript开发方面的首选 |'
- en: '| [Atom](https://atom.io) | Windows, Macintosh, Linux | Yes | Free | Most of
    the chapters in this book were written using Atom with plug-ins for AsciiDoc support
    |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| [Atom](https://atom.io) | Windows, Macintosh, Linux | 是 | 免费 | 本书的大部分章节都是使用Atom，并使用了支持AsciiDoc的插件进行编写
    |'
- en: '| [WebStorm](https://jetbrains.com/webstorm) | Windows, Macintosh, Linux |
    No | Free for open source developers and educational users, otherwise roughly
    $60 per year for an individual | A heavier-weight environment that’s closer to
    a traditional IDE than a code editor |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| [WebStorm](https://jetbrains.com/webstorm) | Windows, Macintosh, Linux |
    否 | 对于开源开发者和教育用户免费，否则个人每年大约 $60 | 一个比较重的环境，更接近传统的 IDE 而不是代码编辑器 |'
- en: '| [Sublime Text](https://sublimetext.com) | Windows, Macintosh, Linux | No
    | A one-time payment of $80 for an individual, although there is no license enforcement
    or time limit | A popular editor with a reputation for fast performance with massive
    text files |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| [Sublime Text](https://sublimetext.com) | Windows, Macintosh, Linux | 否 |
    个人一次性支付 $80，虽然没有许可证执行或时间限制 | 一个以在大型文本文件中快速性能而闻名的流行编辑器 |'
- en: '| [Brackets](http://brackets.io) | Windows, Macintosh | Yes | Free | An Adobe-sponsored
    project that’s focused on web development |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| [Brackets](http://brackets.io) | Windows, Macintosh | 是 | 免费 | 一个由 Adobe
    赞助的专注于 web 开发的项目 |'
- en: No matter what code editor you choose, you’ll follow a similar process to start
    a new project. Begin by creating a new folder for your project (like *test-site*).
    Then, in your code editor, look for a command like **File > Open Folder**, and
    choose the project folder you created. Most code editors will immediately show
    the contents of the project folder in a handy list or tree panel, so you can quickly
    jump between files.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择哪种代码编辑器，启动新项目的过程都大同小异。首先，创建一个新文件夹来存放你的项目（比如*test-site*）。然后，在你的代码编辑器中，查找类似
    **File > Open Folder** 这样的命令，选择你创建的项目文件夹。大多数代码编辑器会立即显示项目文件夹的内容，以便你可以快速在文件之间跳转。
- en: 'Having a project folder also gives you a place to put the packages you use
    ([“Downloading a Package with npm”](#installing_npm_package)) and store application-specific
    configuration files and linting rules ([“Enforcing Code Standards with a Linter”](#using_eslint)).
    And if your editor has a built-in terminal ([“Extra: Using a Terminal and Shell”](#using_terminal)),
    it always starts in the current project folder.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个项目文件夹还能让你放置你使用的软件包（[“使用 npm 下载软件包”](#installing_npm_package)）和存储应用程序特定的配置文件和代码规范文件（[“使用
    ESLint 强制代码规范”](#using_eslint)）。如果你的编辑器有内置终端（[“额外：使用终端和 Shell”](#using_terminal)），它总是会启动在当前项目文件夹中。
- en: Discussion
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Recommending a best editor is a little like *me* choosing *your* dessert. Personal
    taste is definitely a factor, and there are at least a dozen reasonable choices.
    Most of the suggestions listed in [Table 1-1](#code_editors) tick off all the
    important boxes, meaning they’re:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐最佳编辑器有点像 *我* 选择 *你* 的甜点一样。个人口味绝对是一个因素，而且至少有十几种合理的选择。大部分在 [表 1-1](#code_editors)
    中列出的建议都符合所有重要条件，也就是说它们：
- en: Cross-platform, so it doesn’t matter what operating system you’re using.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨平台，因此无论你使用什么操作系统都没问题。
- en: Plug-in-based, so you can snap in whatever features you need. Many of the tools
    mentioned in this book (like the Prettier code formatter described in [“Enforcing
    Code Standards with a Linter”](#using_eslint)) have plug-ins that integrate with
    different editors.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于插件的设计，因此你可以轻松地添加所需的功能。本书提到的许多工具（如 [“使用 ESLint 强制代码规范”](#using_eslint) 中描述的
    Prettier 代码格式化工具）都有与不同编辑器集成的插件。
- en: Multilanguage, allowing you to go beyond HTML, CSS, and JavaScript to write
    code in other programming languages (with the right plug-in).
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多语言支持，允许你不仅限于 HTML、CSS 和 JavaScript，在其他编程语言中编写代码（需要适当的插件）。
- en: Community-driven, which gives you confidence that they’ll be maintained and
    improved long into the future.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 社区驱动，这让你有信心它们将长期维护和改进。
- en: Free, or available for a modest cost.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 免费，或者仅需适度的费用。
- en: Our top choice, VS Code, is a Microsoft-built code editor with native JavaScript
    support. In fact, the editor itself is *written* in JavaScript, and hosted in
    Electron. (More precisely, it’s written in TypeScript, a stricter superset of
    JavaScript that’s transpiled into JavaScript before it’s distributed or executed.)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的首选是 VS Code，这是一个由微软开发的代码编辑器，具有原生的 JavaScript 支持。事实上，这个编辑器本身是用 JavaScript
    *编写* 的，并在 Electron 中托管。（更准确地说，它是用 TypeScript 编写的，这是 JavaScript 的一个更严格的超集，在分发或执行之前被转译成
    JavaScript。）
- en: In many ways, VS Code is the younger, trendier sibling to Microsoft’s sprawling
    Visual Studio IDE, which is also available in a free Community edition, and also
    supports JavaScript coding. But VS Code strikes a better balance for developers
    that aren’t already working with the Microsoft .NET stack. That’s because it starts
    out lightweight, but is endlessly customizable through its [library with thousands
    of community plug-ins](https://oreil.ly/RvMZ9). In Stack Overflow’s developer
    survey, VS Code regularly ranks as the most popular code editor across as languages.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，VS Code 是 Microsoft 强大的 Visual Studio IDE 的年轻、时髦的姐妹产品。Visual Studio IDE
    还有一个免费的社区版，也支持 JavaScript 编码。但是，VS Code 在为不使用 Microsoft .NET 技术栈的开发者提供更好平衡方面做得更好。因为它起初轻量级，但通过其[数千个社区插件的库](https://oreil.ly/RvMZ9)可以进行无限定制。在
    Stack Overflow 的开发者调查中，VS Code 经常被评为最受欢迎的代码编辑器，跨越多种编程语言。
- en: See Also
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: For an introduction to VS Code’s basic features and overall organization, there’s
    an excellent set of [introductory videos](https://oreil.ly/iiRhA). In this chapter,
    you’ll also learn how to use Emmet shortcuts in VS Code ([“Filling in HTML Boilerplate
    with Emmet Shortcuts”](#using_emmet)), and how to add the ESLint ([“Enforcing
    Code Standards with a Linter”](#using_eslint)) and Prettier ([“Styling Code Consistently
    with a Formatter”](#using_prettier)) plug-ins.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 想要了解 VS Code 的基本特性和整体结构，请观看一组优秀的[入门视频](https://oreil.ly/iiRhA)。在本章中，您还将学习如何在
    VS Code 中使用 Emmet 快捷键（[“使用 Emmet 快捷键填充 HTML 模板”](#using_emmet)），以及如何添加 ESLint（[“使用
    Linter 强制代码规范”](#using_eslint)）和 Prettier（[“使用格式化工具一致地进行代码样式设置”](#using_prettier)）插件。
- en: Using the Developer Console in Your Browser
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在您的浏览器中使用开发者控制台
- en: Problem
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to see the errors that occur in your web page and the messages you
    write to the console.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望查看网页中发生的错误以及您在控制台中输出的消息。
- en: Solution
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the developer console in your browser. [Table 1-2](#developer_console_shortcuts)
    shows how to load the developer tools in every modern desktop browser.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您浏览器的开发者控制台。[表格 1-2](#developer_console_shortcuts) 显示了如何在各现代桌面浏览器中加载开发者工具。
- en: Table 1-2\. Shortcut key to load the developer console
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 1-2\. 加载开发者控制台的快捷键
- en: '| Browser | Operating system | Shortcut |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 浏览器 | 操作系统 | 快捷键 |'
- en: '| --- | --- | --- |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Chrome | Windows or Linux | F12 or Ctrl+Shift+J |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| Chrome | Windows or Linux | F12 或 Ctrl+Shift+J |'
- en: '| Chrome | Macintosh | Cmd-Option-J |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| Chrome | Macintosh | Cmd-Option-J |'
- en: '| Edge | Windows or Linux | F12 or Ctrl+Shift+J |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| Edge | Windows or Linux | F12 或 Ctrl+Shift+J |'
- en: '| Firefox | Windows or Linux | F12 or Ctrl+Shift+J |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| Firefox | Windows or Linux | F12 或 Ctrl+Shift+J |'
- en: '| Firefox | Macintosh | Cmd-Shift-J |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| Firefox | Macintosh | Cmd-Shift-J |'
- en: '| Safari^([a](ch01.html#idm45475196605672)) | Macintosh | Cmd-Option-C |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| Safari^([a](ch01.html#idm45475196605672)) | Macintosh | Cmd-Option-C |'
- en: '| Opera | Windows | Ctrl+Shift+J |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| Opera | Windows | Ctrl+Shift+J |'
- en: '| Opera | Macintosh | Cmd-Option-J |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| Opera | Macintosh | Cmd-Option-J |'
- en: '| ^([a](ch01.html#idm45475196605672-marker)) Before you can use the developer
    console in Safari, you must enable it. To do so, choose **Safari Menu > Preferences**
    from the menu, click the **Advanced** tab, and check **Show Develop menu in the
    menu bar**. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| ^([a](ch01.html#idm45475196605672-marker)) 在 Safari 中使用开发者控制台之前，您必须先启用它。要启用控制台，请从菜单中选择**Safari
    菜单 > 首选项**，点击**高级**选项卡，并勾选**在菜单栏中显示“开发”菜单**。 |'
- en: The developer tools are usually presented as a tabbed group of panes at the
    right or bottom of the web browser window. The Console panel is the one that shows
    the messages you output with `console.log()` and any unhandled errors.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者工具通常以选项卡形式显示在网页浏览器窗口的右侧或底部。控制台面板显示使用 `console.log()` 输出的消息以及任何未处理的错误。
- en: 'Here’s the full code for a page that writes to the console and then fails with
    an error:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个页面的完整代码，它先写入控制台，然后出现错误：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[Figure 1-1](#developer_console) shows the output in the developer console.
    The logged message appears first, followed by the error (a `SyntaxError` for “Unexpected
    end of input”). Errors are displayed in red lettering, and Chrome helpfully adds
    links next to each message, so you can quickly view the source code that caused
    the message. Lines in your web pages and script files are numbered automatically.
    In this example, that makes it easy to distinguish between the source of the message
    (line 13) and the source of the error (the closing `</script>` tag on line 19).'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[Figure 1-1](#developer_console) 显示了开发者控制台中的输出。首先是记录的消息，然后是错误（一个 `SyntaxError`，显示为“意外的输入结束”）。错误消息以红色字体显示，并且
    Chrome 友好地在每条消息旁边添加链接，这样你可以快速查看导致消息的源代码。网页和脚本文件中的行号会自动编号。在这个例子中，这使得很容易区分消息的源（第13行）和错误的源（第19行的闭合
    `</script>` 标签）。'
- en: '![jsc3 0101](assets/jsc3_0101.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![jsc3 0101](assets/jsc3_0101.png)'
- en: Figure 1-1\. Viewing the output in Chrome’s developer console
  id: totrans-55
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 1-1\. 在 Chrome 开发者控制台中查看输出结果
- en: Discussion
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: We use `console.log()` throughout this book, often to write quick testing messages.
    However, there are other `console` methods you can use. [Table 1-3](#console_methods)
    lists some of the most useful.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本书中经常使用 `console.log()`，通常用于编写快速测试消息。然而，还有其他 `console` 方法可以使用。[Table 1-3](#console_methods)
    列出了一些最有用的方法。
- en: Table 1-3\. Console methods
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1-3\. 控制台方法
- en: '| Method | Description |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `console.warn(object)` | Similar to `console.log()`, but outputs text with
    a yellow background. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `console.warn(object)` | 类似于 `console.log()`，但输出的文本有黄色背景。 |'
- en: '| `console.error(object)` | Similar to `console.log()`, but outputs text with
    a red background. It’s typically used to log error objects. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `console.error(object)` | 类似于 `console.log()`，但输出的文本有红色背景。通常用于记录错误对象。 |'
- en: '| `console.assert(expression, object)` | If the expression is `false`, the
    message is written to the console along with a stack trace. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `console.assert(expression, object)` | 如果表达式为 `false`，则将消息与堆栈跟踪一起写入控制台。 |'
- en: '| `console.trace()` | Displays a stack trace. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `console.trace()` | 显示堆栈跟踪。 |'
- en: '| `console.count(label)` | Displays the number of times you’ve called this
    method with this label. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `console.count(label)` | 显示调用此方法的次数与标签相关联。 |'
- en: '| `console.dir(object)` | Displays all the properties of an object in an expandable,
    tree-like list. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `console.dir(object)` | 以可展开的树状列表形式显示对象的所有属性。 |'
- en: '| `console.group()` | Starts a new group with the title you supply. The following
    console messages are indented underneath this heading, so they appear to be part
    of one logically related section. You use `console.groupEnd()` to end the group.
    |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `console.group()` | 使用你提供的标题开始一个新的分组。接下来的控制台消息会在此标题下缩进显示，使它们看起来像是一个逻辑相关的部分。你可以使用
    `console.groupEnd()` 来结束分组。 |'
- en: '| `console.time(label)` | Starts a timer with a label you use to identify it.
    |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `console.time(label)` | 使用指定的标签开始计时。 |'
- en: '| `console.timeEnd(label)` | Stops the timer associated with the label and
    displays the elapsed time. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `console.timeEnd(label)` | 停止与标签关联的计时器并显示经过的时间。 |'
- en: Note
  id: totrans-70
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The consoles in modern browsers sometimes use *lazy evaluation* with objects
    and arrays. This issue may appear if you output an object with `console.log()`,
    then change it, and then output the same object a second time. If you do this
    from the script code in a web page, you’ll often find that both calls to `console.log()`
    emit the same changed object, even though the first call preceded the actual change!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现代浏览器中的控制台有时会对对象和数组使用*惰性评估*。如果你使用 `console.log()` 输出一个对象，然后对其进行更改，再次输出相同的对象，可能会出现这个问题。如果你在网页中的脚本代码中这样做，通常会发现
    `console.log()` 的两次调用都输出了同一个已更改的对象，即使第一次调用在实际更改之前！
- en: To avoid this quirk, you can explicitly convert your object to a string before
    you log it. This trick works because the console doesn’t use lazy evaluation with
    strings. This technique isn’t always convenient (for example, it doesn’t help
    if you want to log a complete array that contains objects), but it does let you
    work around most cases.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为避免这种问题，你可以在记录对象之前显式将其转换为字符串。这个技巧有效，因为控制台不会对字符串使用惰性评估。虽然这种技术并不总是方便（例如，如果你想记录包含对象的完整数组时就不适用），但它确实能解决大多数情况。
- en: 'Of course, the console is only one panel (or tab) in the developer tools. Look
    around, and you’ll find quite a bit of useful functionality packed into the other
    panels. The exact arrangement and naming depends on your browser, but here are
    some highlights in Chrome:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，控制台只是开发工具中的一个面板（或选项卡）。四处看看，您会发现其他面板中包含了许多有用的功能。具体的排列和命名取决于您的浏览器，但以下是Chrome的一些亮点。
- en: Elements
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 元素
- en: Use this panel to view the HTML markup for specific parts of your page, and
    inspect the CSS rules that apply to individual elements. You can even *change*
    markup and styles (temporarily) to quickly test potential edits.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此面板查看页面特定部分的HTML标记，并检查适用于各个元素的CSS规则。甚至可以 *更改* 标记和样式（暂时）以快速测试潜在的编辑。
- en: Sources
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 源码
- en: Use this panel to browse all the files the current page is using, including
    JavaScript libraries, images, and style sheets.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此面板浏览当前页面使用的所有文件，包括JavaScript库、图像和样式表。
- en: Network
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 网络
- en: Use the panel tab to watch the size and download time of your page and its resources,
    and to view the asynchronous messages being sent over the wire (for example, as
    part of a `fetch` request).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用面板标签查看页面及其资源的大小和下载时间，以及查看通过网络发送的异步消息（例如，作为`fetch`请求的一部分）。
- en: Performance
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 性能
- en: Use this panel to start tracking the time your code takes to execute (see [“Analyzing
    Runtime Performance”](ch11.html#analyzing_performance_in_console)).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此面板开始跟踪代码执行所需的时间（参见[“分析运行时性能”](ch11.html#analyzing_performance_in_console)）。
- en: Application
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序
- en: Use this panel to review all the data the current site is storing with cookies,
    in local storage or with the IndexedDB API.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此面板查看当前站点使用的所有数据，包括存储在cookie中、本地存储或使用IndexedDB API存储的数据。
- en: You can play around with most of these panels to get an idea about how they
    work, or you can review [Google’s documentation](https://oreil.ly/cZ6AP).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以尝试大多数这些面板，以了解它们的工作原理，或者您可以查阅[Google的文档](https://oreil.ly/cZ6AP)。
- en: See Also
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[“Running Blocks of Code in the Developer Console”](#running_code_developer_console)
    explains how to run ad hoc bits of code in the developer console.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[“在开发者控制台中运行代码块”](#running_code_developer_console) 解释了如何在开发者控制台中运行即席代码片段。'
- en: Running Blocks of Code in the Developer Console
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在开发者控制台中运行代码块
- en: Problem
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to try out a snippet of code without opening an editor and creating
    HTML and JavaScript files.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您想尝试一个代码片段，而无需打开编辑器并创建HTML和JavaScript文件。
- en: Solution
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the developer console in your browser. First, open the developer tools (as
    explained in [“Using the Developer Console in Your Browser”](#using_developer_console)).
    Make sure the Console panel is selected. Then, paste or type your JavaScript.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的浏览器中使用开发者控制台。首先，打开开发者工具（如[“在您的浏览器中使用开发者控制台”](#using_developer_console)中所述）。确保选择控制台面板。然后，粘贴或输入您的JavaScript代码。
- en: Press Enter to run your code immediately. If you need to type multiple lines
    of code, press Shift+Enter at the end of each line to insert a soft return. Only
    press Enter when you’re finished and you want to run your full block of code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 按Enter立即运行您的代码。如果需要输入多行代码，请在每行末尾按Shift+Enter插入软换行。只有当完成并且想要运行完整代码块时才按Enter。
- en: Often, you’ll want to modify the same piece of code and rerun it. In all modern
    browsers, the developer console has a history feature that makes this easy. To
    use it, press the up arrow key to show the previously executed code block. If
    you want to see the code you ran before *that*, press the up arrow multiple times.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您可能希望修改同一段代码并重新运行它。在所有现代浏览器中，开发者控制台都具有历史记录功能，使这一过程变得简单。要使用它，按向上箭头键显示先前执行的代码块。如果要查看之前运行的代码
    *更早* 的代码，则按多次向上箭头键。
- en: '[Figure 1-2](#developer_console_code) shows an example with a code block that
    didn’t run successfully the first time because of a syntax error. The code was
    then called up in the history, edited, and executed, with the output (15) appearing
    underneath.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-2](#developer_console_code) 显示了一个代码块示例，第一次由于语法错误而未能成功运行。然后将代码调用到历史记录中，进行编辑和执行，输出结果（15）显示在下方。'
- en: '![jsc3 0102](assets/jsc3_0102.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![jsc3 0102](assets/jsc3_0102.png)'
- en: Figure 1-2\. Running code in the console
  id: totrans-96
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-2\. 在控制台中运行代码
- en: The history feature only works if you *don’t* start typing in any new code.
    If the console command line isn’t empty, the up arrow key will just move through
    the current code block rather than stepping back through the history.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 历史记录功能仅在 *不* 开始输入任何新代码时才有效。如果控制台命令行不为空，则向上箭头键仅会在当前代码块中移动，而不是回溯历史记录。
- en: Discussion
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: In the developer console, you can enter JavaScript code exactly as you would
    in a script block. In other words, you can add functions and call them, or define
    a class and then instantiate it. You can also access the `document` object, interact
    with HTML elements in the current page, show alerts, and write to the console.
    (The messages will appear directly below.)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发者控制台中，你可以像在脚本块中一样输入 JavaScript 代码。换句话说，你可以添加函数并调用它们，或定义一个类然后实例化它。你还可以访问`document`对象，在当前页面中与
    HTML 元素交互，显示警告，并写入控制台。（消息将直接显示在下方。）
- en: 'There’s one potential stumbling block when using the console for longer code
    examples. You may run into a naming clash, because JavaScript won’t allow you
    to define the same variables or function names in the same scope more than once.
    For example, consider a simple block of code like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当在控制台中使用更长的代码示例时，可能会遇到一个潜在的障碍。你可能会遇到命名冲突，因为 JavaScript 不允许在同一作用域内定义相同的变量或函数名称多次。例如，考虑如下简单的代码块：
- en: '[PRE1]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This works fine if you run it once. But if you call it back up in the history
    to make a modification (by pressing the up arrow), and you try to run it again,
    you’ll get an error informing you that `testValue` is already declared. You could
    rename your variable, but if you’re trying to perfect a snippet of code with multiple
    values and functions, this renaming gets awkward fast. Alternatively, you could
    execute the command `location.reload()` to refresh the page, but that can be slow
    for complex pages, and you might lose some page state you’re trying to keep.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只运行一次，这个方法是有效的。但如果你按向上箭头回退历史来修改它，并再次运行，你会收到一个错误提示，告诉你`testValue`已经声明。你可以重命名你的变量，但如果你试图完善一个包含多个值和函数的代码片段，这种重命名会很快变得笨拙。或者，你可以执行`location.reload()`命令来刷新页面，但对于复杂页面来说速度会慢一些，而且可能会丢失一些你试图保留的页面状态。
- en: Fortunately, there’s a simpler solution. Simply enclose your entire block of
    code in an extra set of braces to create a new naming scope. You can then safely
    run the code multiple times, because each time a new context is created (and then
    discarded).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个更简单的解决方案。只需在你的整个代码块外再加一层大括号，就可以创建一个新的命名范围。这样每次运行代码时都会安全执行，因为每次都会创建（然后丢弃）一个新的上下文。
- en: '[PRE2]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: See Also
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[“Debugging JavaScript”](ch11.html#debugging_javascript_in_console) explores
    the art of debugging in the developer console. [“Analyzing Runtime Performance”](ch11.html#analyzing_performance_in_console)
    shows how to use the developer console for performance analysis.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[“调试 JavaScript”](ch11.html#debugging_javascript_in_console) 探讨了在开发者控制台中调试的艺术。[“分析运行时性能”](ch11.html#analyzing_performance_in_console)
    展示了如何在开发者控制台中进行性能分析。'
- en: Using Strict Mode to Catch Common Mistakes
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用严格模式捕捉常见错误
- en: Problem
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to disallow potentially risky features, like automatic variable creation
    and some statements that fail silently.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要禁止潜在风险的特性，比如自动变量创建和一些会悄悄失败的语句。
- en: Solution
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Add the `use strict` directive at the top of your JavaScript code file, like
    this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 JavaScript 代码文件顶部添加`use strict`指令，就像这样：
- en: '[PRE3]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Alternatively, consider writing your JavaScript in a *module*, which is always
    loaded in strict mode ([“Organizing Your JavaScript Classes with Modules”](ch08.html#using_es6_modules)).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，考虑将你的 JavaScript 写成*模块*，这总是以严格模式加载（[“使用 ES6 模块组织你的 JavaScript 类”](ch08.html#using_es6_modules)）。
- en: Discussion
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: JavaScript has a (somewhat deserved) reputation for tolerating sloppy code practices.
    The problem is that languages that ignore minor rule breaking put developers at
    a disadvantage. After all, you can’t fix a problem that you never notice.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 因容忍懒散的编码习惯而（有些情况下）名声不佳。问题在于忽视细微规则违反的语言会让开发者处于不利地位。毕竟，你不能修复你从未注意到的问题。
- en: The following example demonstrates an example of JavaScript gone bad. Can you
    find the mistake?
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例演示了 JavaScript 糟糕的一个例子。你能找到错误吗？
- en: '[PRE4]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Although the code runs without an error, the results aren’t what we expect.
    The problem occurs in this line:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然代码可以无错误地运行，但结果不符合我们的期望。问题出现在这行代码上：
- en: '[PRE5]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The issue here is that JavaScript creates variables whenever you assign a value,
    even if you don’t explicitly define the variable. So if you assign to `startnumber`
    when you really want `startNumber`, JavaScript quietly creates a new `startnumber`
    variable. The end result is that the value you intended to assign to `startNumber`
    vanishes into another variable, never to be seen or used again.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题在于当你赋值时 JavaScript 会创建变量，即使你没有明确定义这个变量。因此，如果你将值赋给`startnumber`而实际上想要的是`startNumber`，JavaScript
    会悄悄地创建一个新的`startnumber`变量。最终的结果是，你打算赋给`startNumber`的值会消失到另一个变量中，再也看不到或使用不了。
- en: 'To catch this problem, add the strict mode directive to the top of the file,
    before the function code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要捕获这个问题，在函数代码之前，在文件顶部添加严格模式指令：
- en: '[PRE6]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now a `ReferenceError` occurs when JavaScript reaches the `startnumber` assignment.
    This interrupts your code, ending the script. However, the error appears in red
    lettering in the developer console, explaining the problem and the line number
    where it happened. Now, a fix is trivially easy.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当 JavaScript 到达`startnumber`赋值时会出现`ReferenceError`。这会中断你的代码，结束脚本。然而，错误会在开发者控制台以红色字体显示，解释问题及其发生的行号。现在，修复变得非常容易。
- en: 'Strict mode catches a number of small but pernicious errors. Some examples
    include:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 严格模式能够捕获许多微小但有害的错误。一些例子包括：
- en: Assignments to undeclared variables
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给未声明的变量赋值
- en: 'Duplicate parameter names (like `function(a, b, a)`) or object literal property
    names (as in `{a: 5, a: 0}`)'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '重复的参数名（如`function(a, b, a)`）或对象字面量属性名（如`{a: 5, a: 0}`）'
- en: Attempts to assign values to special keywords like `Infinity` or `undefined`
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试给特殊关键词如`Infinity`或`undefined`赋值
- en: Attempts to set read-only properties ([“Customizing the Way a Property Is Defined”](ch07.html#creating_properties_with_define_property))
    or change frozen objects ([“Preventing Any Changes to an Object”](ch07.html#preventing_any_changes_to_an_object))
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试设置只读属性（[“自定义属性定义方式”](ch07.html#creating_properties_with_define_property)）或更改冻结对象（[“防止对象任何更改”](ch07.html#preventing_any_changes_to_an_object)）
- en: Many of these actions would fail without strict mode. However, they would fail
    *silently*, potentially leading to a maddening situation where your code doesn’t
    work the way you expect it to, and you have no idea why.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 很多这些操作如果没有严格模式将会失败。然而，它们会*悄无声息*地失败，可能导致一个令人发狂的情况，你的代码不按预期工作，而你又不知道原因所在。
- en: Tip
  id: totrans-130
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: You may be able to configure your editor to insert the `use strict` directive
    to every new code file. For example, Visual Studio Code has at least [three small
    extensions](https://oreil.ly/ye0o7) that offer to perform this task.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以配置你的编辑器在每个新的代码文件中插入`use strict`指令。例如，Visual Studio Code 至少有[三个小扩展](https://oreil.ly/ye0o7)可以执行这个任务。
- en: Strict mode catches a relatively small set of errors. Most developers also use
    a linting tool ([“Enforcing Code Standards with a Linter”](#using_eslint)) to
    catch a much broader range of bugs and potentially risky actions. In fact, developers
    rely on linters to such an extent that they sometimes don’t bother to apply strict
    mode at all. However, it’s always recommended to have strict mode as a basic level
    of protection against shooting yourself in the foot.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 严格模式能够捕获一小部分错误。大多数开发者也使用一个代码检查工具（[“使用 ESLint 强制代码规范”](#using_eslint)）来捕获更广泛的错误和潜在的危险操作。事实上，开发者如此依赖于代码检查工具，以至于有时根本不使用严格模式。然而，始终建议将严格模式作为基本的防护级别，以防止自己不小心犯错。
- en: See Also
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: For the full details on what strict mode won’t accept, see [the strict mode
    documentation](https://oreil.ly/Z7QhF). To see how to use modules, which always
    execute in strict mode, see [“Organizing Your JavaScript Classes with Modules”](ch08.html#using_es6_modules).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 关于严格模式不接受的详细信息，请参阅[严格模式文档](https://oreil.ly/Z7QhF)。要查看如何使用模块，请参阅[“使用 ES6 模块组织你的
    JavaScript 类”](ch08.html#using_es6_modules)。
- en: Filling in HTML Boilerplate with Emmet Shortcuts
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Emmet 快捷方式填充 HTML 模板
- en: Problem
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to add a common chunk of HTML boilerplate without painstakingly typing
    each start and end tag.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望添加一段常见的 HTML 模板代码，而不必费力地逐个输入每个起始和结束标记。
- en: Solution
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Emmet is an editor feature that automatically changes predefined text abbreviations
    into standard blocks of HTML. Some code editors, like Visual Studio and WebStorm,
    support Emmet natively. Other editors, like Atom and Sublime Text, require the
    use of an editor plug-in. You can usually find the right plug-in by searching
    the plug-in library for “Emmet,” but if you’re in doubt, there’s a [master list
    of Emmet-supporting plug-ins](https://emmet.io/download).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Emmet 是一个编辑器功能，可以自动将预定义的文本缩写转换为标准的 HTML 块。一些代码编辑器，如 Visual Studio 和 WebStorm，原生支持
    Emmet。其他编辑器，如 Atom 和 Sublime Text，则需要使用编辑器插件。你通常可以在插件库中搜索“Emmet”来找到合适的插件，但如果不确定，可以参考[支持
    Emmet 的插件大全](https://emmet.io/download)。
- en: To use Emmet, create a new file and save it with a *.html* or *.htm* extension,
    so your code editor recognizes it as an HTML document. Then, type one of Emmet’s
    abbreviations, followed by the Tab key. (In some editors, you might use a different
    shortcut, like Enter or Ctrl+E, but the Tab key is most common.) Your text will
    be automatically expanded into the corresponding block of markup.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Emmet，创建一个新文件并将其保存为 *.html* 或 *.htm* 扩展名，这样你的代码编辑器将其识别为 HTML 文档。然后，输入一个
    Emmet 缩写，再按 Tab 键（某些编辑器可能使用不同的快捷键，如 Enter 或 Ctrl+E，但 Tab 键是最常用的）。你的文本将自动展开为相应的标记块。
- en: 'For example, the Emmet abbreviation `input:time` expands into this markup:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Emmet 缩写 `input:time` 展开为以下标记：
- en: '[PRE7]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[Figure 1-3](#emmet_in_vscode) shows how VS Code recognizes an Emmet abbreviation
    as you type it. VS Code provides autocomplete support for Emmet, so you can see
    possible choices, and it adds the note “Emmet Abbreviation” to the autocomplete
    menu to signal that you aren’t writing HTML, but an Emmet shortcut that will be
    *translated* into HTML.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-3](#emmet_in_vscode) 展示了 VS Code 在你输入 Emmet 缩写时如何识别它。VS Code 提供了 Emmet
    的自动完成支持，因此你可以看到可能的选择，并在自动完成菜单中添加“Emmet 缩写”提示，以表明你不是在编写 HTML，而是一个将被*翻译*成 HTML 的
    Emmet 快捷方式。'
- en: '![jsc3 0103](assets/jsc3_0103.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![jsc3 0103](assets/jsc3_0103.png)'
- en: Figure 1-3\. Using Emmet in VS Code
  id: totrans-145
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-3\. 在 VS Code 中使用 Emmet
- en: Discussion
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Emmet provides a straightforward syntax, but it’s surprisingly flexible. You
    can write more complicated expressions that create nested combinations of elements,
    set attributes, and incorporate sequential numbers into names. For example, to
    create a bulleted list with five items, you use the abbreviation `ul>li*5`, which
    adds the following block of markup:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Emmet 提供了简单的语法，但其灵活性出乎意料。你可以编写更复杂的表达式，创建嵌套的元素组合，设置属性，并将顺序数字整合到名称中。例如，要创建一个包含五个项目的项目符号列表，可以使用缩写
    `ul>li*5`，它将添加以下的标记块：
- en: '[PRE8]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Or, you can create the starting skeleton for an HTML5 web page (the modern standard)
    with the shortcut `html:5`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用快捷键 `html:5` 创建 HTML5 网页的起始框架（现代标准）。
- en: '[PRE9]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: All of these features are described in the [Emmet documentation](https://docs.emmet.io).
    If you’re in a hurry, start with the patterns in the useful cheatsheet.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些功能在 [Emmet 文档](https://docs.emmet.io) 中有详细描述。如果你着急，可以从有用的速查表开始。
- en: Installing the npm Package Manager (with Node.js)
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 npm 包管理器（使用 Node.js）
- en: Problem
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to install npm, so you can easily download JavaScript libraries from
    the npm registry and add them to web projects.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你想安装 npm，这样就可以轻松地从 npm 注册表下载 JavaScript 库，并将它们添加到 Web 项目中。
- en: Solution
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: The Node Package Manager (npm) hosts the largest (and currently most popular)
    software registry in the world. The easiest way to get software from the npm registry
    is using npm, which is bundled with Node.js. To install Node, download an installer
    for your operating system (Windows, MacOS, or Linux) from the [Node website](https://nodejs.org).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Node 包管理器（npm）是世界上最大（目前也是最流行的）软件注册表的托管者。从 npm 注册表获取软件的最简单方式是使用 npm，它与 Node.js
    捆绑在一起。要安装 Node，可以从 [Node 网站](https://nodejs.org) 下载适用于你操作系统（Windows、MacOS 或 Linux）的安装程序。
- en: 'Once you finish installing Node, you can test that it’s available using the
    command line. Open a terminal window and type the command `node -v`. To check
    if npm is installed, type `npm -v`. You’ll see the version number of both packages:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完 Node 后，可以通过命令行验证其可用性。打开终端窗口，输入命令 `node -v` 检查 Node 的版本。要检查 npm 是否安装，输入 `npm
    -v`。你将看到这两个软件包的版本号：
- en: '[PRE10]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Discussion
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: npm is included with Node.js, a JavaScript runtime environment and web server.
    You might use Node to run a server-side JavaScript framework like Express, or
    to build a JavaScript desktop application with Electron. But even if you don’t
    plan to use Node, you’ll almost certainly still install it just to get access
    to the npm package manager.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: npm 包含在 Node.js 中，这是一个 JavaScript 运行时环境和 Web 服务器。你可以使用 Node 运行服务器端 JavaScript
    框架如 Express，或者用 Electron 构建 JavaScript 桌面应用程序。但即使你不打算使用 Node，你几乎肯定还是会安装它，以便访问
    npm 包管理器。
- en: The Node Package Manager is a tool that can download packages from the npm registry,
    a free catalog that tracks tens of thousands of JavaScript libraries. In fact,
    you’ll be hard-pressed to find a computer that’s used for JavaScript development
    that *doesn’t* have an installation of Node and npm.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Node 包管理器是一个工具，可以从 npm 注册表下载包，这是一个免费目录，跟踪数以万计的 JavaScript 库。事实上，你几乎找不到一台用于 JavaScript
    开发的计算机，*没有*安装 Node 和 npm。
- en: The work of a package manager goes beyond simply downloading useful libraries.
    The package manager also has the responsibility of tracking what libraries your
    project is using (called *dependencies*), downloading the packages *they* depend
    on (sometimes called subdependencies), storing versioning information, and distinguishing
    between test and production builds. Thanks to npm, you can take a completed application
    to another computer and install all the dependencies it needs with a single command,
    as explained in [“Downloading a Package with npm”](#installing_npm_package).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 包管理器的工作远不止简单下载有用的库。包管理器还负责跟踪项目使用的库（称为*依赖项*），下载它们依赖的包（有时称为子依赖项），存储版本信息，并区分测试和生产构建。有了
    npm，你可以通过单个命令将完成的应用程序带到另一台计算机，并安装所有需要的依赖项，如[“使用 npm 下载包”](#installing_npm_package)中所述。
- en: Although npm is currently the most popular package manager for JavaScript, it’s
    not the only one you might encounter. [Yarn](https://yarnpkg.com) is favored by
    some developers who find it offers faster package installation. [Pnpm](https://pnpm.io)
    is another option that aims to be command-line compatible with npm, while requiring
    less diskspace and offering better installation performance.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 npm 目前是 JavaScript 最流行的包管理器，但你可能会遇到其他选项。[Yarn](https://yarnpkg.com) 受到一些开发人员青睐，因为它提供了更快的包安装速度。[Pnpm](https://pnpm.io)
    是另一个选项，它旨在与 npm 兼容，但需要更少的磁盘空间，并提供更好的安装性能。
- en: See Also
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: To install a package with npm, see [“Downloading a Package with npm”](#installing_npm_package).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 npm 安装包，请参见[“使用 npm 下载包”](#installing_npm_package)。
- en: If you’re using Node for development (not just npm), you should consider installing
    it with nvm, the Node version manager. That way you can easily switch between
    different Node versions and quickly update your installation when new releases
    are available (which is often). For more information, see [“Managing Node Versions
    with Node Version Manager”](ch17.html#use-nvm). And if you need help to get started
    running code in the Node environment, [Chapter 17](ch17.html#ch17) has many more
    examples.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在开发时使用 Node（不仅仅是 npm），你应该考虑使用 nvm 安装它，即 Node 版本管理器。这样你可以轻松切换不同的 Node 版本，并在有新版本发布时快速更新安装（这经常发生）。更多信息请参见[“使用
    Node 版本管理器管理 Node 版本”](ch17.html#use-nvm)。如果你需要帮助在 Node 环境中开始运行代码，请参阅[第17章](ch17.html#ch17)，其中有更多示例。
- en: 'Extra: Using a Terminal and Shell'
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附加：使用终端和 Shell
- en: To run Node or npm, you use the *terminal*. Technically, a terminal is a text-based
    interface that communicates with a *shell* to execute commands. Many different
    terminal programs exist, along with many different shells. The terminal and shell
    program that you use depends on your operating system (and your personal preference,
    because there are plenty of third-party alternatives).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行 Node 或 npm，你需要使用*终端*。从技术上讲，终端是一个基于文本的界面，用于与*shell*通信以执行命令。存在许多不同的终端程序和不同的
    shell。你使用的终端和 shell 程序取决于你的操作系统（以及你的个人偏好，因为有大量第三方替代品）。
- en: 'Here are some of the most common terminal and shell combinations you’ll encounter:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是你可能会遇到的一些最常见的终端和 shell 组合：
- en: On a Macintosh computer, go to **Applications**, open the **Utilities** folder,
    and choose **Terminal**. This launches the default terminal program, which uses
    `bash` as its shell.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Macintosh 计算机上，转到**应用程序**，打开**实用工具**文件夹，选择**终端**。这将启动默认的终端程序，它使用 `bash` 作为其
    shell。
- en: On a Linux computer, the terminal program depends on the distro. There’s often
    a shortcut named Terminal, and it almost always uses the `bash` shell.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Linux计算机上，终端程序取决于发行版。通常有一个名为Terminal的快捷方式，几乎总是使用`bash` shell。
- en: On Windows, you can launch PowerShell from the Start menu. Technically, PowerShell
    is the shell and it’s wrapped in a terminal process called `conhost`. Microsoft
    is developing a modern `conhost` replacement called Windows Terminal, which early
    adopters can install from the Windows Store (or [download from GitHub](https://github.com/microsoft/terminal)).
    Microsoft also includes the `bash` shell as part of its [Windows Subsystem for
    Linux](https://oreil.ly/N7EWS), although that’s a relatively recent addition to
    the operating system.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Windows上，您可以从开始菜单启动PowerShell。从技术上讲，PowerShell是Shell，并且它被包装在名为`conhost`的终端进程中。Microsoft正在开发一种现代的`conhost`替代品，称为Windows
    Terminal，早期采用者可以从Windows商店安装（或从[GitHub下载](https://github.com/microsoft/terminal)）。Microsoft还将`bash`
    shell作为其[Windows子系统](https://oreil.ly/N7EWS)的一部分包含在内，尽管这是操作系统的相对较新的添加。
- en: Code editors sometimes include their own terminals. For example, if you open
    the terminal window in VS Code (use the Ctrl + ` shortcut [that’s a backtick,
    not a single quote] or choose **View > Terminal** from the menu) you get VS Code’s
    integrated terminal window. By default, it communicates with PowerShell on Windows
    and `bash` on other systems, although you can configure its settings.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码编辑器有时会包含它们自己的终端。例如，如果您在VS Code中打开终端窗口（使用Ctrl + `快捷键 [注意这是一个反引号，而不是单引号] 或从菜单中选择**视图
    > 终端**），您将获得VS Code集成的终端窗口。默认情况下，它与Windows上的PowerShell和其他系统上的`bash`通信，尽管您可以配置其设置。
- en: When we direct you to use a terminal command, you can use the terminal window
    in your code editor, the terminal program that’s specific to your computer, or
    one of the many third-party terminal and shell applications. They all get the
    same environment variables (which means they have access to Node and npm once
    they’re installed), and they all have the ability to run programs in the current
    path. You can also use your terminal for the usual filesystem maintenance tasks,
    like creating folders and files.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们指示您使用终端命令时，您可以使用代码编辑器中的终端窗口，特定于您计算机的终端程序，或者众多第三方终端和Shell应用程序。它们都具有相同的环境变量（这意味着一旦安装，它们可以访问Node和npm），并且都可以运行当前路径下的程序。您还可以使用终端执行通常的文件系统维护任务，如创建文件夹和文件。
- en: Note
  id: totrans-175
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In this book, when we show the commands you should type in a terminal (as in
    [“Installing the npm Package Manager (with Node.js)”](#installing_node_npm)),
    we preceded them with the `$` character. This is the traditional prompt for `bash`.
    However, different shells have different conventions. If you’re using PowerShell
    you’ll see a folder name followed by the `>` character instead (as in `C:\Projects\Sites\WebTest>`).
    Either way, the commands you use to run utilities (like npm) don’t change.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，当我们展示您应在终端中输入的命令（如[“安装npm包管理器（使用Node.js）”](#installing_node_npm)）时，我们在它们之前加上`$`字符。这是`bash`的传统提示符。然而，不同的Shell有不同的约定。如果您使用PowerShell，则会看到一个文件夹名称，后面跟着`>`字符（如`C:\Projects\Sites\WebTest>`）。无论哪种方式，您用来运行实用程序（如npm）的命令不会改变。
- en: Downloading a Package with npm
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用npm下载包
- en: Problem
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to install a specific software package from the npm registry.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望从npm注册表中安装特定的软件包。
- en: Solution
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'First, you must have npm on your computer (see [“Installing the npm Package
    Manager (with Node.js)”](#installing_node_npm) for instructions). Assuming you
    do, open a terminal window ([“Extra: Using a Terminal and Shell”](#using_terminal)),
    and go to the project directory for your website.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您必须在计算机上安装npm（参见[“安装npm包管理器（使用Node.js）”](#installing_node_npm)以获取说明）。假设您已经安装好了，打开一个终端窗口（参见[“额外内容：使用终端和Shell”](#using_terminal)），并进入您网站项目的项目目录。
- en: 'Next, you should create a *package.json* file, if your application doesn’t
    already have one. You don’t actually need this file to install packages, but it
    does become important for some other tasks (like restoring your packages to another
    development computer). The easiest way to create a *package.json* file is with
    npm’s `init` command:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果您的应用程序尚未有*package.json*文件，您应该创建一个。实际上，您并不需要这个文件来安装包，但是它对某些其他任务（如将您的包恢复到另一台开发计算机）变得很重要。使用npm的`init`命令创建*package.json*文件是最简单的方法：
- en: '[PRE11]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `-y` parameter (for *yes*) means that npm will simply choose default values
    rather than prompt you for specific information about your application. If you
    don’t include the `-y` parameter, you’ll be asked a variety of questions about
    your application (its package name, description, version, license, and so on).
    However, you don’t need to fill in any of these details at first (or at all),
    so it’s perfectly acceptable to press Enter to leave each field blank and create
    the basic *package.json* boilerplate. For more information about the descriptive
    information inside *package.json*, see [“Extra: Understanding package.json”](#package_json).'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`-y` 参数（用于 *yes*）意味着 npm 将只是选择默认值，而不会提示您输入有关应用程序的具体信息。如果不包括 `-y` 参数，您将被询问有关应用程序的各种问题（如包名称、描述、版本、许可证等）。但是，起初（或根本）您无需填写任何这些细节，因此完全可以按
    Enter 键留空每个字段并创建基本的 *package.json* 模板。有关 *package.json* 中描述信息的更多信息，请参见[“额外：理解
    package.json”](#package_json)。'
- en: 'Once you’ve initialized your application, you’re ready to install a package.
    You must know the exact name of the package you want to install. By convention,
    npm names are made up of dash-separated lowercase words, like `fs-extra` or `react-dom`.
    To install your package of choice, run the `npm install` command with the package
    name. For example, here’s how you would install the popular Lodash library:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦初始化了您的应用程序，您就可以安装一个包。您必须知道要安装的包的确切名称。按照约定，npm 的名称由连字符分隔的小写单词组成，如 `fs-extra`
    或 `react-dom`。要安装您选择的包，只需使用包名称运行 `npm install` 命令。例如，以下是如何安装流行的 Lodash 库的示例：
- en: '[PRE12]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: npm adds the packages you install to the *package.json* file. It also records
    more detailed versioning information about each package in a file named *package-lock.json*.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: npm 将您安装的包添加到 *package.json* 文件中。它还在名为 *package-lock.json* 的文件中记录了关于每个包更详细的版本信息。
- en: When you install a package, npm downloads its files and places them in a folder
    named *node_modules*. For example, if you install Lodash in a project folder named
    *test-site*, the Lodash script files will be placed in the folder *test-site/node_modules/lodash*.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 安装包时，npm 将其文件下载并放置在名为 *node_modules* 的文件夹中。例如，如果您在名为 *test-site* 的项目文件夹中安装了
    Lodash，那么 Lodash 脚本文件将放置在文件夹 *test-site/node_modules/lodash* 中。
- en: 'You can remove a package by name using `npm uninstall`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `npm uninstall` 按名称删除一个包：
- en: '[PRE13]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Discussion
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'The genius of npm (or any package manager) becomes apparent when you have a
    typical web project with half a dozen or more packages, each of which depends
    on additional packages. Because all these dependencies are tracked in the *package-lock.json*
    file, it’s easy to figure out what a web application needs. You can see a full
    report by executing this command from your project folder:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: npm（或任何包管理器）的天才表现在于当您有一个典型的 Web 项目，其中包含半打或更多个包，每个包都依赖于其他包时，这一点变得显而易见。因为所有这些依赖项都在
    *package-lock.json* 文件中进行了跟踪，所以很容易知道一个 Web 应用程序需要什么。您可以通过从项目文件夹执行以下命令来查看完整报告：
- en: '[PRE14]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It’s also easy to re-download these packages on a new computer. For example,
    if you copy your website to another computer with the *package.json* and *package-lock.json*
    files, but without the *node_modules* folder, you can install all the dependent
    packages like this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在新计算机上重新下载这些包也很容易。例如，如果您将网站复制到另一台带有 *package.json* 和 *package-lock.json* 文件但不带
    *node_modules* 文件夹的计算机上，您可以像这样安装所有依赖包：
- en: '[PRE15]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: So far, you’ve seen how to install packages *locally* (as part of the current
    web application). npm also allows packages to be installed *globally* (in a system-specific
    folder, so the same version is available to all the web applications on your computer).
    For most software packages, local installation is best. It gives you the flexibility
    to control the exact version of a package that you use, and it lets you use different
    versions of the same package with different applications, so you never break compatibility.
    (This potential problem becomes magnified when one package depends on the specific
    version of *another* package.) However, global installation is useful for certain
    types of packages, particularly development tools that have command-line utilities.
    Some examples of packages that are sometimes installed globally include `create-react-app`
    (used to create a new React project), `http-server` (used to run a test web server),
    `typescript` (used to compile TypeScript code into JavaScript), and `jest` (used
    to run automated tests on your code).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到如何*本地*安装包（作为当前 Web 应用的一部分）。npm 还允许将包*全局*安装（在系统特定的文件夹中，因此所有计算机上的 Web
    应用都可以使用相同版本）。对于大多数软件包来说，本地安装是最佳选择。它使你能够控制所使用包的确切版本，并允许在不同应用程序中使用不同版本的相同包，以避免兼容性问题。当一个包依赖于*另一个*包的特定版本时，这个潜在问题会被放大。但是，全局安装对于某些类型的包特别有用，尤其是具有命令行实用程序的开发工具。有时全局安装的包的示例包括
    `create-react-app`（用于创建新的 React 项目）、`http-server`（用于运行测试 Web 服务器）、`typescript`（用于将
    TypeScript 代码编译为 JavaScript）和 `jest`（用于在代码上运行自动化测试）。
- en: 'To see all the global npm packages installed on your computer, run this command:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看计算机上安装的所有全局 npm 包，请运行此命令：
- en: '[PRE16]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, the `--depth` parameter makes sure that you only see the top layer of
    global packages, not the other packages that these global packages use. npm has
    additional features that we won’t cover here, including the ability to:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`--depth` 参数确保你只看到全局包的顶层，而不是这些全局包使用的其他包。npm 还有其他功能，我们在这里不会涵盖，包括以下能力：
- en: Designate some dependencies as *developer dependencies*, meaning they’re required
    for development but not deployment (like a unit testing tool). You’ll see this
    technique in Recipes and .
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将某些依赖项指定为*开发者依赖项*，意味着它们对开发是必需的，但不是部署所需（比如单元测试工具）。你将在 Recipes 和 中看到这种技术。
- en: Audit your dependencies by searching the npm registry for reports of known vulnerabilities,
    which it may be able to fix by [installing new versions](https://oreil.ly/XJkEM).
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过搜索 npm 注册表中已知漏洞的报告来审核你的依赖项，它可能可以通过[安装新版本](https://oreil.ly/XJkEM)来修复这些问题。
- en: Run command-line tasks through a bundled utility called npx. You can even launch
    tasks automatically by adding them to *package.json*, like prepping your site
    for production deployment or starting a web server during development testing.
    You’ll see this technique with the test server in [“Setting Up a Local Test Server”](#setting_up_test_server).
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过名为 npx 的捆绑实用程序运行命令行任务。你甚至可以通过将它们添加到*package.json*中来自动启动任务，比如为生产部署准备你的站点或在开发测试期间启动
    Web 服务器。你将在[“设置本地测试服务器”](#setting_up_test_server)中看到这种技术。
- en: npm isn’t the only package manager that JavaScript developers use. Yarn is a
    similar package manager that was initially developed by Facebook. It has a performance
    edge in some scenarios, due to the way that it downloads packages in parallel
    and uses caching. Historically, it’s also enforced stricter security checks. There’s
    no reason *not* to use Yarn, but npm remains significantly more popular in the
    JavaScript community.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 开发者使用的包管理器不仅仅有 npm。Yarn 是一个类似的包管理器，最初由 Facebook 开发。在某些场景下，它由于并行下载和缓存使用的方式而具有性能优势。历史上，它还强制执行了更严格的安全检查。使用
    Yarn 没有理由不可以，但 npm 在 JavaScript 社区中仍然显著更受欢迎。
- en: To learn everything there is to know about npm, you can spend some quality time
    with the [npm developer docs](https://docs.npmjs.com). You can also take a peek
    at [Yarn](https://yarnpkg.com).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关 npm 的所有内容，你可以花一些时间阅读[npm 开发者文档](https://docs.npmjs.com)。你还可以看看[Yarn](https://yarnpkg.com)。
- en: 'Extra: Understanding package.json'
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'Extra: 理解 package.json'
- en: The *package.json* file is an application configuration file that was introduced
    with Node, but is now used for a variety of purposes. It stores descriptive information
    about your project, its creator, and its license, which becomes important if you
    ever decide to publish your project as a package on npm (a topic covered in [“Converting
    Your Library into a Node Module”](ch18.html#converting_library_node_module)).
    The *package.json* file also tracks your dependencies (the packages your application
    uses) and can store extra configuration steps for debugging and deployment.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '*package.json* 文件是一个应用程序配置文件，最初是与 Node 引入的，但现在用于各种目的。它存储有关您的项目、其创建者和许可的描述信息，如果您决定将项目作为
    npm 包发布（在[“将您的库转换为 Node 模块”](ch18.html#converting_library_node_module)中讨论的一个主题），这些信息变得非常重要。*package.json*
    文件还跟踪您的依赖项（应用程序使用的包），并且可以存储用于调试和部署的额外配置步骤。'
- en: 'It’s a good practice to begin by creating a *package.json* file whenever you
    start a new project. You can create the file by hand, or using the `npm init -y`
    command, which is what we use in the examples in this chapter. Your newly generated
    file will look something like this (assuming your project folder is named *test_site*):'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始新项目时创建 *package.json* 文件是一个良好的实践。您可以手动创建该文件，或使用 `npm init -y` 命令，这是本章示例中使用的命令。您新生成的文件将类似于这样（假设您的项目文件夹名为
    *test_site*）：
- en: '[PRE17]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you may notice, the *package.json* file uses the JSON (JavaScript Object
    Notation) format. It holds a comma-separated list of property settings, all wrapped
    inside `{}` braces. You can edit *package.json* in your code editor at any time.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，*package.json* 文件使用 JSON（JavaScript 对象表示法）格式。它保存了一个用逗号分隔的属性设置列表，全部包裹在
    `{}` 大括号中。您可以随时在代码编辑器中编辑 *package.json*。
- en: 'When you install a package with npm, that dependency is recorded in *package.json*
    using a property named `dependencies`. For example, if you install Lodash, the
    *package.json* file will look like this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用 npm 安装包时，该依赖项将使用名为 `dependencies` 的属性记录在 *package.json* 中。例如，如果安装了 Lodash，*package.json*
    文件将如下所示：
- en: '[PRE18]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Don’t confuse *package.json* with *package-lock.json*. The *package.json* file
    stores basic project settings and lists all the packages you use. The *package-lock.json*
    file specifies the exact version and checksum of every package you use (and the
    version and checksum of each package *those* packages use). For example, here’s
    the automatically created *package-lock.json* file after you install Lodash:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将 *package.json* 与 *package-lock.json* 搞混了。*package.json* 文件存储基本的项目设置，并列出您使用的所有包。*package-lock.json*
    文件指定了您使用的每个包的确切版本和校验和（以及每个这些包使用的包的版本和校验和）。例如，这是您安装 Lodash 后自动生成的 *package-lock.json*
    文件：
- en: '[PRE19]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In other words, *package-lock.json* “locks” your packages to a specific version.
    This is useful if you’re deploying your project to another computer, and you want
    to install exactly the same versions of every package that you used during development.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，*package-lock.json* “锁定”您的包到特定的版本。如果您要将项目部署到另一台计算机，并且希望安装与开发期间完全相同的每个包的确切版本，这将非常有用。
- en: There are two common reasons you might edit your application’s *package.json*
    file. First, you might want to add more descriptive details for completeness before
    you share the project with anyone else. You’ll definitely want to make sure this
    information is correct if you’re planning to share your package in the npm registry
    ([“Converting Your Library into a Node Module”](ch18.html#converting_library_node_module)).
    Second, you might decide to configure command-line tasks for debugging, like starting
    a test server ([“Setting Up a Local Test Server”](#setting_up_test_server)). For
    a complete, property-by-property description of what you can put in *package.json*,
    refer to the [npm documentation](https://oreil.ly/n9PkO).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会编辑应用程序的 *package.json* 文件有两个常见的原因。首先，您可能希望在与其他人分享项目之前添加更多描述性细节。如果您计划在 npm
    注册表中共享您的包，确保这些信息是正确的是非常重要的（在[“将您的库转换为 Node 模块”](ch18.html#converting_library_node_module)中讨论）。其次，您可能决定配置命令行任务以进行调试，比如启动测试服务器（[“设置本地测试服务器”](#setting_up_test_server)）。关于可以放入
    *package.json* 的每个属性的完整逐属性描述，请参阅 [npm 文档](https://oreil.ly/n9PkO)。
- en: Updating a Package with npm
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 npm 更新包
- en: Problem
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to update an npm package to a newer version.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望将 npm 包更新到更新的版本。
- en: Solution
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'For minor updates, use `npm update`. You can name the specific package you
    want to update, or ask npm to check for new versions of *every* package your site
    uses, and update them all in one fell swoop:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 对于次要更新，请使用 `npm update`。您可以指定要更新的特定包，或要求 npm 检查您站点使用的 *每个* 包的新版本，并一次性更新它们：
- en: '[PRE20]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: npm will examine the *package.json* file and update every dependency and subdependency.
    It will also download any missing packages. Finally, it will update the *package-lock.json*
    file to match the new versions.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: npm 将检查 *package.json* 文件并更新每个依赖项和子依赖项。它还会下载任何缺失的包。最后，它会更新 *package-lock.json*
    文件以匹配新版本。
- en: Discussion
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: It’s a good practice to regularly update the packages you use. However, not
    all updates can happen automatically. npm updates follow the rules of *semver*
    (semantic versioning). npm will install updates that have greater patch numbers
    (for example, updating `2.1.2` to `2.1.3`) or minor version numbers (`2.1.2` to
    `2.2.0`), but it won’t upgrade a dependency if the new release changes the major
    version number (`2.1.2` to `3.0.0`). This behavior guards against breaking changes
    when you update or deploy your application.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 定期更新您使用的包是一个好习惯。但是，并非所有更新都可以自动进行。npm 更新遵循 *semver*（语义化版本控制）规则。npm 将安装具有更高补丁号（例如，从
    `2.1.2` 更新到 `2.1.3`）或次要版本号（从 `2.1.2` 更新到 `2.2.0`）的更新，但如果新版本更改了主要版本号（从 `2.1.2`
    更新到 `3.0.0`），则不会升级依赖关系。这种行为可以防止更新或部署应用程序时发生重大变化。
- en: 'You can review what updates are available for all of your dependencies using
    the `npm outdated` command:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `npm outdated` 命令查看所有依赖项的可用更新情况：
- en: '[PRE21]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This produces output like this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生如下输出：
- en: '[PRE22]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `Wanted` column shows available updates that will be installed the next
    time you run `npm update`. The `Latest` column shows the most recent version of
    the package. In the example above, both `lodash` and `eslint` can be updated to
    the latest package version. But the `eslint-plugin-promise` package will only
    be updated to version 4.3.1\. The latest version, 5.1.0, changes the major version
    number, which means that according to the rules of semver it can’t be applied
    automatically.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`Wanted` 列显示下次运行 `npm update` 时将安装的可用更新。`Latest` 列显示包的最新版本。在上面的示例中，`lodash`
    和 `eslint` 都可以更新到最新的包版本。但 `eslint-plugin-promise` 包仅能更新到版本 4.3.1。最新版本 5.1.0 更改了主要版本号，这意味着根据
    semver 规则，它无法自动应用。'
- en: Note
  id: totrans-230
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This is a slight simplification, because npm gives you the ability to specify
    versioning policies more specifically in the *package.json* file. But in practice,
    this is the way that almost all npm updates will work. For more information about
    npm versioning, see [the npm documentation](https://oreil.ly/NX8js).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个轻微简化，因为 npm 允许您在 *package.json* 文件中更具体地指定版本策略。但在实际操作中，这几乎是所有 npm 更新的工作方式。有关
    npm 版本控制的更多信息，请参阅 [npm 文档](https://oreil.ly/NX8js)。
- en: If you want to update a dependency to use a new major version, you need to do
    it deliberately. Options include editing the *package.json* file by hand (slightly
    painful) or using a tool that can do it for you, like [`npm-check-updates`](https://oreil.ly/0JcMt).
    The `npm-check-updates` tool allows you to review your dependencies, see what
    updates are available, and choose to update the *package.json* file to allow a
    new major version update. Once you’ve done that, call `npm update` to download
    the new version.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要将依赖项更新为使用新的主要版本，请故意执行此操作。选项包括手动编辑 *package.json* 文件（略显繁琐）或使用像 [`npm-check-updates`](https://oreil.ly/0JcMt)
    这样的工具来执行此操作。`npm-check-updates` 工具允许您查看依赖关系、查看可用的更新并选择更新 *package.json* 文件以允许新的主要版本更新。完成后，调用
    `npm update` 下载新版本。
- en: Setting Up a Local Test Server
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置本地测试服务器
- en: Problem
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to test your web pages during development, without local security restrictions,
    and without deploying them to a live web server.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望在开发过程中测试网页，无需本地安全限制，并且无需将其部署到实时 Web 服务器上。
- en: Solution
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Install a local test server on your computer. The test server will handle requests
    and send web pages to your browser, just like a real web server. The only difference
    is that the test server won’t accept remote connections from other computers.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机上安装一个本地测试服务器。测试服务器将处理请求并像真实 Web 服务器一样向浏览器发送网页。唯一的区别是测试服务器不会接受来自其他计算机的远程连接。
- en: There are many choices for a test server (see the Discussion section). However,
    two simple, reliable choices are the `http-server` and `lite-server` packages
    that you can install through npm. We use `lite-server` here, because it adds a
    live update feature that automatically refreshes the page in the browser when
    you save changed code in your editor.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多选择可用于测试服务器（请参阅讨论部分）。然而，两个简单可靠的选择是您可以通过npm安装的`http-server`和`lite-server`软件包。我们在这里使用`lite-server`，因为它添加了一个实时更新功能，当您在编辑器中保存更改的代码时，它会自动刷新浏览器中的页面。
- en: 'Before you install `lite-server`, it helps to have a sample web page to request.
    If you haven’t already done so, make a project folder and configure it with the
    `npm init -y` command ([“Downloading a Package with npm”](#installing_npm_package)).
    Then, add a file named *index.html* with a basic content. If you’re in a hurry,
    here’s a minimal but valid HTML document you can use to test where your code is
    running:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装`lite-server`之前，最好准备一个示例网页以请求。如果您还没有这样做，请创建一个项目文件夹，并使用`npm init -y`命令进行配置（[“使用npm下载软件包”](#installing_npm_package)）。然后，添加一个名为*index.html*的文件，并包含基本内容。如果您赶时间，这里是一个最小但有效的HTML文档，您可以用来测试您的代码在哪里运行：
- en: '[PRE23]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now you’re ready to make this document accessible to your browser through a
    test server.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经准备好通过测试服务器使此文档对您的浏览器可访问。
- en: To install `lite-server`, use npm with the `--save-dev` option. That way it’s
    marked as a *developer dependency* that won’t be deployed in a production build.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装`lite-server`，请使用npm并使用`--save-dev`选项。这样它被标记为*开发人员依赖项*，不会在生产构建中部署。
- en: '[PRE24]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now you can run `lite-server` directly from a terminal window using npm’s package
    runner, `npx`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以直接从终端窗口使用npm的软件包运行器`npx`运行`lite-server`：
- en: '[PRE25]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This launches `lite-server`, opens a new browser tab, and requests *http://localhost:3000*
    (where `3000` is whatever port `lite-server` acquires dynamically). The `lite-server`
    attempts to return *index.html*, or just displays “Cannot GET /” if you don’t
    have a file with that name. If you used the sample page from this section, you’ll
    see the “This is the index page” message on the page and “Running on a local server”
    in the developer console. If you don’t have an *index.html* page in your test
    site, you can load up a different page by editing the URL in the address bar (for
    example, *http://localhost:3000/someOtherPage.html*).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动`lite-server`，打开一个新的浏览器选项卡，并请求*http://localhost:3000*（其中`3000`是`lite-server`动态获取的端口）。`lite-server`会尝试返回*index.html*，或者如果您没有具有该名称的文件，则显示“Cannot
    GET /”。如果您使用本节中的示例页面，您将在页面上看到“这是索引页面”消息，并在开发者控制台中看到“在本地服务器上运行”。如果您的测试站点中没有*index.html*页面，您可以通过编辑地址栏中的URL加载不同的页面（例如，*http://localhost:3000/someOtherPage.html*）。
- en: Now try making some changes. The `lite-server` instance watches your project
    folder. Whenever you change a file, it automatically forces the browser to refresh
    the page. In the terminal, you’ll see a “Reloading Browsers” message whenever
    this happens.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试进行一些更改。`lite-server`实例会监视您的项目文件夹。每当您更改文件时，它会自动强制浏览器刷新页面。在终端中，每当发生这种情况时，您会看到“Reloading
    Browsers”消息。
- en: To end the server, press Ctrl+C at the terminal (Command-C on a Macintosh) and
    answer `Y`. Or, close the terminal window (or use the Kill Terminal trashcan icon
    in VS Code).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 要结束服务器，请在终端上按Ctrl+C（Macintosh上为Command-C）并回答`Y`。或者，关闭终端窗口（或在VS Code中使用Kill Terminal垃圾桶图标）。
- en: Note
  id: totrans-249
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Behind the scenes, `lite-server` uses a popular browser automation tool called
    [BrowserSync](https://oreil.ly/tAwyk) to implement its live reloading. The only
    requirement is that your web page must have a `<body>` section. (Create a super-simple
    test page without that detail, and you won’t see the automatic refreshing behavior.)
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，`lite-server`使用一种名为[BrowserSync](https://oreil.ly/tAwyk)的流行浏览器自动化工具来实现其实时重新加载功能。唯一的要求是您的网页必须有一个`<body>`部分。（创建一个没有这个细节的超级简单测试页面，您将看不到自动刷新行为。）
- en: Discussion
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: You can save a web page on your local computer, open it in a web browser, and
    run its code. However, web browsers greatly restrict pages that are opened from
    the local filesystem. Entire features are unavailable and will fail quietly (like
    web workers, ES modules, and certain Canvas operations). To avoid hitting these
    security barriers or—even worse—being confused at why code isn’t working the way
    you expect, it’s always better to run your web pages from a test web server.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将网页保存在本地计算机上，在Web浏览器中打开并运行其代码。然而，Web浏览器会严格限制从本地文件系统打开的页面。整个功能将不可用，并且会悄无声息地失败（如Web
    Workers、ES模块和某些Canvas操作）。为了避免遇到这些安全障碍，甚至更糟糕的是，对代码为何不按预期工作感到困惑，最好总是从测试Web服务器运行您的网页。
- en: While testing, it’s common to use a development server. There are many options,
    and your decision will depend somewhat on the other server-side technologies that
    you plan to use. For example, if you want to run PHP code in your web pages, you’ll
    need a web server that supports it. If you plan to build part of the backend of
    your application using JavaScript or a JavaScript-powered server-side framework
    like Express, you’ll need to use Node.js. But if you’re running web pages with
    traditional client-side JavaScript, a simple server that sends static files is
    enough, like `http-server` or `lite-server`. There are many more and code editors
    often have their own plug-in-based test server. For example, if you’re using Visual
    Studio Code you can search the extension library for the popular [Live Server
    plug-in](https://oreil.ly/NIrRK).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试时，通常会使用开发服务器。有许多选择，您的决定在某种程度上将取决于您计划使用的其他服务器端技术。例如，如果您想在网页中运行PHP代码，您将需要一个支持它的Web服务器。如果您计划使用JavaScript或JavaScript驱动的服务器端框架（如Express）构建应用程序的后端的一部分，您将需要使用Node.js。但是，如果您正在运行传统客户端JavaScript的网页，那么一个发送静态文件的简单服务器就足够了，比如`http-server`或`lite-server`。还有许多其他选项，代码编辑器通常有自己基于插件的测试服务器。例如，如果您使用Visual
    Studio Code，您可以搜索扩展库以找到流行的[Live Server插件](https://oreil.ly/NIrRK)。
- en: 'In the Solution section, you saw how to run `lite-server` with `npx`. However,
    a more convenient setup is to make a *development run task* that automatically
    starts the server. You can do that by editing the *package.json* file and adding
    the following instruction to the `scripts` section:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案部分，您看到了如何使用`npx`运行`lite-server`。然而，更方便的设置是创建一个*开发运行任务*，自动启动服务器。您可以通过编辑*package.json*文件并将以下指令添加到`scripts`部分来实现这一点：
- en: '[PRE26]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `scripts` section holds executable tasks that you want to run regularly.
    These might include verifying your code with a linter, checking it into source
    control, packaging your files for deployment, or running a unit test. You can
    add as many scripts as you need—for example, it’s common to use one task to run
    your application, another to test it with an automated testing tool ([“Writing
    Unit Tests for Your Code”](ch10.html#unit_testing)), another to prepare it for
    distribution, and so on. In this example, the script is named `dev`, which is
    a convention that identifies a task you plan to use while developing your application.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`scripts`部分包含您希望定期运行的可执行任务。这些任务可能包括使用代码检查器验证代码、将代码提交到源代码控制、为部署打包文件或运行单元测试。您可以根据需要添加尽可能多的脚本——例如，通常使用一个任务来运行应用程序，另一个任务使用自动化测试工具进行测试（[“为您的代码编写单元测试”](ch10.html#unit_testing)），另一个任务准备分发等。在此示例中，脚本命名为`dev`，这是一种约定，用于标识您在开发应用程序时计划使用的任务。'
- en: 'Once you’ve defined a script in *package.json*, you can run it with the `npm
    run` command at the terminal:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您在*package.json*中定义了一个脚本，您可以在终端上使用`npm run`命令运行它：
- en: '[PRE27]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This launches `lite-server` with `npx`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用`npx`启动`lite-server`。
- en: Some code editors have additional support for this configuration detail. For
    example, if you open the *package.json* file in VS Code you’ll see that a “Debug”
    link is added just above the `dev` setting. Click this link and VS Code opens
    a new terminal and launches `lite-server` automatically.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 一些代码编辑器对此配置细节有额外的支持。例如，如果您在VS Code中打开*package.json*文件，您会看到在`dev`设置的正上方添加了一个“Debug”链接。单击此链接，VS
    Code将打开一个新终端并自动启动`lite-server`。
- en: See Also
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: To learn more about using Node as a test server, see the recipes in [Chapter 17](ch17.html#ch17).
    For more information about running tasks with npm, you can read [this good overview](https://oreil.ly/nq31H).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于使用Node作为测试服务器的信息，请参阅[第17章](ch17.html#ch17)中的示例。有关使用npm运行任务的更多信息，您可以阅读[这篇很好的概述](https://oreil.ly/nq31H)。
- en: Enforcing Code Standards with a Linter
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Linter强制执行代码标准
- en: Problem
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to standardize your JavaScript code, follow best practices, and avoid
    common pitfalls that can lead to bugs.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望规范化您的JavaScript代码，遵循最佳实践，并避免可能导致错误的常见陷阱。
- en: Solution
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Check your code with a *linter*, which warns you when you deviate from the rules
    you’ve chosen to follow. The most popular JavaScript linter is ESLint.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*linter*检查您的代码，当您偏离所选择的规则时会收到警告。最受欢迎的JavaScript linter是ESLint。
- en: 'To use ESLint, you first need npm (see [“Installing the npm Package Manager
    (with Node.js)”](#installing_node_npm)). Open a terminal window in your project
    folder. If you haven’t already created the *package.json* file, get npm to create
    it now:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用ESLint，您首先需要npm（请参阅[“安装npm软件包管理器（带Node.js）”](#installing_node_npm)）。在项目文件夹中打开一个终端窗口。如果您还没有创建*package.json*文件，请让npm现在创建它：
- en: '[PRE28]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, install the `eslint` package using the `--save-dev` option, because you
    want ESLint to be a *developer dependency* that’s installed on developer computers,
    but not deployed to a production server:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用`--save-dev`选项安装`eslint`包，因为您希望ESLint成为*开发人员依赖项*，安装在开发人员计算机上，但不部署到生产服务器上：
- en: '[PRE29]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If you don’t already have an ESLint configuration file, you need to create
    one now. Use npx to run the ESLint setup:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有ESLint配置文件，现在需要创建一个。使用npx运行ESLint设置：
- en: '[PRE30]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ESLint will ask you a series of questions to assess the type of rules it should
    enforce. Often, it presents a small menu of choices, and you must use the arrow
    keys to pick the option you want.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ESLint会询问您一系列问题，以评估应该强制执行的规则类型。通常，它会呈现一个小菜单供选择，您必须使用箭头键选择您想要的选项。
- en: 'The first question is “How would you like to use ESLint?” Here you have three
    options, arranged from least strict to most strict:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题是“您希望如何使用ESLint？”这里有三个选项，从最不严格到最严格排列：
- en: Check syntax only
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 仅检查语法
- en: Uses ESLint to catch errors. It’s not any stricter than the error-highlighting
    feature in most code editors.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ESLint来捕捉错误。它并不比大多数代码编辑器中的错误突出功能更严格。
- en: Check syntax and find problems
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 检查语法并找出问题
- en: Enforces [ESLint’s recommended practices](https://eslint.org/docs/rules) (the
    ones marked with a checkmark). This is an excellent starting point, and you can
    override individual rules to your preference later on.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 强制执行[ESLint推荐的实践](https://eslint.org/docs/rules)（标有复选标记的实践）。这是一个很好的起点，您可以稍后根据个人喜好覆盖单个规则。
- en: Check syntax, find problems, and enforce code style
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 检查语法，找出问题，并强制执行代码风格
- en: Is a good choice if you want to use a specific JavaScript style guide, like
    [Airbnb](https://github.com/airbnb/javascript), to enforce a broader set of style
    conventions. If you choose this option, you’ll be asked to pick the style guide
    later in the process.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用特定的JavaScript样式指南，比如[Airbnb](https://github.com/airbnb/javascript)，来强制执行更广泛的样式约定，那么这是一个不错的选择。如果选择此选项，您将在后续过程中被要求选择样式指南。
- en: 'Next, you’ll be asked a series of technical questions: are you using modules,
    the React or Vue framework, or the TypeScript language? Choose JavaScript modules
    to get support for the ES6 modules standard described in [“Organizing Your JavaScript
    Classes with Modules”](ch08.html#using_es6_modules), and choose No for other questions
    unless you’re using the technology in question.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将被问及一系列技术问题：您是否使用模块，React或Vue框架，或TypeScript语言？选择JavaScript模块以获得对[“使用ES6模块组织您的JavaScript类”](ch08.html#using_es6_modules)中描述的ES6模块标准的支持，并对其他问题选择No，除非您正在使用相关技术。
- en: Next, you’ll be asked “Where does your code run?” Choose Browser for a traditional
    website with client-side JavaScript code (the usual), or Node if you’re building
    a server-side application that runs in the Node.js server.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将被问及“您的代码在哪里运行？”如果您正在构建在Node.js服务器中运行的服务器端应用程序，则选择Node；如果您构建传统网站使用客户端JavaScript代码（通常情况），则选择Browser。
- en: If you’ve chosen to use a style guide, JavaScript will now prompt you to pick
    one from a small list of choices. It then installs these rules automatically using
    one or more separate packages, provided you allow it.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择使用样式指南，JavaScript现在会提示您从一个小列表中选择一个。然后，它会自动安装这些规则，使用一个或多个单独的包，前提是您允许它。
- en: Finally, ESLint asks “What format do you want your config file to be in?” All
    the format choices work equally well. We prefer to use JSON for symmetry with
    the *package.json* file, in which case ESList stores its configuration in a file
    named *.eslintrc.json*. If you use a JavaScript configuration file, the extension
    is *.js*, and if you choose a YAML configuration file, the extension is *.yaml*.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，ESLint会问：“您希望配置文件采用什么格式？”所有格式选择都同样有效。我们倾向于使用JSON以与*package.json*文件对称，此时ESList会将其配置存储在名为*.eslintrc.json*的文件中。如果您使用JavaScript配置文件，则扩展名为*.js*，如果选择YAML配置文件，则扩展名为*.yaml*。
- en: 'Here’s what you’ll see in the *.eslintrc.json* file if you’ve asked ESLint
    to “check syntax and find problems” without the addition of a separate style guide:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已要求ESLint“检查语法并找出问题”，而没有添加单独的样式指南，那么在*.eslintrc.json*文件中将看到以下内容：
- en: '[PRE31]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now you can ESLint to check your files in the terminal:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以在终端中使用ESLint来检查您的文件：
- en: '[PRE32]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: But a far more practical option is to use a plug-in that integrates ESLint with
    your code editor. All the code editors introduced in [“Choosing a Code Editor”](#choosing_code_editor)
    support ESLint, and you can browse the full list of [ESLint-supporting plug-ins](https://oreil.ly/isQMA).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 但更实际的选择是使用将 ESLint 与您的代码编辑器集成的插件。所有在 [“选择代码编辑器”](#choosing_code_editor) 中介绍的代码编辑器都支持
    ESLint，并且您可以浏览 [支持 ESLint 的插件](https://oreil.ly/isQMA) 的完整列表。
- en: 'To add ESLint to your code editor, go to its plug-in library. For example,
    in Visual Studio Code you begin by clicking **Extensions** in the left panel,
    and then searching the library for “eslint,” then clicking **Install**. Once you’ve
    installed ESLint, you will need to officially allow it through the plug-in’s settings
    page (or by clicking the lightbulb icon that appears when you open a code file
    in the editor, and then choosing **Allow**). You may also need to install ESLint
    globally across your entire computer so the plug-in can find it:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 ESLint 添加到您的代码编辑器中，请转到其插件库。例如，在 Visual Studio Code 中，您可以从左侧面板中点击 **Extensions**，然后搜索库中的
    “eslint”，然后点击 **Install**。安装完 ESLint 后，您需要通过插件的设置页面正式允许它（或者在编辑器中打开代码文件时点击出现的灯泡图标，然后选择
    **Allow**）。您可能还需要在整个计算机上全局安装 ESLint，以便插件可以找到它：
- en: '[PRE33]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Once ESLint is enabled, you’ll see the squiggly underlines that denote ESLint
    errors and warnings. [Figure 1-4](#vs_eslint) shows an example where ESLint detects
    a `case` in a `switch` statement that falls through to the next `case`, which
    isn’t allowed in ESLint’s standard settings. The “eslint” label in the pop-up
    identifies that this message is from the ESLint plug-in, not VS Code’s standard
    error checking.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启用 ESLint，您将看到标志着 ESLint 错误和警告的波浪线。[图 1-4](#vs_eslint) 显示了一个示例，在此示例中，ESLint
    检测到一个 `switch` 语句中的 `case` 没有跳出到下一个 `case`，这在 ESLint 的标准设置中是不允许的。弹出窗口中的 “eslint”
    标签标识出这条消息来自 ESLint 插件，而不是 VS Code 的标准错误检查。
- en: Note
  id: totrans-294
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If ESLint isn’t catching the issues that you expect it to catch, it could be
    due to *another* error in your file, possibly even one in a different section
    of code. Try resolving any outstanding issues, and then recheck your file.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 ESLint 没有捕获您预期的问题，这可能是因为文件中的 *另一个* 错误，甚至可能是代码的不同部分。尝试解决任何未解决的问题，然后重新检查您的文件。
- en: '![jsc3 0104](assets/jsc3_0104.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![jsc3 0104](assets/jsc3_0104.png)'
- en: Figure 1-4\. ESLint flags an error in VS Code
  id: totrans-297
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-4\. ESLint 在 VS Code 中标记了一个错误
- en: 'Click **Quick Fix** (or the lightbulb icon in the margin) to learn more about
    the problem or attempt a fix (if possible). You can also disable checking for
    this issue in the current line or file, in which case your override is recorded
    in a special comment. For example, this disables the rule against declaring variables
    that you don’t use:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **Quick Fix**（或边栏中的灯泡图标）以了解更多有关问题或尝试修复（如果可能）。您还可以禁用当前行或文件中的此问题检查，在这种情况下，您的覆盖将记录在特殊注释中。例如，这会禁用对未使用变量进行声明的规则：
- en: '[PRE34]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If you must override ESLint with comments, it’s probably best to be as targeted
    and judicious as possible. Instead of disabling checking for an entire file, override
    it for a single, specific line, like this:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果必须通过注释覆盖 ESLint，则最好尽可能具体和审慎。与其禁用整个文件的检查，不如只为单个特定行覆盖它，就像这样：
- en: '[PRE35]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'or this (replacing `eslint-disable-next-line` with `eslint-disable-line`):'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 或者（将 `eslint-disable-next-line` 替换为 `eslint-disable-line`）：
- en: '[PRE36]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If you want to resume checking for the issue, just remove the comment.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要恢复对问题的检查，只需移除注释。
- en: Discussion
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: JavaScript is a permissive language that gives developers a great deal of flexibility.
    Sometimes this flexibility can lead to problems. For example, it can hide errors
    or cause ambiguity that makes the code harder to understand. A linter works to
    prevent these problems by enforcing a range of standards, even if they don’t correspond
    to outright errors. It flags potential issues in the making, and suspicious practices
    that don’t trigger your code editor’s error checker but may eventually come back
    to haunt you.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 是一种宽容的语言，为开发人员提供了很大的灵活性。有时，这种灵活性可能会导致问题。例如，它可能隐藏错误或导致代码更难理解的歧义。通过实施一系列标准，即使它们不对应明显错误，代码检查器也可以通过防止这些问题来工作。它会标记潜在的问题和可疑做法，这些做法不会触发您的代码编辑器的错误检查，但最终可能会回来困扰您。
- en: ESLint is an *opinionated* linter, which means it flags issues that you may
    not consider problems, like variables you declare but don’t use, parameter values
    you change in a function, empty conditional blocks, and regular expressions that
    include literal spaces (to name just a few). If you want to allow some of these,
    you have the power to override any of these settings in the ESLint configuration
    file (or on a file-by-file or line-by-line basis with a comment). But usually
    you’ll just decide to change your ways to get along, knowing that ESLint’s choices
    will eventually avoid a future headache.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: ESLint是一种*主观*的linter，这意味着它会标记您可能不认为是问题的问题，比如您声明但未使用的变量、您在函数中更改的参数值、空条件块以及包含文字空格的正则表达式（仅举几例）。如果您希望允许其中一些问题，您可以在ESLint配置文件中（或通过文件或逐行基础的注释）覆盖任何设置。但通常您只需改变您的方式来避免未来的麻烦，因为ESLint的选择最终会避免未来的问题。
- en: ESLint also has the ability to correct certain types of errors automatically,
    and enforce style conventions (like tabs versus spaces, single quotes versus double
    quotes, brace and indent styles, and so on). Using the ESLint plug-in for an editor
    like VS Code, you can configure it to perform these corrections automatically
    when you save your file. Or, you can use ESLint to flag potential problems only,
    and use a formatter ([“Styling Code Consistently with a Formatter”](#using_prettier))
    to enforce code style conventions.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: ESLint还具有自动纠正某些类型错误的能力，并强制执行样式约定（如制表符与空格、单引号与双引号、大括号和缩进样式等）。使用VS Code等编辑器的ESLint插件，可以在保存文件时自动配置它执行这些纠正。或者，您可以仅使用ESLint标记潜在问题，并使用格式化程序（[“使用格式化程序一致地设计代码”](#using_prettier)）来强制执行代码样式约定。
- en: If you work in a team, you may simply receive a preordained ESLint configuration
    file to use. If not, you need to decide which set of ESLint defaults to follow.
    You can lean more about [ESLint recommended set](https://eslint.org/docs/rules)
    (used in this recipe), which provides examples of nonconforming code for every
    issue the ESLint can check. If you want to use a more thorough JavaScript style
    guide, we recommend the popular [Airbnb JavaScript Style Guide](https://github.com/airbnb/javascript),
    which can be installed automatically with `eslint -init`.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在团队中工作，可能会收到一个预先配置好的ESLint配置文件来使用。如果没有，你需要决定要遵循哪一套ESLint默认设置。你可以了解更多关于[ESLint推荐的设置](https://eslint.org/docs/rules)（在这个教程中使用），它提供了每个ESLint可以检查的问题的不符合规范的代码示例。如果你想使用更详细的JavaScript样式指南，我们推荐流行的[Airbnb
    JavaScript样式指南](https://github.com/airbnb/javascript)，可以通过`eslint -init`自动安装。
- en: Styling Code Consistently with a Formatter
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用格式化程序一致地设计代码
- en: Problem
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to format your JavaScript consistently to improve readability and reduce
    ambiguity.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 想要保持JavaScript的一致格式以提高可读性并减少歧义。
- en: Solution
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the Prettier code formatter to automatically format your code according
    to the rules you’ve established. Prettier enforces consistency on style details
    like indentation, use of single and double quotes, spacing inside brackets, spacing
    for function parameter lists, and the wrapping of long code lines. But unlike
    a linter ([“Enforcing Code Standards with a Linter”](#using_eslint)), Prettier
    doesn’t flag these issues for you to fix them. Instead, it applies its formatting
    automatically every time you save your JavaScript code, HTML markup, or CSS style
    rules.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Prettier代码格式化程序根据您制定的规则自动格式化代码。Prettier强制执行一致的样式细节，如缩进、单双引号使用、括号内的空格、函数参数列表的空格以及长代码行的换行方式。但与linter不同（[“使用ESLint强制执行代码标准”](#using_eslint)），Prettier不会标记这些问题以供您解决。相反，每次保存JavaScript代码、HTML标记或CSS样式规则时，它都会自动应用其格式。
- en: Although Prettier exists as a package you can install with npm and use at the
    command line, it’s much more useful to use a plug-in for your code editor. All
    the code editors introduced in [“Choosing a Code Editor”](#choosing_code_editor)
    have a Prettier plug-in. Most of them are listed [at the Prettier website](https://oreil.ly/weRb5).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Prettier作为一个可以通过npm安装并在命令行中使用的包存在，但在代码编辑器中使用插件要更为实用。在[“选择代码编辑器”](#choosing_code_editor)介绍的所有代码编辑器中，都有Prettier插件。大部分列在[Prettier网站](https://oreil.ly/weRb5)上。
- en: To add Prettier to your code editor, go to its plug-in library. For example,
    in Visual Studio Code you click **Extensions** in the left panel, search the library
    for “prettier,” and then click **Install**.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 要将Prettier添加到您的代码编辑器中，请转到其插件库。例如，在Visual Studio Code中，您点击左侧面板的**Extensions**，搜索“prettier”库，然后点击**Install**安装。
- en: Once you’ve installed Prettier, you’ll be able to use it when you’re editing
    a code file. Right-click next to your code in the editor and choose **Format Document**.
    You can configure the plug-in settings to change a small set of options (like
    the maximum allowed width before code lines are split, and whether you prefer
    spaces to tabs).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了Prettier，您在编辑代码文件时就可以使用它。右键单击编辑器中代码旁边，并选择**格式化文档**。您可以配置插件设置来更改一小部分选项（例如允许代码行分割的最大宽度，以及您是否更喜欢空格而不是制表符）。
- en: Tip
  id: totrans-318
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: In VS Code, you can also configure Prettier to run automatically every time
    you save a file. To activate this behavior, choose **File > Preferences > Settings**,
    go to the **Text Editor > Formatting** section, and choose **Format On Save**.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在VS Code中，您还可以配置Prettier在每次保存文件时自动运行。要激活此行为，请选择**文件 > 首选项 > 设置**，转到**文本编辑器 >
    格式设置**部分，并选择**保存时格式化**。
- en: Discussion
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Although many code editors have their own automatic formatting features, a code
    formatter goes beyond these. For example, the Prettier formatter strips away any
    custom formatting. It parses all the code and reformats it according to the conventions
    you’ve set, with almost no consideration to how it was originally written. (Blank
    lines and object literals are the only two exceptions.) This approach guarantees
    that the same code is always presented in the same way, and that code from different
    developers is completely consistent. And like a linter, the rules for a code formatter
    are defined in a configuration file, which means you can easily distribute them
    to different members of a team, even if they’re using different code editors.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管许多代码编辑器都有其自己的自动格式化功能，但代码格式化程序超越了这些功能。例如，Prettier格式化程序会去除任何自定义格式。它解析所有代码并根据您设置的约定重新格式化代码，几乎不考虑其原始编写方式（空行和对象文字是唯二的例外）。这种方法保证了相同的代码始终以相同的方式呈现，并且来自不同开发者的代码完全一致。而像linter一样，代码格式化程序的规则是在配置文件中定义的，这意味着您可以轻松地将它们分发给团队的不同成员，即使他们使用不同的代码编辑器。
- en: 'The Prettier formatter takes particular care with line breaks. By default,
    the maximum line length is set to 80, but Prettier will allows some lines to stretch
    a bit longer if it avoids a confusing line break. And if a line break is required,
    Prettier does it intelligently. For example, it would prefer to fit a function
    call into one line:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: Prettier格式化程序特别关注换行。默认情况下，最大行长度设置为80，但如果可以避免混乱的换行，Prettier将允许一些行略长一些。如果需要换行，Prettier会以智能方式处理。例如，它更愿意将函数调用放在一行中：
- en: '[PRE37]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'But if that isn’t practical, it doesn’t just wrap the code however it fits.
    It chooses the most pleasing arrangement it understands:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果这不太实际，它不会随便将代码包装起来。它会选择它理解的最合适的排列方式：
- en: '[PRE38]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Of course, no matter how intelligent a formatter like Prettier is, you may prefer
    your own idiosyncratic code arrangements. It’s sometimes said that “Nobody loves
    what Prettier does to their syntax. Everyone loves what Prettier does to their
    coworkers’ syntax.” In other words, the value of an aggressive, opinionated formatter
    like Prettier is the way it unifies different developers, cleans up legacy code,
    and irons out bizarre habits. And if you decide to use Prettier, you’ll have the
    unchecked freedom to write your code without thinking about spacing, line breaks,
    or presentation. In the end, your code will still be converted to the same canonical
    form.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，无论Prettier这样的格式化程序有多聪明，您可能更喜欢自己特有的代码布局。有时人们说“没有人喜欢Prettier对他们的语法所做的事情。每个人都喜欢Prettier对他们同事的语法所做的事情。”换句话说，像Prettier这样具有攻击性和主观见解的格式化程序的价值在于它统一了不同开发者的风格，清理了旧代码，并消除了奇怪的习惯。如果您决定使用Prettier，您将可以自由地编写代码，而不必考虑间距、换行或排版。最终，您的代码仍将转换为相同的规范形式。
- en: Tip
  id: totrans-327
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If you’re not entirely certain that you want to use a code formatter, or you’re
    not sure how to configure its settings, spend some time in the [Prettier playground](https://oreil.ly/TKam1)
    to explore how it works.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不完全确定是否要使用代码格式化程序，或者不知道如何配置其设置，请花些时间在[Prettier playground](https://oreil.ly/TKam1)中探索其工作原理。
- en: 'A linter like ESLint and a formatter like Prettier have some overlap. However,
    their goals are different and their use is complementary. If you’re using both
    ESLint and Prettier, you should keep the ESLint rules that catch suspicious coding
    practices, but disable the ones that enforce formatting conventions about indents,
    quotes, and spacing. Fortunately, this is easy to do by adding an extra ESLint
    configuration rule that turns off potential settings that could conflict with
    Prettier. And the easiest way to do that is by adding the `eslint-config-prettier`
    package to your project:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 像 ESLint 这样的 linter 和像 Prettier 这样的格式化工具有一些重叠。然而，它们的目标不同，它们的使用是互补的。如果你同时使用 ESLint
    和 Prettier，你应该保留 ESLint 规则，这些规则可以捕获可疑的编码实践，但禁用那些强制执行格式化约定的规则，如缩进、引号和间距。幸运的是，通过添加额外的
    ESLint 配置规则，可以轻松做到这一点，这个规则可以关闭可能与 Prettier 产生冲突的设置。最简单的方法是向你的项目添加`eslint-config-prettier`包：
- en: '[PRE39]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Lastly, you need to add `prettier` to the `extends` section in your *.eslintrc.json*
    file. The `extends` section will hold a list wrapped in square brackets, and `prettier`
    should be at the very end. Here’s an example:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要在你的*.eslintrc.json*文件中的`extends`部分中添加`prettier`。`extends`部分将包含一个包含方括号的列表，`prettier`应位于最后。这里是一个例子：
- en: '[PRE40]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: To review the most recent installation instructions, check out the documentation
    for the [`eslint-config-prettier` package](https://oreil.ly/AgxiF).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看最新的安装说明，请查看[`eslint-config-prettier`包](https://oreil.ly/AgxiF)的文档。
- en: Experimenting in a JavaScript Playground
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 JavaScript 操场上进行实验
- en: Problem
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to quickly test or share a code idea without building a project and
    spinning up your desktop code editor.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望快速测试或分享一个代码想法，而不必构建一个项目并启动你的桌面代码编辑器。
- en: Solution
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use a JavaScript *playground*, which is a website where you can edit and run
    JavaScript code. There are well over a dozen JavaScript playgrounds, but [Table 1-4](#js_playgrounds)
    lists five of the most popular.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JavaScript *操场*，这是一个可以编辑和运行 JavaScript 代码的网站。超过一打的 JavaScript 操场，但[表 1-4](#js_playgrounds)列出了五个最受欢迎的。
- en: Table 1-4\. JavaScript playgrounds
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1-4。JavaScript 操场
- en: '| Website | Notes |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| 网站 | 备注 |'
- en: '| --- | --- |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [JSFiddle](https://jsfiddle.net) | Arguably the first JavaScript playground,
    JSFiddle is still at the forefront with features for simulating asynchronous calls
    and GitHub integration. |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| [JS 弹簧床](https://jsfiddle.net) | 可以说是第一个 JavaScript 操场，JS 弹簧床在模拟异步调用和 GitHub
    集成方面仍然处于领先地位。 |'
- en: '| [JS Bin](https://jsbin.com) | A classic playground with a simple tab-based
    interface that lets you pop different sections (JavaScript, HTML, CSS) into view
    one at a time. The code for JS Bin is also available as an open source project.
    |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| [JS 碎片](https://jsbin.com) | 一个经典的操场，它有一个简单的标签式界面，让你一次查看一个不同的部分（JavaScript、HTML、CSS）。JS
    碎片的代码也可作为开源项目可用。 |'
- en: '| [CodePen](https://codepen.io) | One of the more attractively designed playgrounds,
    with an emphasis on the social (popular examples are promoted in the CodePen community).
    Its polished interface is particularly suitable for novice users. |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| [CodePen](https://codepen.io) | 设计上更为出色的操场，以社交为重点（流行的例子在 CodePen 社区中被推广）。其光滑的界面特别适合新手用户。
    |'
- en: '| [CodeSandbox](http://codesandbox.io) | One of the newer playgrounds, it uses
    an IDE-like layout that feels a lot like a web-hosted version of Visual Studio
    Code. |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| [代码沙箱](http://codesandbox.io) | 其中之一的新兴操场，它使用 IDE 样式布局，感觉就像是 Visual Studio
    Code 的 Web 主机版。 |'
- en: '| [Glitch](https://glitch.com) | Another IDE-in-a-browser, Glitch is notable
    for its VS Code plug-in, which lets you switch between editing in a browser playground
    or using your desktop editor on the same project. |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| [击穿](https://glitch.com) | 另一种浏览器内 IDE，以其 VS Code 插件而闻名，你可以在浏览器操场上编辑和使用你的桌面编辑器编辑同一项目。
    |'
- en: All these JavaScript playgrounds are powerful, practical choices. They all work
    similarly, although they can look strikingly different. For example, compare the
    dense developer cockpit of JSFiddle ([Figure 1-5](#jsfiddle)) to the more spaced-out
    editor in CodePen ([Figure 1-6](#codepen)).
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些 JavaScript 操场都是强大的、实用的选择。它们的工作方式大体相同，尽管它们看起来截然不同。例如，将 JS 弹簧床的密集开发驾驶舱与 CodePen
    的更为宽敞的编辑器进行比较（[图 1-5](#jsfiddle)）。
- en: '![jsc3 0105](assets/jsc3_0105.png)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![jsc3 0105](assets/jsc3_0105.png)'
- en: Figure 1-5\. The JavaScript playground JSFiddle
  id: totrans-349
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-5。JavaScript 操场 JS 弹簧床
- en: '![jsc3 0106](assets/jsc3_0106.png)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![jsc3 0106](assets/jsc3_0106.png)'
- en: Figure 1-6\. A simple example in CodePen
  id: totrans-351
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-6。CodePen 的简单示例
- en: Here’s how you use a JavaScript playground. When you visit the site, you can
    start coding immediately at a blank page. Even though your JavaScript, HTML, and
    CSS are presented separately, you don’t need to explicitly add a `<script>` element
    to connect your JavaScript or a `<link>` element for your style sheet. These details
    are already filled into the markup of your page or, more commonly, are an implicit
    part of boilerplate that’s hidden behind the scenes.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何使用 JavaScript 游乐场的。当你访问网站时，你可以立即在一个空白页面上开始编码。尽管你的 JavaScript、HTML 和 CSS
    被分开呈现，但你不需要明确地添加一个 `<script>` 元素来连接你的 JavaScript 或一个 `<link>` 元素来连接你的样式表。这些细节已经填写到你的页面标记中，或者更常见的是，它们是隐藏在幕后的样板的一个隐含部分。
- en: All JavaScript playgrounds let you see the page you’re working on beside your
    code window. In some (like CodePen), the preview is refreshed automatically as
    you make changes. In others (like JSFiddle), you need to explicitly click a Play
    or Run button to reload your page. If you write messages with `console.log()`,
    some JavaScript playgrounds send that directly to the browser console (like CodePen),
    while others can also show it in a dedicated panel that’s visible on the page
    (like JSFiddle).
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 JavaScript 游乐场都让你在代码窗口旁边看到你正在工作的页面预览。在一些游乐场中（如 CodePen），预览会随着你的更改而自动刷新。在其他一些游乐场中（如
    JSFiddle），你需要明确点击一个播放或运行按钮来重新加载你的页面。如果你使用 `console.log()` 写消息，一些 JavaScript 游乐场会直接将其发送到浏览器控制台（如
    CodePen），而其他一些还可以在页面上可见的专用面板中显示（如 JSFiddle）。
- en: When you’re finished you can save your work, at which point you receive a newly
    generated, shareable link. However, it’s a better idea to sign up for an account
    first, so you’re able to return to the JavaScript playground, find all the examples
    you’ve created, and edit them. (If you save an example anonymously, you can’t
    edit it, although you can use it as a starting point to build another example.)
    All the playgrounds listed in [Table 1-4](#js_playgrounds) let you create an account
    and save your work for free.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成后，你可以保存你的工作，这时你会收到一个新生成的可共享链接。然而，最好先注册一个账户，这样你就能返回到 JavaScript 游乐场，找到你创建的所有示例，并对其进行编辑。（如果你匿名保存一个示例，你将无法编辑它，尽管你可以将其用作构建另一个示例的起点。）所有在
    [表 1-4](#js_playgrounds) 中列出的游乐场都允许你免费创建账户并保存你的工作。
- en: Note
  id: totrans-355
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The exact terminology for the kind of example you create in a JavaScript playground
    varies based on the site. It might be called a fiddle, a pen, a snippet, or something
    else.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 游乐场中创建的示例的确切术语因网站而异。它可能被称为 fiddle、pen、snippet 或其他内容。
- en: Discussion
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'JavaScript playgrounds are a useful idea that’s been picked up by more than
    a dozen websites. Almost all of them share some important characteristics:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 游乐场是一个被十多个网站采纳的有用概念。几乎所有这些网站都共享一些重要特征：
- en: They’re free to use. However, many have a subscription option for premium features,
    like being able to save your work and keep it private.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是免费使用的。然而，许多网站有订阅选项，提供高级功能，比如能够保存你的工作并保持私密。
- en: You can save your work indefinitely. This is particularly handy if you want
    to share a quick mock-up or collaborate on a new experiment with others.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以无限期保存你的工作。如果你想要分享一个快速的模型或与他人合作进行新实验，这将非常方便。
- en: They support a wide range of popular JavaScript libraries and frameworks. For
    example, you can quickly add Lodash, React, or jQuery to your example, just by
    picking it from a list.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们支持各种流行的 JavaScript 库和框架。例如，你可以通过从列表中选择快速添加 Lodash、React 或 jQuery 到你的示例中。
- en: You can edit HTML, JavaScript, and CSS all in one window. Depending on the playground,
    it may be divided into panels that are all visible at once (like JSFiddle) or
    tabs that you switch between (like JS Bin). Or, it may be customizable (like CodePen).
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在一个窗口中编辑 HTML、JavaScript 和 CSS。根据游乐场的不同，它可能被分成同时可见的面板（如 JSFiddle）或者你可以在之间切换的选项卡（如
    JS Bin）。或者，它可能是可定制的（如 CodePen）。
- en: They provide some level of autocompletion, error checking, and syntax highlighting
    (colorizing different code ingredients), although it’s not as complete as what
    you’ll get in a desktop code editor.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们提供一定程度的自动完成、错误检查和语法高亮（给不同的代码部分上色），尽管它不像你在桌面代码编辑器中得到的那样完整。
- en: They provide a preview of your page so you can jump easily between coding and
    testing.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们提供页面预览，让你可以轻松地在编码和测试之间跳转。
- en: JavaScript playgrounds also have limits. For example, you may not be able to
    host other resources like images, interact with backend services like databases,
    or use asynchronous requests with `fetch`.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript playgrounds 也有其局限性。例如，你可能无法托管其他资源如图片，与后端服务如数据库进行交互，或者使用 `fetch` 进行异步请求。
- en: JavaScript playgrounds should also be distinguished from full cloud-based programming
    environments. For example, you can use VS Code online in a completely hosted environment
    called [GitHub Codespaces](https://oreil.ly/Vo95d), or [AWS Cloud9 from Amazon](https://oreil.ly/tvTZq),
    or [Google Cloud](https://oreil.ly/fqWuW). None of these products are free, but
    all are appealing if you want to set up a specific development environment that
    you can use in your browser, on different devices, and with no setup or performance
    concerns.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript playgrounds 应当与完整的基于云的编程环境区分开来。例如，你可以在完全托管的环境中使用 [GitHub Codespaces](https://oreil.ly/Vo95d)，或者来自亚马逊的
    [AWS Cloud9](https://oreil.ly/tvTZq)，或者 [Google Cloud](https://oreil.ly/fqWuW)。这些产品都不是免费的，但如果你想要在浏览器中设置特定的开发环境，并且不需要进行任何设置或担心性能问题，它们都是很有吸引力的选择。
