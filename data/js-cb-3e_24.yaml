- en: Chapter 21\. Building Web Applications with Express
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第21章。使用Express构建Web应用程序
- en: '[Express](https://expressjs.com) is a lightweight web framework that has been
    the long-standing leader in web application development in Node. Similar to Ruby’s
    Sinatra and Python’s Flask, the Express framework by itself is very minimal, but
    can be extended to build any type of web application. Express is also the backbone
    of batteries included in web application frameworks, such as [Keystone.js](https://keystonejs.com),
    [Sails](https://sailsjs.com), and [Vulcan.js](http://vulcanjs.org). If you are
    doing web application development in Node, you are likely to encounter Express.
    This chapter focuses on a handful of basic recipes for working with Express, which
    can be extended to build out all sorts of web applications.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[Express](https://expressjs.com)是一个轻量级的Web框架，在Node中长期领先于Web应用程序开发。与Ruby的Sinatra和Python的Flask类似，Express框架本身非常简洁，但可以扩展以构建任何类型的Web应用程序。Express也是Web应用程序框架中的一部分，例如[Keystone.js](https://keystonejs.com)、[Sails](https://sailsjs.com)和[Vulcan.js](http://vulcanjs.org)。如果你在Node中进行Web应用程序开发，你很可能会遇到Express。本章重点介绍了使用Express处理基本应用程序的几种方法，可以扩展到各种Web应用程序。'
- en: Using Express to Respond to Requests
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Express响应请求
- en: Problem
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Your Node application needs to respond to HTTP requests.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 您的Node应用程序需要响应HTTP请求。
- en: Solution
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Install the Express package:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Express包：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To set up Express, we require the module, call the module, and specify a port
    for connections in a file named *index.js*:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置Express，我们需要引入模块，调用模块，并在名为*index.js*的文件中指定一个连接端口：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To respond to a request, specify a route and the response using Express’s `.get`
    method:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要响应请求，指定一个路由并使用Express的`.get`方法进行响应：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To serve static files, we can specify a directory with the `express.static`
    middleware
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要提供静态文件，我们可以使用`express.static`中间件指定一个目录。
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To respond with HTML generated from a template, first install the templating
    engine:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用从模板生成的HTML来响应，请先安装模板引擎：
- en: '[PRE4]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, in the *index.js* file, set the `view engine` and specify the route that
    will respond with the template content:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在*index.js*文件中设置`view engine`并指定将以模板内容响应的路由：
- en: '[PRE5]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And then create a template file in the *views* subdirectory of the project
    with a new file. The template filename should match the name specified in `res.render`.
    In *views/template.pug*:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在项目的*views*子目录中创建一个新文件，作为模板文件。模板文件名应与`res.render`中指定的名称匹配。在*views/template.pug*中：
- en: '[PRE6]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now requests to *http://localhost:3000/template* will return the template content
    as HTML.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对*http://localhost:3000/template*的请求将返回HTML格式的模板内容。
- en: Discussion
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Express is a minimalist, but highly configurable framework for responding to
    HTTP requests and building out web applications. In the example, we set the port
    to `process.env.PORT` or port `3000`. In development, we can then specify a new
    port using an environment variable, such as:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Express是一个极简但高度可配置的框架，用于响应HTTP请求和构建Web应用程序。在示例中，我们将端口设置为`process.env.PORT`或端口`3000`。在开发中，我们可以通过环境变量指定一个新的端口：
- en: '[PRE7]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: or by using a *.env* file paired with the `dotenv` Node module. When deploying
    the application, the application hosting platform may require a specific port
    number or allow us to configure the port number ourselves.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 或者通过使用配对`dotenv`Node模块的*.env*文件。在部署应用程序时，应用程序托管平台可能需要特定的端口号或允许我们自己配置端口号。
- en: 'With the Express `get` method, the application receives a request to a specific
    URI and then responds. In our example, when the application receives a request
    to the root URI (*/*), we respond with the text “Hello World”:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Express的`get`方法，应用程序接收到特定URI的请求，然后做出响应。在我们的例子中，当应用程序接收到根URI（*/*）的请求时，我们会回复“Hello
    World”文本：
- en: '[PRE8]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: These responses can also be HTML, templates rendered to HTML, static files,
    and formatted data (such as JSON or XML).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这些响应也可以是HTML、渲染为HTML的模板、静态文件和格式化数据（如JSON或XML）。
- en: 'Due to its minimal nature, Express itself contains minimal functionality, but
    can be extended using middleware. In Express, middleware functions have access
    to the `request` and `response` objects. Application-level middleware is bound
    to an instance of the `app` object through `app.use(MIDDLEWARE)`. In the example,
    we’re making use of the built-in static files middleware:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其极简的特性，Express本身包含了极少的功能，但可以通过中间件进行扩展。在Express中，中间件函数可以访问`request`和`response`对象。应用级中间件通过`app.use(MIDDLEWARE)`绑定到`app`对象的一个实例上。在这个例子中，我们正在使用内置的静态文件中间件：
- en: '[PRE9]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Middleware packages can be used to extend Express’s functionality in many ways.
    The `helmet` middleware package can be used to improve the Express security defaults:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件包可以在许多方面扩展 Express 的功能。`helmet` 中间件包可以用于改善 Express 的安全默认设置：
- en: '[PRE10]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Templating engines simplify the process of writing HTML and allow you to pass
    data from your application to the page.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 模板引擎简化了编写 HTML 的过程，并允许你将数据传递给页面。
- en: 'Here I am passing the data from the `userData` object to the template found
    at *views/user.pug*, which will be accessible at the */user* route:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我正在从 `userData` 对象中传递数据到 *views/user.pug* 模板，该模板可以在 */user* 路由中访问：
- en: '[PRE11]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then in our template, we can make use of the data:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在我们的模板中，我们可以使用数据：
- en: '[PRE12]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The Pug templating engine is maintained by the Express core team and is a popular
    choice for Express applications, but its whitespace-driven syntax is not for everyone.
    [EJS](https://ejs.co) is an excellent alternative that offers a more HTML-like
    syntax. Here’s how the above example would look using EJS.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Pug 模板引擎由 Express 核心团队维护，是 Express 应用程序的流行选择，但其基于空白符的语法不适合每个人。[EJS](https://ejs.co)
    是一个更接近 HTML 的语法的优秀选择。以下是使用 EJS 的上述示例的效果。
- en: 'First, specify to install the `ejs` package:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，指定安装 `ejs` 包：
- en: '[PRE13]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then set EJS as the view engine in your Express application:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在你的 Express 应用程序中设置 EJS 作为视图引擎：
- en: '[PRE14]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And in *views/user.ejs*:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 而在 *views/user.ejs* 中：
- en: '[PRE15]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Using the Express-Generator
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Express-Generator
- en: Problem
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You’re interested in using Express to manage your server-side data application,
    but you don’t want to manage all of the setup yourself.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你有兴趣使用 Express 管理你的服务器端数据应用程序，但不想自己处理所有设置。
- en: Solution
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: To kickstart your Express application, use the Express-Generator. This is a
    command-line tool that generates the skeleton infrastructure of a typical Express
    application.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动你的 Express 应用程序，请使用 Express-Generator。这是一个命令行工具，用于生成典型 Express 应用程序的基础架构骨架。
- en: 'First, create a working directory where the tool can safely install a new application
    subdirectory. Next, run the `express-generator` command with `npx`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个工作目录，在这里工具可以安全地安装一个新的应用程序子目录。接下来，使用 `npx` 运行 `express-generator` 命令：
- en: '[PRE16]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'I’ve passed two options with the command: `--pug` will result in the use of
    the Pug templating engine, while `--git` will generate a default *.gitignore*
    file in the project directory. For the full list of options, run the generator
    with the `-h` option:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我在命令中传递了两个选项：`--pug` 将使用 Pug 模板引擎，而 `--git` 将在项目目录中生成默认的 *.gitignore* 文件。要查看所有选项，请使用
    `-h` 选项运行生成器：
- en: '[PRE17]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The generator creates a new directory with several subdirectories, some basic
    files to get you started, and a *package.json* file with all of the dependencies.
    To install the dependencies, change to the newly created directory and type:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器创建一个新目录，包含多个子目录、一些基本文件和一个包含所有依赖项的 *package.json* 文件。要安装依赖项，请切换到新创建的目录并输入：
- en: '[PRE18]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once all of the dependencies are installed, run the application using the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了所有依赖项，使用以下命令运行应用程序：
- en: '[PRE19]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can now access the generated Express application, using your IP address
    or domain and port 3000, the default Express port.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过你的 IP 地址或域名和端口 3000 访问生成的 Express 应用程序，这是 Express 的默认端口。
- en: Discussion
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Express provides a web application framework based on Node and with support
    for multiple templating engines and CSS preprocessors. In the solution, the options
    I chose for the example application are Pug as the template engine (the default)
    and the default of plain CSS (no CSS preprocessor). Though building the application
    from scratch enables a wider selection, Express supports only the following template
    engines:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Express 提供了一个基于 Node 的 Web 应用程序框架，并支持多个模板引擎和 CSS 预处理器。在这个解决方案中，我选择的示例应用程序选项是
    Pug 作为模板引擎（默认设置）和纯 CSS（无 CSS 预处理器）。虽然从头开始构建应用程序可以选择更多选项，但 Express 仅支持以下模板引擎：
- en: '`--ejs`'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`--ejs`'
- en: Adds support for the EJS template engine
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 添加对 EJS 模板引擎的支持
- en: '`--pug`'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`--pug`'
- en: Adds support for the Pug template engine
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 添加对 Pug 模板引擎的支持
- en: '`--hbs`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`--hbs`'
- en: Adds support for the Handlebar template engine
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 添加对 Handlebar 模板引擎的支持
- en: '`--hogan`'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`--hogan`'
- en: Adds support for the Hogan.js template engine
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 添加对 Hogan.js 模板引擎的支持
- en: 'Express also supports the following CSS preprocessors:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Express 还支持以下 CSS 预处理器：
- en: '`express --css sass`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`express --css sass`'
- en: Support for Sass
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 支持 Sass
- en: '`express --css less`'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`express --css less`'
- en: Support for Less
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 支持 Less
- en: '`express --css stylus`'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`express --css stylus`'
- en: Support for Stylus
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 支持 Stylus
- en: '`express --css compass`'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`express --css compass`'
- en: Support for Compass
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 支持 Compass
- en: Not specifying any CSS preprocessor defaults to plain CSS.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不指定任何 CSS 预处理器，默认为纯 CSS。
- en: Express also assumes that the project directory is empty. If it isn’t, force
    the Express generator to generate the content by using the `-f` or `--force` option.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Express 还假定项目目录为空。如果不是，可以通过使用 `-f` 或 `--force` 选项强制 Express 生成内容。
- en: 'The newly generated subdirectory has the following structure (disregarding
    `node​_mod⁠ules`):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 新生成的子目录具有以下结构（忽略 `node_modules`）：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The *app.js* file is the core of the Express application. It includes the references
    to the necessary libraries:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*app.js* 文件是 Express 应用程序的核心。它包括对必要库的引用：'
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-83
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Although the convention followed in this book is to use `const` and `let` to
    define variables, at the time of writing, the Express generator uses `var`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本书遵循的惯例是在定义变量时使用 `const` 和 `let`，但在编写时，Express 生成器使用 `var`。
- en: 'It also creates the Express app with the following line:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 还使用以下行创建 Express 应用程序：
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, it establishes Pug as the view engine by defining the `views` and `view
    engine` variables:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过定义 `views` 和 `view engine` 变量，将 Pug 设置为视图引擎：
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The *middleware* calls are loaded next with `app.use()`. Middleware is functionality
    that sits between the raw request and the routing, processing specific types of
    requests. The rule for the middleware is if a path is not given as the first parameter,
    it defaults to a path of `/`, which means the middleware functions are loaded
    with the default path. In the following generated code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来通过 `app.use()` 加载 *middleware* 调用。中间件是位于原始请求和路由之间的功能，用于处理特定类型的请求。中间件的规则是如果不给定路径作为第一个参数，则默认路径为
    `/`，这意味着中间件函数加载了默认路径。在以下生成的代码中：
- en: '[PRE24]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The first several middleware are loaded with every app request. Among the middleware
    includes support for development logging, as well as parsers for both JSON and
    *urlencoded* bodies. It’s only when we get to the `static` entry that we see assignment
    to specific paths: the static file request middleware are loaded when requests
    are made to the *public* directory.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序请求都加载了前几个中间件。其中中间件包括开发日志记录的支持，以及 JSON 和 *urlencoded* 体的解析器。只有当我们到达 `static`
    条目时，我们看到分配到特定路径的静态文件请求中间件：当请求发送到 *public* 目录时加载静态文件请求中间件。
- en: 'The routing is handled next:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来处理路由：
- en: '[PRE25]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The top-level web request (*/*) is directed to the `routes` module, while all
    user requests (*/users*) get routed to the `users` module.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 顶级 Web 请求 (*/*) 被定向到 `routes` 模块，而所有用户请求 (*/users*) 被路由到 `users` 模块。
- en: Note
  id: totrans-95
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Read more about routing with Express in [“Routing”](#express-routing).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 了解更多关于 Express 中的路由的信息，请参阅 [“Routing”](#express-routing)。
- en: 'What follows is the error handling. First up is `404` error handling when a
    request is made to a nonexistent web resource:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是错误处理。首先处理的是当请求到一个不存在的 Web 资源时的 `404` 错误处理：
- en: '[PRE26]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next comes the server error handling, for both production and development:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是服务器错误处理，适用于生产和开发环境：
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The last line of the generated file is the `module.exports` for the `app`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 生成文件的最后一行是 `module.exports` 的 `app`：
- en: '[PRE28]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the *routes* subdirectory, the default routing is included in the *routes/index.js*
    file:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *routes* 子目录中，默认路由包含在 *routes/index.js* 文件中：
- en: '[PRE29]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'What’s happening in the file is the Express router is used to route any HTTP
    GET requests to `/` to a callback where the request response receives a view rendered
    for the specific resource page. This is in contrast to what happens in the *routes/users.js*
    file, where the response receives a text message rather than a view:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 文件中发生的情况是 Express 路由器用于将任何 HTTP GET 请求路由到 `/` 的回调函数中，其中请求响应接收为特定资源页面渲染的视图。这与
    *routes/users.js* 文件中发生的情况形成对比，后者响应接收的是文本消息而不是视图：
- en: '[PRE30]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'What happens with the view rendering in the first request? There are three
    Pug files in the *views* subdirectory: one for error handling, one defining the
    page layout, and one, *index.pug*, that renders the page. The *index.pug* file
    contains:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个请求中视图渲染会发生什么？在 *views* 子目录中有三个 Pug 文件：一个用于错误处理，一个定义页面布局，还有一个 *index.pug*，用于渲染页面。*index.pug*
    文件包含：
- en: '[PRE31]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'It extends the *layout.pug* file, which contains:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 它扩展了 *layout.pug* 文件，其中包含：
- en: '[PRE32]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The *layout.pug* file defines the overall structure of the page, regardless
    of content, including a reference to an automatically generated CSS file. The
    `block content` setting defines where the location of the content is placed. The
    format for the content is defined in *index.js*, in the equivalently named `block
    content` setting.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*layout.pug* 文件定义了页面的整体结构，包括对自动生成的CSS文件的引用。`block content` 设置定义了内容的位置。内容的格式在
    *index.js* 中定义，与同名的 `block content` 设置相对应。'
- en: Note
  id: totrans-112
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The Pug templating engine (formerly known as Jade) was popularized by Express
    and offers a minimalist take on templating that makes use of whitespace in place
    of traditional HTML style tags. This approach may not be for everyone, and the
    Pug alternatives (Handlebars, Hogan.js, and EJS) all offer a more HTML-like syntax.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Pug模板引擎（以前称为Jade）由Express推广，并提供了一种极简的模板化方式，使用空白符代替传统的HTML样式标签。这种方法可能不适合所有人，而Pug的替代方案（Handlebars、Hogan.js
    和 EJS）都提供了更接近HTML的语法。
- en: The two Pug files define a basic web page with an `h1` element assigned a title
    variable, and a paragraph with a welcome message. [Figure 21-1](#page_using_default_settings)
    shows the default page.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个Pug文件定义了一个基本的网页，其中包含一个分配了标题变量的 `h1` 元素，以及包含欢迎消息的段落。[图 21-1](#page_using_default_settings)
    显示了默认页面。
- en: '![jsc3 2101](assets/jsc3_2101.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![jsc3 2101](assets/jsc3_2101.png)'
- en: Figure 21-1\. The Express-generated web page
  id: totrans-116
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 21-1\. Express生成的网页
- en: '[Figure 21-1](#page_using_default_settings) shows that the page isn’t especially
    fascinating, but it does represent how the pieces are holding together: the application
    router routes the request to the appropriate route module, which directs the response
    to the appropriate rendered view, and the rendered view uses data passed to it
    to generate the web page. If you make the following web request:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 21-1](#page_using_default_settings) 显示了页面并不特别吸引人，但它确实展示了这些组件如何协同工作：应用程序路由将请求路由到适当的路由模块，该模块将响应定向到适当的渲染视图，并使用传递给它的数据生成网页。如果您进行以下Web请求：'
- en: '[PRE33]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: you’ll see the plain text message, rather than the rendered view.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到纯文本消息，而不是渲染后的视图。
- en: 'By default, Express is set up to run in *development mode*. To change the application
    to *production mode*, you need to set an *environment variable*, `NODE-ENV` to
    “production.” In a Linux or Unix environment, the following could be used:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Express 设置为运行在 *开发模式* 下。要将应用程序切换到 *生产模式*，您需要设置一个 *环境变量* `NODE-ENV` 为 “production”。在Linux或Unix环境中，可以使用以下方式：
- en: '[PRE34]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Routing
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由
- en: Problem
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to route users to different resources in your application based on
    the request.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望根据请求将用户路由到应用程序中的不同资源。
- en: Solution
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use routes in Express to send specific resources based on the request path
    and parameters:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在Express中使用路由，根据请求路径和参数发送特定资源：
- en: '[PRE35]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Discussion
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'In Express, we can return a response to the user when they make an HTTP request.
    In the above examples, I’m using `get` requests, but Express supports a number
    of additional methods. The most common of these methods are:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在Express中，当用户发出HTTP请求时，我们可以向其返回响应。在上面的示例中，我使用了 `get` 请求，但Express支持多种额外的方法。其中最常见的方法包括：
- en: '`app.get`: request data'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.get`: 请求数据'
- en: '`app.post`: send data'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.post`: 发送数据'
- en: '`app.put`: send or update data'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.put`: 发送或更新数据'
- en: '`app.delete`: delete data'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.delete`: 删除数据'
- en: '[PRE36]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Often we may want to enable multiple HTTP methods to a specific route. We can
    accomplish this by chaining them together:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我们可能希望对特定路由启用多个HTTP方法。我们可以通过将它们链接在一起来实现这一目标：
- en: '[PRE37]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Often requests have parameters with specific values that we will make use of
    in our application. We can specify these in the URL using a colon (`:`):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 请求通常具有具体值的参数，我们将在应用程序中使用这些值。我们可以在URL中使用冒号 (`:`) 指定这些值：
- en: '[PRE38]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the above example, when a user visits a URL at */users/adam123*, the browser
    will send the response of `Hello user adam123`. While this is a simple example,
    we could also make use of the URL parameter to retrieve data from our database,
    passing the information on to a template.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，当用户访问 */users/adam123* 这个URL时，浏览器将发送 `Hello user adam123` 的响应。虽然这是一个简单的示例，但我们也可以利用URL参数从数据库中检索数据，并将信息传递给模板。
- en: 'We’re also able to specify formats for the request parameters. In the following
    example, I make use of a regular expression to limit the `noteId` parameter to
    a six-digit integer:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还能够为请求参数指定格式。在以下示例中，我使用正则表达式将 `noteId` 参数限制为六位整数：
- en: '[PRE39]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We are also able to use a regular expression to define an entire route:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用正则表达式来定义整个路由：
- en: '[PRE40]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The above example will route any request ending in `day`. For example, in local
    development a request to *http://localhost:3000/Sunday* will result in “Every
    day feels like Sunday” being printed to the page.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例将路由任何以`day`结尾的请求。例如，在本地开发中，请求*http://localhost:3000/Sunday*将在页面上打印出“Every
    day feels like Sunday”。
- en: Working with OAuth
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OAuth进行工作
- en: Problem
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need access to a third-party API (such as GitHub, Facebook, or Twitter)
    in your Node application, but it requires authorization. Specifically, it requires
    OAuth authorization.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在Node应用程序中访问第三方API（如GitHub、Facebook或Twitter），但它需要授权。具体而言，它需要OAuth授权。
- en: Solution
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: You’ll need to incorporate an OAuth client in your application. You’ll also
    need to meet the OAuth requirements demanded by the resource provider.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 需要在你的应用程序中集成一个OAuth客户端。你还需要满足资源提供者所要求的OAuth需求。
- en: See the discussion for details.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 查看详细讨论。
- en: Discussion
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: OAuth is an authorization framework used with most popular social media and
    cloud content applications. If you’ve ever gone to a site and it’s asked you to
    authorize access to data from a third-party service, such as GitHub, you’ve participated
    in the OAuth authorization *flow*.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth是一个授权框架，与大多数流行的社交媒体和云内容应用程序一起使用。如果你曾经访问过一个网站，并被要求授权访问来自第三方服务的数据，比如GitHub，那么你已经参与了OAuth授权*流程*。
- en: There are two versions of OAuth, 1.0 and 2.0, which are not compatible with
    one another. OAuth 1.0 was based on proprietary APIs developed by Flickr and Google,
    was heavily web page focused, and didn’t gracefully transcend the barrier among
    web, mobile, and service applications. When wanting to access resources in a mobile
    phone app, the app would have the user log in to the app in a mobile browser and
    then copy access tokens to the app. Other criticisms of OAuth 1.0 is that the
    process required that the authorization server be the same as the resource server,
    which doesn’t scale when you’re talking about service providers such as Twitter,
    Facebook, and Amazon.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth有两个版本，1.0和2.0，它们彼此不兼容。OAuth 1.0基于Flickr和Google开发的专有API，主要集中在网页上，并未很好地跨越Web、移动和服务应用程序之间的障碍。在想要在手机应用程序中访问资源时，应用程序需要用户在移动浏览器中登录应用程序，然后将访问令牌复制到应用程序中。对OAuth
    1.0的其他批评是，授权服务器必须与资源服务器相同，这在涉及Twitter、Facebook和Amazon等服务提供商时无法扩展。
- en: OAuth 2.0 presents a simpler authorization process, and also provides different
    types of authorization (different flows) for different circumstances. Some would
    say, though, that it does so at the cost of security, as it doesn’t have the same
    demands for encrypting hash tokens and request strings.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0提供了一个更简单的授权流程，并为不同情况提供了不同类型的授权（不同流程）。尽管如此，有人会说，这是以安全为代价的，因为它对加密哈希令牌和请求字符串没有同样的要求。
- en: Most developers won’t have to create an OAuth 2.0 server, and doing so is way
    beyond the scope of this book, much less this recipe. But it’s common for applications
    to incorporate an OAuth client (1.0 or 2.0) for one service or another, so I’m
    going to present different types of OAuth use. First, though, let’s discuss the
    differences between authorization and authentication.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发者不必创建OAuth 2.0服务器，这超出了本书甚至本节的范围。但是，应用程序通常会集成一个OAuth客户端（1.0或2.0）来使用某项服务，因此我将介绍不同类型的OAuth使用。首先，让我们讨论授权与认证之间的区别。
- en: Authorization isn’t authentication
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 授权并非认证
- en: Authorization is saying, “I authorize this application to access my resources
    on your server.” Authentication is the process of authenticating whether you are,
    indeed, the person who owns this account and has control over these resources.
    An example would be if I want to comment on an article at a newspaper’s online
    site. It will likely ask me to log in via some service. If I pick my Facebook
    account to use as the login, the news site will most likely want some data from
    Facebook.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 授权意味着：“我授权此应用程序访问我在你服务器上的资源。”认证是验证你是否确实是拥有此账户并控制这些资源的人。例如，如果我想在报纸的在线站点上发表评论，它可能会要求我通过某些服务登录。如果我选择使用我的Facebook账户作为登录方式，新闻网站很可能会要求一些来自Facebook的数据。
- en: 'The news site is, first, authenticating me as a legitimate Facebook user, with
    an established Facebook account. In other words, I’m not just some random person
    coming in and commenting anonymously. Secondly, the news site wants something
    from me in exchange for the privilege of commenting: it’s going to want data about
    me. Perhaps it will ask for permission to post for me (if I post my comment to
    Facebook as well as the news site). This is both an authentication and an authorization
    request.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，新闻网站验证我是合法的Facebook用户，拥有已建立的Facebook账户。换句话说，我不是只是随便进来匿名评论的任何人。其次，新闻网站希望在为评论提供特权的同时从我这里获取一些东西：它将要求获取有关我的数据。也许它会请求允许代表我发布（如果我将我的评论同时发布到Facebook和新闻网站）。这既是身份验证又是授权请求。
- en: If I’m not already logged in to Facebook, I’ll have to log in. Facebook is using
    my correct application of username and password to authenticate that, yes, I own
    the Facebook account in question. Once logged in, Facebook asks whether I agree
    to giving the newspaper site the authorization to access the resources it wants.
    If I agree (because I desperately want to comment on a particular story), Facebook
    gives the news site the authorization, and there’s now a persistent connection
    from the newspaper to my Facebook account (which you can see in your Facebook
    settings). I can make my comment, and make comments at other stories, until I
    log out or revoke the Facebook authorization.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我还没有登录Facebook，我将不得不登录。Facebook使用我正确的用户名和密码来验证，确认我拥有所讨论的Facebook账户。登录后，Facebook会询问我是否同意允许新闻网站访问它想要的资源。如果我同意（因为我非常想评论某个特定的故事），Facebook会授予新闻网站授权，此时从报纸到我的Facebook账户之间就建立了持久连接（你可以在你的Facebook设置中看到）。我可以发表我的评论，以及在其他故事中发表评论，直到我注销或撤销Facebook授权。
- en: Of course, none of this implies that Facebook or the news site are actually
    authenticating who I am. Authentication, in this case, is about establishing that
    I am the owner of the Facebook account. The only time *real* authentication enters
    the picture is in a social media context such as Twitter’s authenticated accounts
    for celebrities.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不意味着Facebook或新闻网站实际上在验证我的身份。在这种情况下，身份验证是指确认我是Facebook账户的所有者。只有在社交媒体环境（如Twitter为名人创建的认证账户）中，才会涉及*真正*的身份验证。
- en: Our development task is made simpler by the fact that software to handle authorization
    is frequently the same software that authenticates the individual, so we’re not
    having to deal with two different JavaScript libraries/modules/systems. There
    are also several excellent OAuth (1.0 and 2.0) modules we can use in Node applications.
    One of the most popular is [Passport](http://www.passportjs.org), and there are
    extensions for various authorization services created specifically for the Passport
    system. However, there are also very simple OAuth clients that provide barebones
    authorization access for a variety of services, and some modules that are created
    specifically for one service.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的开发任务因为处理授权的软件通常也是验证个人身份的软件而变得更简单，所以我们不需要处理两种不同的JavaScript库/模块/系统。在Node应用中，有几个优秀的OAuth（1.0和2.0）模块可供使用。其中最流行的之一是[Passport](http://www.passportjs.org)，并且还有为Passport系统专门创建的各种授权服务扩展。然而，也有一些非常简单的OAuth客户端，专门为各种服务提供基础授权访问，以及一些为单一服务创建的模块。
- en: Note
  id: totrans-162
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注：
- en: Passport.js is covered in [“OAuth 2 User Authentication with Passport.js”](#redirect-auth).
    You can also read more about Passport and its various *strategies* supporting
    different servers at its website.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Passport.js 的内容可在[“使用Passport.js进行OAuth 2用户身份验证”](#redirect-auth)中找到。您也可以在其网站上了解更多关于Passport及其支持不同服务器的各种*策略*。
- en: Now, on to the technology.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，进入技术方面。
- en: Client Credentials Grant
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 客户端凭据授权
- en: There are few web resources that nowadays provide an API you can access without
    having some kind of authorization credential. This means having to incorporate
    a round-trip directive to the end users—asking them to authorize access to their
    account at the service before the application can access data. The problem is
    that sometimes all you need is simple read-only access without update privileges,
    without a frontend login interface, and without having a specific user make an
    authorizing grant.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如今几乎没有网页资源提供可以在没有某种授权凭证的情况下访问的API。这意味着必须要向最终用户发出一个往返指令——要求他们在应用程序可以访问数据之前授权访问其服务账户。问题在于，有时你只需要简单的只读访问权限，而不需要更新权限，也不需要前端登录界面，并且也不需要特定用户进行授权授予。
- en: OAuth 2.0 accounts for this particular type of authorizing flow with the *Client
    Credentials Grant*. The diagram for this simplified authorization is shown in
    [Figure 21-2](#client_credentials_grant_img).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0考虑了使用*客户端凭据授予*进行特定类型的授权流程。这种简化授权的图示显示在[图21-2](#client_credentials_grant_img)中。
- en: '![jsc3 2102](assets/jsc3_2102.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![jsc3 2102](assets/jsc3_2102.png)'
- en: Figure 21-2\. The Client Credentials Grant authorization flow
  id: totrans-169
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图21-2. 客户端凭据授权流程
- en: Twitter provides what it calls application-only authorization, which is based
    on OAuth 2.0’s Client Credentials Grant. We can use this type of authorization
    to access Twitter’s Search API.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Twitter提供了所谓的应用程序授权，基于OAuth 2.0的客户端凭据授予。我们可以使用这种授权类型来访问Twitter的搜索API。
- en: 'In the following example, I used the Node module `oauth` to implement the authorization.
    It’s the most basic of the authorization modules, and supports both OAuth 1.0
    and OAuth 2.0 authorization flows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我使用了Node模块`oauth`来实现授权。这是授权模块中最基本的一种，支持OAuth 1.0和OAuth 2.0的授权流程：
- en: '[PRE41]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: To use the Twitter authorization API, the client application has to register
    its application with Twitter. Twitter provides both a *consumer key* and a *consumer
    secret*.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Twitter授权API，客户端应用程序必须在Twitter注册其应用程序。Twitter提供了*消费者密钥*和*消费者密钥*。
- en: 'Using the `oauth` module, a new OAuth2 object is created, passing in:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`oauth`模块，创建了一个新的OAuth2对象，传入：
- en: Consumer key
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费者密钥
- en: Consumer secret
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费者密钥
- en: API base URI (API URI minus the query string)
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API基本URI（API URI减去查询字符串）
- en: A value of null signals OAuth to use the default */oauth/authorize*
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空值表示OAuth使用默认的*/oauth/authorize*
- en: The access token path
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问令牌路径
- en: Null, because we’re not using any custom headers
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空，因为我们不使用任何自定义标头
- en: 'The `oauth` module takes this data and forms a POST request to Twitter, passing
    along the consumer key and secret, as well as providing a *scope* for the request.
    Twitter’s documentation provides an example POST request for an access token (line
    breaks inserted for readability):'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`oauth`模块使用这些数据创建一个POST请求到Twitter，同时传递消费者密钥和密钥，还为请求提供了*范围*。Twitter的文档提供了一个获取访问令牌的示例POST请求（为了可读性插入了换行符）：'
- en: '[PRE42]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The response includes the access token (again, line breaks for readability):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 响应包括访问令牌（再次为了可读性插入换行符）：
- en: '[PRE43]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The access token has to be used with any of the API requests. There are no further
    authorization steps, so the process is very simple. In addition, since the authorization
    is at the application level, it doesn’t require an individual’s authorization,
    making it less disruptive to the user.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 任何API请求都必须使用访问令牌。没有进一步的授权步骤，因此流程非常简单。此外，由于授权是在应用程序级别进行的，不需要个人的授权，使得对用户的干扰较少。
- en: Note
  id: totrans-186
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Twitter provides wonderful documentation. I recommend reading the [“Application-only
    authentication overview”](https://oreil.ly/Mikyl).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Twitter提供了出色的文档。建议阅读[“仅应用程序身份验证概述”](https://oreil.ly/Mikyl)。
- en: Read/write authorization with OAuth 1.0
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用OAuth 1.0进行读/写授权
- en: Application-Only authentication is great for accessing read-only data, but what
    if you want to access a user’s specific data, or even make a change to their data?
    Then you’ll need the full OAuth authorization. In this section, we’ll again use
    Twitter for the demonstration because of its use of OAuth 1.0 authorization. In
    the next recipe, we’ll look at OAuth 2.0.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 仅应用程序身份验证非常适合访问只读数据，但如果您想要访问用户的特定数据，甚至对其数据进行更改怎么办？那么您将需要完整的OAuth授权。在本节中，我们再次使用Twitter进行演示，因为它使用OAuth
    1.0授权。在下一个示例中，我们将介绍OAuth 2.0。
- en: Note
  id: totrans-190
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: I refer to it as OAuth 1.0, but Twitter’s service is based on [OAuth Core 1.0
    Revision A](http://oauth.net/core/1.0a). However, it’s a lot easier just to say
    OAuth 1.0.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我称之为OAuth 1.0，但Twitter的服务基于[OAuth Core 1.0修订版A](http://oauth.net/core/1.0a)。不过，说OAuth
    1.0更简单。
- en: 'OAuth 1.0 requires a digital signature. The steps to derive this digital signature,
    graphically represented in [Figure 21-3](#oauth_one_flow), and as outlined by
    Twitter, are:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 1.0需要数字签名。生成此数字签名的步骤在[Twitter的图21-3](#oauth_one_flow)中有图形表示。
- en: Collect the HTTP method and the base URI, minus any query string.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集HTTP方法和基本URI，去除任何查询字符串。
- en: Collect the parameters, including the consumer key, request data, nonce, signature
    method, and so on.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集参数，包括消费者密钥、请求数据、随机数、签名方法等等。
- en: Create a signature base string, which consists of the data we’ve gathered, formed
    into a string in a precise manner, and encoded just right.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建签名基础字符串，其中包含我们收集的数据，以一种精确的方式形成字符串，并适当编码。
- en: Create a signing key, which is a combination of consumer key and OAuth token
    secret, again combined in a precise manner.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建签名密钥，这是消费者密钥和 OAuth 令牌密钥的组合，再次以精确的方式组合起来。
- en: Pass the signature base string and the signing key to an HMAC-SHA1 hashing algorithm,
    which returns a binary string that needs further encoding.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将签名基本字符串和签名密钥传递给 HMAC-SHA1 散列算法，返回一个需要进一步编码的二进制字符串。
- en: '![jsc3 2103](assets/jsc3_2103.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![jsc3 2103](assets/jsc3_2103.png)'
- en: Figure 21-3\. OAuth 1.0 authorization flow
  id: totrans-199
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 21-3\. OAuth 1.0 授权流程
- en: You have to follow this process for *every* request. Thankfully, we have modules
    and libraries that do all of this mind-numbing work for us. I don’t know about
    you, but if I had to do this, my interest in incorporating Twitter data and services
    into my application would quickly wane.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 每次请求都必须遵循这个流程。幸运的是，我们有模块和库来完成所有这些令人昏昏欲睡的工作。我不知道你怎么看，但如果我必须这样做，我对将 Twitter 数据和服务整合到我的应用中的兴趣很快就会减退。
- en: Our friend `oauth` provides the underlying OAuth 1.0 support, but we don’t have
    to code to it directly this time. Another module, `node-twitter-api`, has wrapped
    all of the OAuth pieces. All we need do is create a new `node-twitter-api` object,
    passing in our consumer key and secret, as well as the callback/redirect URL required
    by the resource services, as part of the authorization process. Processing the
    `request` object in that URL provides us the access token and secret we need for
    API access. Every time we make a request, we pass in the access token and secret.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的朋友 `oauth` 提供了底层的 OAuth 1.0 支持，但这次我们不必直接编写代码。另一个模块 `node-twitter-api` 已经包装了所有
    OAuth 的部分。我们只需要创建一个新的 `node-twitter-api` 对象，传入我们的消费者密钥和密钥，以及资源服务所需的回调/重定向 URL，作为授权过程的一部分。处理该
    URL 中的 `request` 对象会为我们提供访问令牌和密钥，以便访问 API。每次我们发起请求时，都会传入访问令牌和密钥。
- en: 'The `twitter-node-api` module is a thin wrapper around the REST API: to make
    a request, we extrapolate what the function is from the API. If we’re interested
    in posting a status update, the REST API endpoint is:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`twitter-node-api` 模块是 REST API 的一个薄包装：为了发起请求，我们从 API 推断功能是什么。如果我们有兴趣发布状态更新，REST
    API 的端点是：'
- en: '[PRE44]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `twitter-node-api` object instance function is `statuses()`, and the first
    parameter is the verb, `update`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`twitter-node-api` 对象实例函数是 `statuses()`，第一个参数是动词 `update`：'
- en: '[PRE45]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The callback function arguments include any possible error, requested data (if
    any), and the raw response.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数的参数包括任何可能的错误、请求的数据（如果有的话）以及原始响应。
- en: A complete example is shown in [Example 21-1](#complete_twitter_app_using_oauth).
    It uses Express as a server and provides a primitive web page for the user, and
    then uses another module.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例显示在 [Example 21-1](#complete_twitter_app_using_oauth) 中。它使用 Express 作为服务器，并为用户提供了一个基本的网页，然后使用另一个模块。
- en: Example 21-1\. Twitter app fully authorized via OAuth 1.0
  id: totrans-208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 21-1\. 使用 OAuth 1.0 完全授权的 Twitter 应用
- en: '[PRE46]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The routes of interest in the app are:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 应用中感兴趣的路由包括：
- en: '`/`: Page that triggers a redirect to Twitter for authorization'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/`: 触发重定向到 Twitter 进行授权的页面'
- en: '`/auth`: The callback or redirect URL registered with the app, and passed in
    the request'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/auth`: 注册在应用程序中的回调或重定向 URL，并在请求中传递'
- en: '`/post/status/`: Post a status to the Twitter account'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/post/status/`: 向 Twitter 账户发布状态'
- en: '`/get/account/`: Get account information for the individual'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/get/account/`: 获取个人账户信息'
- en: 'In each case, the appropriate `node-twitter-api` function is used:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，都使用适当的 `node-twitter-api` 函数：
- en: '`/`: Get a request token and request token secret, using `getRequestToken()`'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/`: 使用 `getRequestToken()` 获取请求令牌和请求令牌密钥'
- en: '`/auth/`: Get the API access token and token secret, caching them locally,
    display menu'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/auth/`: 获取 API 访问令牌和令牌密钥，将它们缓存到本地，显示菜单'
- en: '`/post/status/`: `status()` with *update* as first parameter, status, access
    token and secret, and callback function'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/post/status/`: `status()` 的第一个参数为 *update*，状态、访问令牌和密钥，以及回调函数'
- en: '`/get/account/`: `account()` with *settings* as the first parameter, an empty
    object, since no data is needed for the request, and the access token, secret,
    and callback'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/get/account/`: `account()` 的第一个参数为 *settings*，一个空对象，因为请求不需要数据，还有访问令牌、密钥和回调'
- en: The Twitter authorization page that pops up is displayed in [Figure 21-4](#twitter_authorization_page),
    and the web page that displays account information for yours truly is displayed
    in [Figure 21-5](#twitter_account_data).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 弹出的 Twitter 授权页面显示在 [Figure 21-4](#twitter_authorization_page) 中，显示本人账户信息的网页显示在
    [Figure 21-5](#twitter_account_data) 中。
- en: Note
  id: totrans-221
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Though it is no longer actively maintained, you can read more about the `node-twitter-api`
    module at its [GitHub repository page](https://github.com/reneraab/node-twitter-api).
    Other libraries are more actively maintained and provide the same type of functionality,
    but I found `node-twitter-api` offers the simplest functional example for the
    purpose of demonstration.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它已经不再积极维护，但您可以在其[GitHub 仓库页面](https://github.com/reneraab/node-twitter-api)上阅读有关
    `node-twitter-api` 模块的更多信息。其他库更积极地维护并提供相同类型的功能，但我发现 `node-twitter-api` 提供了最简单的功能示例，用于演示目的。
- en: '![jsc3 2104](assets/jsc3_2104.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![jsc3 2104](assets/jsc3_2104.png)'
- en: Figure 21-4\. Twitter authorization page, redirected from the recipe app
  id: totrans-224
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 21-4\. 从菜谱应用程序重定向到 Twitter 授权页面
- en: '![jsc3 2105](assets/jsc3_2105.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![jsc3 2105](assets/jsc3_2105.png)'
- en: Figure 21-5\. Display of Twitter user account data in app
  id: totrans-226
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 21-5\. 在应用程序中显示 Twitter 用户账户数据
- en: OAuth 2 User Authentication with Passport.js
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Passport.js 进行 OAuth 2 用户认证
- en: Problem
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to authenticate users in your application through a third-party service.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望通过第三方服务在应用程序中对用户进行认证。
- en: Solution
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the Passport.js library paired with the appropriate strategy for the authentication
    provider you’ve chosen. In this example, I’ll make use of the GitHub strategy,
    but the workflow will be identical for any OAuth 2 provider, including Facebook,
    Google, and Twitter.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Passport.js 库与所选认证提供程序的适当策略配对。在本例中，我将使用 GitHub 策略，但对于包括 Facebook、Google 和
    Twitter 在内的任何 OAuth 2 提供程序，工作流程都将是相同的。
- en: You can make use of the GitHub strategy, first by visiting GitHub’s website
    and [registering a new OAuth application](https://github.com/settings/applications/new).
    Once the application is registered, you can integrate the Passport.js OAuth code
    into the application.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以利用 GitHub 策略，首先访问 GitHub 的网站并[注册新的 OAuth 应用程序](https://github.com/settings/applications/new)。一旦注册了应用程序，就可以将
    Passport.js OAuth 代码集成到应用程序中。
- en: 'To begin, configure the Passport strategy, which will include the GitHub-provided
    client ID and client secret, along with the callback URL that you have specified:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请配置 Passport 策略，其中包括 GitHub 提供的客户端 ID 和客户端密钥，以及您指定的回调 URL：
- en: '[PRE47]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To restore authentication state across HTTP requests, Passport needs to serialize
    and deserialize users:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 HTTP 请求之间恢复认证状态，Passport 需要对用户进行序列化和反序列化：
- en: '[PRE48]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To preserve user logins across browser sessions, make use of the `express-session`
    middleware:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 要跨浏览器会话保留用户登录状态，请使用 `express-session` 中间件：
- en: '[PRE49]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You can then authenticate requests using `passport.authenticate`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以然后使用 `passport.authenticate` 对请求进行认证：
- en: '[PRE50]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'And reference the `user` object from requests:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 并引用来自请求的 `user` 对象：
- en: '[PRE51]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Discussion
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: OAuth is an open standard for user authentication. It allows us to authenticate
    users through third-party applications. This can be useful when allowing users
    to easily create accounts and log in to your applications, as well as for authenticating
    to use data from a third-party source.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 是用于用户认证的开放标准。它允许我们通过第三方应用程序对用户进行认证。当允许用户轻松创建帐户并登录到您的应用程序时，以及用于从第三方来源认证使用数据时，这将非常有用。
- en: 'OAuth requests follow a specific flow:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 请求遵循特定的流程：
- en: Your application makes an authorization request to the third-party service.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的应用程序向第三方服务发出授权请求。
- en: The user approves that request.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户批准该请求。
- en: The service redirects the user back to your application, along with an authorization
    code.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务将用户重定向回您的应用程序，并携带授权码。
- en: The application makes a request to the third-party service with the authorization
    code.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序使用授权码向第三方服务发出请求。
- en: The service responds with an access token (and optionally a refresh token).
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务响应访问令牌（及可选的刷新令牌）。
- en: The application makes a request to the service with the access token.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序使用访问令牌向服务发送请求。
- en: The service responds with the protected resource (in our case, the user account
    information).
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务响应受保护的资源（在我们的案例中是用户账户信息）。
- en: Using Passport.js along with a Passport.js strategy for the OAuth provider simplifies
    this flow in an Express.js application. In this example, we’ll build a small Express
    application that authenticates with GitHub and persists user logins across sessions.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Express.js 应用程序中，结合 Passport.js 策略使用 Passport.js 简化了此流程。在本例中，我们将构建一个小型 Express
    应用程序，该应用程序通过 GitHub 进行认证，并跨会话保持用户登录状态。
- en: 'Once we have registered our application with the service provider, we can begin
    development by installing the appropriate dependencies:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们已经向服务提供商注册了我们的应用程序，就可以通过安装适当的依赖项开始开发：
- en: '[PRE52]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'To store our OAuth client ID, client secret, and session secret values, we
    will use a *.env* file. Alternately, you could use a JavaScript file (such as
    a *config.js* file). It is critical that we not check this file into public source
    control, and I recommend adding it to your *.gitignore* file. In *.env*:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 为了存储我们的 OAuth 客户端 ID、客户端密钥和会话密钥值，我们将使用一个 *.env* 文件。或者，你可以使用一个 JavaScript 文件（比如
    *config.js* 文件）。重要的是不要将此文件提交到公共源代码控制中，并建议将其添加到你的 *.gitignore* 文件中。在 *.env* 中：
- en: '[PRE53]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Next, we’ll set up our Express application with Passport.js. In *index.js*:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在 *index.js* 中设置我们的 Express 应用程序与 Passport.js 集成。
- en: '[PRE54]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: You can then build your view templates, which can access the user data.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以构建你的视图模板，这些模板可以访问用户数据。
- en: 'In *views/home.pug*:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *views/home.pug* 中：
- en: '[PRE55]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In *views/login.pug*:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *views/login.pug* 中：
- en: '[PRE56]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In *views/profile.pug*:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *views/profile.pug* 中：
- en: '[PRE57]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Finally, we can set up our routes in the *index.js* file:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 *index.js* 文件中设置我们的路由：
- en: '[PRE58]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This example was designed to closely match the [Express 4.x Facebook example](https://github.com/passport/express-4.x-facebook-example),
    which provides well-documented code for working with Express and Facebook authentication.
    You can view hundreds of additional [Passport.js strategies](http://www.passportjs.org).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例被设计得与 [Express 4.x Facebook 示例](https://github.com/passport/express-4.x-facebook-example)
    高度匹配，提供了与 Express 和 Facebook 认证相关的代码详细文档。你可以查看数百种额外的 [Passport.js 策略](http://www.passportjs.org)。
- en: Serving Up Formatted Data
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供格式化数据
- en: Problem
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Instead of serving up a web page or sending plain text, you want to return formatted
    data, such as XML, to the browser.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望返回格式化的数据（如 XML）给浏览器，而不是提供一个网页或发送纯文本。
- en: Solution
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use Node module(s) to help format the data. For example, if you want to return
    XML, you can use a module to create the formatted data:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Node 模块来帮助格式化数据。例如，如果你想返回 XML，可以使用一个模块来创建格式化的数据：
- en: '[PRE59]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Then create the appropriate header to go with the data, and return the data
    to the browser:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 然后创建适当的头部信息，与数据一起返回到浏览器：
- en: '[PRE60]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Discussion
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Web servers frequently serve up static or server-side generated resources, but
    just as frequently, what’s returned to the browser is formatted data that’s then
    processed in the web page before display.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Web 服务器经常提供静态或服务器端生成的资源，但同样频繁的是，返回给浏览器的是格式化的数据，在网页显示之前进行处理。
- en: There are two key elements to generating and returning formatted data. The first
    is to make use of whatever Node library to simplify the generation of the data,
    and the second is to make sure that the header data sent with the data is appropriate
    for the data.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 生成和返回格式化数据有两个关键要素。第一个是利用任何 Node 库来简化数据生成的过程，第二个是确保发送数据的头部信息与数据一致。
- en: 'In the solution, the `xmlbuilder` module is used to assist us in creating proper
    XML. This isn’t one of the modules installed with Node by default, so we have
    to install it using npm, the Node Package Manager:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案中，使用了 `xmlbuilder` 模块来辅助我们创建正确的 XML。这不是 Node 默认安装的模块之一，所以我们需要使用 Node 包管理器
    npm 来安装它：
- en: '[PRE61]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Then it’s a matter of creating a new XML document, a root element, and then
    each resource element, as demonstrated in the solution. It’s true, we could build
    the XML string ourselves, but that’s a pain. And it’s too easy to make mistakes
    that are then hard to discover. One of the best things about Node is the enormous
    number of modules available to do most anything we can think of. Not only do we
    not have to write the code ourselves, but most of the modules have been thoroughly
    tested and actively maintained.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建一个新的 XML 文档，一个根元素，然后每个资源元素，正如解决方案中所示。的确，我们可以自己构建 XML 字符串，但这很麻烦。而且容易出现难以发现的错误。Node
    最好的一点之一是有大量的模块可以做我们能想到的几乎任何事情。我们不仅不必亲自编写代码，大多数模块都经过了彻底测试并得到了积极维护。
- en: Once the formatted data is ready to return, create the header that goes with
    it. In the solution, because the document is XML, the header content type is set
    to `application/xml` before the data is returned as a string.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦格式化数据准备好返回，创建对应的头部信息。在解决方案中，因为文档是 XML，所以在将数据返回为字符串之前，设置头部内容类型为 `application/xml`。
- en: Building a RESTful API
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个 RESTful API
- en: Problem
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to build a REST API using Node.js.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望使用 Node.js 构建一个 REST API。
- en: Solution
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use Express with the `app.get`, `app.post`, `app.put`, and `app.delete` methods:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Express 和 `app.get`、`app.post`、`app.put` 和 `app.delete` 方法：
- en: '[PRE62]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Discussion
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: REST stands for “Representational State Transfer,” and is the most common architectural
    approach for building APIs. REST allows us to interact with a remote data source
    over HTTP, using the standard HTTP methods of `GET`, `POST`, `PUT`, and `DELETE`.
    We can make use of the Express routing methods to accept these requests.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: REST 代表“表述性状态转移”，是构建 API 的最常见的架构方法。REST 允许我们使用标准的 HTTP 方法（`GET`、`POST`、`PUT`
    和 `DELETE`）通过 HTTP 与远程数据源交互。我们可以利用 Express 路由方法来接受这些请求。
- en: 'In the following example, I’ll create several routes that serve as API endpoints.
    Each endpoint will respond to an HTTP request:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我将创建几个作为 API 端点的路由。每个端点将响应 HTTP 请求：
- en: '`/todos`'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`/todos`'
- en: Will accept a `get` request for a list of todos as well as a `post` request
    for creating a new todo.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 将接受一个 `get` 请求以获取 todo 列表，以及一个 `post` 请求以创建新的 todo。
- en: '`/todos/:todoId`'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`/todos/:todoId`'
- en: Will accept a `get` request that will return a specific todo as well as a `put`
    request, which will allow the user to update the todo content or completed state,
    and a `delete` request, which will delete the specific todo.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 将接受一个 `get` 请求，返回特定的 todo，以及一个 `put` 请求，允许用户更新 todo 的内容或完成状态，以及一个 `delete` 请求，删除特定的
    todo。
- en: 'With these routes defined, we can develop a REST API that responds to these
    requests appropriately:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些定义的路由，我们可以开发一个能够适当响应这些请求的 REST API。
- en: '[PRE63]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'From the terminal, you can use `curl` to test our responses:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 从终端可以使用 `curl` 测试我们的响应：
- en: '[PRE64]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Manually testing with `curl` can quickly become tedious. For API development,
    you may also want to make use of a REST client UI, such as [Insomnia](https://insomnia.rest)
    or [Postman](https://postman.com) (see [Figure 21-6](#rest_insomnia)).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `curl` 进行手动测试很快会变得乏味。对于 API 开发，您可能还想使用 REST 客户端 UI，例如 [Insomnia](https://insomnia.rest)
    或 [Postman](https://postman.com)（参见 [Figure 21-6](#rest_insomnia)）。
- en: '![A screenshot of the Insomnia REST client](assets/jsc3_2106.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![Insomnia REST 客户端的截图](assets/jsc3_2106.png)'
- en: Figure 21-6\. A GET request in the Insomnia REST client
  id: totrans-304
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 21-6\. Insomnia REST 客户端中的 GET 请求
- en: In the above example, I’m using an in-memory data store. When building an API,
    you will most likely want to connect to a database. To do so, you can reach for
    a library such as [Sequelize](https://oreil.ly/NuXyR) (for SQL databases), [Mongoose](https://oreil.ly/zP8Fr)
    (for MongoDB), or an online data store such as [Firebase](https://oreil.ly/iZSFB).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我正在使用内存数据存储。构建 API 时，您很可能希望连接到数据库。为此，您可以使用诸如 [Sequelize](https://oreil.ly/NuXyR)（用于
    SQL 数据库）、[Mongoose](https://oreil.ly/zP8Fr)（用于 MongoDB）或在线数据存储（如 [Firebase](https://oreil.ly/iZSFB)）等库。
- en: Building a GraphQL API
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 GraphQL API
- en: Problem
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You would like to build a GraphQL API server application or add GraphQL endpoints
    to an existing Express application.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要构建一个 GraphQL API 服务器应用程序或向现有的 Express 应用程序添加 GraphQL 端点。
- en: Solution
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use the Apollo Server package to include GraphQL type definitions, GraphQL
    resolvers, and the GraphQL Playground:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Apollo Server 包含 GraphQL 类型定义、GraphQL 解析器和 GraphQL Playground：
- en: '[PRE65]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Apollo Server provides access to the GraphQL Playground (see [Figure 21-7](#graphql_playground)),
    which allows us to easily interact with the API during development (and in production,
    if desired).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: Apollo Server 提供了对 GraphQL Playground 的访问（参见 [Figure 21-7](#graphql_playground)），这使我们可以在开发过程中轻松与
    API 进行交互（如果需要，在生产环境中也可以）。
- en: '![A screenshot of the GraphQL Playground](assets/jsc3_2107.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![GraphQL Playground 的截图](assets/jsc3_2107.png)'
- en: Figure 21-7\. A GraphQL query in the GraphQL Playground
  id: totrans-314
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 21-7\. GraphQL Playground 中的 GraphQL 查询
- en: The GraphQL Playground also provides automatically generated documentation for
    the API, based on the type definitions you’ve provided (see [Figure 21-8](#unique_id)).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL Playground 还根据您提供的类型定义自动生成 API 的文档（参见 [Figure 21-8](#unique_id)）。
- en: '![A screenshot of the generated GraphQL documentation](assets/jsc3_2108.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![生成的 GraphQL 文档截图](assets/jsc3_2108.png)'
- en: Figure 21-8\. The generated documentation in GraphQL Playground
  id: totrans-317
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 21-8\. GraphQL Playground 中生成的文档
- en: Discussion
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: GraphQL is an open source query language for APIs. It was developed with the
    goal of providing single endpoints for data, allowing applications to request
    the specific data that is needed. [Apollo Server](https://oreil.ly/toPLM) can
    be used as a standalone package or integrated as middleware for popular Node.js
    server application libraries, such as Express, Hapi, Fastify, and Koa.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 是用于 API 的开放源码查询语言。它的开发目标是提供数据的单一端点，允许应用程序请求所需的特定数据。[Apollo Server](https://oreil.ly/toPLM)
    可以作为独立包使用，也可以集成为流行的 Node.js 服务器应用程序库的中间件，如 Express、Hapi、Fastify 和 Koa。
- en: 'In GraphQL, a type definition schema is a written representation of our data
    and interactions. By requiring a schema, GraphQL enforces a strict plan for our
    API. This is because your API can only return data and perform interactions that
    are defined within the schema. The fundamental component of GraphQL schemas are
    object types. GraphQL contains five built-in scalar types:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GraphQL 中，类型定义模式是我们数据和交互的书面表示。通过要求模式，GraphQL 强制执行 API 的严格计划。这是因为您的 API 只能返回在模式中定义的数据并执行其中定义的交互。GraphQL
    模式的基本组件是对象类型。GraphQL 包含五种内置标量类型：
- en: 'String: A string with UTF-8 character encoding'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串：采用 UTF-8 字符编码的字符串
- en: 'Boolean: A true or false value'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值：一个真或假的值
- en: 'Int: A 32-bit integer'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数：一个 32 位整数
- en: 'Float: A floating-point value'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点数：一个浮点数值
- en: 'ID: A unique identifier'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ID：一个唯一标识符
- en: Once the schema is written, we provide the API with a series of resolvers. These
    are functions that specify how the data should be returned in a query or changed
    within a data mutation.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦模式编写完成，我们就为 API 提供一系列解析器。这些解析器是指定查询中应如何返回数据或在数据变异中进行更改的函数。
- en: 'In the previous example, we’re using the `apollo-server-express` package, which
    should be installed alongside the `express` and `gql` packages:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的示例中，我们使用了 `apollo-server-express` 包，它应与 `express` 和 `gql` 包一起安装：
- en: '[PRE66]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'To create a CRUD application, we can define our GraphQL type definitions and
    the appropriate resolvers. The following example mimics the one found in [“Building
    a RESTful API”](#express-rest):'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 CRUD 应用程序，我们可以定义我们的 GraphQL 类型定义和适当的解析器。下面的示例模仿了 [“构建 RESTful API”](#express-rest)
    中找到的示例：
- en: '[PRE67]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: In the above example, I’m using an in-memory data store. When building an API,
    you will most likely want to connect to a database. To do so, you can reach for
    a library such as Sequelize (for SQL databases), Mongoose (for MongoDB), or an
    online data store such as Firebase.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我正在使用内存数据存储。构建 API 时，您很可能希望连接到数据库。为此，您可以使用像 Sequelize（用于 SQL 数据库）、Mongoose（用于
    MongoDB）或在线数据存储（如 Firebase）这样的库。
- en: The defined queries return data directly from the API, while the mutations allow
    us to perform changes to the data, such as create a new item, update an item,
    or delete an item.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 定义的查询直接从 API 返回数据，而变异允许我们对数据执行更改，例如创建新项目、更新项目或删除项目。
