- en: Chapter 8\. Classes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。类
- en: Some functional devs
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一些功能开发人员
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Try to *never* use classes
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽量*永远*不使用类
- en: ''
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Too intense for me
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对我来说太强烈了
- en: The world of JavaScript during TypeScript’s creation and release in the early
    2010s was quite different from today. Features such as arrow functions and `let`/`const`
    variables that would later be standardized in ES2015 were still distant hopes
    on the horizon. Babel was a few years away from its first commit; its predecessor
    tools such as Traceur that converted newer JavaScript syntax to old hadn’t achieved
    full mainstream adoption.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript创建和发布于2010年代初期的JavaScript世界与今天大不相同。例如箭头函数和`let`/`const`变量等功能，这些功能后来在ES2015中标准化，当时还只是遥远的希望。Babel离第一个提交还有几年时间；其前身工具如Traceur，将新的JavaScript语法转换为旧的，尚未完全普及。
- en: TypeScript’s early marketing and feature set were tailored to that world. In
    addition to its type checking, its transpiler was emphasized—with classes as a
    frequent example. Nowadays TypeScript’s class support is just one feature among
    many to support all JavaScript language features. TypeScript neither encourages
    nor discourages class use or any other popular JavaScript pattern.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript早期的市场营销和功能设置是针对那个世界的。除了类型检查之外，还强调了其转译器，以类作为一个常见的例子。如今，TypeScript的类支持只是支持所有JavaScript语言特性之一的一部分。TypeScript既不鼓励也不阻止类的使用或任何其他流行的JavaScript模式。
- en: Class Methods
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类方法
- en: TypeScript generally understands methods the same way it understands standalone
    functions. Parameter types default to `any` unless given a type or default value;
    calling the method requires an acceptable number of arguments; return types can
    generally be inferred if the function is not recursive.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript通常将方法理解为独立函数。参数类型默认为`any`，除非给定类型或默认值；调用方法需要接受适当数量的参数；如果函数不是递归的话，通常可以推断返回类型。
- en: 'This code snippet defines a `Greeter` class with a `greet` class method that
    takes in a single required parameter of type `number`:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段定义了一个`Greeter`类，其中包含一个接受类型为`number`的单个必需参数的`greet`类方法：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Class constructors are treated like typical class methods with regards to their
    parameters. TypeScript will perform type checking to make sure a correct number
    of arguments with correct types are provided to method calls.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 类构造函数在其参数方面与典型的类方法一样对待。TypeScript将执行类型检查，以确保方法调用提供了正确数量和正确类型的参数。
- en: 'This `Greeted` constructor also expects its `message: string` parameter to
    be provided:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '这个`Greeted`构造函数也期望提供`message: string`参数：'
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: I’ll cover constructors in the context of subclasses later in this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在本章的子类上下文中涵盖构造函数。
- en: Class Properties
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类属性
- en: 'To read from or write to a property on a class in TypeScript, it must be explicitly
    declared in the class. Class properties are declared using the same syntax as
    interfaces: their name followed optionally by a type annotation.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要在TypeScript中从类的属性读取或写入，必须在类中明确声明它们。类属性使用与接口相同的语法声明：它们的名称后面可以选择跟上类型注释。
- en: TypeScript will not attempt to deduce what members may exist on a class from
    their assignments in a constructor.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript不会试图从构造函数中的赋值推断出类可能存在的成员。
- en: 'In this example, `destination` is allowed to be assigned to and accessed on
    instances of the `FieldTrip` class because it is explicitly declared as a `string`.
    The `this.nonexistent` assignment in the constructor is not allowed because the
    class does not declare a `nonexistent` property:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`destination`允许在`FieldTrip`类的实例上分配和访问，因为它被明确声明为`string`。在构造函数中的`this.nonexistent`赋值是不允许的，因为该类没有声明`nonexistent`属性：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Explicitly declaring class properties allows TypeScript to quickly understand
    what is or is not allowed to exist on instances of classes. Later, when class
    instances are in use, TypeScript uses that understanding to give a type error
    if code attempts to access a member of a class instance not known to exist, such
    as with this continuation’s `trip.nonexistent`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 明确声明类属性允许TypeScript快速理解哪些实例中可以存在或不存在。稍后，在使用类实例时，TypeScript利用这一理解，在代码尝试访问未知存在的类实例成员时，例如在本段续写中的`trip.nonexistent`，会给出类型错误：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Function Properties
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数属性
- en: 'Let’s recap some JavaScript method scoping and syntax fundamentals for a bit,
    as they can be surprising if you’re not accustomed to them. JavaScript contains
    two syntaxes for declaring a member on a class to be a callable function: *method*
    and *property*.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要回顾一些 JavaScript 方法作用域和语法基础知识，因为如果您不习惯，它们可能会让人惊讶。JavaScript 包含两种语法用于声明类的成员为可调用函数：*方法*
    和 *属性*。
- en: I’ve already shown the method approach of putting parentheses after the member
    name, like `myFunction() {}`. The method approach assigns a function to the class
    prototype, so all class instances use the same function definition.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经展示了在成员名称后加括号的方法，例如 `myFunction() {}`。方法的方法会将函数分配给类的原型，因此所有类实例使用相同的函数定义。
- en: 'This `WithMethod` class declares a `myMethod` method that all instances are
    able to refer to:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此 `WithMethod` 类声明了一个 `myMethod` 方法，所有实例均能引用：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The other syntax is to declare a property whose value happens to be a function.
    This creates a new function per instance of the class, which can be useful with
    `() =>` arrow functions whose `this` scope should always point to the class instance
    (at the time and memory cost of creating a new function per class instance).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种语法是声明一个其值恰好为函数的属性。这会为类的每个实例创建一个新的函数，对于箭头函数 `() =>`，这可以保证 `this` 的作用域始终指向类实例（以时间和内存开销换取）。
- en: 'This `WithProperty` class contains a single property of name `myProperty` and
    type `() => void` that will be re-created for each class instance:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此 `WithProperty` 类包含一个名为 `myProperty`，类型为 `() => void` 的单一属性，每个类实例将重新创建该属性：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Function properties can be given parameters and return types using the same
    syntax as class methods and standalone functions. After all, they’re a value assigned
    to a class member and the value happens to be a function.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 函数属性可以使用与类方法和独立函数相同的语法提供参数和返回类型。毕竟，它们是分配给类成员的值，其值恰好是一个函数。
- en: 'This `WithPropertyParameters` class has a `takesParameters` property of type
    `(input: string) => number`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '此 `WithPropertyParameters` 类具有类型为 `(input: string) => number` 的 `takesParameters`
    属性：'
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Initialization Checking
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化检查
- en: With strict compiler settings enabled, TypeScript will check that each property
    declared whose type does not include `undefined` is assigned a value in the constructor.
    This strict initialization checking is useful because it prevents code from accidentally
    forgetting to assign a value to a class property.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 启用严格的编译器设置后，TypeScript 将检查每个声明的属性，确保其类型不包括 `undefined`，在构造函数中被赋值。这种严格的初始化检查非常有用，因为它可以防止代码意外地忘记为类属性赋值。
- en: 'The following `WithValue` class does not assign a value to its `unused` property,
    which TypeScript recognizes as a type error:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的 `WithValue` 类没有为其 `unused` 属性赋值，这在 TypeScript 中被识别为类型错误：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Without strict initialization checking, a class instance could be allowed to
    access a value that might be `undefined` even though the type system says it can’t
    be.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有严格的初始化检查，可能允许类实例访问一个可能为 `undefined` 的值，尽管类型系统说它不可能。
- en: 'This example would compile happily if strict initialization checking didn’t
    happen, but the resultant JavaScript would crash at runtime:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有发生严格的初始化检查，这个例子将编译通过，但生成的 JavaScript 代码在运行时会崩溃：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The billion-dollar mistake strikes again!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 十亿美元的错误再次发生！
- en: Configuring strict property initialization checking with TypeScript’s `strictPropertyInitialization`
    compiler option is covered in [Chapter 12, “Using IDE Features”](ch12.xhtml#using_ide_features).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 TypeScript 的 `strictPropertyInitialization` 编译器选项配置严格的属性初始化检查详见[第 12 章 “使用
    IDE 功能”](ch12.xhtml#using_ide_features)。
- en: Definitely assigned properties
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 明确分配的属性
- en: Although strict initialization checking is useful most of the time, you may
    come across some cases where a class property is intentionally able to be unassigned
    after the class constructor. If you are absolutely sure a property should not
    have strict initialization checking applied to it, you can add a `!` after its
    name to disable the check. Doing so asserts to TypeScript that the property will
    be assigned a value other than `undefined` before its first usage.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管严格的初始化检查大多数时候很有用，您可能会遇到一些情况，其中一个类属性被有意允许在类构造函数后未分配。如果您确信某个属性不应该被应用严格的初始化检查，您可以在其名称后加上
    `!` 来禁用检查。这样做断言给 TypeScript，该属性在第一次使用前会被赋值为非 `undefined` 的值。
- en: 'This `ActivitiesQueue` class is meant to be re-initialized any number of times
    separately from its constructor, so its `pending` property must be asserted with
    a `!`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`ActivitiesQueue`类可以在任意次数中单独重新初始化，因此它的`pending`属性必须用`!`断言：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Warning
  id: totrans-47
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Needing to disable strict initialization checking on a class property is often
    a sign of code being set up in a way that doesn’t lend itself well to type checking.
    Instead of adding a `!` assertion and reducing type safety for the property, consider
    refactoring the class to no longer need the assertion.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 需要在类属性上禁用严格的初始化检查通常是代码设置方式不适合类型检查的标志。不要为了属性添加`!`断言并降低类型安全性，考虑重构类以不再需要断言。
- en: Optional Properties
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选属性
- en: Much like interfaces, classes in TypeScript may declare a property as optional
    by adding a `?` after its declaration name. Optional properties behave roughly
    the same as properties whose types happen to be a union that includes `| undefined`.
    Strict initialization checking won’t mind if they’re not explicitly set in their
    constructor.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 类似接口，TypeScript 中的类可以通过在声明名称后添加`?`将属性声明为可选。可选属性的行为与类型为包括`| undefined`的联合的属性大致相同。如果它们在构造函数中没有被明确设置，严格的初始化检查不会介意。
- en: 'This `OptionalProperty` class marks its `property` as optional, so it’s allowed
    to not be assigned in the class constructor regardless of strict property initialization
    checking:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`OptionalProperty`类将其`property`标记为可选，因此允许在类构造函数中不分配它：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Read-Only Properties
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 只读属性
- en: Again much like interfaces, classes in TypeScript may declare a property as
    read-only by adding the `readonly` keyword before its declaration name. The `readonly`
    keyword exists purely within the type system and is removed when compiling to
    JavaScript.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 与接口类似，TypeScript 中的类可以通过在声明名称前添加`readonly`关键字将属性声明为只读。`readonly`关键字完全存在于类型系统中，并且在编译为
    JavaScript 时会被移除。
- en: Properties declared as `readonly` may only be assigned initial values where
    they are declared or in a constructor. Any other location—including methods on
    the class itself—may only read from the properties, not write to them.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 声明为`readonly`的属性只能在声明它们或构造函数中分配初始值。任何其他位置 —— 包括类本身的方法 —— 只能从属性中读取，而不能写入它们。
- en: 'In this example, the `text` property on the `Quote` class is given a value
    in the constructor, but the other uses cause type errors:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Quote`类的`text`属性在构造函数中被赋值，但其他用法会导致类型错误：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Warning
  id: totrans-58
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: External users of your code, such as consumers of any npm packages you published,
    might not respect `readonly` modifiers—especially if they’re writing JavaScript
    and don’t have type checking. If you need true read-only protection, consider
    using `#` private fields and/or `get()` function properties.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 外部使用你的代码的用户，比如你发布的任何 npm 包的消费者，可能不会尊重`readonly`修饰符 —— 特别是如果他们正在编写 JavaScript
    并且没有类型检查。如果你需要真正的只读保护，请考虑使用`#`私有字段和/或`get()`函数属性。
- en: 'Properties declared as `readonly` with an initial value of a primitive have
    a slight quirk compared to other properties: they are inferred to be their value’s
    narrowed *literal* type if possible, rather than the wider *primitive*. TypeScript
    feels comfortable with a more aggressive initial type narrowing because it knows
    the value won’t be changed later; it is similar to `const` variables taking on
    narrower types than `let` variables.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 初始值为原始值的属性声明为`readonly`，与其他属性相比有一个小小的怪癖：如果可能的话，它们被推断为其值的狭窄*字面*类型，而不是更宽的*原始*类型。
    TypeScript 对更积极的初始类型缩小感到舒适，因为它知道这个值后来不会改变；这与`const`变量比`let`变量具有更窄类型类似。
- en: 'In this example, the class properties are both initially declared as a string
    literal, so in order to widen one of them to `string`, a type annotation is needed:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，类的属性最初都声明为字符串字面值，因此为了将其中一个扩展为`string`，需要一个类型注释：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Widening a property’s type explicitly is not necessary very often. Still, it
    can sometimes be useful in the case of conditional logic in constructors like
    the one in `RandomQuote`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 明确扩展属性的类型通常不是很必要。但在构造函数中的条件逻辑的情况下有时会有用，比如`RandomQuote`中的构造函数：
- en: Classes as Types
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类作为类型
- en: Classes are relatively unique in the type system in that a class declaration
    creates both a runtime value—the class itself—as well as a type that can be used
    in type annotations.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 类在类型系统中相对独特，因为类声明既创建一个运行时值（类本身），又创建一个可以用于类型注释的类型。
- en: 'The name of this `Teacher` class is used to annotate a `teacher` variable,
    telling TypeScript that it should be assigned only values that are assignable
    to the `Teacher` class—such as instances of the `Teacher` class itself:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `Teacher` 类的名称用于注释一个 `teacher` 变量，告诉 TypeScript 它只能被分配给可以分配给 `Teacher` 类的值，比如
    `Teacher` 类的实例：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Interestingly, TypeScript will consider any object type that happens to include
    all the same members of a class to be assignable to the class. This is because
    TypeScript’s structural typing cares only about the shape of objects, not how
    they’re declared.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，TypeScript 将认为任何包含与类的所有相同成员的对象类型都可以分配给这个类。这是因为 TypeScript 的结构类型检查只关心对象的形状，而不关心它们的声明方式。
- en: 'Here, `withSchoolBus` takes in a parameter of type `SchoolBus`. That can be
    satisfied by any object that happens to have a `getAbilities` property of type
    `() => string[]`, such as an instance of the `SchoolBus` class:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`withSchoolBus` 接受一个类型为 `SchoolBus` 的参数。任何对象，只要它恰好具有类型为 `() => string[]`
    的 `getAbilities` 属性，比如 `SchoolBus` 类的一个实例，就可以满足这一要求：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Tip
  id: totrans-71
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: In most real-world code, developers don’t pass object values in places that
    ask for class types. This structural checking behavior may seem unexpected but
    doesn’t come up very often.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数真实世界的代码中，开发者不会在需要类类型的地方传递对象值。这种结构检查行为可能看起来意外，但并不经常发生。
- en: Classes and Interfaces
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类与接口
- en: Back in [Chapter 7, “Interfaces”](ch07.xhtml#interfaces), I showed you how interfaces
    allow TypeScript developers to set up expectations for object shapes in code.
    TypeScript allows a class to declare its instances as adhering to an interface
    by adding the `implements` keyword after the class name, followed by the name
    of an interface. Doing so indicates to TypeScript that instances of the class
    should be assignable to each of those interfaces. Any mismatches would be called
    out as type errors by the type checker.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾[第7章，“接口”](ch07.xhtml#interfaces)中，我向你展示了接口如何允许 TypeScript 开发者在代码中设置对象形状的期望。通过在类名后添加
    `implements` 关键字，接着是接口的名称，允许一个类声明其实例应该可以分配给这些接口中的每一个。任何不匹配的地方将被类型检查器指出为类型错误。
- en: 'In this example, the `Student` class correctly implements the `Learner` interface
    by including its property `name` and method `study`, but `Slacker` is missing
    a `study` and thus results in a type error:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Student` 类通过包含其属性 `name` 和方法 `study` 正确地实现了 `Learner` 接口，但 `Slacker`
    缺少了 `study` 方法，因此导致类型错误：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-77
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Interfaces meant to be implemented by classes are a typical reason to use the
    method syntax for declaring an interface member as a function—as used by the `Learner`
    interface.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接口用于被类实现是使用方法语法声明接口成员作为函数的典型原因，正如 `Learner` 接口所示。
- en: 'Marking a class as implementing an interface doesn’t change anything about
    how the class is used. If the class already happened to match up to the interface,
    TypeScript’s type checker would have allowed its instances to be used in places
    where an instance of the interface is required anyway. TypeScript won’t even infer
    the types of methods or properties on the class from the interface: if we had
    added a `study(hours) {}` method to the `Slacker` example, TypeScript would consider
    the `hours` parameter an implicit `any` unless we gave it a type annotation.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 将类标记为实现接口不会改变类的使用方式。如果类已经恰好匹配接口，TypeScript 的类型检查器将允许将其实例用于需要接口实例的地方。 TypeScript
    甚至不会从接口推断类的方法或属性的类型：如果我们在 `Slacker` 示例中添加了一个 `study(hours) {}` 方法，TypeScript 将会将
    `hours` 参数视为隐式的 `any`，除非我们对其进行类型注释。
- en: 'This version of the `Student` class causes implicit `any` type errors because
    it doesn’t provide type annotations on its members:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `Student` 类的版本会因为没有为其成员提供类型注解而导致隐式的 `any` 类型错误：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Implementing an interface is purely a safety check. It does not copy any interface
    members onto the class definition for you. Rather, implementing an interface signals
    your intention to the type checker and surfaces type errors in the class definition,
    rather than later on where class instances are used. It’s similar in purpose to
    adding a type annotation to a variable even though it has an initial value.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 实现接口纯粹是一种安全检查。它不会为你在类定义中复制任何接口成员。而是通过实现接口向类型检查器表明你的意图，并在类定义中暴露类型错误，而不是在稍后使用类实例的地方。它的目的类似于为变量添加类型注解，即使它具有初始值。
- en: Implementing Multiple Interfaces
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现多个接口
- en: Classes in TypeScript are allowed to be declared as implementing multiple interfaces.
    The list of implemented interfaces for a class may be any number of interface
    names with commas in-between.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 中的类允许声明为实现多个接口。类的实现接口列表可以是任意数量的接口名称，用逗号分隔。
- en: 'In this example, both classes are required to have at least a `grades` property
    to implement `Graded` and a `report` property to implement `Reporter`. The `Empty`
    class has two type errors for failing to implement either of the interfaces properly:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，两个类都必须至少有一个 `grades` 属性来实现 `Graded`，并且一个 `report` 属性来实现 `Reporter`。`Empty`
    类由于未能正确实现任何接口而存在两个类型错误：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In practice, there may be some interfaces whose definitions make it impossible
    to have a class implement both. Attempting to declare a class implementing two
    conflicting interfaces will result in at least one type error on the class.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 实际应用中，可能会存在一些接口定义使得同一个类无法实现两者。尝试声明一个类同时实现两个冲突接口将导致类至少有一个类型错误。
- en: 'The following `AgeIsANumber` and `AgeIsNotANumber` interfaces declare very
    different types for an `age` property. Neither the `AsNumber` class nor `NotAsNumber`
    class properly implement both:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的 `AgeIsANumber` 和 `AgeIsNotANumber` 接口为 `age` 属性声明了非常不同的类型。`AsNumber` 类和
    `NotAsNumber` 类都未能正确实现这两个接口：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Cases where two interfaces describe very different object shapes generally indicate
    you shouldn’t try to implement them with the same class.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个接口描述非常不同的对象形状的情况下，通常表明你不应该尝试使用同一个类来实现它们。
- en: Extending a Class
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展类
- en: TypeScript adds type checking onto the JavaScript concept of a class extending,
    or subclassing, another class. To start, any method or property declared on a
    base class will be available on the subclass, also known as the derived class.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 在 JavaScript 类扩展或子类化的概念上增加了类型检查。首先，基类上声明的任何方法或属性都将在子类（也称为派生类）上可用。
- en: 'In this example, `Teacher` declares a `teach` method that may be used by instances
    of the `StudentTeacher` subclass:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`Teacher` 声明了一个 `teach` 方法，可以被 `StudentTeacher` 子类的实例使用：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Extension Assignability
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展可分配性
- en: Subclasses inherit members from their base class much like derived interfaces
    extend base interfaces. Instances of subclasses have all the members of their
    base class and thus may be used wherever an instance of the base is required.
    If a base class doesn’t have all the members a subclass does, then it can’t be
    used when the more specific subclass is required.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 子类像派生接口扩展基础接口一样继承其基类的成员。子类的实例具有其基类的所有成员，因此可以在需要基类实例的地方使用。如果基类没有子类具有的所有成员，则在需要更具体的子类时不能使用基类。
- en: 'Instances of the following `Lesson` class may not be used where instances of
    its derived `OnlineLesson` are required, but derived instances may be used to
    satisfy either the base or subclass:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `Lesson` 类的实例不能在需要其派生类 `OnlineLesson` 的地方使用，但派生实例可以用来满足基类或子类的要求：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Per TypeScript’s structural typing, if all the members on a subclass already
    exist on its base class with the same type, then instances of the base class are
    still allowed to be used in place of the subclass.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 TypeScript 的结构类型，如果子类的所有成员在其基类上已经存在且类型相同，则仍允许使用基类的实例来代替子类的实例。
- en: 'In this example, `LabeledPastGrades` only adds an optional property to `PastGrades`,
    so instances of the base class may be used in place of the subclass:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`LabeledPastGrades` 只向 `PastGrades` 添加了一个可选属性，因此基类的实例可以替换子类的实例：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Tip
  id: totrans-103
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: In most real-world code, subclasses generally add new required type information
    on top of their base class. This structural checking behavior may seem unexpected
    but doesn’t come up very often.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数真实世界的代码中，子类通常在其基类之上添加新的必需类型信息。这种结构检查行为可能看起来出乎意料，但并不经常发生。
- en: Overridden Constructors
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖构造函数
- en: As with vanilla JavaScript, subclasses are not required by TypeScript to define
    their own constructor. Subclasses without their own constructor implicitly use
    the constructor from their base class.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 与原始 JavaScript 类似，TypeScript 中的子类不需要定义自己的构造函数。没有自己构造函数的子类隐式使用其基类的构造函数。
- en: In JavaScript, if a subclass does declare its own constructor, then it must
    call its base class constructor via the `super` keyword. Subclass constructors
    may declare any parameters regardless of what their base class requires. TypeScript’s
    type checker will make sure that the call to the base class constructor uses the
    correct parameters.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，如果子类确实声明了自己的构造函数，则必须通过 `super` 关键字调用其基类构造函数。子类构造函数可以声明任何参数，而不管其基类需要什么参数。TypeScript
    的类型检查器将确保对基类构造函数的调用使用了正确的参数。
- en: 'In this example, `PassingAnnouncer`’s constructor correctly calls the base
    constructor with a `number` argument, while `FailingAnnouncer` gets a type error
    for forgetting to make that call:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`PassingAnnouncer` 的构造函数正确地使用一个 `number` 参数调用了基类构造函数，而 `FailingAnnouncer`
    由于忘记进行此调用而导致类型错误：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As per JavaScript rules, the constructor of a subclass must call the base constructor
    before accessing `this` or `super`. TypeScript will report a type error if it
    sees a `this` or `super` being accessed before `super()`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 JavaScript 规则，在子类的构造函数中，在访问 `this` 或 `super` 之前必须调用基类构造函数。如果 TypeScript 在
    `super()` 之前看到 `this` 或 `super` 被访问，将报告类型错误。
- en: 'The following `ContinuedGradesTally` class erroneously refers to `this.grades`
    in its constructor before calling to `super()`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的 `ContinuedGradesTally` 类在其构造函数中在调用 `super()` 之前错误地引用了 `this.grades`：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Overridden Methods
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 被重写的方法
- en: Subclasses may redeclare new methods with the same names as the base class,
    as long as the method on the subclass method is assignable to the method on the
    base class. Remember, since subclasses can be used wherever the original class
    is used, the types of the new methods must be usable in place of the original
    methods.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 子类可以重新声明与基类相同名称的新方法，只要子类方法上的方法可以分配给基类上的方法即可。请记住，由于子类可以用在原始类可用的任何地方，新方法的类型必须能够替代原始方法的位置。
- en: 'In this example, `FailureCounter`’s `countGrades` method is permitted because
    it has the same first parameter and return type as the base `GradeCounter`’s `countGrades`
    method. `AnyFailureChecker`’s `countGrades` causes a type error for having the
    wrong return type:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`FailureCounter` 的 `countGrades` 方法被允许，因为它与基类 `GradeCounter` 的 `countGrades`
    方法具有相同的第一个参数和返回类型。`AnyFailureChecker` 的 `countGrades` 因返回类型不正确而导致类型错误：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Overridden Properties
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 被重写的属性
- en: Subclasses may also explicitly redeclare properties of their base class with
    the same name, as long as the new type is assignable to the type on the base class.
    As with overridden methods, subclasses must structurally match up with base classes.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 子类也可以显式地重新声明其基类的同名属性，只要新类型可分配给基类的类型即可。与重写方法一样，子类必须与基类结构匹配。
- en: Most subclasses that redeclare properties do so either to make those properties
    a more specific subset of a type union or to make the properties a type that extends
    from the base class property’s type.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数重新声明属性的子类都是为了将这些属性作为类型联合的更具体子集，或者使属性成为扩展自基类属性类型的类型。
- en: 'In this example, the base class `Assignment` declares its `grade` to be `number
    |` `undefined`, while the subclass `GradedAssignment` declares it as a `number`
    that must always exist:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，基类 `Assignment` 将其 `grade` 声明为 `number |` `undefined`，而子类 `GradedAssignment`
    将其声明为一个始终存在的 `number`：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Expanding the allowed set of values of a property’s union type is not allowed,
    as doing so would make the subclass property no longer assignable to the base
    class property’s type.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展属性联合类型的允许值集合是不允许的，因为这样做将使子类属性不再可分配给基类属性的类型。
- en: 'In this example, `VagueGrade`’s `value` tries to add `| string` on top of the
    base class `NumericGrade`’s `number` type, causing a type error:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`VagueGrade` 的 `value` 尝试在基类 `NumericGrade` 的 `number` 类型之上添加 `| string`，导致类型错误：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Abstract Classes
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象类
- en: It can sometimes be useful to create a base class that doesn’t itself declare
    the implementation of some methods, but instead expects a subclass to provide
    them. Marking a class as abstract is done by adding TypeScript’s `abstract` keyword
    in front of the class name and in front of any method intended to be abstract.
    Those abstract method declarations skip providing a body in the abstract base
    class; instead, they are declared the same way an interface would be.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有时创建一个基类，它本身不声明某些方法的实现，而是期望子类提供它们，这样做可以很有用。通过在类名前面加上 TypeScript 的 `abstract`
    关键字和任何预期为抽象的方法前面加上 `abstract` 关键字来标记一个类为抽象。这些抽象方法声明在抽象基类中不提供具体实现；相反，它们的声明方式与接口相同。
- en: 'In this example, the `School` class and its `getStudentTypes` method are marked
    as `abstract`. Its subclasses—`Preschool` and `Absence`—are therefore expected
    to implement `getStudentTypes`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`School` 类及其 `getStudentTypes` 方法被标记为 `abstract`。因此，其子类——`Preschool` 和
    `Absence`——应当实现 `getStudentTypes`：
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: An abstract class cannot be instantiated directly, as it doesn’t have definitions
    for some methods that its implementation may assume do exist. Only nonabstract
    (“concrete”) classes can be instantiated.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类不能直接实例化，因为它没有某些方法的定义，其实现可能假定存在。只有非抽象（“具体的”）类可以被实例化。
- en: 'Continuing the `School` example, attempting to call `new School` would result
    in a TypeScript type error:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 继续 `School` 示例，尝试调用 `new School` 将导致 TypeScript 类型错误：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Abstract classes are often used in frameworks where consumers are expected
    to fill out details of a class. The class may be used as a type annotation to
    indicate values must adhere to the class—as with the earlier example of `school:
    School`—but creating new instances must be done with subclasses.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '抽象类通常在期望消费者填写类细节的框架中使用。类可以用作类型注解，以指示值必须遵守该类，就像早期示例中的 `school: School` 一样，但创建新实例必须使用子类完成。'
- en: Member Visibility
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 成员可见性
- en: JavaScript includes the ability to start the name of a class member with `#`
    to mark it as a “private” class member. Private class members may only be accessed
    by instances of that class. JavaScript runtimes enforce that privacy by throwing
    an error if an area of code outside the class tries to access the private method
    or property.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 允许在类成员名称前面加 `#` 标记为“私有”类成员。私有类成员只能由该类的实例访问。JavaScript 运行时通过在类外部的代码尝试访问私有方法或属性时抛出错误来强制执行此隐私。
- en: 'TypeScript’s class support predates JavaScript’s true `#` privacy, and while
    TypeScript supports private class members, it also allows a slightly more nuanced
    set of privacy definitions on class methods and properties that exist solely in
    the type system. TypeScript’s member visibilities are achieved by adding one of
    the following keywords before the declaration name of a class member:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 的类支持早于 JavaScript 的真正的 `#` 隐私功能，虽然 TypeScript 支持私有类成员，但它还允许在仅存在于类型系统中的类方法和属性上定义略微更加微妙的隐私定义。通过在类成员的声明名称之前添加以下关键字之一，可以实现
    TypeScript 的成员可见性：
- en: '`public` (default)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`public`（默认）'
- en: Allowed to be accessed by anybody, anywhere
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 允许任何人在任何地方访问
- en: '`protected`'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`protected`'
- en: Allowed to be accessed only by the class itself and its subclasses
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 只允许类本身及其子类访问
- en: '`private`'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`private`'
- en: Allowed to be accessed only by the class itself
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 只允许类本身访问
- en: These keywords exist purely within the type system. They’re removed along with
    all other type system syntax when the code is compiled to JavaScript.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这些关键字仅存在于类型系统中。当代码编译为 JavaScript 时，它们与所有其他类型系统语法一起被移除。
- en: 'Here, `Base` declares two `public` members, one `protected`, one `private`,
    and one true private with `#truePrivate`. `Subclass` is allowed to access the
    `public` and `protected` members but not `private` or `#truePrivate`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Base` 声明了两个 `public` 成员，一个 `protected` 成员，一个 `private` 成员和一个真正的私有成员 `#truePrivate`。`Subclass`
    可以访问 `public` 和 `protected` 成员，但不能访问 `private` 或 `#truePrivate`：
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The key difference between TypeScript’s member visibilities and JavaScript’s
    true private declarations is that TypeScript’s exist only in the type system,
    while JavaScript’s also exist at runtime. A TypeScript class member declared as
    `protected` or `private` will compile to the same JavaScript code as if they were
    declared `public` explicitly or implicitly. As with interfaces and type annotations,
    visibility keywords are erased when outputting JavaScript. Only `#` private fields
    are truly private in runtime JavaScript.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 的成员可见性与 JavaScript 的真正私有声明的关键区别在于 TypeScript 的存在仅存在于类型系统中，而 JavaScript
    的私有成员也存在于运行时。 TypeScript 中声明为 `protected` 或 `private` 的类成员在编译为 JavaScript 代码时，与显式或隐式声明为
    `public` 的代码相同。与接口和类型注解一样，可见性关键字在输出 JavaScript 时会被擦除。只有 `#` 私有字段在运行时的 JavaScript
    中才是真正私有的。
- en: Visibility modifiers may be marked along with `readonly`. To declare a member
    both as `readonly` and with an explicit visibility, the visibility comes first.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 可见性修饰符可以与 `readonly` 一起标记。要同时声明成员为 `readonly` 和显式可见性，可见性应该先声明。
- en: 'This `TwoKeywords` class declares its `name` member as both `private` and `readonly`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 此 `TwoKeywords` 类将其 `name` 成员声明为 `private` 和 `readonly`：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note that it is not permitted to mix TypeScript’s old member visibility keyword
    with JavaScript’s new `#` private fields. Private fields are always private by
    default, so there’s no need to additionally mark them with the `private` keyword.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，不允许将 TypeScript 的旧成员可见性关键字与 JavaScript 的新 `#` 私有字段混合使用。私有字段默认始终为私有，因此无需额外使用
    `private` 关键字标记它们。
- en: Static Field Modifiers
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态字段修饰符
- en: JavaScript allows declaring members on a class itself—rather than its instances—using
    the `static` keyword. TypeScript supports using the `static` keyword on its own
    and/or with `readonly` and/or with one of the visibility keywords. When combined,
    the visibility keyword comes first, then `static`, then `readonly`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 允许在类本身上声明成员——而不是其实例——使用 `static` 关键字。 TypeScript 支持在其自身上使用 `static`
    关键字和/或与 `readonly` 和/或一个可见性关键字结合使用。当组合使用时，可见性关键字首先出现，然后是 `static`，然后是 `readonly`。
- en: 'This `HasStatic` class puts them all together to make its `static` `prompt`
    and `answer` properties both `readonly` and `protected`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `HasStatic` 类将它们全部整合到一起，使其 `static` 的 `prompt` 和 `answer` 属性都是 `readonly`
    和 `protected`：
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Using read-only and/or visibility modifiers to static class fields is useful
    for restricting those fields from being accessed or modified outside their class.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用只读和/或可见性修饰符来限制静态类字段，对于阻止这些字段在其类外被访问或修改很有用。
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter introduced a plethora of type system features and syntaxes around
    classes:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了关于类的大量类型系统特性和语法：
- en: Declaring and using class methods and properties
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明和使用类的方法和属性
- en: Marking properties `readonly` and/or optional
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将属性标记为 `readonly` 和/或可选
- en: Using class names as types in type annotations
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将类名用作类型注释的类型
- en: Implementing interfaces to enforce class instance shapes
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现接口以强制执行类实例的形状
- en: Extending classes, along with assignability and override rules for subclasses
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展类，以及子类的可赋值性和覆盖规则
- en: Marking classes and methods as abstract
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将类和方法标记为抽象
- en: Adding type system modifiers to class fields
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向类字段添加类型系统修饰符
- en: Tip
  id: totrans-164
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Now that you’ve finished reading this chapter, practice what you’ve learned
    on [*https://learningtypescript.com/classes*](https://learningtypescript.com/classes).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经完成了阅读本章，可以将所学的内容练习到 [*https://learningtypescript.com/classes*](https://learningtypescript.com/classes)
    上。
- en: Why do object-oriented programming developers always wear suits?
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么面向对象编程开发人员总是穿着西装？
- en: ''
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Because they’ve got class.
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 因为它们拥有类。
