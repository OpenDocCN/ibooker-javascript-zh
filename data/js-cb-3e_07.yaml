- en: Chapter 6\. Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。函数
- en: Functions are the building blocks that you use to assemble a program out of
    discrete, reusable code routines. But in JavaScript, that’s only part of the story.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是你用来组装程序的离散、可重用代码例程的构建块。但在 JavaScript 中，这只是故事的一部分。
- en: JavaScript functions are also genuine *objects*—instances of the `Function`
    type. They can be assigned to variables and passed around your code. They can
    be declared in an expression, without a function name, and optionally using a
    streamlined *arrow syntax*. You can even wrap one function in another to create
    a private package that includes the function’s state (called a *closure*).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 函数也是真正的*对象*—`Function` 类型的实例。它们可以被赋值给变量并在代码中传递。它们可以在表达式中声明，不需要函数名，并且可以使用简化的*箭头语法*。你甚至可以将一个函数包装在另一个函数中，以创建一个包含函数状态的私有包（称为*闭包*）。
- en: Functions are also at the core of JavaScript’s object-oriented support. That’s
    because custom classes are really just a special type of constructor function
    (as you’ll see in [Chapter 8](ch08.html#ch08)). Sooner or later, everything in
    JavaScript comes back to functions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 函数也是 JavaScript 面向对象支持的核心。这是因为自定义类实际上只是一种特殊类型的构造函数（正如你将在[第8章](ch08.html#ch08)中看到的）。迟早，JavaScript
    中的一切都会回到函数。
- en: Passing a Function as an Argument to Another Function
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将函数作为参数传递给另一个函数
- en: Problem
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You’re calling a function that expects you to provide your own function. What’s
    the best way to pass it?
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在调用一个期望你提供自己函数的函数。最佳的传递方式是什么？
- en: Solution
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Many functions in JavaScript accept, or even require, a function that’s passed
    as an argument. Some operations ask for a callback function that will be triggered
    when a task is complete. Others need to use your function to complete a broader
    task. For example, many methods of the `Array` object ask you to provide a function
    for sorting, converting, combining, or selecting data. The array then uses your
    function multiple times, until it has processed every element.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 中的许多函数接受，甚至要求，作为参数传递的函数。一些操作要求回调函数在任务完成时触发。其他需要使用你的函数完成更广泛的任务。例如，`Array`
    对象的许多方法要求你提供一个用于排序、转换、组合或选择数据的函数。然后数组多次使用你的函数，直到处理完每个元素。
- en: 'There are several different approaches you can use when supplying a function
    as an argument. Here are three common patterns:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供函数作为参数时，有几种不同的方法可以使用。以下是三种常见模式：
- en: Provide a reference to a function that’s already declared elsewhere in your
    code. This approach makes sense if you want to use the function in other parts
    of your application, or if the function is particularly long or complex.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供对已在代码中其他位置声明的函数的引用。如果你想在应用程序的其他部分使用该函数，或者该函数特别长或复杂，这种方法是有意义的。
- en: Declare the function in a *function expression*, then pass it as an argument.
    This approach works well for straightforward tasks, and if you don’t plan to use
    the function anywhere else.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*函数表达式*中声明函数，然后将其作为参数传递。这种方法适用于简单的任务，并且如果你不打算在其他地方使用该函数。
- en: Declare the function inline, at the exact moment it’s required—when you pass
    it as an argument to another function. This is similar to the second approach,
    but it makes your code even more compact. It works best for very short, straightforward
    functions (especially one-liners).
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在需要时内联声明函数—当你将其作为参数传递给另一个函数时。这类似于第二种方法，但使你的代码更加紧凑。它最适合非常简短、直接的函数（尤其是一行代码）。
- en: 'Let’s start with a simple page that has this button:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的页面开始，页面上有这个按钮：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We attach an event handler as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如下附加事件处理程序：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now consider the built-in `setTimeout()` function, which schedules a function
    to run after a certain delay (you supply the function). Here’s the first approach
    to function passing, with a separate function named `showMessage()`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑内置的`setTimeout()`函数，它安排一个函数在一定延迟后运行（你提供函数）。这是将函数传递的第一种方法，使用一个名为`showMessage()`的单独函数：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-19
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When you pass a function reference by name, make sure you don’t add a set of
    empty parentheses. This example passes `showMessage` to the `setTimeout()` function.
    If you accidentally write `showMessage()`, JavaScript will *run* the `showMessage()`
    function immediately, and pass its return value to `setTimeout()` instead of passing
    a function reference.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过名称传递函数引用时，请确保不要添加一组空括号。这个例子将`showMessage`传递给`setTimeout()`函数。如果你意外地写成`showMessage()`，JavaScript
    将立即*运行*`showMessage()`函数，并将其返回值传递给`setTimeout()`，而不是传递函数引用。
- en: 'Here’s the second approach, which declares the function closer to where it’s
    needed using a function expression:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第二种方法，它在需要的地方使用函数表达式声明函数：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this case, the scope of `showMessage()` is limited to the `buttonClicked()`
    function. It can’t be called from another function elsewhere in your code. Optionally,
    you could omit the function name (`showMessage`), making it an *anonymous function*.
    Either way, `timeoutCallback` works the same, but a function name can be useful
    in debugging, because it will appear in a stack trace if an error occurs.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`showMessage()`的作用域仅限于`buttonClicked()`函数。它无法从代码中的其他函数中调用。选择性地，你可以省略函数名（`showMessage`），使其成为一个*匿名函数*。无论哪种方式，`timeoutCallback`的工作方式都是相同的，但是函数名在调试时非常有用，因为在堆栈跟踪中会显示它如果发生错误。
- en: 'And here’s the third approach, which declares the function inline when calling
    `setTimeout()`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第三种方法，它在调用`setTimeout()`时内联声明函数：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now the `showMessage()` function is declared and passed to `setTimeout()` in
    one statement. There’s no way for any other part of code to interact with `showMessage()`,
    even inside the `buttonClicked()` function. Optionally, you can leave out the
    name `showMessage()` so that it becomes an anonymous function:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`showMessage()`函数在一个语句中声明并传递给`setTimeout()`。任何代码的其他部分都无法与`showMessage()`交互，即使在`buttonClicked()`函数内部也是如此。选择性地，你可以省略名称`showMessage()`，使其成为一个匿名函数：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can simplify this approach even further using arrow syntax, as demonstrated
    in [“Using Arrow Functions”](#arrow_functions). But using a function name is a
    good practice for long or complex code routines. That’s because you’ll see the
    function name in the stack trace if an error occurs inside the function.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以进一步简化这种方法，使用箭头语法，如示例中的[“使用箭头函数”](#arrow_functions)所示。但是对于长或复杂的代码例程，使用函数名是一个很好的实践。这是因为如果函数内部发生错误，你将在堆栈跟踪中看到函数名。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Pay attention to your organization’s style conventions when you use anonymous
    functions. One common pattern is to place the `function()` declaration and the
    opening `{` brace on the same line. Then, put all the code for the anonymous function
    underneath, with one extra level of indent. Finally, put the closing `}` brace
    on a separate line, followed immediately by the rest of the arguments for the
    function call.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用匿名函数时，注意你组织的风格约定。一个常见的模式是在同一行上放置`function()`声明和开放的`{`括号。然后，在下面放置匿名函数的所有代码，缩进一个额外的级别。最后，将闭合的`}`括号放在单独的一行上，紧接着函数调用的其余参数。
- en: Discussion
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: These three approaches demonstrate a gradually narrowing scope, from the most
    accessible function (in the first example) to the least accessible function (in
    the last example). As a general rule, it’s best to use the narrowest scope possible.
    This reduces ambiguity in your code (making it more understandable for the other
    developers who follow in your footsteps), and reduces the possibility of unexpected
    side effects. However, there’s a trade-off. As a function becomes longer and more
    complex, inline declarations become less readable. And if you want to use the
    function separately, or run unit tests against it, you will need to break it out
    into a separate function.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种方法展示了逐渐缩小范围的示例，从最可访问的函数（第一个示例中）到最不可访问的函数（最后一个示例中）。作为一个通用的规则，尽可能使用最窄的范围是最好的。这减少了代码中的歧义（使其更容易理解后续开发者），并减少了意外副作用的可能性。但是，这是一个权衡。随着函数变得更长和更复杂，内联声明变得不太可读。如果你想单独使用函数或对其运行单元测试，你需要将其拆分为一个单独的函数。
- en: 'If you’re in any doubt about how a function *uses* a function reference, here’s
    a simple example with a custom function named `callYouBack()` that accepts a function
    parameter and then calls it. Inside the `callYouBack()` function, you treat the
    function reference exactly like an ordinary function, calling it by name and supplying
    any parameters it needs:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对函数如何*使用*函数引用有任何疑问，这里有一个简单的示例，使用一个名为`callYouBack()`的自定义函数，它接受一个函数参数然后调用它。在`callYouBack()`函数内部，你像调用普通函数一样对待函数引用，通过名称调用它并提供它需要的任何参数：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you run this code and click the button, it produces output like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这段代码并点击按钮，它会产生如下输出：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: See Also
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: See [“Using Arrow Functions”](#arrow_functions) for a syntax that lets you simplify
    the declaration of anonymous functions, and is especially useful for single-line
    functions that return a value. See [Table 5-1](ch05.html#functional_array_methods)
    for the most important `Array` methods that accept function parameters.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 参见[“使用箭头函数”](#arrow_functions)，这种语法允许您简化匿名函数的声明，特别适用于返回值的单行函数。参见[表 5-1](ch05.html#functional_array_methods)中接受函数参数的最重要的`Array`方法。
- en: Using Arrow Functions
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用箭头函数
- en: Problem
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to use JavaScript’s arrow syntax to declare an inline function in the
    most compact way possible.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 想要使用JavaScript的箭头语法以最简洁的方式声明内联函数。
- en: Solution
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: In recent years, JavaScript has shifted to emphasize functional programming
    patterns—array processing and asynchronous promises are two notable examples.
    To help, they’ve added a new, streamlined function syntax for writing inline functions,
    called *arrow syntax*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，JavaScript已经转向强调函数式编程模式——数组处理和异步Promise是其中两个显著例子。为了帮助，他们添加了一种新的、简化的函数语法来编写内联函数，称为*箭头语法*。
- en: 'Here’s an example of using the `Array.map()` method to transform the contents
    of an array using a named function without using arrow syntax. The initial array
    is a list of numbers, and the transformed array has the square of each number:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用`Array.map()`方法对数组内容进行转换的示例，使用了不带箭头语法的命名函数。初始数组是一组数字，转换后的数组是每个数字的平方：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here’s the same example, but with the `squareNumber()` function declared inline
    using arrow syntax:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相同的示例，但使用箭头语法内联声明了`squareNumber()`函数：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Discussion
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'This example uses the most compact form of arrow syntax. This works for single-parameter,
    single-statement functions. Other functions may not be able to use all the simplifications
    of arrow syntax. To understand why, here’s a step-by-step breakdown of how you
    convert a named function to a function expression that uses arrow syntax:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用最简洁的箭头语法形式。这适用于单参数、单语句函数。其他函数可能无法使用箭头语法的所有简化。为了理解其中的原因，这里逐步解释如何将命名函数转换为使用箭头语法的函数表达式：
- en: Put the list of parameters first, followed the `=>` symbol. If there are no
    parameters, use an empty set of parentheses before the `=>` symbol.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先放置参数列表，然后是`=>`符号。如果没有参数，在`=>`符号之前使用空的括号。
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If there is exactly one parameter (as in this example), you can remove the parentheses
    around the parameter list.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果只有一个参数（如此示例），可以删除参数列表周围的括号。
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Put the braces and body of the function on the other side of the arrow.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将函数的大括号和函数体放在箭头的另一侧。
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If there is just one statement, you can remove the braces and the `return` keyword.
    But if you have more than one statement, you must keep both the braces *and* the
    `return` keyword.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果只有一个语句，可以删除大括号和`return`关键字。但如果有多个语句，则必须保留大括号和`return`关键字。
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Remember, the arrow function is used for declaring inline functions, so you’ll
    always be passing it to a parameter or assigning it to a variable in an expression:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，箭头函数用于声明内联函数，因此你总是会将它传递给一个参数或将其分配给一个表达式中的变量：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now let’s look at converting this slightly more complex function:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何转换这个稍微复杂的函数：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can carry out steps 1, 3, and 4, but step 2 doesn’t apply (because this
    function has two parameters):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以执行步骤1、3和4，但步骤2不适用（因为此函数有两个参数）：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Or, consider this more detailed string processing function:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，考虑这个更详细的字符串处理函数：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, steps 1, 2, and 3 apply, but step 4 does not. You must keep the braces
    and `return` statement intact.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，步骤1、2和3适用，但步骤4不适用。你必须保留大括号和`return`语句不变。
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now the difference between the traditional approach and the arrow syntax is
    much smaller. Only the function declaration at the beginning has changed, and
    the overall code savings is minimal.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在传统方法和箭头语法之间的差异变得更小。只有开头的函数声明发生了变化，总体代码节省量极少。
- en: Note
  id: totrans-69
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Here’s where the decisions around arrow syntax become murkier. It’s often possible
    to compress a function with several statements into a single expression. In the
    string processing example, you could use method chaining (as in [“Replacing All
    Occurrences of a String”](ch02.html#replacing_all_occurrences_string)) and the
    `Array.map()` function ([“Transforming Every Element of an Array”](ch05.html#mapping_array))
    instead of a `for` loop. Applied aggressively, these changes can shorten `applyTitleCase()`
    down to one long statement. You could then use all the arrow syntax shortcuts.
    However, in this case the goal of more concise code isn’t worth the tradeoff in
    clarity. As a general rule of thumb, arrow syntax is a benefit only when it helps
    you write more readable code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，围绕箭头语法的决策变得更加模糊。通常可以将几个语句的函数压缩为单个表达式。在字符串处理示例中，您可以使用方法链（如[“替换字符串的所有出现”](ch02.html#replacing_all_occurrences_string)）和`Array.map()`函数（[“转换数组的每个元素”](ch05.html#mapping_array)）而不是`for`循环。如果应用得当，这些更改可以将`applyTitleCase()`缩短为一个长语句。然后，您可以使用所有箭头语法的快捷方式。然而，在这种情况下，更简洁的代码目标不值得以清晰度为代价。作为一般的经验法则，箭头语法仅在帮助您编写更可读的代码时才有益。
- en: Arrow functions have a different way of binding the `this` keyword. In a declared
    function, `this` maps to the object that calls the function, which could be the
    current window, a button, and so on. In an arrow function, `this` simply refers
    to the code where the arrow function is defined. (In other words, whatever `this`
    is where you create your arrow function remains `this` when the function runs.)
    This behavior simplifies many issues, but at a cost. It means that arrow syntax
    isn’t suitable for object methods and constructors, because arrow functions won’t
    be bound to the object on which they’re called. Even using `Function.bind()` won’t
    change this behavior.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数有一种不同的绑定`this`关键字的方式。在声明的函数中，`this`映射到调用函数的对象，可以是当前窗口、按钮等。在箭头函数中，`this`简单地指向定义箭头函数的代码。换句话说，无论在何处创建箭头函数时`this`是什么，函数运行时`this`保持不变。这种行为简化了许多问题，但代价是箭头语法不适合对象方法和构造函数，因为箭头函数不会绑定到它们被调用的对象上。即使使用`Function.bind()`也不会改变这种行为。
- en: There are a few smaller restrictions as well. Arrow functions can’t be used
    with `yield` to make a generator function, and don’t support the `arguments` object.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些较小的限制。箭头函数不能与`yield`一起用于生成器函数，并且不支持`arguments`对象。
- en: See Also
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Chapter 5](ch05.html#arrays) has numerous examples that use arrow syntax to
    pass short functions to array-processing methods. See, for instance, Recipes ,
    , and .'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[第五章](ch05.html#arrays)有许多使用箭头语法将短函数传递给数组处理方法的示例。例如，Recipes，，和。'
- en: Providing a Default Parameter Value
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供默认参数值
- en: Problem
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to specify a default value for a parameter, which will be used if the
    caller doesn’t pass in an argument when calling the function.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望为参数指定默认值，如果调用函数时未传入参数，则将使用该默认值。
- en: Solution
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'You can directly assign default values to your parameters when you declare
    a function. Here’s an example that sets a default value for the third parameter,
    `thirdNum`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当您声明一个函数时，可以直接为参数分配默认值。以下是一个为第三个参数`thirdNum`设置默认值的示例：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now it’s possible to call this function without specifying all three parameters:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以调用此函数而不指定所有三个参数：
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Discussion
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Default parameters are a relatively recent invention. However, JavaScript has
    never forced function callers to supply all the parameters for a function. In
    this distant past, functions could simply check if a parameter was `undefined`
    (by testing it with the `typeof` operator, as described in [“Checking if an Object
    Is a Certain Type”](ch07.html#check_object_type)).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 默认参数是一个相对较新的发明。然而，JavaScript从未强制函数调用者为函数提供所有参数。在遥远的过去，函数可以简单地检查参数是否为`undefined`（通过使用`typeof`运算符测试，如[“检查对象是否为某一类型”](ch07.html#check_object_type)中所述）。
- en: You can set default values for as many parameters as you want. As a matter of
    good style, you should put your required parameters first, followed by parameters
    that have default values. In other words, once you add a default parameter, all
    the parameters *after* should also become optional and have default values. This
    convention isn’t required, but it makes code clearer.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为尽可能多的参数设置默认值。作为良好风格的一部分，应首先放置您需要的参数，然后是具有默认值的参数。换句话说，一旦添加了默认参数，后面的所有参数*都应该*变得可选并具有默认值。这种约定不是必需的，但可以使代码更清晰。
- en: 'When calling a function that has multiple default parameters, you can pick
    and choose which values you supply. Consider this example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用具有多个默认参数的函数时，可以选择提供哪些值。考虑以下示例：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you want to specify `firstNum`, `secondNum`, and `multiplier`, but omit
    the `thirdNum` parameter, you need to use `undefined` as a placeholder. This allows
    you to pass all your parameters in the proper order:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要指定`firstNum`、`secondNum`和`multiplier`，但省略`thirdNum`参数，则需要使用`undefined`作为占位符。这使您可以按正确的顺序传递所有参数：
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'But `null` won’t work as a placeholder. In this example, it’s simply converted
    to the number 0, changing the result:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 但是`null`不能作为占位符使用。在这个例子中，它被简单地转换为数字0，改变了结果：
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Many other languages have nicer shortcuts for default parameters (such as using
    commas to indicate order without needing to supply a placeholder value, or setting
    parameter values by name). JavaScript does not, although you can simulate named
    parameters using object literal syntax ([“Using Named Function Parameters”](#named_parameters)).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 许多其他语言有更好的默认参数快捷方式（例如使用逗号指示顺序而无需提供占位符值，或通过名称设置参数值）。JavaScript没有这样的功能，尽管您可以使用对象文字语法模拟命名参数（[“使用命名函数参数”](#named_parameters)）。
- en: Creating a Function That Accepts Unlimited Arguments
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个接受无限参数的函数
- en: Problem
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to create a function that accepts as many arguments as the caller wants
    to supply, without requiring the creation of an array.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望创建一个函数，该函数接受调用者想要提供的任意数量的参数，而无需创建数组。
- en: Solution
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use a *rest parameter* when you declare your function. The rest parameter is
    defined with three dots before its name:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明函数时使用*rest参数*。rest参数在其名称之前用三个点定义：
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Discussion
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The rest parameter does not need to be the only parameter, but it must be the
    last parameter. It collects all the extra arguments that are passed to the function
    and adds them to a new array.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: rest参数不需要是唯一的参数，但必须是最后一个参数。它收集传递给函数的所有额外参数，并将它们添加到一个新数组中。
- en: In the past, JavaScript developers used the `arguments` object for similar functionality.
    The `arguments` object is available in every function (technically, it’s the `Function.arguments`
    property), and it provides array-like access to all the parameters. However, `arguments`
    is not a true array, and developers often used boilerplate code to transform it
    into one. You may still see this approach in the wild, but today rest parameters
    avoid this hassle.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，JavaScript开发者使用`arguments`对象来实现类似的功能。`arguments`对象在每个函数中都可用（技术上来说，它是`Function.arguments`属性），它提供了类似数组的访问所有参数的方式。然而，`arguments`不是真正的数组，开发者经常使用样板代码将其转换为数组。您可能仍然会在实际应用中看到这种方法，但现在使用rest参数可以避免这种麻烦。
- en: Note
  id: totrans-102
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The rest parameter looks the same as the spread operator ([“Breaking Down an
    Array into Separate Variables”](ch05.html#destructuring_arrays)), but the two
    play complementary roles. The spread operator *expands* an array or the properties
    of an object into separate values, whereas the rest operator collects separate
    values and inserts them into a single array object.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: rest参数看起来与展开运算符相似（[“将数组分解为单独变量”](ch05.html#destructuring_arrays)），但两者扮演互补角色。展开运算符*展开*一个数组或对象的属性为单独的值，而rest运算符则收集单独的值并将它们插入到一个单一的数组对象中。
- en: See Also
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: If you have an array of values that you want to pass into a function, but the
    function expects a rest parameter, you can make the conversion using the spread
    operator (see [“Breaking Down an Array into Separate Variables”](ch05.html#destructuring_arrays)).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个值数组，想要将其传递给一个函数，但该函数期望一个rest参数，您可以使用展开运算符进行转换（参见[“将数组分解为单独变量”](ch05.html#destructuring_arrays)）。
- en: This example uses a loop to process the array of values, but you could achieve
    the same result more cleanly with the `Array.reduce()` function, as demonstrated
    in [“Combining an Array’s Values in a Single Calculation”](ch05.html#reducing_array).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 本例中使用循环来处理值数组，但您可以使用`Array.reduce()`函数更清晰地实现相同的结果，如[“将数组的值组合成单一计算”](ch05.html#reducing_array)中演示的那样。
- en: Using Named Function Parameters
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用命名函数参数
- en: Problem
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want an easier way to choose the optional parameters you send to a function.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望有一种更简单的方法来选择发送到函数的可选参数。
- en: Solution
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Bundle all the optional parameters into a single object literal ([“Using an
    Object Literal to Bundle Data”](ch07.html#object_literal)). The caller can then
    decide what optional parameters to include when they create the object literal.
    Here’s an example of how you call a function that uses this pattern:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有可选参数捆绑到单个对象字面量中（[“使用对象字面量捆绑数据”](ch07.html#object_literal)）。调用者可以决定在创建对象字面量时包含哪些可选参数。这是使用此模式的函数调用示例：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In your function, you can use *destructuring assignment* to quickly copy the
    values out of the object literal and into separate variables. Here’s an example
    of a function that accepts three arguments. The first two (`newerDate` and `olderDate`)
    are required, but the third parameter is an object literal that can hold three
    optional values (`discardTime`, `discardYears`, and `precision`):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的函数中，您可以使用 *解构赋值* 快速地将值从对象字面量中复制到单独的变量中。这是一个接受三个参数的函数的示例。前两个参数（`newerDate`
    和 `olderDate`）是必需的，但第三个参数是一个对象字面量，可以包含三个可选值（`discardTime`、`discardYears` 和 `precision`）：
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You can call `dateDifferenceInSeconds()` with or without the object literal:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 可以带有或不带有对象字面量调用 `dateDifferenceInSeconds()`：
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Discussion
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: A common pattern in JavaScript is to use an object literal to transmit optional
    values. This lets you set only the properties you need, without worrying about
    the order.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 中的一个常见模式是使用对象字面量传递可选值。这样可以只设置需要的属性，而不必担心顺序。
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the function, you can retrieve properties from the object literal individually,
    like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数中，您可以像这样单独从对象字面量中检索属性：
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'But this solution in this recipe uses a better shortcut. It unpacks the object
    literal into named variables using destructuring, which maps the properties of
    an object to individual, named variables. You can use destructuring assignment
    in a statement:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 但是本节中的解决方案使用了一个更好的快捷方式。它使用解构将对象字面量解包到命名变量中，这将对象的属性映射到单独的命名变量中。您可以在语句中使用解构赋值：
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'or right in the function declaration:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 或者直接在函数声明中：
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'It’s a good practice to set an empty object literal as a default value ([“Providing
    a Default Parameter Value”](#provide_default_parameter)). This empty object is
    used if the caller doesn’t supply the object literal:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个空对象字面量设置为默认值是一个很好的做法（[“提供默认参数值”](#provide_default_parameter)）。如果调用者没有提供对象字面量，则使用这个空对象：
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'It’s up to the caller whether they decide to set some, all, or none of the
    properties in the object literal. Any values that aren’t set will evaluate to
    the special value `undefined`, which you can test for in your code. Here’s a less-optimized
    example:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 调用者可以决定是否设置一些、全部或不设置对象字面量中的属性。未设置的任何值将计算为特殊值 `undefined`，您可以在代码中测试这些值。以下是一个不太优化的示例：
- en: '[PRE33]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Often, you won’t need to explicitly check for `undefined` values. For example,
    `undefined` evaluates to `false` in conditional logic. The `dateDifferenceInSeconds()`
    function uses the behavior when it evaluates the `discardYears` and `discardTime`
    properties, allowing us to shorten the code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您不需要显式检查 `undefined` 值。例如，`undefined` 在条件逻辑中求值为 `false`。`dateDifferenceInSeconds()`
    函数在评估 `discardYears` 和 `discardTime` 属性时使用这种行为，这使我们可以缩短代码：
- en: '[PRE34]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There’s a similar shortcut with the `precision` property. It’s safe to call
    `Number.toPrecision(undefined)`, because that’s the same as calling `toPrecision()`
    with no argument. Either way, the number is rounded to the nearest whole integer.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`precision` 属性有一个类似的快捷方式。安全地调用 `Number.toPrecision(undefined)` 是可以的，因为这与不带参数调用
    `toPrecision()` 是一样的。无论哪种方式，数字都会四舍五入到最接近的整数。'
- en: 'The only disadvantage to the object literal pattern is that there’s no way
    to prevent property-naming mistakes, like this one:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对象字面量模式的唯一缺点是无法防止属性命名错误，例如：
- en: '[PRE35]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: See Also
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[“Using an Object Literal to Bundle Data”](ch07.html#object_literal) introduces
    object literals. [“Breaking Down an Array into Separate Variables”](ch05.html#destructuring_arrays)
    shows the array destructuring syntax, which is similar to the object destructuring
    syntax used in this recipe, except it acts on arrays instead of objects (and uses
    square brackets instead of curly braces).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[“使用对象字面量捆绑数据”](ch07.html#object_literal) 介绍了对象字面量。[“将数组分解为单独变量”](ch05.html#destructuring_arrays)
    展示了数组解构语法，它类似于本节中使用的对象解构语法，只是作用于数组而不是对象（并使用方括号而不是花括号）。'
- en: Creating a Function That Stores its State with a Closure
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用闭包存储其状态的函数创建
- en: Problem
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to create a function that can remember data, but without having to
    use global variables and without repeatedly sending the same data with each function
    call.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您想创建一个可以记住数据但又无需使用全局变量并且不需要在每个函数调用中重复发送相同数据的函数。
- en: Solution
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Wrap the function that needs to preserve its state in *another* function. The
    outer function returns the inner function, following this structure:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 将需要保留其状态的函数包装在*另一个*函数中。外部函数返回内部函数，遵循以下结构：
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Both of these functions can accept parameters. But here’s the trick. The outer
    function’s parameters live as long as you have a reference to the inner function.
    You can call the inner function as many times as you want, and the data from the
    outer function persists. (Conceptually, it’s as though the outer function is an
    object-creation method, and the inner function is an object with state.)
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数都可以接受参数。但这里有一个诀窍。外部函数的参数只要您引用内部函数就会一直存在。您可以随意调用内部函数，外部函数中的数据将持久存在。（在概念上，外部函数就像是一个对象创建方法，而内部函数就像是具有状态的对象。）
- en: 'Here’s a complete example:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个完整的示例：
- en: '[PRE37]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Discussion
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Often, you’ll find that you need a way to store data that’s used across several
    function calls. You could use global variables, but that’s a technique of last
    resort. Global variables lead to naming collisions, complicate code, and often
    lead to hidden interdependencies between different functions, limiting the reuse
    of your code and giving cover for subtle coding bugs to hide.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您会发现需要一种方法来存储跨多个函数调用使用的数据。您可以使用全局变量，但这是最后的手段。全局变量会导致命名冲突，使代码复杂化，并经常导致不同函数之间隐藏的相互依赖关系，限制代码的重用，并为隐藏的编码错误提供掩盖。
- en: You could ask the function caller to maintain this information, and send it
    with each function call, but this can also be awkward. This example shows a different
    solution—creating a stateful function package called a *closure*.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以要求函数调用者维护此信息，并在每个函数调用时发送它，但这样做可能会很尴尬。本示例展示了另一种解决方案——创建一个保持状态的函数包，称为*闭包*。
- en: In this solution, the outer function `greetingMaker()` takes one argument, which
    is a specific greeting. It also returns an inner function, `addName()`, which
    itself takes the person’s name. The closure encompasses the `addName()` function
    and its surrounding context, which includes the parameter that was passed to the
    `greetingMaker()` function. To demonstrate this fact, two copies of `addName()`
    are created, in two different contexts. One exists in a closure where a daytime
    message was passed to `greetingMaker()`, and the other exists in a closure where
    a nighttime message was passed to `greetingMaker()`. Either way, when the `addName()`
    function is called, it uses the current context to construct its message.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在此解决方案中，外部函数`greetingMaker()`接受一个参数，即特定的问候语。它还返回一个内部函数`addName()`，该函数本身接受人名。闭包包含`addName()`函数及其周围的上下文，其中包括传递给`greetingMaker()`函数的参数。为了演示这一事实，创建了两个`addName()`的副本，存在于两个不同的上下文中。一个存在于将白天消息传递给`greetingMaker()`的闭包中，另一个存在于将夜间消息传递给`greetingMaker()`的闭包中。无论如何，当调用`addName()`函数时，它都使用当前上下文构造其消息。
- en: 'It’s worth noting that state isn’t limited to parameter values. Any variables
    that are in the outer function also stay alive as long as the function reference
    exists. Here’s an example that uses a simple counter variable to keep track of
    how many function calls you’ve made:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，状态不仅限于参数值。任何在外部函数中的变量只要函数引用存在就会保持活动状态。以下是一个示例，其中使用简单的计数器变量来跟踪调用了多少次函数：
- en: '[PRE38]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: See Also
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'To see an another example of a function that uses a closure to store state,
    see [“Extra: Building a Repeatable Pseudorandom Number Generator”](#repeatable_PRNG).'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看使用闭包存储状态的另一个函数示例，请参阅[“额外：构建可重复使用的伪随机数生成器”](#repeatable_PRNG)。
- en: It’s not an accident that closures and wrapped functions seem to echo object-oriented
    programming. In the past, JavaScript developers used functions to mimic custom
    classes (see [“Using the Constructor Pattern to Make a Custom Class”](ch08.html#constructor_pattern)),
    and JavaScript’s `class` keyword extends this approach (see [“Creating a Reusable
    Class”](ch08.html#using_es6_classes)).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 不是偶然闭包和包装函数似乎在模仿面向对象编程。过去，JavaScript 开发人员使用函数来模仿自定义类（参见[“使用构造函数模式创建自定义类”](ch08.html#constructor_pattern)），而
    JavaScript 的 `class` 关键字扩展了这种方法（参见[“创建可重用类”](ch08.html#using_es6_classes)）。
- en: Creating a Generator Function That Yields Multiple Values
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个生成器函数，可以产生多个值
- en: Problem
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to create a *generator*, a function that can provide multiple values
    on-demand. Each time a generator returns a value, it pauses its execution until
    the caller requests the next value.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你想创建一个*生成器*，一个能按需提供多个值的函数。每当生成器返回一个值时，它会暂停执行，直到调用者请求下一个值。
- en: Solution
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'To declare a generator function, start by replacing the `function` keyword
    with `function*`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个生成器函数，首先用`function*`替换`function`关键字：
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Inside the generator function, use the `yield` keyword each time you want to
    return a result. Remember, execution stops after you yield (much like when you
    use the `return` keyword). However, execution *resumes* when the caller asks for
    the function’s next value. This process continues until your function code ends,
    or you return a final value with the `return` keyword.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成器函数内部，每当你想要返回一个结果时使用`yield`关键字。记住，执行在你`yield`后停止（就像使用`return`关键字时一样）。然而，当调用者请求函数的下一个值时，执行会*恢复*。这个过程会一直持续，直到你的函数代码结束，或者你使用`return`关键字返回最终值。
- en: 'Here is a naïve implementation of a generator. (It works, but it doesn’t solve
    a useful problem.) This function yields three values, followed by a return value:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个生成器的简单实现。（它可以工作，但并没有解决一个有用的问题。）这个函数生成三个值，然后返回一个值：
- en: '[PRE40]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: When you call a generator function, you receive a `Generator` object as a return
    value. This happens immediately, before the generator function code begins to
    run. You use the `Generator` object to run the function and retrieve the values
    that are yielded. You can also use it to determine when the generator function
    is finished.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用一个生成器函数时，你会得到一个`Generator`对象作为返回值。这发生在生成器函数代码开始运行之前立即发生。你可以使用`Generator`对象来运行函数并检索生成的值。你也可以用它来确定生成器函数何时完成。
- en: Each time you call `Generator.next()`, the generator function runs until it
    reaches the next `yield` (or the final `return`). The `next()` method returns
    an object with two values. The `value` property wraps the yielded or returned
    value from the generator function. The `done` property is a Boolean that remains
    `false` until the generator function has ended.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你调用`Generator.next()`时，生成器函数会运行直到达到下一个`yield`（或最终的`return`）。`next()`方法返回一个带有两个值的对象。`value`属性包装了从生成器函数中产生的值或返回的值。`done`属性是一个布尔值，在生成器函数结束前保持为`false`。
- en: '[PRE41]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Discussion
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Generators allow you to create functions that can be paused and resumed. Best
    of all, JavaScript manages their state automatically, which means you don’t need
    to write any code to preserve values in-between calls to `next()`. (This is different
    than building a custom iterator, for example.)
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器允许你创建可以暂停和恢复的函数。最重要的是，JavaScript会自动管理它们的状态，这意味着你不需要编写任何代码来在调用`next()`之间保存值。（这与构建自定义迭代器不同，例如。）
- en: Because generators have a lazy-execution model, they’re a good choice for time-consuming
    data creation or retrieval operations. For example, you could use a generator
    to calculate numbers in a complex sequence, to retrieve chunks of information
    from a stream of data.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 因为生成器具有延迟执行模型，所以它们非常适合耗时的数据创建或检索操作。例如，你可以使用生成器来计算复杂序列中的数字，或者从数据流中检索信息块。
- en: 'Usually, you won’t know how many values a generator will return. You could
    write a `while` loop that checks the `Generator.done` property and keeps calling
    `next()` until it’s finished. But because the generator object is iterable, a
    `for`…`of` loop works even better:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，你不会知道一个生成器会返回多少值。你可以编写一个`while`循环，检查`Generator.done`属性，并不断调用`next()`直到完成。但因为生成器对象是可迭代的，一个`for`…`of`循环效果更好：
- en: '[PRE42]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Either way, this approach only gets *yielded* results. If your generator has
    a final return value, it’s ignored.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，这种方法只能获取*yielded*的结果。如果你的生成器有最终的返回值，它将被忽略。
- en: Some generator functions are designed to be *infinite*. As long as you keep
    calling `next()`, they keep yielding values. If you’re calling an infinite generator,
    you can’t dump all its values into an array (your program will hang). Instead,
    you’ll probably use a `while` loop with a condition that turns `false` when you
    have all the values you need.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 一些生成器函数设计为*无限*。只要你继续调用`next()`，它们就会继续生成值。如果你调用一个无限生成器，你不能把所有的值都放入数组中（程序会挂起）。相反，你可能会使用一个带有条件的`while`循环，当你得到所需的所有值时条件会变为`false`。
- en: See Also
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[“Creating an Asynchronous Generator Function”](ch09.html#async_generator)
    shows how to create generators that run asynchronously.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[“创建异步生成器函数”](ch09.html#async_generator)展示了如何创建异步运行的生成器。'
- en: 'Extra: Building a Repeatable Pseudorandom Number Generator'
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 额外信息：构建一个可重复的伪随机数生成器
- en: Although you’ve dissected the essential syntax for generator functions, you
    haven’t seen a truly practical example. Here’s one that shows how an infinite
    generator function can provide a useful sequence of values.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您已经剖析了生成器函数的基本语法，但尚未见过一个真正实用的示例。以下是一个演示无限生成器函数如何提供有用值序列的示例。
- en: As explained in [“Generating Random Numbers”](ch03.html#generating_random_numbers),
    the `Math.random()` method lets you generate pseudorandom numbers, but you can’t
    control the *seed value*. (Instead, `Math.random()` seeds its pseudorandom number
    generator using a opaque, noncryptographically secure method that may vary from
    one JavaScript implementation to the next.) This is fine for most applications.
    But in some scenarios you need a way to generate a *repeatable* sequence of random-seeming
    numbers. The numbers still need to be statistically random in their distribution;
    the only difference is that you need to be able to ask your pseudorandom number
    generator to give you same sequence more than once. Examples where repeatable
    pseudorandom numbers are important include certain types of simulations or tests
    that need to be precisely reproducible.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如[“生成随机数”](ch03.html#generating_random_numbers)中所解释的，`Math.random()` 方法允许您生成伪随机数，但您无法控制*种子值*。（相反，`Math.random()`
    使用不透明、非加密安全的方法来为其伪随机数生成器种子化，这可能因JavaScript实现而异。）这对大多数应用来说都是可以接受的。但在某些情况下，您需要一种方法来生成一个*可重复*的伪随机数序列。这些数字在分布上仍然需要是统计上随机的；唯一的区别在于，您需要能够要求您的伪随机数生成器给出同样的序列超过一次。需要重复的伪随机数的重要示例包括某些需要精确可再现的模拟或测试。
- en: 'There are several third-party JavaScript libraries that provide seedable (and
    thus repeatable) pseudorandom number generators. You can find a long list at [GitHub](https://github.com/bryc/code/blob/master/jshash/PRNGs.md).
    One of the simplest is Mulberry32\. Its JavaScript implementation fits in a single
    dense block of code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个第三方JavaScript库提供可种子化（因此可重复）的伪随机数生成器。您可以在[GitHub](https://github.com/bryc/code/blob/master/jshash/PRNGs.md)上找到一个长列表。其中一个最简单的是Mulberry32。其JavaScript实现适合于单个密集的代码块：
- en: '[PRE43]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `mulberry32()` function uses the closure technique described in [“Creating
    a Function That Stores its State with a Closure”](#create_a_function_that_remembers_its_sta).
    It accepts a seed value that’s then locked into the context of the inner `random()`
    function. That means that whenever you call `random()`, the original seed value
    will be available in the outer function. This is important, because a different
    seed means a different sequence of random variables. If you call `mulberry32()`
    with the same seed value, you’re guaranteed to get the same sequence of pseudorandom
    numbers from `random()`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`mulberry32()` 函数使用了在[“创建使用闭包记住其状态的函数”](#create_a_function_that_remembers_its_sta)中描述的闭包技术。它接受一个种子值，然后将其锁定在内部`random()`函数的上下文中。这意味着无论何时调用`random()`，原始种子值都将在外部函数中可用。这很重要，因为不同的种子意味着不同的随机变量序列。如果您使用相同的种子值调用`mulberry32()`，则保证从`random()`获得相同的伪随机数序列。'
- en: Note
  id: totrans-182
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Like most pseudorandom number generators, Mulberry32 returns a fractional value
    between 0 and 1\. To convert this to integer in a given range, use the technique
    shown in [“Generating Random Numbers”](ch03.html#generating_random_numbers).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 像大多数伪随机数生成器一样，Mulberry32 返回一个介于0和1之间的分数值。要将其转换为给定范围内的整数，请使用[“生成随机数”](ch03.html#generating_random_numbers)中所示的技术。
- en: 'Closures have been a part of the JavaScript language since time immemorial,
    but generators are a much newer innovation. You can rewrite this example using
    a generator function, which more clearly expresses its purpose:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 自闭包从JavaScript语言的太古时代起就存在，但生成器却是一个较新的创新。您可以使用生成器函数重写此示例，更清晰地表达其目的：
- en: '[PRE44]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Because the `mulberry32()` function is declared with `function*`, it’s immediately
    obvious that it will return multiple values. Inside, an infinite loop ensures
    that the generator will always be ready to create a new number. After each pass
    through the loop, `random()` yields a new random value and then pauses until a
    new value is requested with `next()`. The overall operation of this solution is
    similar to its original version, but now it follows a familiar pattern that could
    make its usage easier to discover. (But—as always—the value of a refactoring like
    this depends on the conventions of your organization, the expectations of the
    people reading your code, and your own personal taste.)
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`mulberry32()`函数声明为`function*`，所以立即清楚它将返回多个值。在内部，无限循环确保生成器始终准备好创建新的数字。每次通过循环后，`random()`都会产生一个新的随机值，然后暂停，直到使用`next()`请求新值。该解决方案的整体操作与其原始版本类似，但现在遵循一个熟悉的模式，这可能使其使用更容易发现。（但——像往常一样——这种重构的价值取决于您组织的约定、阅读您代码的人的期望以及您个人的品味。）
- en: Note
  id: totrans-187
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: There’s no danger to building an infinite loop in a generator as long as it
    yields. Yielding pauses the code, ensuring that it won’t tie up the JavaScript
    event loop. Unlike normal functions, there is no expectation that a generator
    function will run to its final closing brace. As soon as a `Generator` object
    goes out of scope, that function and its context are made available for garbage
    collection.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成器中构建无限循环并没有危险，只要它们进行 yield 操作。通过 yield 操作暂停代码，确保不会阻塞 JavaScript 事件循环。与普通函数不同，没有期望生成器函数将运行到最终的闭括号。一旦`Generator`对象超出范围，该函数及其上下文将可供垃圾收集。
- en: Reducing Redundancy by Using Partial Application
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过使用部分应用程序减少冗余
- en: Problem
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You have a function that takes several arguments. You want to wrap this function
    with one or more specialized versions that require fewer arguments.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 您有一个接受多个参数的函数。您希望用一个或多个特定版本的新函数包装此函数，这些版本需要更少的参数。
- en: Solution
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'The following `makestring()` function accepts three parameters (in other words,
    it has an *arity* of 3):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的`makestring()`函数接受三个参数（换句话说，它的*arity*为3）：
- en: '[PRE45]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: However, the first and last arguments are often repeated based on a specific
    use case. You want to eliminate the repetition of arguments whenever possible.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，第一个和最后一个参数通常基于特定用例重复。您希望尽可能消除参数的重复。
- en: 'You can solve this problem by creating new functions that wrap the previously
    created `makeString()` function, but with known argument values locked down:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过创建新的函数来解决这个问题，这些函数封装了先前创建的`makeString()`函数，但已知参数值被锁定：
- en: '[PRE46]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now only one argument is needed to call any of these new functions:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只需一个参数即可调用这些新函数中的任何一个：
- en: '[PRE47]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Discussion
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The technique of wrapping one function in another function to lock down one
    or more argument values is called *partial application* (because the new functions
    *partially apply* the argument values to the original function). Of course, the
    tradeoff is that the extra functions you create can also clutter up your code,
    so don’t build wrappers you don’t intend to use and reuse.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个函数包装在另一个函数中以锁定一个或多个参数值的技术称为*部分应用程序*（因为新函数*部分应用*到原始函数的参数值）。当然，这样做的权衡是，您创建的额外函数也可能会使您的代码变得混乱，因此不要构建您不打算使用和重用的包装器。
- en: 'Advanced: A Partial Function Factory'
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级：部分函数工厂
- en: You can reduce the redundancy of this approach even further by creating a function
    that can partial-ize *any* other function. In fact, this approach is a fairly
    common JavaScript design pattern. In the past, you needed to rely on the JavaScript
    `arguments` object and array manipulation. In modern JavaScript, the rest and
    spread operators make the job much simpler.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以通过创建一个能够部分化*任何*其他函数的函数进一步减少此方法的冗余。事实上，这种方法是一种相当常见的 JavaScript 设计模式。在过去，您需要依赖
    JavaScript 的`arguments`对象和数组操作。在现代 JavaScript 中，剩余和展开运算符使这项工作变得更加简单。
- en: In the implementation shown here, the partial-izing function is named `partial()`.
    It’s capable of reducing any number of arguments for any function.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里显示的实现中，部分化函数命名为`partial()`。它能够为任何函数减少任意数量的参数。
- en: '[PRE48]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This function requires a bit of unpacking. But first, it helps to see a simple
    example that uses it. Here, the `partial()` function is used to create a new `cubeIt()`
    function that wraps the more general `raiseToPower()` function. In other words,
    `cubeIt()` uses partial application to lock down one of the `raiseToPower()` arguments
    (the exponent, which it sets to 3).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数需要一点解包操作。但首先，看一个使用它的简单例子是有帮助的。在这里，`partial()`函数用于创建一个新的`cubeIt()`函数，它包装了更通用的`raiseToPower()`函数。换句话说，`cubeIt()`使用部分应用来锁定`raiseToPower()`的一个参数（指数，它设置为3）。
- en: '[PRE49]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Now when you call `cubeIt(9)`, the call is mapped to `raiseToPower(3, 9)`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你调用`cubeIt(9)`时，调用被映射到`raiseToPower(3, 9)`。
- en: So how does it work? The `partial()` function accepts two arguments. First is
    the function you want to partial-ize (`fn`). Second is a list of all the arguments
    you want to lock in place (`argsToApply`), which is captured in an array using
    the rest operator (`...`), as explained in [“Creating a Function That Accepts
    Unlimited Arguments”](#creating_function_unlimted_arguments).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 那么它是如何工作的呢？`partial()`函数接受两个参数。第一个是你想要部分应用的函数（`fn`）。第二个是你想要锁定在原位的所有参数的列表（`argsToApply`），这些参数使用剩余操作符（`...`）捕获到一个数组中，如在[“创建一个接受无限参数的函数”](#creating_function_unlimted_arguments)中所解释的那样。
- en: '[PRE50]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now things get interesting. The `partial` function returns a nested inner function
    (a technique explored in [“Creating a Function That Stores its State with a Closure”](#create_a_function_that_remembers_its_sta)).
    The nested inner function accepts all the arguments that *aren’t* locked in place.
    Once again, these arguments are captured in an array using the rest operator (`...restToApply`):'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在事情变得有趣了。`partial`函数返回一个嵌套的内部函数（一种在[“创建一个存储其闭包状态的函数”](#create_a_function_that_remembers_its_sta)中探讨的技术）。嵌套的内部函数接受所有未锁定在原位的参数。再次强调，这些参数使用剩余操作符（`...restToApply`）捕获到一个数组中：
- en: '[PRE51]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This newly created function now has three key pieces of information: the underlying
    function (`fn`), the arguments that are locked in place (`argsToApply`), and the
    arguments that are set each time the function is called (`restArgsToApply`).'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个新创建的函数有三个关键部分的信息：底层函数（`fn`），锁定在原位的参数（`argsToApply`），以及每次调用函数时设置的参数（`restArgsToApply`）。
- en: 'There’s only one line of code inside this function, but it packs in a lot.
    It expands the two arrays into argument lists using the spread operator (which,
    somewhat confusingly, looks exactly like the rest operator). In other words, `argsToApply`
    becomes a list or arguments followed by `restToApply`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 函数内部只有一行代码，但包含了很多信息。它使用展开操作符将两个数组展开为参数列表（这有些令人困惑，因为它看起来与剩余操作符完全相同）。换句话说，`argsToApply`变成了一个参数列表，后跟`restToApply`：
- en: '[PRE52]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note
  id: totrans-216
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A common practice in functional programming is writing *higher-order functions*
    (functions that operate on other functions). The `partial()` function is a higher-level
    function that creates a wrapper for another function.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程中的一个常见做法是编写*高阶函数*（操作其他函数的函数）。`partial()`函数是一个创建另一个函数包装器的高级函数。
- en: 'There is one limitation to this implementation of the `partial()` function.
    Because it puts fixed arguments first, you can’t lock down a later argument without
    locking down all the arguments that occur first. If you wanted to use `partial()`
    to make a wrapper for the `makeString()` function from the original solution,
    you need to rearrange its arguments first:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`partial()`函数的实现有一个限制。因为它首先放置固定的参数，所以你无法锁定稍后的参数而不锁定所有先出现的参数。如果你想使用`partial()`为原始解决方案中的`makeString()`函数创建一个包装器，你需要首先重新排列它的参数：
- en: '[PRE53]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Extra: Using bind() to Partially Provide Arguments'
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 额外：使用bind()部分提供参数
- en: You can also create partial applications with the `Function.bind()` method.
    The `bind()` method returns a new function, setting `this` to whatever is provided
    as a first argument. All the other arguments are prepended to the argument list
    for the new function.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`Function.bind()`方法创建部分应用程序。`bind()`方法返回一个新函数，将`this`设置为提供的第一个参数。所有其他参数都被预置到新函数的参数列表中。
- en: 'Rather than having to use `partial()` to create the named entity function,
    we can now use `bind()` to provide the same functionality, passing in `undefined`
    as the first argument:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们不必使用`partial()`来创建命名实体函数，而是可以使用`bind()`来提供相同的功能，将`undefined`作为第一个参数传递：
- en: '[PRE54]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now you have two good ways to create multiple versions of a function that use
    different parameters.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有两种好方法来创建使用不同参数的函数的多个版本。
- en: Fixing this with Function Binding
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复此功能绑定问题
- en: Problem
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Your function is attempting to use the keyword `this`, but it’s not bound to
    the right object.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 您的函数试图使用关键字`this`，但未绑定到正确的对象。
- en: Solution
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use the `Function.bind()` method to change the context of your function and
    the meaning of the `this` reference:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Function.bind()`方法来更改函数的上下文和`this`引用的含义：
- en: '[PRE55]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Discussion
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The keyword `this` refers to the owner or parent of a function. The challenge
    associated with `this` in JavaScript is that we can’t always guarantee what parent
    object will apply to a function.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字`this`指的是函数的所有者或父级。在JavaScript中，与`this`相关的挑战是我们无法始终保证哪个父对象将应用于函数。
- en: In the solution, the object has a method, `sayGreeting()`, which outputs a message
    and maps another nested function to its property, `nestedGreeting`. You’ll see
    this approach if you use the constructor pattern ([“Using the Constructor Pattern
    to Make a Custom Class”](ch08.html#constructor_pattern)) to create class-like
    function objects.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案中，对象有一个方法`sayGreeting()`，输出一条消息并将另一个嵌套函数映射到其属性`nestedGreeting`。如果您使用构造函数模式（[“使用构造函数模式创建自定义类”](ch08.html#constructor_pattern)）创建类似类的函数对象，您将看到这种方法。
- en: Without the `Function.bind()` method, the first message would say “Now this
    is easy, object,” but the second would say “hello window.” The reason the second
    message has a different name is because the nesting of the function disassociates
    the inner function from the surrounding object, and all *unscoped* functions automatically
    become the property of the `window` object.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 没有`Function.bind()`方法，第一条消息将会说“现在这很容易，对象”，但第二条消息将会说“hello window”。第二条消息有不同名称的原因是因为函数的嵌套使内部函数与周围对象分离，所有*未作用域限定*的函数自动成为`window`对象的属性。
- en: The `bind()` method solves this problem by binding the function to the object
    you choose. In the example, the `bind()` method is invoked on the nested function
    and given a reference to the parent object. Now, when the code inside `nestedGreeting()`
    uses `this`, it points to the parent object you set.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`bind()`方法通过将函数绑定到您选择的对象来解决这个问题。在示例中，`bind()`方法被调用在嵌套函数上，并给出对父对象的引用。现在，当`nestedGreeting()`内部代码使用`this`时，它指向您设置的父对象。'
- en: The `bind()` method is particularly useful for the `setTimeout()` and `setInterval()`
    timer functions. Ordinarily, when these functions trigger your callback, the `this`
    reference is lost (it becomes `undefined`). But with `bind()`, you can ensure
    that the callback function keeps the reference you want.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`bind()`方法特别适用于`setTimeout()`和`setInterval()`计时器函数。通常情况下，当这些函数触发您的回调时，`this`引用会丢失（变为`undefined`）。但是通过`bind()`，您可以确保回调函数保持您想要的引用。'
- en: '[Example 6-1](#demonstration_of_the_utility_of_function) is a web page that
    uses `setTimeout()` to perform a countdown operation from 10 to 0\. As the numbers
    are counted down, they’re inserted into the web page. This example also uses the
    constructor pattern for object creation (as described in [“Using the Constructor
    Pattern to Make a Custom Class”](ch08.html#constructor_pattern)) to create a class-like
    `Counter` function.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-1](#demonstration_of_the_utility_of_function)是一个网页，使用`setTimeout()`执行从10到0的倒计时操作。随着数字的倒数，它们被插入到网页中。此示例还使用构造函数模式进行对象创建（如[“使用构造函数模式创建自定义类”](ch08.html#constructor_pattern)中描述的）来创建类似类的`Counter`函数。'
- en: Example 6-1\. Demonstrating the utility of `bind()`
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-1\. 展示`bind()`的实用性
- en: '[PRE56]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If the `setTimeout()` function in the code sample had been the following:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码示例中的`setTimeout()`函数是以下内容：
- en: '[PRE57]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: it would lose `this`, and the callback function wouldn’t be able to access variables
    like `currentCount`, even though the `incrementCounter()` method is part of the
    same object.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 它会丢失`this`，回调函数将无法访问像`currentCount`这样的变量，即使`incrementCounter()`方法是同一对象的一部分。
- en: 'Extra: self = this'
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 额外：self = this
- en: 'An older alternative to using `bind()`, and one that is still in use, is to
    assign `this` to a variable in the outer function, which is then accessible to
    the inner. Typically `this` is assigned to a variable named `that` or `self`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`bind()`的一个较旧的替代方法，仍在使用中，是将`this`分配给外部函数中的一个变量，然后内部函数可以访问该变量。通常`this`被分配给一个名为`that`或`self`的变量：
- en: '[PRE58]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Without the assignment, the second message would once again reference “window,”
    not “object.”
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 没有这个赋值，第二条消息将再次引用“window”，而不是“object”。
- en: Implementing a Recursive Algorithm
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现递归算法
- en: Problem
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to implement a function that *calls itself* to accomplish a task, which
    is a technique called recursion. Recursion is useful when dealing with hierarchical
    data structures (for example, node trees or nested arrays), certain types of algorithms
    (sorting), and some mathematical calculations (the Fibonacci sequence).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现一个*调用自身*以完成任务的函数，这种技术称为递归。递归在处理分层数据结构（例如节点树或嵌套数组）、某些类型的算法（排序）和一些数学计算（斐波那契数列）时非常有用。
- en: Solution
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Recursion is a well-known concept in the field of mathematics, as well as computer
    science. An example of recursion in mathematics is the *Fibonacci sequence*. A
    Fibonacci number is the sum of the two previous Fibonacci numbers:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 递归在数学和计算机科学领域都是一个众所周知的概念。在数学中，递归的一个例子是*斐波那契数列*。斐波那契数是前两个斐波那契数的和：
- en: '[PRE59]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Another example of mathematical recursion is a *factorial*, usually denoted
    with an exclamation point (4!). A factorial is the product of all integers from
    1 to a given number *n*. If *n* is 4, then the factorial (4!) would be:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 数学递归的另一个例子是*阶乘*，通常用感叹号表示（4!）。阶乘是从1到给定数字*n*的所有整数的乘积。如果*n*为4，则阶乘（4!）为：
- en: '[PRE60]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'These recursions can be coded in JavaScript using a series of loops and conditions,
    but they can also be coded using functional recursion. Here’s a recursive function
    that finds the nth number in the Fibonacci sequence:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这些递归可以使用一系列循环和条件在JavaScript中编码，但也可以使用功能性递归来编码。这里是一个找到斐波那契数列第n个数的递归函数：
- en: '[PRE61]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'And here’s one that solves a factorial:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个解决阶乘的例子：
- en: '[PRE62]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Discussion
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: A characteristic that distinguishes recursive functions is a *termination condition*
    (also known as a *base case*). A recursive function cannot keep calling itself
    indiscriminately, because that would lead to an infinite loop (until stack space
    is exhausted and the program fails). Instead, a recursive function examines a
    condition and then decides to call itself (stepping one level deeper into recursion)
    or return a value (stepping one level back, to the calling function). When the
    top-level function returns a value, that becomes the final result and the recursive
    operation is complete.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 区分递归函数的特征是*终止条件*（也称为*基本情况*）。递归函数不能随意地持续调用自身，因为这会导致无限循环（直到堆栈空间耗尽并导致程序失败）。相反，递归函数检查一个条件，然后决定调用自身（进入递归的下一层）或返回一个值（回到调用函数的一层）。当顶层函数返回一个值时，这个值就成为最终结果，递归操作完成。
- en: In the Fibonacci example, `n` is tested to see if it’s less than 2\. If it is,
    it’s returned; otherwise the Fibonacci function is called again with (`n-1`) and
    with (`n-2`), and the sum of both is returned.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在斐波那契的例子中，测试`n`是否小于2。如果是，则返回它；否则再次调用斐波那契函数，分别传入(`n-1`)和(`n-2`)，并返回两者的和。
- en: In the factorial example, when the function is first called, the value passed
    as the argument is compared to the number 1\. If `n` is less than or equal to
    1 (negative numbers aren’t supported in this simple implementation), the function
    terminates, returning 1\. However, if `n` is greater than 1, what’s returned is
    the value of `n` times a call to the `factorial()` function again, this time passing
    in a value of `n–1`. The value of `n` then decreases with each iteration of the
    function, until the termination condition is reached.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在阶乘的例子中，当首次调用函数时，传递的参数值与数字1进行比较。如果`n`小于或等于1（在这个简单的实现中不支持负数），函数将终止并返回1。然而，如果`n`大于1，返回的是`n`乘以再次调用`factorial()`函数，这次传入的值是`n-1`。随着函数的每次迭代，`n`的值递减，直到达到终止条件。
- en: 'As a factorial is being computed, the interim values of each function call
    are pushed onto a stack in memory and kept until the termination condition is
    met. Then the values are popped from memory and returned, in a state similar to
    the following:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当计算阶乘时，每个函数调用的中间值被推送到内存中的堆栈，并保留直到达到终止条件。然后，这些值从内存中弹出并返回，类似于以下状态：
- en: '| return 1; | // 0! |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| return 1; | // 0! |'
- en: '| return 1; | // 1! |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| return 1; | // 1! |'
- en: '| return 1 * 2; | // 2! |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| return 1 * 2; | // 2! |'
- en: '| return 1 * 2 * 3; | // 3! |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| return 1 * 2 * 3; | // 3! |'
- en: '| return 1 * 2 * 3 * 4; | // 4! |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| return 1 * 2 * 3 * 4; | // 4! |'
- en: Most recursive functions can be replaced with code that performs the same function
    linearly, via some kind of loop. And loops may perform better, although the difference
    is often negligible. The advantage of recursion is that recursive functions can
    be very terse and minimal. Whether they are clearer is a matter of debate. (They
    are clearly *shorter*, which makes them easier to digest, but their self-referential
    nature can make their logic harder to grasp at first glance, particularly for
    programmers who haven’t used recursive functions before.)
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数递归函数可以用通过某种循环线性执行相同功能的代码来替换。循环可能性能更好，尽管差异通常微不足道。递归的优势在于递归函数可以非常简洁和简洪。它们是否更清晰是一个有争议的问题。（它们显然*更短*，这使得它们更容易消化，但它们的自我引用性质可能使得它们的逻辑一开始就更难理解，特别是对于之前没有使用过递归函数的程序员来说。）
- en: If a recursive function calls itself over and over again, it will eventually
    exhaust the call stack. This condition leads to an error with a message like “Out
    of stack space,” “Too much recursion,” or “Maximum call stack size exceeded.”
    The exact message and the number of open function calls that are allowed at once
    depend on the implementation of the JavaScript engine. However, these error messages
    usually indicate an incorrectly structured recursive function that is failing
    to evaluate its termination condition and calling itself in an infinite loop.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个递归函数一遍又一遍地调用自身，最终会耗尽调用栈。这种情况会导致出现类似“栈空间不足”、“递归过深”或“超出最大调用栈大小”等错误。确切的错误消息和一次允许的开放函数调用数量取决于JavaScript引擎的实现。然而，这些错误消息通常表明一个结构不正确的递归函数未能评估其终止条件并在无限循环中调用自身。
