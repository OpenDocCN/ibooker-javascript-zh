- en: Chapter 4\. Shared Memory
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 共享内存
- en: So far you’ve been exposed to the web workers API for browsers, covered in [Chapter 2](ch02.xhtml#ch_browser),
    and the worker threads module for Node.js, covered in [“The worker_threads Module”](ch03.xhtml#ch_nodejs_sec_workermodule).
    These are two powerful tools for working with concurrency in JavaScript, allowing
    developers to run code in parallel in a way that wasn’t previously available to
    JavaScript.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经接触过用于浏览器的Web Workers API，这在[第2章](ch02.xhtml#ch_browser)中有所涵盖，并且Node.js的工作线程模块，在[“worker_threads模块”](ch03.xhtml#ch_nodejs_sec_workermodule)中有所涵盖。这两个工具对于在JavaScript中处理并发非常有用，使开发人员能够以以前无法实现的方式并行运行代码。
- en: 'However, the interaction you’ve had with them so far has been fairly shallow.
    While it’s true they allow you to run code in parallel, you’ve only done so using
    message-passing APIs, ultimately depending on the familiar event loop to handle
    the receipt of a message. This is a much less performant system than the threading
    code you worked with in [“Threads in C: Get Rich with Happycoin”](ch01.xhtml#ch_intro_sec_happycoin)
    where these disparate threads are able to access the same shared memory.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您迄今为止与它们的互动还相当浅显。虽然它们确实允许您并行运行代码，但您只是使用了消息传递API，最终仍依赖于熟悉的事件循环来处理消息的接收。这比您在[“C语言中的线程：与Happycoin一起致富”](ch01.xhtml#ch_intro_sec_happycoin)中使用的线程代码要低效得多，那里这些不同的线程能够访问相同的共享内存。
- en: 'This chapter covers two powerful tools available to your JavaScript applications:
    the `Atomics` object and the `SharedArrayBuffer` class. These allow you to share
    memory between two threads without depending on message passing. But before diving
    into a complete technical explanation for these objects, a quick introductory
    example is in order.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了JavaScript应用程序可用的两个强大工具：`Atomics`对象和`SharedArrayBuffer`类。这些工具允许您在两个线程之间共享内存，而无需依赖消息传递。但在深入讨论这些对象的完整技术说明之前，我们先来看一个快速的介绍性示例。
- en: In the wrong hands, the tools covered here can be dangerous, introducing logic-defying
    bugs to your application that slither in the shadows during development only to
    rear their heads in production. But when honed and used properly, these tools
    allow your application to soar to new heights, squeezing never-before-seen levels
    of performance from your hardware.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具如果被滥用可能会很危险，在开发过程中引入逻辑上的错误到您的应用程序中，这些错误在生产环境中可能会显露出来。但如果经过磨练并正确使用，这些工具可以让您的应用程序在硬件上表现出前所未见的高性能水平。
- en: Intro to Shared Memory
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享内存介绍
- en: For this example you will build a very basic application that is able to communicate
    between two web workers. While this does require an initial bit of boilerplate
    using `postMessage()` and `onmessage`, subsequent updates won’t rely on such functionality.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，您将构建一个非常基本的应用程序，能够在两个Web Worker之间进行通信。虽然这需要一些初始的样板代码使用`postMessage()`和`onmessage`，但后续的更新将不依赖于这样的功能。
- en: This shared memory example will work in a browser as well as in Node.js, though
    the setup work required is a little different for the two of them. For now, you’ll
    build out an example that works in the browser, and a lot of description is provided.
    Later, once you’re a little more familiar, you’ll build out an example using Node.js.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 此共享内存示例将在浏览器以及Node.js中运行，尽管两者所需的设置工作有些不同。现在，您将构建一个在浏览器中工作的示例，并提供了大量的描述。稍后，一旦您更加熟悉，您将构建一个使用Node.js的示例。
- en: Shared Memory in the Browser
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浏览器中的共享内存
- en: To get started, create another directory to house this project in named *ch4-web-workers/*.
    Then, create an HTML file named *index.html*, and add the content from [Example 4-1](#ex_sharedmemory_index)
    to it.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请创建另一个目录以存放名为*ch4-web-workers/*的项目，然后创建一个名为*index.html*的HTML文件，并将内容从[示例 4-1](#ex_sharedmemory_index)添加到其中。
- en: Example 4-1\. *ch4-web-workers/index.html*
  id: totrans-10
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-1\. *ch4-web-workers/index.html*
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once you’re done with that file you’re ready for the more complicated part of
    the application. Create a file named *main.js* containing the content from [Example 4-2](#ex_sharedmemory_main).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 完成文件后，您可以开始应用程序的更复杂部分。创建一个名为*main.js*的文件，其中包含来自[示例 4-2](#ex_sharedmemory_main)的内容。
- en: Example 4-2\. *ch4-web-workers/main.js*
  id: totrans-13
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-2\. *ch4-web-workers/main.js*
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](Images/1.png)](#co_shared_memory_CO1-1)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_shared_memory_CO1-1)'
- en: When `crossOriginIsolated` is true, then `SharedArrayBuffer` can be used.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当`crossOriginIsolated`为true时，可以使用`SharedArrayBuffer`。
- en: '[![2](Images/2.png)](#co_shared_memory_CO1-2)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_shared_memory_CO1-2)'
- en: Instantiates a 1 KB buffer.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化一个1 KB缓冲区。
- en: '[![3](Images/3.png)](#co_shared_memory_CO1-3)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_shared_memory_CO1-3)'
- en: A view into the buffer is created.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一个对缓冲区的视图。
- en: '[![4](Images/4.png)](#co_shared_memory_CO1-4)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_shared_memory_CO1-4)'
- en: A modified property is read.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 读取了修改后的属性。
- en: This file is similar to one that you created before. In fact, it’s still making
    use of a dedicated worker. But a few complexities have been added. The first new
    thing is the check for the `crossOriginIsolated` value, which is a global variable
    available in modern browsers. This value tells you if the JavaScript code currently
    being run is capable of, among other things, instantiating a `SharedArrayBuffer`
    instance.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件类似于您之前创建的文件。实际上，它仍在使用专用工作者。但是增加了一些复杂性。第一件新事是检查`crossOriginIsolated`值，这是现代浏览器中可用的全局变量之一。此值告诉您当前运行的JavaScript代码是否能够实例化`SharedArrayBuffer`实例。
- en: 'For security reasons (related to the Spectre CPU attack), the `SharedArrayBuffer`
    object isn’t always available for instantiation. In fact, a few years ago browsers
    disabled this functionality entirely. Now, both Chrome and Firefox support the
    object and require additional HTTP headers to be set when the document is served
    before it will allow a `SharedArrayBuffer` to be instantiated. Node.js doesn’t
    have the same restrictions. Here are the required headers:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 出于与Spectre CPU攻击相关的安全原因，`SharedArrayBuffer`对象并非始终可用于实例化。事实上，几年前浏览器完全禁用了这个功能。现在，Chrome和Firefox都支持该对象，并要求在文档服务之前设置额外的HTTP标头，才能允许实例化`SharedArrayBuffer`。Node.js没有相同的限制。以下是所需的标头：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The test server that you’ll run automatically sets these headers. Any time you
    build a production-ready application that uses `SharedArrayBuffer` instances you’ll
    need to remember to set these headers.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您将自动运行的测试服务器设置这些标头。任何时候构建一个使用`SharedArrayBuffer`实例的生产就绪应用程序，都需要记住设置这些标头。
- en: After a dedicated worker is instantiated, an instance of a `SharedArrayBuffer`
    is also instantiated. The argument that follows, 1,024 in this case, is the number
    of bytes allocated to the buffer. Unlike other arrays or buffer objects you might
    be familiar with, these buffers cannot shrink or grow in size after they’ve been
    created.^([1](ch04.xhtml#idm45995921045144))
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化专用工作者后，还会实例化一个`SharedArrayBuffer`的实例。此处的参数1,024是分配给缓冲区的字节数。与您熟悉的其他数组或缓冲对象不同，这些缓冲区在创建后无法收缩或增长。^([1](ch04.xhtml#idm45995921045144))
- en: A view to work with the buffer named `view` has also been created. Such views
    are covered extensively in [“SharedArrayBuffer and TypedArrays”](#ch_shared_mem_sec_typedarrays),
    but for now, think of them as a way to read from and write to a buffer.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 还创建了一个用于处理名为`view`的缓冲区的视图。此类视图在[“SharedArrayBuffer and TypedArrays”](#ch_shared_mem_sec_typedarrays)中有详细介绍，但现在，请将其视为一种读取和写入缓冲区的方法。
- en: This view into the buffer allows us to read from it using the array index syntax.
    In this case, we’re able to inspect the 0th byte in the buffer by logging a call
    to `view[0]`. After that, the buffer instance is passed into the worker using
    the `worker.postMessage()` method. In this case the buffer is the only thing being
    passed in. However, a more complex object could have been passed in as well, with
    the buffer being one of the properties. Whereas the algorithm discussed in the
    [Appendix](app01.xhtml#app_sca) mostly clobbers complex objects, instances of
    `SharedArrayBuffer` are an intentional exception.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个对缓冲区的视图，我们可以使用数组索引语法从中读取。在本例中，我们通过记录调用`view[0]`来检查缓冲区中的第0字节。之后，使用`worker.postMessage()`方法将缓冲区实例传递给工作者。在这种情况下，传递的唯一内容是缓冲区。然而，也可以传递更复杂的对象，其中缓冲区是其中一个属性。虽然附录中讨论的算法主要破坏复杂对象，但`SharedArrayBuffer`的实例是一个明确的例外。
- en: Once the script is finished with the setup work, it schedules a function to
    run in 500 ms. This script prints the 0th byte of the buffer again and also attempts
    to print a property attached to the buffer named `.foo`. Note that this file otherwise
    does not have a `worker.onmessage` handler defined.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦脚本完成设置工作，它会安排一个函数在500毫秒后运行。此脚本再次打印缓冲区的第0字节，并尝试打印一个名为`.foo`的附加到缓冲区的属性。请注意，此文件中否则没有定义`worker.onmessage`处理程序。
- en: Now that you’re finished with the main JavaScript file you’re ready to create
    the worker. Make a file named *worker.js* and add the content from [Example 4-3](#ex_sharedmemory_worker)
    to it.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经完成了主JavaScript文件，准备好创建工作者。创建一个名为*worker.js*的文件，并将内容从[示例 4-3](#ex_sharedmemory_worker)添加到其中。
- en: Example 4-3\. *ch4-web-workers/worker.js*
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-3\. *ch4-web-workers/worker.js*
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[![1](Images/1.png)](#co_shared_memory_CO2-1)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_shared_memory_CO2-1)'
- en: A property on the buffer object is written.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲对象上的一个属性已被写入。
- en: '[![2](Images/2.png)](#co_shared_memory_CO2-2)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_shared_memory_CO2-2)'
- en: The 0th index is set to the number 2.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第 0 索引被设置为数字 2。
- en: This file attaches a handler for the `onmessage` event, which is run after the
    `.postMessage()` method in *main.js* is fired. Once called, the buffer argument
    is grabbed. The first thing that happens in the handler is that a `.foo` property
    is attached to the `SharedArrayBuffer` instance. Next, another view is created
    for the buffer. After that the buffer is updated through the view. Once that’s
    done, a message is printed so that you can see what has happened.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件附加了一个处理程序，用于在 *main.js* 中的 `.postMessage()` 方法触发后运行的 `onmessage` 事件。一旦调用，将获取缓冲区参数。处理程序中的第一件事就是将
    `.foo` 属性附加到 `SharedArrayBuffer` 实例上。接下来，为缓冲区创建了另一个视图。之后，通过视图更新了缓冲区。完成这些后，将打印一条消息，以便你可以看到发生了什么。
- en: 'Now that your files are complete, you’re ready to run your new application.
    Open up a terminal window and run the following command. It’s a little different
    than the `serve` commands you ran before because it needs to provide the security
    headers:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的文件已经完成，可以准备运行新的应用程序了。打开一个终端窗口并运行以下命令。它与之前运行的 `serve` 命令有些不同，因为它需要提供安全头信息：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As before, open the link displayed in your terminal. Next, open the web inspector
    and visit the Console tab. You might not see any output; if so, refresh the page
    to execute the code again. You should see logs printed from the application. An
    example of the output has been reproduced in [Table 4-1](#ex_sharedmemory_output).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，在你的终端中打开显示的链接。接下来，打开网页检查器并访问“控制台”选项卡。你可能看不到任何输出；如果是这样，请刷新页面以重新执行代码。你应该能看到应用程序打印的日志。输出的示例已在
    [表 4-1](#ex_sharedmemory_output) 中重现。
- en: Table 4-1\. Example console output
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-1\. 示例控制台输出
- en: '| Log | Location |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 日志 | 位置 |'
- en: '| --- | --- |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| now 0 | main.js:10:9 |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 现在 0 | main.js:10:9 |'
- en: '| updated in worker | worker.js:5:11 |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 更新于 worker | worker.js:5:11 |'
- en: '| later 2 | main.js:15:11 |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 稍后 2 | main.js:15:11 |'
- en: '| prop undefined | main.js:16:11 |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 属性未定义 | main.js:16:11 |'
- en: The first printed line is the initial value of the buffer as seen in *main.js*.
    In this case the value is `0`. Next, the code in *worker.js* is run, though the
    timing of this is mostly indeterminate. About half a second later, the value as
    perceived in *main.js* is printed again, and the value is now set to `2`. Again,
    notice that other than the initial setup work, no message passing happened between
    the thread running the *main.js* file and the thread running the *worker.js* file.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行打印的是在 *main.js* 中看到的缓冲区的初始值。在本例中，该值为 `0`。接下来，运行 *worker.js* 中的代码，不过其具体时序大多是不确定的。大约半秒钟后，再次打印在
    *main.js* 中看到的值，并且该值现在设置为 `2`。再次注意，除了初始设置工作外，没有在运行 *main.js* 文件的线程与运行 *worker.js*
    文件的线程之间进行消息传递。
- en: Note
  id: totrans-50
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: This is a very simple example that, while it works, is not how you would normally
    write multithreaded code. There is no guarantee that the value updated in *worker.js*
    would be visible in *main.js*. For example, a clever JavaScript engine could treat
    the value as a constant, though you’d be hard-pressed to find a browser where
    this doesn’t happen.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的示例，虽然它能运行，但并不是你通常编写多线程代码的方式。不能保证在 *worker.js* 中更新的值会在 *main.js* 中可见。例如，聪明的
    JavaScript 引擎可能会将该值视为常量，尽管你很难找到一个不会这样处理的浏览器。
- en: After the buffer value is printed, the `.foo` property is also printed and a
    value of `undefined` is displayed. Why might this be? Well, while it’s true that
    a reference to the memory location that stores the binary data contained in the
    buffer has been shared between the two JavaScript environments, the actual object
    itself has not been shared. If it had been, this would violate the constraint
    of the structured clone algorithm wherein object references cannot be shared between
    threads.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在打印缓冲区值之后，也会打印 `.foo` 属性，并显示值 `undefined`。这可能是为什么呢？好吧，虽然确实存在一个引用内存位置的引用，该内存位置存储在缓冲区中的二进制数据，但实际对象本身并没有被共享。如果共享了，这将违反结构化克隆算法的约束，该算法规定对象引用不能在线程之间共享。
- en: Shared Memory in Node.js
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Node.js 中的共享内存
- en: The Node.js equivalent of this application is mostly similar; however, the `Worker`
    global provided by browsers isn’t available, and the worker thread won’t make
    use of `self.onmessage`. Instead, the worker threads module must be required to
    gain access to this functionality. Since Node.js isn’t a browser the *index.html*
    file isn’t applicable.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序的Node.js等效版本大部分是相似的；然而，浏览器提供的`Worker`全局变量不可用，并且工作线程不会使用`self.onmessage`。相反，必须要求工作线程模块以获取这个功能。由于Node.js不是浏览器，因此*index.html*文件不适用。
- en: To create a Node.js equivalent, you’ll only need two files, which can be put
    in the same *ch4-web-workers/* folder you’ve been using. First, create a *main-node.js*
    script, and add the content from [Example 4-4](#ex_sharedmemory_main_node) to
    it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个Node.js等效版本，你只需要两个文件，它们可以放在相同的*ch4-web-workers/*文件夹中。首先，创建一个*main-node.js*脚本，并将内容从[示例 4-4](#ex_sharedmemory_main_node)添加到其中。
- en: Example 4-4\. *ch4-web-workers/main-node.js*
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-4\. *ch4-web-workers/main-node.js*
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The code is a little different, but it should feel mostly familiar. Because
    the `Worker` global isn’t available, it is instead accessed by pulling the `.Worker`
    property from the required `worker_threads` module. When instantiating the worker
    a more explicit path to the worker must be provided than what is accepted by browsers.
    In this case the path *./worker-node.js* was required, even though browsers are
    fine with just *worker.js*. Other than that, the main JavaScript file for this
    Node.js example is mostly unchanged when compared to the browser equivalent. The
    final `worker.unref()` call was added to prevent the worker from keeping the process
    running forever.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 代码有些许不同，但大体上应该感觉上是熟悉的。因为全局的`Worker`不可用，所以必须从需要的`worker_threads`模块中获取`.Worker`属性来访问它。在实例化工作线程时，必须提供比浏览器接受的更明确的工作线程路径。在这种情况下，尽管浏览器只需*worker.js*，但需要提供更明确的路径*./worker-node.js*。除此之外，与浏览器等效的主JavaScript文件在这个Node.js示例中基本保持不变。最后的`worker.unref()`调用是为了防止工作线程永远保持进程运行状态。
- en: Next, create a file named *worker-node.js*, which will contain the Node.js equivalent
    of the browser worker. Add the content from [Example 4-5](#ex_sharedmemory_worker_node)
    to this file.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为*worker-node.js*的文件，其中包含与浏览器工作线程[示例 4-5](#ex_sharedmemory_worker_node)相对应的Node.js版本。将内容添加到这个文件中。
- en: Example 4-5\. *ch4-web-workers/worker-node.js*
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-5\. *ch4-web-workers/worker-node.js*
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this case the `self.onmessage` value isn’t available to the worker. Instead,
    the `worker_threads` module is required again, and the `.parentPort` property
    from the module is used. This is used to represent a connection to the port from
    the calling JavaScript environment.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`self.onmessage`值对于工作线程是不可用的。相反，再次需要`worker_threads`模块，并使用模块中的`.parentPort`属性。这用于表示与调用JavaScript环境的端口的连接。
- en: The `.onmessage` handler can be assigned to the `parentPort` object, and the
    method `.on('message', cb)` can be called. If using both, they’ll be called in
    the order that they were used. The callback function for the `message` event receives
    the object being passed in (`buffer` in this case) directly as an argument, while
    the `onmessage` handler provides a `MessageEvent` instance with a `.data` property
    containing `buffer`. Which approach you use mostly depends on personal preference.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`.onmessage`处理程序可以分配给`parentPort`对象，并调用`.on(''message'', cb)`方法。如果同时使用这两种方法，它们将按照它们被使用的顺序调用。`message`事件的回调函数直接作为参数接收传入的对象（在这种情况下是`buffer`），而`onmessage`处理程序则提供一个包含`buffer`的`.data`属性的`MessageEvent`实例。大多数情况下，使用哪种方法取决于个人偏好。'
- en: Other than that the code is exactly the same between Node.js and the browser,
    the same applicable globals like `SharedArrayBuffer` are still available, and
    they still work the same for the sake of this example.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，Node.js和浏览器之间的代码完全相同，像`SharedArrayBuffer`这样的全局变量仍然可用，并且在这个示例中仍然起作用。
- en: 'Now that these files are complete, you can run them using this command:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这些文件已经完整，你可以使用以下命令来运行它们：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The output from this command should be equivalent to the output in [Table 4-1](#ex_sharedmemory_output)
    as displayed in the browser. Again, the same structured clone algorithm allows
    instances of `SharedArrayBuffer` to be passed along, but only the underlying binary
    buffer data, not a direct reference to the object itself.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令的输出应当等同于浏览器中显示的[表 4-1](#ex_sharedmemory_output)中的输出。同样，相同的结构克隆算法允许`SharedArrayBuffer`的实例被传递，但只传递底层的二进制缓冲区数据，而不是对象本身的直接引用。
- en: SharedArrayBuffer and TypedArrays
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SharedArrayBuffer和TypedArrays
- en: Traditionally the JavaScript language didn’t really support interaction with
    binary data. Sure, there were strings, but they really abstracted the underlying
    data storage mechanism. There were also arrays, but those can contain values of
    any type and aren’t appropriate for representing binary buffers. For many years
    that was sort of “good enough,” especially before the advent of Node.js and the
    popularity of running JavaScript outside of a web page context took off.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，JavaScript 语言并不真正支持与二进制数据的交互。当然，有字符串，但它们实际上抽象了底层数据存储机制。还有数组，但这些数组可以包含任何类型的值，并不适合表示二进制缓冲区。多年来，这种状态差不多算是“够用了”，尤其是在
    Node.js 出现之前和在不涉及网页上下文的情况下运行 JavaScript 受欢迎之前。
- en: The Node.js runtime is, among other things, capable of reading and writing to
    the filesystem, streaming data to and from the network, and so on. Such interactions
    are not only limited to ASCII-based text files but can also include piping binary
    data as well. Since there wasn’t a convenient buffer data structure available,
    the authors created their own. Thus, the Node.js `Buffer` was born.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 运行时除了其他功能外，还能读写文件系统、在网络中进行数据流传输等。这些交互不仅限于基于 ASCII 的文本文件，还可以包括管道传输二进制数据。由于没有现成的便捷缓冲数据结构，作者们创建了自己的。因此，Node.js
    的 `Buffer` 诞生了。
- en: As the boundaries of the JavaScript language itself were pushed, so too grew
    the APIs and the capabilities of the language to interact with the world outside
    of the browser window. Eventually the `ArrayBuffer` object and later the `SharedArrayBuffer`
    object were created and are now a core part of the language. Most likely, if Node.js
    were created today, it would not have created its own `Buffer` implementation.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 JavaScript 语言本身边界的推动，API 和语言与浏览器窗口外部互动的能力也得到了增强。最终创建了 `ArrayBuffer` 对象，稍后又创建了
    `SharedArrayBuffer` 对象，它们现在是语言的核心组成部分。很可能，如果今天创建 Node.js，它就不会创建自己的 `Buffer` 实现了。
- en: Instances of `ArrayBuffer` and `SharedArrayBuffer` represent a buffer of binary
    data that is of fixed length and cannot be resized. While the two are quite similar,
    it is the latter that will be the focus of this section because it allows applications
    to share memory across threads. Binary data, while ubiquitous and a first-class
    concept in many traditional programming languages like C, can be easy to misunderstand,
    especially for developers using high-level languages such as JavaScript.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrayBuffer` 和 `SharedArrayBuffer` 的实例表示固定长度且不能调整大小的二进制数据缓冲区。虽然两者相似，但后者将是本节的重点，因为它允许应用程序在线程之间共享内存。二进制数据在许多传统编程语言（如
    C 语言）中是一个普遍存在且重要的概念，但对于使用高级语言如 JavaScript 的开发人员来说，理解起来可能并不容易。'
- en: Just in case you haven’t had experience with it, *binary* is a system of counting
    that is 2 based, which at the lowest level is represented as 1s and 0s. Each of
    these numbers is referred to as a *bit*. *Decimal*, the system humans mostly use
    for counting, is 10 based and is represented with numerals from 0 to 9\. A combination
    of 8 bits is referred to as a byte and is often the smallest addressable value
    in memory since it’s usually easier to deal with than individual bits. Basically,
    this means CPUs (and programmers) work with bytes instead of individual bits.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有使用过，*二进制* 是一种基于 2 的计数系统，最低级别上表示为 1 和 0。每个数字称为一个 *位*。*十进制* 是人类主要用于计数的系统，基数为
    10，用数字 0 到 9 表示。8 个位的组合称为一个字节，通常是内存中最小可寻址的值，因为与单个位相比处理起来更容易。基本上，这意味着 CPU（和程序员）处理字节而不是单个位。
- en: These bytes are often represented as two *hexadecimal* characters, which is
    a 16 based system of counting using the numerals 0–9 and the letters A–F. In fact,
    when you log an instance of an `ArrayBuffer` using Node.js, the resulting output
    displays the value of the buffer using hexadecimal.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字节通常以两个 *十六进制* 字符表示，这是一种基于 16 的计数系统，使用数字 0–9 和字母 A–F。实际上，在 Node.js 中记录 `ArrayBuffer`
    的实例时，结果输出显示的是用十六进制表示的缓冲区值。
- en: Given an arbitrary set of bytes that is stored on disk, or even in a computer’s
    memory, it’s a little ambiguous what the data means. For example, what might the
    hexadecimal value `0x54` (the `0x` prefix in JavaScript means the value is in
    hexadecimal) represent? Well, if it’s part of a string, it might mean the capital
    letter *T*. However, if it represents an integer, it might mean the decimal number
    84\. It might even refer to a memory location, part of a pixel in a JPEG image,
    or any other number of things. The context here is very important. That same number,
    represented in binary, looks like `0b01010100` (the `0b` prefix represents binary).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 假设存储在磁盘上或甚至计算机内存中的一组任意字节，数据意义有点模糊。例如，十六进制值`0x54`（JavaScript中的`0x`前缀表示值是十六进制的）代表什么？如果它是字符串的一部分，可能表示大写字母*T*。但如果它代表一个整数，可能是十进制数84。它甚至可能是指内存位置，JPEG图像中的像素的一部分，或者其他任意数量的事物。这里的上下文非常重要。相同的数字，在二进制中表示为`0b01010100`（`0b`前缀表示二进制）。
- en: Keeping this ambiguity in mind, it’s also important to mention that the contents
    of an `ArrayBuffer` (and `SharedArrayBuffer`) can’t be directly modified. Instead,
    a “view” into the buffer must first be created. Also, unlike other languages which
    might provide access to abandoned memory, when an `ArrayBuffer` in JavaScript
    is instantiated the contents of the buffer are initialized to 0\. Considering
    these buffer objects only store numeric data, they truly are a very elementary
    tool for data storage, one that more complicated systems are often built upon.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要记住这种模糊性，还要提到，无法直接修改`ArrayBuffer`（和`SharedArrayBuffer`）的内容。相反，必须先创建对缓冲区的“视图”。此外，不同于其他语言可能提供对废弃内存的访问，JavaScript中实例化`ArrayBuffer`时缓冲区的内容被初始化为0。考虑到这些缓冲区对象仅存储数值数据，它们确实是数据存储的非常基础的工具，通常用于构建更复杂的系统。
- en: Both `ArrayBuffer` and `SharedArrayBuffer` inherit from `Object` and come with
    those associated methods. Other than that, they come with two properties. The
    first is the read-only value `.byteLength`, representing the byte length of the
    buffer, and the second is the `.slice(begin, end)` method, which returns a copy
    of the buffer depending on the range that is provided.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrayBuffer`和`SharedArrayBuffer`都继承自`Object`，并具有相关的方法。除此之外，它们各自还有两个属性。第一个是只读的值`.byteLength`，表示缓冲区的字节长度；第二个是`.slice(begin,
    end)`方法，根据提供的范围返回缓冲区的副本。'
- en: The `begin` value of `.slice()` is inclusive, while the `end` value is exclusive,
    and is notably different than, say, `String#substr(begin, length)`, where the
    second parameter is a length. If the `begin` value is omitted, it defaults to
    the first element, and if the `end` value is omitted, it defaults to the last
    element. Negative numbers represent values from the end of the buffer.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`.slice()`的`begin`值是包含的，而`end`值是排除的，这显然与`String#substr(begin, length)`不同，后者的第二个参数是长度。如果省略了`begin`值，则默认为第一个元素；如果省略了`end`值，则默认为最后一个元素。负数表示从缓冲区末尾计数。'
- en: 'Here’s an example of some basic interaction with an `ArrayBuffer`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是与`ArrayBuffer`基本交互的示例：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Different JavaScript environments display the contents of an `ArrayBuffer` instance
    differently. Node.js displays a list of hexadecimal pairs as if the data were
    going to be viewed as a `Uint8Array`. Chrome v88 displays an expandable object
    with several different views. Firefox, however, won’t display the data, and will
    need to first be passed through a view.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的JavaScript环境以不同方式显示`ArrayBuffer`实例的内容。Node.js显示一列十六进制对，就像数据将被视为`Uint8Array`。Chrome
    v88显示一个可展开的对象，具有几种不同的视图。然而，Firefox不会显示数据，需要首先通过视图传递。
- en: The term *view* has been mentioned in a few places, and now is a good time to
    define it. Due to the ambiguity of what binary data can mean, we need to use a
    view to read and write to the underlying buffer. There are several of these views
    available in JavaScript. Each of these views extends from a base class called
    `TypedArray`. This class can’t be instantiated directly and isn’t available as
    a global, but it can be accessed by grabbing the `.prototype` property from an
    instantiated child class.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*视图*已经在几个地方提到过，现在是定义它的好时机。由于二进制数据的含义可能存在歧义，我们需要使用视图来读取和写入底层缓冲区。在JavaScript中有几种这样的视图可用。每个视图都是从名为`TypedArray`的基类扩展而来。这个类不能直接实例化，也不作为全局变量提供，但可以通过从实例化的子类中获取`.prototype`属性来访问。
- en: '[Table 4-2](#list_typed_array) contains a list of the view classes that extend
    from `TypedArray`.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 4-2](#list_typed_array)包含一组扩展自`TypedArray`的视图类列表。'
- en: Table 4-2\. Classes that extend `TypedArray`
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 表4-2。扩展了`TypedArray`的类
- en: '| Class | Bytes | Minimum Value | Maximum Value |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| Class | Bytes | Minimum Value | Maximum Value |'
- en: '| --- | --- | --- | --- |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `Int8Array` | 1 | –128 | 127 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `Int8Array` | 1 | –128 | 127 |'
- en: '| `Uint8Array` | 1 | 0 | 255 |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `Uint8Array` | 1 | 0 | 255 |'
- en: '| `Uint8ClampedArray` | 1 | 0 | 255 |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `Uint8ClampedArray` | 1 | 0 | 255 |'
- en: '| `Int16Array` | 2 | –32,768 | 32,767 |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `Int16Array` | 2 | –32,768 | 32,767 |'
- en: '| `Uint16Array` | 2 | 0 | 65,535 |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `Uint16Array` | 2 | 0 | 65,535 |'
- en: '| `Int32Array` | 4 | –2,147,483,648 | 2,147,483,647 |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `Int32Array` | 4 | –2,147,483,648 | 2,147,483,647 |'
- en: '| `Uint32Array` | 4 | 0 | 4294967295 |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `Uint32Array` | 4 | 0 | 4294967295 |'
- en: '| `Float32Array` | 4 | 1.4012984643e-45 | 3.4028235e38 |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `Float32Array` | 4 | 1.4012984643e-45 | 3.4028235e38 |'
- en: '| `Float64Array` | 8 | 5e–324 | 1.7976931348623157e308 |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `Float64Array` | 8 | 5e–324 | 1.7976931348623157e308 |'
- en: '| `BigInt64Array` | 8 | –9,223,372,036,854,775,808 | 9,223,372,036,854,775,807
    |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `BigInt64Array` | 8 | –9,223,372,036,854,775,808 | 9,223,372,036,854,775,807
    |'
- en: '| `BigUint64Array` | 8 | 0 | 18,446,744,073,709,551,615 |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `BigUint64Array` | 8 | 0 | 18,446,744,073,709,551,615 |'
- en: The Class column is the name of the class that is available for instantiation.
    These classes are globals and are accessible in any modern JavaScript engine.
    The Bytes column is the number of bytes that are used to represent each individual
    element in the view. The Minimum Value and Maximum Value columns display the valid
    numeric ranges that can be used to represent an element in the buffer.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 类（Class）列是可用于实例化的类名称。这些类是全局的，在任何现代 JavaScript 引擎中都可以访问。字节（Bytes）列是用于表示每个单独元素的字节数。最小值（Minimum
    Value）和最大值（Maximum Value）列显示了可以用来表示缓冲区中元素的有效数值范围。
- en: When creating one of these views, the `ArrayBuffer` instance is passed into
    the constructor of the view. The buffer byte length must be a multiple of the
    element byte length used by the particular view that it’s being passed into. For
    example, if an `ArrayBuffer` composed of 6 bytes were created, it is acceptable
    to pass that into an `Int16Array` (byte length of 2) because this will represent
    three `Int16` elements. However, the same 6-byte buffer cannot be passed into
    an `Int32Array` because it would represent one and a half elements, which isn’t
    valid.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 创建其中一个视图时，`ArrayBuffer`实例被传递到视图的构造函数中。缓冲区的字节长度必须是特定视图使用的元素字节长度的倍数。例如，如果创建了一个由6个字节组成的`ArrayBuffer`，则可以将其传递给`Int16Array`（字节长度为2），因为这将表示三个`Int16`元素。然而，相同的6字节缓冲区不能传递给`Int32Array`，因为这将表示一个半元素，这是无效的。
- en: The names of these views might be familiar if you’ve programmed with lower-level
    languages such as C or Rust.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您曾使用过低级语言如C或Rust，这些视图的名称可能会很熟悉。
- en: The `U` prefix to half of these classes refers to unsigned, which means that
    only positive numbers may be represented. Classes without the `U` prefix are signed
    and so negative and positive numbers may be represented, though with only half
    the maximum value. This is because a signed number uses the first bit to represent
    the “sign,” conveying if the number is positive or negative.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`U`前缀用于这些类的一半，表示只能表示正数。没有`U`前缀的类是有符号的，因此可以表示负数和正数，尽管最大值只有一半。这是因为有符号数使用第一位表示“符号”，传达数字是正数还是负数。'
- en: The numeric range limitations come from the amount of data that can be stored
    in a single byte to uniquely identify a number. Much like with decimal, numbers
    are counted from zero on up to the base, and then roll over to a number on the
    left. So, for a `Uint8` number, or an “unsigned integer represented by 8 bits,”
    the maximum value (`0b11111111`) is equal to 255.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 数值范围的限制来自于可以存储在单个字节中的数据量，以唯一标识一个数字。就像十进制一样，数字从零开始计数，直到基数，然后转到左边的数字。因此，对于`Uint8`数，或称为“由8位表示的无符号整数”，最大值（`0b11111111`）等于255。
- en: JavaScript doesn’t have an integer data type, only its `Number` type, which
    is an implementation of the [IEEE 754 floating-point number](https://oreil.ly/gOSK8).
    It is equivalent to the `Float64` data type. Otherwise, any time a JavaScript
    `Number` is written to one of these views, some sort of conversion process needs
    to happen.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 没有整数数据类型，只有其`Number`类型，这是[IEEE 754浮点数](https://oreil.ly/gOSK8)的实现。它相当于`Float64`数据类型。否则，任何时候将JavaScript`Number`写入其中一个视图时，都需要进行某种转换过程。
- en: When a value is written to `Float64Array`, it can be left mostly as the same.
    The minimum allowed value is the same as `Number.MIN_VALUE`, while the maximum
    is `Number.MAX_VALUE`. When a value is written to a `Float32Array`, not only are
    the minimum and maximum value ranges reduced but the decimal precision will be
    truncated as well.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当值被写入`Float64Array`时，它几乎可以保持不变。最小允许值与`Number.MIN_VALUE`相同，而最大值是`Number.MAX_VALUE`。当值被写入`Float32Array`时，不仅最小和最大值范围缩小，而且小数精度也会被截断。
- en: 'As an example of this, consider the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下代码：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this case, the decimal precision for the `float64` number is accurate to
    the 15th decimal, while the precision for the `float32` number is only accurate
    to the 6th decimal.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`float64`数的小数精度精确到第15位小数，而`float32`数的精度仅精确到第6位小数。
- en: This code exemplifies another thing of interest. In this case, there is a single
    `ArrayBuffer` instance named `buffer`, and yet there are two different `TypedArray`
    instances that point to this buffer data. Can you think of what’s weird with this?
    [Figure 4-1](#fig_array_buffer) might give you a hint.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码展示了另一个有趣的事情。在这种情况下，有一个名为`buffer`的单个`ArrayBuffer`实例，但是有两个不同的`TypedArray`实例指向此缓冲区数据。你能想到其中有什么奇怪的地方吗？[图 4-1](#fig_array_buffer)可能会给你一些提示。
- en: '![Two TypedArray views pointing at a single ArrayBuffer](Images/mtjs_0401.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![指向单个ArrayBuffer的两个TypedArray视图](Images/mtjs_0401.png)'
- en: Figure 4-1\. Single `ArrayBuffer` and multiple `TypeArray` views
  id: totrans-110
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-1\. 单个`ArrayBuffer`和多个`TypeArray`视图
- en: What do you think will be returned if you were to read either `view64[1]`, `view32[0]`,
    or `view32[1]`? In this case, a truncated version of the memory used to store
    data of one type will be combined, or split, to represent data of another type.
    The values returned are interpreted in the wrong way and are nonsensical, though
    they should be deterministic and consistent.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你读取`view64[1]`、`view32[0]`或`view32[1]`，你认为会返回什么？在这种情况下，用于存储一种类型数据的内存的截断版本将被组合或分割，以表示另一种类型的数据。返回的值被错误地解释，是不合理的，尽管它们应该是确定性和一致性的。
- en: 'When numeric values that are outside of the range of the supported `TypedArray`
    for nonfloats are written, they need to go through some sort of conversion process
    to fit the target data type. First, the number must be converted into an integer,
    as if it were passed into `Math.trunc()`. If the value falls outside of the acceptable
    range, then it wraps around and resets at `0` as if using the modulus (`%`) operator.
    Here are some examples of this happening with a `Uint8Array` (which is a `TypedArray`
    with a max element value of 255):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当超出`TypedArray`非浮点数支持范围的数值被写入时，它们需要经过某种转换过程以适应目标数据类型。首先，该数字必须被转换为整数，就像传递给`Math.trunc()`一样。如果值超出可接受范围，则像使用模运算符（`%`）一样环绕并重置为`0`。以下是使用`Uint8Array`（最大元素值为255的`TypedArray`）时的一些示例：
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[Table 4-3](#list_typedarray_conversion) contains a list of the values output
    on the second line, with their correlating values on the first line.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 4-3](#list_typedarray_conversion) 包含第二行输出的值及其对应的第一行值的列表。'
- en: Table 4-3\. `TypedArray` conversions
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-3\. `TypedArray`转换
- en: '| Input | 255 | 256 | 257 | –1 | 1.1 | 1.999 | –1.1 | –1.9 |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 输入 | 255 | 256 | 257 | –1 | 1.1 | 1.999 | –1.1 | –1.9 |'
- en: '| Output | 255 | 0 | 1 | 255 | 1 | 1 | 255 | 255 |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 输出 | 255 | 0 | 1 | 255 | 1 | 1 | 255 | 255 |'
- en: This behavior is a little different for `Uint8ClampedArray`. When a negative
    value is written, it is converted into `0`. When a value greater than 255 is written,
    it’s converted into 255\. When a noninteger value is provided, it’s instead passed
    to `Math.round()`. Depending on your use case, it may make more sense to use this
    view.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为对于`Uint8ClampedArray`有些不同。当写入负值时，它转换为`0`。当写入大于255的值时，它转换为255。当提供非整数值时，它会被传递给`Math.round()`。根据你的使用情况，使用这个视图可能更合适。
- en: Finally, the `BigInt64Array` and `BigUint64Array` entries also deserve some
    special attention. Unlike the other `TypedArray` views, which work with the `Number`
    type, these two variants work with the `BigInt` type (`1` is a `Number` while
    `1n` is a `BigInt`). This is because the numeric values that can be represented
    using 64 bytes fall out of the range of the numbers than can be represented using
    JavaScript’s `Number`. For that reason, setting a value with these views must
    be done with a `BigInt`, and the values retrieved will also be of type `BigInt`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`BigInt64Array` 和 `BigUint64Array` 条目也值得特别关注。与其他`TypedArray`视图不同，这两个变体使用`BigInt`类型工作（`1`
    是 `Number` 而 `1n` 是 `BigInt`）。这是因为可以使用 64 字节表示的数值超出了 JavaScript 的 `Number` 可表示的范围。因此，使用这些视图设置值必须使用
    `BigInt`，检索的值也将是 `BigInt` 类型。
- en: In general, using multiple `TypedArray` views, especially those of different
    sizes, to look into the same buffer instance is a dangerous thing and should be
    avoided when possible. You might find that you accidentally clobber some data
    when performing different operations. It is possible to pass more than one `SharedArrayBuffer`
    between threads, so if you find yourself needing to mix types, then you might
    benefit from having more than one buffer.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，使用多个`TypedArray`视图，尤其是不同大小的视图来查看同一缓冲区实例是一件危险的事情，应尽可能避免。在执行不同操作时，可能会意外覆盖一些数据。可以在线程之间传递多个`SharedArrayBuffer`，因此，如果发现自己需要混合类型，则可能会受益于拥有多个缓冲区。
- en: Now that you’re familiar with the basics of `ArrayBuffer` and `SharedArrayBuffer`
    you’re ready to interact with them using a more complex API.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经熟悉了`ArrayBuffer` 和 `SharedArrayBuffer`的基础知识，可以使用更复杂的 API 与它们进行交互了。
- en: Atomic Methods for Data Manipulation
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据操作的原子方法
- en: '*Atomicity* is a term that you might have heard before, particularly when it
    comes to databases, where it’s the first word in the acronym ACID (atomicity,
    consistency, isolation, durability). Essentially, if an operation is *atomic*,
    it means that while the overall operation may be composed of multiple smaller
    steps, the overall operation is guaranteed to either entirely succeed or entirely
    fail. For example, a single query sent to a database is going to be atomic, but
    three separate queries aren’t atomic.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*原子性* 这个术语你可能之前听过，特别是在数据库方面，它是ACID（原子性、一致性、隔离性、持久性）首字母缩略词中的第一个词。基本上，如果一个操作是*原子的*，那么虽然整体操作可能由多个较小的步骤组成，但整体操作保证要么完全成功，要么完全失败。例如，发送到数据库的单个查询是原子的，但三个单独的查询不是原子的。'
- en: Then again, if those three queries are wrapped in a database transaction, then
    the whole lot becomes atomic; either all three queries run successfully, or none
    run successfully. It’s also important that the operations are executed in a particular
    order, assuming they manipulate the same state or otherwise have any side effects
    than can affect each other. The *isolation* part means that other operations can’t
    run in the middle; for example, a read can’t occur when only some of the operations
    have been applied.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果这三个查询包含在数据库事务中，则整个事务变得原子化；要么所有三个查询成功运行，要么一个也不成功运行。此外，重要的是操作按特定顺序执行，假设它们操作相同状态或以其他方式具有可能相互影响的副作用。*隔离性*
    部分意味着其他操作不能在中间运行；例如，当只应用了一些操作时，不能进行读取。
- en: Atomic operations are very important in computing, especially when it comes
    to distributed computing. Databases, which may have many client connections, need
    to support atomic operations. Distributed systems, where many nodes on a network
    communicate, also need to support atomic operations. Extrapolating that idea a
    little, even within a single computer where data access is shared across multiple
    threads, atomicity is important.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 原子操作在计算机领域非常重要，特别是在分布式计算方面。数据库可能有许多客户端连接，需要支持原子操作。分布式系统中，网络上的多个节点进行通信，同样需要支持原子操作。稍微推广一下，即使在单个计算机上，数据访问在多个线程之间共享时，原子性也很重要。
- en: JavaScript provides a global object named `Atomics` with several static methods
    available on it. This global follows the same pattern as the familiar `Math` global.
    In either case you can’t use the `new` operator to create a new instance, and
    the available methods are stateless, not affecting the global itself. Instead,
    with `Atomics`, they’re used by passing in a reference to the data that is to
    be modified.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript提供了一个名为`Atomics`的全局对象，其中包含几个静态方法。这个全局对象遵循与熟悉的`Math`全局对象相同的模式。在任何情况下，都不能使用`new`操作符创建新实例，并且这些方法是无状态的，不影响全局对象本身。而是通过传递要修改的数据的引用来使用`Atomics`中的方法。
- en: The rest of this section lists all but three of the methods that are available
    on the `Atomics` object. The remaining methods are covered in [“Atomic Methods
    for Coordination”](ch05.xhtml#ch_adv_shared_mem_sec_atomics). With the exception
    of `Atomics.isLockFree()`, all of these methods accept a `TypedArray` instance
    as the first argument and the index to act upon as the second argument.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此部分剩余的方法列出了`Atomics`对象上除了三个方法之外的所有方法。剩余的方法在[“协调用的原子方法”](ch05.xhtml#ch_adv_shared_mem_sec_atomics)中有介绍。除了`Atomics.isLockFree()`之外，所有这些方法都将`TypedArray`实例作为第一个参数，并将要操作的索引作为第二个参数。
- en: Atomics.add()
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Atomics.add()`'
- en: '[PRE11]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This method adds the provided `value` to the existing value in a `typedArray`
    that is located at `index`. The old value is returned. Here’s what the nonatomic
    version might look like:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法将提供的`value`添加到位于`index`的`typedArray`中的现有值中。返回旧值。这里是非原子版本可能看起来像这样：
- en: '[PRE12]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Atomics.and()
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Atomics.and()`'
- en: '[PRE13]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This method performs a bitwise `and` using `value` with the existing value
    in `typedArray` located at `index`. The old value is returned. Here’s what the
    nonatomic version might look like:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法使用`value`与位于`index`的`typedArray`中的现有值执行位与操作，并返回旧值。这里是非原子版本可能看起来像这样：
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Atomics.compareExchange()
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Atomics.compareExchange()`'
- en: '[PRE15]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This method checks `typedArray` to see if the value `oldExpectedValue` is located
    at `index`. If it is, then the value is replaced with `value`. If not, then nothing
    happens. The old value is always returned, so you can tell if the exchange succeeded
    if `oldExpectedValue === old`. Here’s what the nonatomic version might look like:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法检查`typedArray`，看看`oldExpectedValue`是否位于`index`。如果是，则用`value`替换该值。如果不是，则不会发生任何事情。始终返回旧值，因此您可以通过比较`oldExpectedValue
    === old`来确定交换是否成功。这里是非原子版本可能看起来像这样：
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Atomics.exchange()
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Atomics.exchange()`'
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This method sets the value in `typedArray` located at `index` to `value`. The
    old value is returned. Here’s what the nonatomic version might look like:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法将位于`index`的`typedArray`中的值设置为`value`。返回旧值。这里是非原子版本可能看起来像这样：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Atomics.isLockFree()
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Atomics.isLockFree()`'
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This method returns a `true` if `size` is a value that appears as the `BYTES_PER_ELEMENT`
    for any of the `TypedArray` subclasses (usually 1, 2, 4, 8), and a `false` if
    otherwise.^([2](ch04.xhtml#idm45995919889496)) If `true`, then using the `Atomics`
    methods will be quite fast using the current system’s hardware. If `false`, then
    the application might want to use a manual locking mechanism, like what is covered
    in [“Mutex: A Basic Lock”](ch06.xhtml#ch_patterns_sec_basiclock), especially if
    performance is the main concern.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '这个方法在`size`作为任何`TypedArray`子类的`BYTES_PER_ELEMENT`值（通常为1、2、4、8）出现时返回`true`，否则返回`false`^([2](ch04.xhtml#idm45995919889496))。如果返回`true`，那么使用`Atomics`方法在当前系统硬件上将非常快速。如果返回`false`，则应用程序可能希望使用类似[“Mutex:
    A Basic Lock”](ch06.xhtml#ch_patterns_sec_basiclock)中介绍的手动锁定机制，特别是在性能是主要关注点时。'
- en: Atomics.load()
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Atomics.load()`'
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This method returns the value in `typedArray` located at `index`. Here’s what
    the nonatomic version might look like:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法返回位于`index`的`typedArray`中的值。这里是非原子版本可能看起来像这样：
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Atomics.or()
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Atomics.or()`'
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This method performs a bitwise `or` using `value` with the existing value in
    `typedArray` located at `index`. The old value is returned. Here’s what the nonatomic
    version might look like:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法使用`value`与位于`index`的`typedArray`中的现有值执行位或操作。返回旧值。这里是非原子版本可能看起来像这样：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Atomics.store()
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Atomics.store()`'
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This method stores the provided `value` in `typedArray` located at `index`.
    The `value` that was passed in is then returned. Here’s what the nonatomic version
    might look like:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法将提供的`value`存储在位于`index`的`typedArray`中。然后返回传入的`value`。这里是非原子版本可能看起来像这样：
- en: '[PRE25]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Atomics.sub()
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Atomics.sub()`'
- en: '[PRE26]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This method subtracts the provided `value` from the existing value in `typedArray`
    that is located at `index`. The old value is returned. Here’s what the nonatomic
    version might look like:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法从位于`index`位置的`typedArray`中的现有值中减去提供的`value`。返回旧值。以下是非原子版本可能的样子：
- en: '[PRE27]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Atomics.xor()
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Atomics.xor()
- en: '[PRE28]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This method performs a bitwise `xor` using `value` with the existing value
    in `typedArray` located at `index`. The old value is returned. Here’s what the
    nonatomic version might look like:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法使用`value`对`typedArray`中位于`index`位置的现有值执行位异或操作。返回旧值。以下是非原子版本可能的样子：
- en: '[PRE29]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Atomicity Concerns
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原子性问题
- en: The methods covered in [“Atomic Methods for Data Manipulation”](#ch_shared_mem_sec_atomics)
    are each guaranteed to execute atomically. For example, consider the `Atomics.compareExchange()`
    method. This method takes an `oldExpectedValue` and a new `value`, replacing the
    existing value only if it equals `oldExpectedValue` with the new `value`. While
    this operation would take several individual statements to represent with JavaScript,
    it’s guaranteed that the overall operation will always execute entirely.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[“数据操作的原子方法”](#ch_shared_mem_sec_atomics)中介绍的方法都保证原子执行。例如，考虑`Atomics.compareExchange()`方法。该方法接受一个`oldExpectedValue`和一个新的`value`，仅当现有值等于`oldExpectedValue`时用新的`value`替换它。虽然用JavaScript表示这个操作需要多个单独的语句，但是保证整个操作总是完全执行。'
- en: 'To illustrate this, imagine you have a `Uint8Array` named `typedArray`, and
    the 0th element is set to 7\. Then, imagine that multiple threads have access
    to that same `typedArray`, and each of them executes some variant of the following
    line of code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，想象一下你有一个名为`typedArray`的`Uint8Array`，第0个元素设置为7。然后，想象多个线程都可以访问同一个`typedArray`，并且每个线程执行以下代码的某个变体：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: It’s entirely nondeterministic the order that these three methods are called
    in, or even the timing of their calls. In fact, they could be called simultaneously!
    However, with the atomicity guarantee of the `Atomics` object, it’s guaranteed
    that exactly one of the threads will have the initial `7` value returned, while
    the other thread will get the updated value of `1` or `2` returned. A timeline
    of how these operations work can be seen in [Figure 4-2](#fig_cex_atomic), with
    the `CEX(oldExpectedValue, value)` being a shorthand for `Atomics.compareExchange()`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 完全不确定这三种方法的调用顺序，甚至它们的调用时间。实际上，它们可能同时被调用！然而，通过`Atomics`对象的原子性保证，确保只有一个线程会得到初始值`7`的返回，而另一个线程将得到更新后的值`1`或`2`的返回。这些操作的时间线可以在[图 4-2](#fig_cex_atomic)中看到，其中`CEX(oldExpectedValue,
    value)`是`Atomics.compareExchange()`的简写。
- en: '![Multiple calls to Atomics.compareExchange() are atomic.](Images/mtjs_0402.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![多次调用Atomics.compareExchange()是原子的。](Images/mtjs_0402.png)'
- en: Figure 4-2\. Atomic form of `Atomics.compareExchange()`
  id: totrans-173
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-2\. `Atomics.compareExchange()`的原子形式
- en: 'On the other hand, if you’re using the nonatomic equivalent of `compareExchange()`,
    such as reading and writing to `typedArray[0]` directly, it is entirely possible
    that the program will accidentally clobber a value. In this case both threads
    read the existing value at about the same time, then they both see that the original
    value is present, then they both write at about the same time. Here is an annotated
    version of the nonatomic `compareExchange()` code again:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果使用类似`compareExchange()`的非原子等效方法，比如直接读取和写入`typedArray[0]`，则完全可能程序会意外破坏一个值。在这种情况下，两个线程几乎同时读取现有值，然后都看到原始值存在，然后它们几乎同时写入。以下是`compareExchange()`非原子版本的注释版本：
- en: '[PRE31]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This code performs multiple interactions with shared data, notably the line
    where the data is retrieved (labeled as `GET()`) and later where the data is later
    set (labeled as `SET(value)`). For this code to function properly it would need
    a guarantee that other threads aren’t able to read or write to the value while
    the code is running. This guarantees that only one thread gets exclusive access
    to shared resources is called a *critical section*.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码与共享数据进行多次交互，特别是在检索数据的地方（标记为`GET()`）和稍后设置数据的地方（标记为`SET(value)`）。为了使此代码正常工作，需要确保其他线程在代码运行时无法读取或写入该值。这种保证只允许一个线程独占共享资源的情况称为*临界区*。
- en: '[Figure 4-3](#fig_cex_not_atomic) shows a timeline of how this code might run,
    as is, without the exclusive access guarantees.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-3](#fig_cex_not_atomic)展示了在没有独占访问保证的情况下，此代码可能如何运行的时间线。'
- en: '![Nonatomic calls result in data loss.](Images/mtjs_0403.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![非原子调用会导致数据丢失。](Images/mtjs_0403.png)'
- en: Figure 4-3\. Nonatomic form of `Atomics.compareExchange()`
  id: totrans-179
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-3\. `Atomics.compareExchange()` 的非原子形式
- en: In this case both threads think they have successfully set the value, but the
    desired outcome only persists for the second thread. This class of bug is referred
    to as a *race condition*, where two or more threads are racing against each other
    to perform some action.^([3](ch04.xhtml#idm45995919269384)) The worst thing about
    these bugs is that they don’t happen consistently, are notoriously hard to reproduce,
    and may only happen in one environment, such as a production server, and not another
    environment, like your development laptop.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，两个线程都认为它们已成功设置了值，但期望的结果仅对第二个线程持续存在。这种错误类型被称为*竞争条件*，即两个或更多线程竞争执行某些操作。^([3](ch04.xhtml#idm45995919269384))
    这类错误最糟糕的地方在于，它们不会一致发生，极难复现，并且可能仅在一个环境（例如生产服务器）中发生，而在另一个环境（如开发笔记本电脑）中却不会发生。
- en: To benefit from the atomic properties of the `Atomics` object when interacting
    with an array buffer, you’ll need to take care when mixing `Atomics` calls with
    direct array buffer access. If one thread of your application is using the `compareExchange()`
    method, and another thread is directly reading and writing to the same buffer
    location, then the safety mechanisms will have been defeated and your application
    will have nondeterministic behavior. Essentially, when using `Atomics` calls,
    there’s an implicit lock in place to make interactions convenient.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当与数组缓冲区交互时，如果希望利用`Atomics`对象的原子属性，则在混合使用`Atomics`调用和直接数组缓冲区访问时需要小心。如果应用程序的一个线程使用`compareExchange()`方法，而另一个线程直接读取和写入同一缓冲区位置，则安全机制将被打破，您的应用程序将具有非确定性行为。基本上，使用`Atomics`调用时，存在一个隐含的锁定机制，以使交互变得方便。
- en: 'Sadly, not all of the operations you’ll need to perform with shared memory
    can be represented using the `Atomics` methods. When that happens you’ll need
    to come up with a more manual locking mechanism, allowing you to read and write
    freely and preventing other threads from doing so. This concept is covered later
    in [“Mutex: A Basic Lock”](ch06.xhtml#ch_patterns_sec_basiclock).'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '遗憾的是，并非所有需要使用`Atomics`方法执行的操作都可以表示。当这种情况发生时，您需要设计更多手动锁定机制，允许您自由读写并阻止其他线程这样做。稍后的
    [“Mutex: A Basic Lock”](ch06.xhtml#ch_patterns_sec_basiclock) 将介绍这个概念。'
- en: Data Serialization
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据序列化
- en: Buffers are extremely powerful tools. That said, working with them from an entirely
    numeric point of view can start to get a little difficult. Sometimes you’ll need
    to store things that represent nonnumeric data using a buffer. When this happens
    you’ll need to serialize that data in some manner before writing it to the buffer,
    and you’ll later need to deserialize it when reading from the buffer.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区是非常强大的工具。尽管如此，从完全数值角度处理它们可能开始变得有些困难。有时，您需要使用缓冲区存储表示非数值数据的内容。当这种情况发生时，您需要以某种方式对数据进行序列化，然后在从缓冲区读取时进行反序列化。
- en: Depending on the type of data that you’d like to represent, there will be different
    tools that you can use to serialize it. Some tools will work for different situations,
    but each comes with different trade-offs with regard to storage size and serialization
    performance.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您希望表示的数据类型，将有不同的工具可供您用来序列化它。一些工具适用于不同的情况，但每种工具在存储大小和序列化性能方面都有不同的权衡。
- en: Booleans
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔值
- en: Booleans are easy to represent because they take a single bit to store the data,
    and a bit is less than a byte. So you can then create one of the smallest views,
    such as a `Uint8Array`, then point it at an `ArrayBuffer` with a byte length of
    1, and be set. Of course, the interesting thing here is that you can then store
    up to eight of these booleans using a single byte. In fact, if you’re dealing
    with a ton of boolean values, you might be able to outperform the JavaScript engine
    by storing large numbers of them in a buffer since there is additional metadata
    overhead for each boolean instance. [Figure 4-4](#fig_serialize_booleans) shows
    a list of booleans represented as a byte.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值易于表示，因为它们只需一个位来存储数据，而位数小于一个字节。因此，您可以创建最小的视图之一，例如`Uint8Array`，然后将其指向一个字节长度为1的`ArrayBuffer`，然后设置它。当然，这里有趣的是，您可以使用单个字节存储多达八个这些布尔值。实际上，如果您处理大量布尔值，通过将它们存储在缓冲区中，您可能会超越JavaScript引擎，因为每个布尔值实例都有额外的元数据开销。[图 4-4](#fig_serialize_booleans)显示了以字节表示的布尔值列表。
- en: '![Bits are ordered from right to left](Images/mtjs_0404.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![位从右到左排序](Images/mtjs_0404.png)'
- en: Figure 4-4\. Boolean values stored in a byte
  id: totrans-189
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-4. 存储在字节中的布尔值
- en: 'When storing data in individual bits like this, it’s best to start with the
    least significant bit, e.g., the bit farthest to the right labeled 0, then move
    on to more significant bits if you find yourself adding more booleans to the byte
    that you’re storing them in. The reason for this is simple: as the number of booleans
    you need to store grows, so too will the size of the buffer, and existing bit
    locations should remain correct. While the buffer itself can’t grow dynamically,
    newer releases of your application might need to instantiate large buffers.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当像这样存储数据在单独的位中时，最好从最低有效位开始，例如，最右侧标记为 0 的位，然后如果您发现需要将更多的布尔值添加到存储它们的字节中，则转移到更重要的位。这样做的原因很简单：随着您需要存储的布尔值数量的增加，缓冲区的大小也会增加，而现有的位位置应该保持正确。虽然缓冲区本身无法动态增长，但您的应用程序的新版本可能需要实例化更大的缓冲区。
- en: If the buffer that stores the booleans is today 1 byte, and tomorrow 2 bytes,
    by using the least significant digits first the decimal representation of the
    data will remain either a 0 or a 1\. However, if the most significant digit were
    used, then today the value might be 0 and 128, while tomorrow it might be 32,768
    and 0\. This could potentially cause issues if you’re persisting these values
    somewhere and using them between releases.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存储布尔值的缓冲区今天是 1 字节，明天是 2 字节，通过首先使用最低有效位，数据的十进制表示将始终是 0 或 1。然而，如果使用最高有效位，则今天的值可能是
    0 和 128，而明天可能是 32,768 和 0。如果你在版本之间持久化这些值并在它们之间使用，可能会引发问题。
- en: 'The following is an example of how to store and retrieve these boolean values
    so that they’re backed in an `ArrayBuffer`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何存储和检索这些布尔值的示例，以便它们在 `ArrayBuffer` 中得到支持：
- en: '[PRE32]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This code creates a one-byte buffer (`0b00000000` in binary) then creates a
    view into the buffer. To set the value in the least significant digit in the `ArrayBuffer`
    to true, you would use the call `setBool(0, true)`. To set the second least significant
    digit to false, you would call `setBool(1, false)`. To retrieve the values stored
    at the third least significant digit, you would then call `getBool(2)`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码创建一个一字节缓冲区 (`0b00000000` 以二进制表示)，然后创建一个指向该缓冲区的视图。要将最低有效位中的值设置为 true，您可以使用调用
    `setBool(0, true)`。要将第二低有效位设置为 false，您将调用 `setBool(1, false)`。然后，要检索存储在第三低有效位的值，您将调用
    `getBool(2)`。
- en: The `setBool()` function works by taking the boolean `value` and converting
    it into an integer (`value|0` converts `false` to 0 and `true` to 1). Then it
    “shifts the value left” by adding zeros to the right based on which `slot` to
    store it in (`0b1<<0` stays `0b1`, `0b1<<1` becomes `0b10`, etc.). It also takes
    the number 1 and shifts it based on the `slot` (so `0b1000` if the `slot` is 3),
    then inverts the bits (using `~`), and gets a new value by AND-ing (`&`) the existing
    value with this new value (`view[0] & ~(1 << slot)`). Finally, the modified old
    value and the new shifted values are OR-ed together (`|`) and assigned to `view[0]`.
    Basically, it reads the existing bits, replaces the appropriate bit, and writes
    the bits back.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`setBool()` 函数的工作方式是将布尔值 `value` 转换为整数 (`value|0` 将 `false` 转换为 0，`true` 转换为
    1)。然后根据要存储的 `slot`，通过“左移值”来添加右侧的零位 (`0b1<<0` 保持 `0b1`，`0b1<<1` 变为 `0b10`，依此类推)。它还获取数字
    1 并根据 `slot` 进行移位（如果 `slot` 是 3，则为 `0b1000`），然后反转位（使用 `~`），并通过与这个新值进行 AND 操作 (`&`)，将现有值与新移位值进行
    AND 操作 (`view[0] & ~(1 << slot)`）。最后，修改后的旧值和新移位值通过 OR 操作 (`|`) 进行合并，并赋值给 `view[0]`。基本上，它读取现有的位，替换相应的位，然后将位重新写入。'
- en: The `getBool()` function works by taking the number 1, shifting it based on
    the slot, then using `&` to compare it to the existing value. The shifted value
    (on the right of `&`) only contains a single 1 and seven 0s. The AND-ing between
    this modified value and the existing value returns either a number representing
    the value of the shifted slot, assuming the value at the `slot` position located
    at `view[0]` was truthy; otherwise, it returns 0\. This value is then checked
    to see if it is exactly equal to 0 (`===0`), and the result of that is negated
    (`!`). Basically, it returns the value of the bit at `slot`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`getBool()` 函数的工作方式是取数字 1，根据 slot 进行移位，然后使用 `&` 与现有值进行比较。修改后的值（在 `&` 的右侧）仅包含一个
    1 和七个 0。这个修改后的值与现有值之间的 AND 操作返回一个数字，表示假设位于 `view[0]` 的 `slot` 位置的值为真。否则，它返回 0。然后检查此值是否恰好等于
    0 (`===0`)，并对其进行否定 (`!`)。基本上，它返回 `slot` 处位的值。'
- en: This code has some shortcomings and shouldn’t necessarily be used in production.
    For example, it isn’t meant for working with buffers that are larger than a single
    byte, and you’ll encounter undefined behavior when reading or writing to entries
    past 7\. A production-ready version would consider the size of storage and do
    bounds checking, but that’s an exercise left to the reader.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码存在一些缺陷，并不一定适用于生产环境。例如，它不适用于处理大于单个字节的缓冲区，并且在读取或写入超过7的条目时会遇到未定义行为。一个适用于生产的版本会考虑存储的大小并进行边界检查，但这是留给读者的练习。
- en: Strings
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串
- en: Strings aren’t as easy to encode as they may seem at first glance. It’s easy
    to assume that each character in a string can be represented using a single byte,
    and that the `.length` property of a string is sufficient to choose the size of
    a buffer to store it in. While this may seem to work sometimes, particularly with
    simple strings, you’ll soon encounter errors when dealing with more complex data.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串并不像乍看起来那么容易编码。很容易假设字符串中的每个字符可以用单个字节表示，并且字符串的`.length`属性足以选择存储它的缓冲区的大小。虽然这有时可能有效，特别是对于简单的字符串，但在处理更复杂的数据时很快就会遇到错误。
- en: The reason this will work with simple strings is that data represented using
    ASCII does allow a single character to fit into a single byte. In fact, in the
    C programming language, the data storage type that represents a single byte of
    data is referred to as a `char`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这将适用于简单字符串的原因是，使用 ASCII 表示的数据确实允许单个字符适合单个字节。实际上，在 C 编程语言中，表示单个数据字节的数据存储类型被称为`char`。
- en: There are many ways to encode individual characters using strings. With ASCII
    the entire range of characters can be represented with a byte, but in a world
    of many cultures, languages, and emojis, it’s absolutely impossible to represent
    all these characters in such a manner. Instead, we use encoding systems where
    a variable number of bytes can be used to represent a single character. Internally,
    JavaScript engines use a variety of encoding formats to represent strings depending
    on the situation, and the complexity of this is hidden from our applications.
    One possible internal format is UTF-16, which uses 2 or 4 bytes to represent a
    character, or even up to 14 bytes to represent certain emojis. A more universal
    standard is UTF-8, which uses 1 to 4 bytes of storage per character and is backwards
    compatible with ASCII.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以使用字符串编码单个字符。使用 ASCII，整个字符范围可以用一个字节表示，但在一个拥有许多文化、语言和表情符号的世界中，绝对不可能以这种方式表示所有这些字符。相反，我们使用编码系统，其中可以使用可变数量的字节来表示单个字符。在内部，JavaScript
    引擎根据情况使用各种编码格式来表示字符串，这种复杂性对我们的应用程序是隐藏的。一个可能的内部格式是 UTF-16，它使用2或4个字节来表示一个字符，甚至最多使用14个字节来表示某些表情符号。一个更通用的标准是
    UTF-8，它使用1到4个字节的存储空间来表示每个字符，并且与 ASCII 兼容。
- en: 'The following is an example of what happens when a string is iterated using
    its `.length` property and the resulting values are mapped to a `Uint8Array` instance:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，展示了当使用其`.length`属性迭代字符串并将结果值映射到`Uint8Array`实例时会发生什么：
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this case storing the basic string `foo` is fine. However, the `€` character,
    which is really represented by the value 8,364, is greater than the maximum 255
    value supported by `Uint8Array` and has accordingly been truncated to 172\. Converting
    that number back into a character gives the wrong value.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，存储基本字符串`foo`是可以的。然而，`€`字符，实际上代表的值为8,364，大于`Uint8Array`支持的最大值255，因此被截断为172。将该数字转换回字符会得到错误的值。
- en: An API is available to modern JavaScript for encoding and decoding strings directly
    to `ArrayBuffer` instances. This API is provided by the globals `TextEncoder`
    and `TextDecoder`, both of which are constructors and are globally available in
    modern JavaScript environments including browsers and Node.js. These APIs encode
    and decode using the UTF-8 encoding due to its ubiquity.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现代 JavaScript 提供了一个 API，可以直接将字符串编码和解码为`ArrayBuffer`实例。这个 API 由全局变量`TextEncoder`和`TextDecoder`提供，它们都是构造函数，并在现代
    JavaScript 环境中（包括浏览器和 Node.js）全局可用。这些 API 使用 UTF-8 编码进行编码和解码，因为它的普遍性。
- en: 'Here’s an example of how to safely encode strings into the UTF-8 encoding using
    this API:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何使用这个 API 安全地将字符串编码为 UTF-8 编码的示例：
- en: '[PRE34]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'And here’s how to decode such values:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何解码这样的值：
- en: '[PRE35]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Notice that `TextDecoder#decode()` works with either the `Uint8Array` view,
    or with the underlying `ArrayBuffer` instance. This makes it convenient to decode
    data that you might get from a network call without the need to first wrap it
    in a view.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`TextDecoder#decode()`可以与`Uint8Array`视图或底层的`ArrayBuffer`实例一起使用。这使得在不需要先将数据包装在视图中的情况下解码可能从网络调用中获取的数据变得方便。
- en: Objects
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象
- en: 'Considering that objects can already be represented as strings using JSON,
    you do have the option of taking an object that you’d like to make use of across
    two threads, serializing it into a JSON string, and writing that string to an
    array buffer using the same `TextEncoder` API that you worked with in the previous
    section. This can essentially be performed by running the following code:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到可以使用 JSON 将对象表示为字符串，您可以选择将要在两个线程之间使用的对象序列化为 JSON 字符串，并使用相同的`TextEncoder`
    API将该字符串写入数组缓冲区。这基本上可以通过运行以下代码来完成：
- en: '[PRE36]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: JSON takes a JavaScript object and converts it into a string representation.
    When this happens, there are many redundancies in the output format. If you wanted
    to reduce the size of a payload even more, you could make use of a format like
    [MessagePack](https://msgpack.org), which is able to reduce the size of a serialized
    object even more by representing object metadata using binary data. This makes
    tools like MessagePack not necessarily a good fit in situations where plain text
    is appropriate, like an email, but in situations where binary buffers are passed
    around it might not be as bad. The `msgpack5` npm package is a browser and Node.js
    compatible package for doing just that.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 将 JavaScript 对象转换为字符串表示形式。在这种情况下，输出格式中存在许多冗余。如果您希望进一步减少有效负载的大小，可以使用像[MessagePack](https://msgpack.org)这样的格式，它能够通过使用二进制数据表示对象元数据来进一步减少序列化对象的大小。这使得像
    MessagePack 这样的工具在像电子邮件这样适合使用纯文本的情况下可能不是一个好选择，但在传递二进制缓冲区的情况下可能效果不会太差。`msgpack5`
    npm 包是一个既适用于浏览器又适用于 Node.js 的包，用于执行此操作。
- en: That said, the performance trade-offs when communicating between threads is
    not usually due to the size of the payload being transferred, but is more than
    likely due to the cost of serializing and deserializing payloads. For that reason
    it’s usually better to pass simpler data representations between threads. Even
    when it comes to passing objects between threads, you might find that the structured
    clone algorithm, combined with the `.onmessage` and `.postMessage` methods, is
    going to be faster and safer than serializing objects and writing them to buffers.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，在线程间通信时的性能权衡通常不是由传输的有效负载大小决定的，而更有可能是由于序列化和反序列化有效负载的成本。因此，通常最好在线程之间传递更简单的数据表示。即使在传递对象到线程之间时，您可能会发现结构化克隆算法与`.onmessage`和`.postMessage`方法结合使用比将对象序列化并写入缓冲区更快速且更安全。
- en: If you do find yourself building an application that serializes and deserializes
    objects and writes them to a `SharedArrayBuffer`, you might want to reconsider
    some of the architecture of the application. You’re almost always better off finding
    a way to take objects that you’re passing around, serializing them using lower-level
    types, and passing those along instead.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现自己构建了一个将对象序列化并反序列化并将其写入`SharedArrayBuffer`的应用程序，您可能需要重新考虑应用程序的某些架构。通常最好找到一种方式，使用较低级别的类型对传递的对象进行序列化，并传递这些对象。
- en: ^([1](ch04.xhtml#idm45995921045144-marker)) This restriction may change in the
    future; see [“In-Place Resizable and Growable ArrayBuffers”](https://oreil.ly/im1CV)
    for a proposal.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch04.xhtml#idm45995921045144-marker)) 这种限制可能在未来会改变；请参阅[“原地可调整大小和可增长的 ArrayBuffer”](https://oreil.ly/im1CV)的提案。
- en: ^([2](ch04.xhtml#idm45995919889496-marker)) If running JavaScript on rare hardware,
    it is possible that this method may return a `false` for 1, 2, or 8\. That said,
    4 will always return `true`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch04.xhtml#idm45995919889496-marker)) 如果在罕见的硬件上运行 JavaScript，可能会导致此方法返回`false`，对于
    1、2 或 8，则可能会返回。也就是说，对于 4，将始终返回`true`。
- en: ^([3](ch04.xhtml#idm45995919269384-marker)) It’s possible, with the way code
    is compiled, ordered, and executed, that a racy program can fail in a way that
    can’t be explained by this diagram of interleaving steps. When this happens you
    may end up with a value that defies all expectations.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch04.xhtml#idm45995919269384-marker)) 根据代码编译、排序和执行方式，可能会出现一个充满竞争的程序以一种无法通过交错步骤图解释的方式失败。当发生这种情况时，您可能会得到一个超出所有预期的值。
