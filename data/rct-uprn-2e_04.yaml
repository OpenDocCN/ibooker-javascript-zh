- en: Chapter 4\. Functional Excel
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章。功能性Excel
- en: Remember function components? At some point in [Chapter 2](ch02.xhtml#ch2),
    as soon as *state* came into the picture, function components dropped out of the
    discussion. It’s time to bring them back.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 记得函数组件吗？在[第 2 章](ch02.xhtml#ch2)的某个时候，当 *state* 出现时，函数组件退出了讨论。现在是时候把它们带回来了。
- en: 'A Quick Refresher: Function versus Class Components'
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速复习：函数 vs 类组件
- en: 'In its simplest form a class component only needs one `render()` method. This
    is where you build the UI, optionally using `this.props` and `this.state`:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单的形式下，类组件只需要一个`render()`方法。这是您构建UI的地方，可以选择使用`this.props`和`this.state`：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In a function component the whole component *is* the function and the UI is
    whatever the function returns. The props are passed to the function when the component
    is constructed:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数组件中，整个组件 *就是* 函数，UI 是函数返回的内容。当组件构建时，props 将传递给函数：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The usefulness of function components ended with React v16.8: you can use them
    only for components that don’t maintain state (*stateless* components). But with
    the addition of *hooks* in v16.8, it’s now possible to use function components
    everywhere. Through the rest of this chapter you’ll see how the `Excel` component
    from [Chapter 3](ch03.xhtml#ch3) can be implemented as a function component.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 函数组件的实用性在 React v16.8 之后结束了：您只能用它们来创建不维护状态（*stateless*）的组件。但是随着 v16.8 中 hooks
    的增加，现在可以在任何地方使用函数组件。在本章的其余部分中，您将看到如何将 [第 3 章](ch03.xhtml#ch3) 的 `Excel` 组件实现为函数组件。
- en: Rendering the Data
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染数据
- en: The first step is to render the data passed to the component ([Figure 4-1](#FIG0401)).
    How the component is used doesn’t change. In other words, a developer using your
    component doesn’t need to know if it’s a class or a function component. The `initialData`
    and `headers` props look the same. Even the `propTypes` definitions are the same.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是渲染传递给组件的数据（[图 4-1](#FIG0401)）。使用组件的开发人员不需要知道它是类组件还是函数组件。`initialData` 和
    `headers` props 看起来一样。即使是 `propTypes` 定义也是相同的。
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Implementing the body of the function component is largely copy-pasting the
    body of the `render()` method of the class component:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 实现函数组件的主体主要是复制粘贴类组件的 `render()` 方法的主体部分：
- en: '[PRE3]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the code above you can see that instead of `function Excel(props){}` you
    can use destructuring syntax `function Excel({headers, initialData}){}` to save
    typing of `props.headers` and `props.initialData` later on.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，您可以看到，可以使用解构语法`function Excel({headers, initialData}){}`代替`function
    Excel(props){}`，以节省稍后使用`props.headers`和`props.initialData`的输入。
- en: '![rur2 0401](Images/rur2_0401.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![rur2 0401](Images/rur2_0401.png)'
- en: Figure 4-1\. Rendering the table in a function component (see *04.01.fn.table.html*)
  id: totrans-15
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-1\. 在函数组件中渲染表格（见*04.01.fn.table.html*）
- en: The State Hook
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态钩子
- en: To be able to maintain *state* in your function components, you need *hooks*.
    What’s a hook? It’s a function prefixed with the word `use*` that lets you use
    various React features, such as tools for managing state and component lifecycles.
    You can also create your own hooks. By the end of this chapter you’ll learn how
    to use several built-in hooks as well as write your own.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要在函数组件中维护 *state*，您需要 *hooks*。什么是 hook？它是一个以`use*`开头的函数，允许您使用各种React功能，如管理状态和组件生命周期的工具。您还可以创建自己的
    hooks。本章结束时，您将学习如何使用几个内置 hooks 并编写自己的 hooks。
- en: Let’s start with the state hook. It’s a function called `useState()` that’s
    available as a property of the `React` object (`React.useState()`). It takes one
    value, the initial value of a state variable (a piece of data you want to manage),
    and returns an array of two elements (a tuple). The first element is the state
    variable and the second is a function to change this variable. Let’s see an example.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从状态钩子开始。它是一个名为`useState()`的函数，作为`React`对象的属性提供（`React.useState()`）。它接受一个值，即状态变量（要管理的数据片段）的初始值，并返回包含两个元素（元组）的数组。第一个元素是状态变量，第二个是用于修改此变量的函数。让我们看一个例子。
- en: 'In a class component, in the `constructor()` you define the initial value like
    so:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在类组件中，在 `constructor()` 中定义初始值的方法如下：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Later on, when you want to change the `data` state, you can instead do the
    following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，当您想要更改`data`状态时，可以改为执行以下操作：
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In a function component, you both define the initial state and get an updater
    function:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数组件中，您既定义初始状态，又获得更新器函数：
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-25
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note the array destructuring syntax where you assign the two elements of the
    array returned by `useState()` to two variables: `data` and `setData`. It’s a
    shorter and cleaner way to get the two return values, as opposed to, say:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意数组解构语法，其中您将`useState()`返回的数组的两个元素分配给两个变量：`data`和`setData`。这是获取两个返回值的更短更干净的方法，与之相反：
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For rendering, you can now use the variable `data`. When you want to update
    this variable, use:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于渲染，您现在可以使用变量`data`。当您想要更新此变量时，请使用：
- en: '[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Rewriting the component to use the state hook can now look like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 重写使用状态钩子的组件现在可以看起来像这样：
- en: '[PRE9]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Even though this example (see *04.02.fn.table-state.html*) doesn’t use `setData()`,
    you can see how it’s using the `data` state. Let’s move on to sorting the table,
    where you’ll need the means to change the state.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这个示例（见*04.02.fn.table-state.html*）没有使用`setData()`，您仍然可以看到它如何使用`data`状态。让我们继续排序表格，这时您将需要改变状态的手段。
- en: Sorting the Table
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对表进行排序
- en: In a class component, all the various bits of state go into the `this.state`
    object, a grab bag of often unrelated pieces of information. Using the state hook
    you can still do the same, but you can also decide to keep pieces of state in
    different variables. When it comes to sorting a table, the `data` contained in
    the table is one piece of information while the auxiliary sorting-specific information
    is another piece. In other words, you can use the state hook as many times as
    you want.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在类组件中，所有各种状态的碎片都放在`this.state`对象中，这是一个通常包含不相关信息片段的大杂烩。使用状态钩子，您仍然可以做同样的事情，但也可以决定将状态片段保留在不同的变量中。当涉及到对表格进行排序时，表中包含的`data`是一个信息片段，而辅助的特定于排序的信息是另一个信息片段。换句话说，您可以使用状态钩子任意次数。
- en: '[PRE10]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `data` is what you display in the table; the `sorting` object is a separate
    concern. It’s about how you sort (ascending or descending) and by which column
    (title, author, etc.).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`data`是您在表格中显示的内容；`sorting`对象是一个独立的问题。它涉及如何排序（升序或降序）以及按哪一列（标题、作者等）。'
- en: 'The function that does the sorting is now inline inside the `Excel` function:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在排序的函数内联在`Excel`函数内部：
- en: '[PRE11]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `sort()` function figures out which column to sort by (using its index)
    and whether the sorting is descending:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort()`函数确定按哪列（使用其索引）排序以及排序是否降序：'
- en: '[PRE12]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, it clones the `data` array because it’s still a bad idea to modify the
    state directly:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它克隆`data`数组，因为直接修改状态仍然是个坏主意：
- en: '[PRE13]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-43
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'A reminder that the `clone()` function is still the quick and dirty JSON encode/decode
    way of deep copying:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒一下，`clone()`函数仍然是深度复制的快速脏JSON编码/解码方式：
- en: '[PRE14]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The actual sorting is the same as before:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 实际排序与以前相同：
- en: '[PRE15]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And finally, the `sort()` function needs to update the two pieces of state
    with the new values:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`sort()`函数需要用新值更新这两个状态片段：
- en: '[PRE16]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And that’s about it for the business of sorting. What’s left is just to update
    the UI (the return value of the `Excel()` function) to reflect which column is
    used for sorting and to handle clicks on any of the headers:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 至于排序的事务，就是这样。剩下的只是更新UI（`Excel()`函数的返回值），以反映用于排序的列，并处理标题的任何点击：
- en: '[PRE17]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can see the result with the sorting arrow in [Figure 4-2](#FIG0402).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[图 4-2](#FIG0402)中看到带有排序箭头的结果。
- en: 'You may have noticed another nice thing about using state hooks: there’s no
    need to bind any callback functions like you do in the constructor of a class
    component. None of this `this.sort = this.sort.bind(this)` business. No `this`,
    no `constructor()`. A function is all you need to define a component.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，使用状态钩子的另一个好处是，不需要像在类组件的构造函数中那样绑定任何回调函数。没有`this`，没有`constructor()`。一个函数就足以定义一个组件。
- en: '![rur2 0402](Images/rur2_0402.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![rur2 0402](Images/rur2_0402.png)'
- en: Figure 4-2\. Sorting the data (see *04.03.fn.table-sort.html*)
  id: totrans-55
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-2\. 数据排序（见*04.03.fn.table-sort.html*）
- en: Editing Data
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑数据
- en: 'As you remember from [Chapter 3](ch03.xhtml#ch3), the editing functionality
    consists of the following steps:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从[第3章](ch03.xhtml#ch3)记得的那样，编辑功能包括以下步骤：
- en: You double-click a table cell and it turns into a text input form.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您双击表格单元格，它会变成文本输入表单。
- en: You type in the text input form.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您在文本输入表单中输入文字。
- en: When done, you press Enter to submit the form.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，按Enter提交表单。
- en: To keep track of this process, let’s add an `edit` state object. It’s `null`
    when there’s no editing; otherwise, it stores the row and column indices of the
    cell being edited.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪此过程，请添加一个`edit`状态对象。当没有编辑时为`null`；否则，它存储正在编辑的单元格的行和列索引。
- en: '[PRE18]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the UI you need to handle double-clicks (`onDoubleClick={showEditor}`) and,
    if the user is editing, show a form. Otherwise, show only the data. When the user
    hits Enter, you trap the submit event (`onSubmit={save}`).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 UI 中，你需要处理双击事件 (`onDoubleClick={showEditor}`)，如果用户正在编辑，则显示表单；否则，只显示数据。当用户按下
    Enter 键时，你会捕获提交事件 (`onSubmit={save}`)。
- en: '[PRE19]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'There are two short functions left to be implemented: `showEditor()` and `save()`.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两个短函数需要实现：`showEditor()` 和 `save()`。
- en: The `showEditor()` is invoked on double-clicking a cell in the table body. There
    you update the `edit` state (via `setEdit()`) with row and column indexes, so
    the rendering knows which cells to replace with a form.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`showEditor()` 在双击表格主体的单元格时被调用。在这里，你通过 `setEdit()` 更新 `edit` 状态，并提供行和列索引，以便渲染知道要用表单替换哪些单元格。'
- en: '[PRE20]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `save()` function traps the form submit event, prevents the submission,
    and updates the `data` state with the new value in the cell being edited. It also
    calls `setEdit()` passing `null` as the new edit state, which means the editing
    is complete.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`save()` 函数捕获表单提交事件，阻止提交，并更新 `data` 状态为正在编辑的单元格中的新值。它还调用 `setEdit()` 并传递 `null`
    作为新的编辑状态，表示编辑完成。'
- en: '[PRE21]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: And with this, the editing functionality is finished. Consult *04.04.fn.table-edit.html*
    in the book’s repo for the complete code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，编辑功能就完成了。请参考书的仓库中的 *04.04.fn.table-edit.html* 获取完整的代码。
- en: Searching
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索
- en: Searching/filtering the data doesn’t pose any new challenges when it comes to
    React and hooks. You can try to implement it yourself and reference the implementation
    in *04.05.fn.table-search.html* in the book’s repo.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 数据的搜索/过滤在 React 和 hooks 中没有新挑战。你可以尝试自己实现，并在书的仓库中的 *04.05.fn.table-search.html*
    中参考实现。
- en: 'You’ll need two new pieces of state:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要两个新的状态变量：
- en: The boolean `search` to signify whether the user is filtering or just looking
    at the data
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值 `search` 用于表示用户是在过滤还是仅查看数据。
- en: The copy of `data` as `preSearchData`, because now `data` becomes a filtered
    subset of all data
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `data` 的拷贝作为 `preSearchData`，因为现在 `data` 成为了所有数据的过滤子集。
- en: '[PRE22]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You need to take care of keeping `preSearchData` updated, since `data` (the
    filtered subset) can be updated when the user is editing while also filtering.
    Consult [Chapter 3](ch03.xhtml#ch3) as a refresher.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要确保及时更新 `preSearchData`，因为 `data`（过滤后的子集）可能在用户编辑时也会更新。作为复习，请参考 [第三章](ch03.xhtml#ch3)。
- en: 'Let’s move on to implementing the replay feature, which provides a chance to
    become familiar with two new concepts:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着实现回放功能，这提供了一个机会去熟悉两个新概念：
- en: Using lifecycle hooks
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用生命周期 hooks
- en: Writing your own hooks
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自编写 hooks
- en: Lifecycles in a World of Hooks
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Hooks 的世界中的生命周期
- en: 'The replay feature in [Chapter 3](ch03.xhtml#ch3) uses two lifecycle methods
    of the `Excel` class: `componentDidMount()` and `componentWillUnmount()`.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[第三章](ch03.xhtml#ch3) 中的回放功能使用了 `Excel` 类的两个生命周期方法：`componentDidMount()` 和
    `componentWillUnmount()`。'
- en: Troubles with Lifecycle Methods
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生命周期方法的问题
- en: 'If you revisit the *03.14.table-fetch.html* example, you may notice each of
    those has two tasks, unrelated to each other:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你重新查看 *03.14.table-fetch.html* 的例子，你可能会注意到每个例子有两个不相关的任务：
- en: '[PRE23]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In `componentDidMount()` you set up a `keydown` listener to initiate the replay
    and also fetch data from a server. In `componentWillUnmount()` you remove the
    `keydown` listener and also clean up a `setInterval()` ID. This illustrates two
    problems related to the use of lifecycle methods in class components (which are
    resolved when using hooks):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `componentDidMount()` 中，你设置了一个 `keydown` 监听器来启动回放，并从服务器获取数据。在 `componentWillUnmount()`
    中，你移除了 `keydown` 监听器，并清除了一个 `setInterval()` 的 ID。这展示了在类组件中使用生命周期方法时遇到的两个问题（这些问题在使用
    hooks 时得到解决）：
- en: Unrelated tasks are implemented together
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 不相关的任务被一起实现了。
- en: For example, performing data fetching and setting up event listeners in one
    place. This makes the lifecycle methods grow in length while performing the unrelated
    tasks. In simple components this is fine, but in larger ones you need to resort
    to code comments or moving pieces of code to various other functions, so you can
    split up the unrelated tasks and make the code more readable.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在一个地方进行数据获取和设置事件监听器。这导致生命周期方法变得很长，同时执行着不相关的任务。在简单的组件中，这没问题，但在更大的组件中，你需要依靠代码注释或将代码片段移动到不同的函数中，以便分割不相关的任务，使代码更易读。
- en: Related tasks are spread out
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 相关的任务分散开来。
- en: For example, consider adding and removing the same event listener. As the lifecycle
    methods grow in size, it’s harder to consider the separate pieces of the same
    concern at a glance because they simply don’t fit in the same screen of code when
    you read it later.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑添加和移除相同的事件侦听器。随着生命周期方法的增长，当您以后阅读代码时，很难一眼看到相同关注点的不同部分，因为它们根本不适合在同一屏幕中。
- en: useEffect()
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: useEffect()
- en: The built-in hook that replaces both of the lifecycle methods above is `React.use​Ef⁠fect()`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 替代上述两个生命周期方法的内置钩子是 `React.use​Ef⁠fect()`。
- en: Note
  id: totrans-93
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The word “effect” stands for “side effect,” meaning a type of work that is unrelated
    to the main task but happens around the same time. The main task of any React
    component is to render something based on state and props. But rendering at the
    same time (in the same function) alongside a few side jobs (such as fetching data
    from a server or setting up event listeners) may be necessary.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 单词 “effect” 代表 “副作用”，意思是与主任务无关的工作类型，但在大致相同的时间内发生。任何 React 组件的主要任务是根据状态和属性渲染某些内容。但是在同一函数中（在同一功能中）与几个副作业（例如从服务器获取数据或设置事件侦听器）同时进行渲染可能是必要的。
- en: In the `Excel` component, for example, setting up a `keydown` handler is a side
    effect of the main task of rendering data in a table.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 `Excel` 组件中，设置 `keydown` 处理程序是渲染表格数据主要任务的副作用。
- en: 'The hook `useEffect()` takes two arguments:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 钩子 `useEffect()` 接受两个参数：
- en: A callback function that is called by React at the opportune time
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 在适当的时间调用的回调函数
- en: An optional array of *dependencies*
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的 *依赖项* 数组
- en: The list of dependencies contains variables that will be checked before the
    callback is invoked and dictate whether the callback should even be invoked.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项列表包含在回调函数被调用之前将被检查的变量，并决定是否应该调用回调函数。
- en: If the values of the dependent variables have not changed, there’s no need to
    invoke the callback.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果依赖变量的值未更改，则无需调用回调函数。
- en: If the list of dependencies is an empty array, the callback is called only once,
    similarly to `componentDidMount()`.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果依赖项列表是空数组，则回调函数只会被调用一次，类似于 `componentDidMount()`。
- en: If the dependencies are omitted, the callback is invoked on every rerender
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果省略依赖项，则回调函数在每次重新渲染时都会被调用。
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Cleaning Up Side Effects
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清理副作用
- en: 'Now you know how to use hooks to accomplish what `componentDidMount()` has
    to offer in class components. But what about an equivalent to `componentWill​Un⁠mount()`?
    For this task, you use the return value from the callback function you pass to
    `useEffect()`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何使用钩子来完成类组件中 `componentDidMount()` 提供的功能。但是如何处理类似 `componentWill​Un⁠mount()`
    的等效操作呢？为此，您可以使用传递给 `useEffect()` 的回调函数的返回值：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let’s see a more complete example (*04.06.useEffect.html* in the repo):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个更完整的例子（*04.06.useEffect.html* 在存储库中）：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Clicking the button once renders a child component and clicking it again removes
    it. As you can see in [Figure 4-3](#FIG0403), the return value of `useEffect()`
    (which is a function) is invoked when the component is removed from the DOM.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 点击按钮一次会渲染一个子组件，再次点击则会将其移除。正如您在 [图 4-3](#FIG0403) 中所见，`useEffect()` 的返回值（一个函数）会在组件从
    DOM 中移除时被调用。
- en: '![rur2 0403](Images/rur2_0403.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![rur2 0403](Images/rur2_0403.png)'
- en: Figure 4-3\. Using `useEffect`
  id: totrans-111
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-3\. 使用 `useEffect`
- en: Note that the cleanup (a.k.a. *teardown*) function was called when the component
    is removed from the DOM because the dependency array is empty. If there were a
    value in the dependency array, the teardown function would be called whenever
    the dependency value changes.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当依赖数组为空时，清理（也称为 *teardown*）函数在组件从 DOM 中移除时被调用。如果依赖数组中有值，则每当依赖值发生变化时都会调用清理函数。
- en: Trouble-Free Lifecycles
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无麻烦的生命周期
- en: 'If you consider again the use case of setting up and clearing event listeners,
    it can be implemented like so:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果再次考虑设置和清除事件侦听器的用例，可以像这样实现：
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The pattern above solves the second problem with class-based lifecycle methods
    mentioned previously—the problem of spreading related tasks all around the component.
    Here you can see how using hooks allows you to have the handler function, its
    setup, and its removal, all in the same place.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 上述模式解决了以前提到的基于类的生命周期方法的第二个问题——即在组件周围分散相关任务的问题。在这里，您可以看到如何使用钩子允许您在同一个地方拥有处理函数、其设置和其移除。
- en: 'As for the the first problem (having unrelated tasks in the same place), this
    is solved by having multiple `useEffect` calls, each dedicated to a specific task.
    Similarly to how you can have separate pieces of state instead of one grab-bag
    object, you can also have separate `useEffect` calls, each addressing a separate
    concern, as opposed to a single class method that needs to take care of everything:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 至于第一个问题（在同一地方处理无关任务），可以通过多个 `useEffect` 调用来解决，每个调用专注于一个特定任务。类似于可以拥有单独的状态而不是一个杂包对象，您也可以拥有单独的
    `useEffect` 调用，每个调用专注于一个不同的关注点，而不是需要处理所有事情的单个类方法：
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: useLayoutEffect()
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`useLayoutEffect()`'
- en: To wrap up the discussion of `useEffect()` let’s consider another built-in hook
    called `useLayoutEffect()`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 总结 `useEffect()` 的讨论，让我们再考虑另一个名为 `useLayoutEffect()` 的内置钩子。
- en: Note
  id: totrans-121
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: There are just a few built-in hooks, so don’t worry about having to memorize
    a long list of new APIs.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 只有少数几个内置钩子，所以不必担心要记住一长串新的 API。
- en: '`useLayoutEffect()` works like `useEffect()`, the only difference being that
    it’s invoked before React is done painting all the DOM nodes of a render. In general,
    you should use `useEffect()` unless you need to measure something on the page
    (maybe dimensions of a rendered component or scrolling position after an update)
    and then rerender based on this information. When none of this is required, `useEffect()`
    is better as it’s asynchronous and also indicates to the reader of your code that
    DOM mutations are not relevant to your component.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`useLayoutEffect()` 的工作原理类似于 `useEffect()`，唯一的区别在于它在 React 完成渲染所有 DOM 节点之前调用。一般情况下，除非需要测量页面上的某些内容（比如渲染组件的尺寸或更新后的滚动位置），然后根据这些信息重新渲染，否则应该使用
    `useEffect()`。当这些都不需要时，`useEffect()` 更好，因为它是异步的，并且也告诉代码阅读者 DOM 变化对组件不重要。'
- en: Because `useLayoutEffect()` is called sooner, you can recalculate and rerender
    and the user sees only the last render. Otherwise, they see the initial render
    first, then the second render. Depending on how complicated the layout use, users
    may perceive a flicker between the two renders.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `useLayoutEffect()` 被更早调用，您可以重新计算和重新渲染，用户只会看到最后一次渲染。否则，他们会先看到初始渲染，然后是第二次渲染。根据布局的复杂程度，用户可能会在两次渲染之间感受到闪烁效果。
- en: The next example (*04.07.useLayoutEffect.html* in the repo) renders a long table
    with random cell widths (just to make it harder for the browser). Then the width
    of the table is set in an effect hook.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例（repo 中的 *04.07.useLayoutEffect.html*）渲染了一个具有随机单元格宽度的长表格（只是为了使浏览器更难处理）。然后，在效果钩子中设置表格的宽度。
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Depending on whether you trigger the `useEffect()` or `useLayoutEffect()` path,
    you may see a flicker as the table is being resized from its random value (around
    600 px) to the hardcoded 250 px (see [Figure 4-4](#FIG0404)).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 根据是否触发 `useEffect()` 或 `useLayoutEffect()` 路径，当表格从随机值（大约 600 像素）调整为硬编码的 250
    像素时，可能会看到闪烁效果（见[图 4-4](#FIG0404)）。
- en: '![rur2 0404](Images/rur2_0404.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![rur2 0404](Images/rur2_0404.png)'
- en: Figure 4-4\. Flickering rerender
  id: totrans-129
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-4\. 闪烁重新渲染的示意图
- en: Note that in both cases, you’re able to get the geometry of the table (e.g.,
    `table​.off⁠setWidth`), so if you need this only for information purposes and
    you’re not going to rerender, you’re better off with the asynchronous `useEffect()`.
    `useLayout​Ef⁠fect()` should be reserved for avoiding flicker in cases where you
    need to act (rerender) based on something you measure, for example, positioning
    a fancy tooltip component based on the size of the element it’s pointing to.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，无论哪种情况，您都可以获取表格的几何信息（例如 `table.offsetWidth`），因此如果仅出于信息目的需要此信息并且不打算重新渲染，则使用异步的
    `useEffect()` 会更好。`useLayoutEffect()` 应该保留用于避免闪烁，例如在需要基于测量的内容执行（重新渲染）时，例如根据所指向的元素大小定位一个花哨工具提示组件。
- en: A Custom Hook
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义钩子
- en: Let’s go back to `Excel` and see how to go about implementing the replay feature.
    In the case of class components, it was necessary to create a `logSetState()`
    and then replace all `this.setState()` calls with `this.logSetState()`. With function
    components you can replace all calls to the `useState()` hook with `useLoggedState()`.
    This is a bit more convenient since there are just a few calls (for every independent
    bit of state) and they are all at the top of the function.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到 `Excel`，看看如何实现回放功能。对于类组件，需要创建 `logSetState()` 并将所有 `this.setState()` 调用替换为
    `this.logSetState()`。对于函数组件，可以将所有 `useState()` 钩子调用替换为 `useLoggedState()`。这样做更加方便，因为调用次数较少（每个独立的状态位点）且都位于函数顶部。
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'There is no built-in `useLoggedState()` hook, but that’s OK. You can create
    your own *custom hooks*. Like the built-in hooks, a custom hook is just a function
    that starts with `use*()`. Here’s an example:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 没有内置的 `useLoggedState()` 钩子，但没关系。你可以创建自己的*自定义钩子*。像内置钩子一样，自定义钩子只是以 `use*()` 开头的函数。这里是一个例子：
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The signature of the hook can be anything you want. In this case, there’s an
    additional `isData` argument. Its purpose is to help differentiate data state
    versus non-data state. In the class component example from [Chapter 3](ch03.xhtml#ch3)
    all the state is a single object, but here several pieces of the state are present.
    In the replay feature, the main goal is to show the data changes and then show
    that all the supporting info (sorting, descending, etc.) is secondary. Since the
    replay is updated every second, it won’t be as fun to watch the supporting data
    change individually; the replay would be too slow. So let’s have a main log (`dataLog`
    array) and an auxiliary one (`auxLog` array). In addition, it is useful to include
    a flag indicating whether the state changes because of user interaction or (automatically)
    during replay:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 钩子的签名可以是任何你想要的。在这种情况下，有一个额外的 `isData` 参数。它的目的是帮助区分数据状态与非数据状态。在第 3 章的类组件示例中，所有状态都是一个单一对象，但这里存在多个状态片段。在回放功能中，主要目标是显示数据变化，然后显示所有辅助信息（排序、降序等）是次要的。由于每秒更新一次回放，逐个观察支持数据变化将不那么有趣；回放将会太慢。因此，我们有一个主要日志（`dataLog`
    数组）和一个辅助日志（`auxLog` 数组）。此外，包含一个标志指示状态是因用户交互（自动）还是在回放过程中变化，也是很有用的：
- en: '[PRE32]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The custom hook’s goal is not to interfere with the regular state updates,
    so it delegates this responsibility to the original `useState`. The goal is to
    log the state together with a reference to the function that knows how to update
    this state during replay. The function looks something like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义钩子的目标不是干预常规状态更新，因此将此责任委托给原始的 `useState`。目标是在回放期间记录状态，并提供一个知道如何在回放期间更新此状态的函数的引用。这个函数看起来像这样：
- en: '[PRE33]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The code above is using the default `useState`. But now you have the references
    to a piece of state and the means to update it. You need to log that. Let’s benefit
    from the `useEffect()` hook here:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码正在使用默认的 `useState`。但现在你有了一个状态片段的引用和更新它的方法。你需要记录下来。让我们在这里利用 `useEffect()`
    钩子的好处：
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This method ensures that the logging happens only when the value of `state`
    changes. The `useLoggedState()` function may be called a number of times during
    various rerenders, but you can ignore these calls unless they involve a change
    in an interesting piece of state.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法确保仅在 `state` 的值变化时才记录日志。`useLoggedState()` 函数可能在各种重新渲染过程中被多次调用，但除非涉及感兴趣的状态变化，否则可以忽略这些调用。
- en: 'In the callback of `useEffect()` you:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `useEffect()` 的回调函数中：
- en: Don’t do anything if the user is replaying.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户正在回放，则不执行任何操作。
- en: Log every change to the data state to `dataLog`.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将每个数据状态的变化记录到 `dataLog` 中。
- en: Log every change to supporting data to `auxLog`, indexed by the associated change
    in data.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将每个支持数据的变化记录到 `auxLog` 中，按关联的数据变化索引。
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Why do custom hooks exist? They help you isolate and neatly package a piece
    of logic that is used in a component and often shared between components. The
    custom `useLoggedState()` above can be dropped into any component that can benefit
    from logging its state. Additionally, custom hooks can call other hooks, which
    regular (non-hook and non-component) functions cannot.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么存在自定义钩子？它们帮助你隔离并整洁打包在组件中使用的逻辑片段，通常在组件之间共享。上面的自定义 `useLoggedState()` 可以嵌入到任何可以从记录其状态中受益的组件中。此外，自定义钩子可以调用其他钩子，而常规（非钩子和非组件）函数无法做到这一点。
- en: Wrapping up the Replay
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结回放
- en: Now that you have a custom hook that logs the changes to various bits of state,
    it’s time to plug in the replay feature.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了一个能够记录各种状态变化的自定义钩子，是时候接入回放功能了。
- en: 'The `replay()` function is not an exciting aspect of the React discussion,
    but it sets up an interval ID. You need that ID to clean up the interval in the
    event that `Excel` gets removed from the DOM while replaying. In the replay, the
    data changes are replayed every second, while the auxiliary ones are flushed together:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`replay()` 函数在 React 讨论中并不是一个激动人心的部分，但它设置了一个间隔 ID。当 `Excel` 在回放过程中从 DOM 中移除时，你需要这个
    ID 来清理间隔。在回放过程中，数据变化每秒钟重播一次，而辅助信息则一起刷新：'
- en: '[PRE36]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The final bit of plumbing is to set up an effects hook. After `Excel` renders,
    the hook is responsible for setting up listeners that monitor the particular.
    combination of keys to start the replay show. This is also the place to clean
    up after the component is destroyed.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点是设置一个效果挂钩。在`Excel`渲染后，挂钩负责设置监听器，监视特定组合的键来开始回放展示。这也是在组件销毁后进行清理的地方。
- en: '[PRE37]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: To see the code in its entirety, check out *04.08.fn.table-replay.html* in the
    book’s repo.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看完整的代码，请访问书籍存储库中的*04.08.fn.table-replay.html*。
- en: useReducer
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: useReducer
- en: Let’s wrap up the chapter with one more built-in hook called `useReducer()`.
    Using a reducer is an alternative to `useState()`. Instead of various parts of
    the component calling changing state, all changes can be handled in a single location.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个名为`useReducer()`的内置钩子结束本章。使用减速器是替代`useState()`的一种选择。不同部分的组件调用变更状态的方式，可以在单个位置处理所有更改。
- en: A reducer is just a JavaScript function that takes two inputs—the old state
    and an action—and returns the new state. Think of the action as something that
    has happened in the app, maybe a click, data fetch, or timeout. Something has
    happened and it requires a change. All three of the variables (new state, old
    state, action) can be of any type, though most commonly they are objects.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 减速器只是一个JavaScript函数，接受两个输入——旧状态和动作——并返回新状态。将动作视为应用程序中发生的事件，例如点击、数据获取或超时。某些变量（新状态、旧状态、动作）可以是任何类型，尽管它们通常是对象。
- en: Reducer Functions
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 减速器函数
- en: 'A reducer function in its simplest form looks like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 减速器函数在其最简单形式如下所示：
- en: '[PRE38]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Imagine that the reducer function is responsible for making sense of the reality
    when something happens in the world. The world is a `mess`, then an `event` happens.
    The function that should `makeSense()` of the world reconciles the mess with the
    new event and reduces all the complexity to a nice state or `order`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，当世界发生某事时，减速器函数负责理清现实。世界是一团`混乱`，然后发生了一个`事件`。应该`makeSense()`的函数调和了混乱和新事件，并将所有复杂性减少为一个良好的状态或`秩序`：
- en: '[PRE39]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Another analogy comes from the world of cooking. Some sauces and soups are called
    *reductions* too, produced by the process of *reduction* (thickening, intensifying
    the flavor). The initial state is a pot of water, then various actions (boiling,
    adding ingredients, stirring) alter the state of the contents of the pot with
    every action.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个类比来自烹饪世界。一些酱料和汤也被称为*还原物*，通过*还原*过程（浓缩，增强风味）产生。初始状态是一锅水，然后各种操作（沸腾，添加成分，搅拌）通过每个动作改变了锅内内容的状态。
- en: Actions
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动作
- en: 'The reducer function can take anything (a string, an object), but a common
    implementation is an `event` object with:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 减速器函数可以采取任何内容（字符串、对象），但常见的实现是具有`event`对象的形式：
- en: A `type` (e.g., `click` in the DOM world)
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`类型`（例如DOM世界中的`click`）
- en: Optionally, some `payload` of other information about the event
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选地，一些`payload`或关于事件的其他信息
- en: Actions are then “dispatched.” When the action is dispatched, the appropriate
    reducer function is called by React with the current state and your new event
    (action).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后“调度”动作。调度动作时，React将使用当前状态和您的新事件（动作）调用适当的减速器函数。
- en: 'With `useState` you have:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`useState`时：
- en: '[PRE40]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Which can be replaced with the reducer:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用减速器替换：
- en: '[PRE41]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `data` is still used the same way to render the component. But when something
    happens, instead of doing a bit of work followed by a call to `setData()`, you
    call the `dispatch()` function returned by `useReducer()`. From there the reducer
    takes over and returns the new version of `data`. There’s no other function to
    call to set the new state; the new `data` is used by React to rerender the component.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`data`仍然以相同方式用于渲染组件。但是当发生某事时，不再进行少量工作后调用`setData()`，而是调用`useReducer()`返回的`dispatch()`函数。从那里，减速器接管并返回新版本的`data`。没有其他函数调用来设置新状态；React使用新的`data`重新渲染组件。'
- en: '[Figure 4-5](#FIG0405) shows a diagram of this process.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-5](#FIG0405)展示了此过程的图表。'
- en: '![rur2 0405](Images/rur2_0405.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![rur2 0405](Images/rur2_0405.png)'
- en: Figure 4-5\. Component-dispatch-action-reducer flow
  id: totrans-177
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-5\. 组件-调度-动作-减速器流
- en: An Example Reducer
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个示例减速器
- en: Let’s see a quick, isolated example of using a reducer. Say you have a table
    of random data together with buttons that can either refresh the data or change
    the table’s background and foreground colors to random ones (as depicted in [Figure 4-6](#FIG0406)).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个快速、独立的使用reducer的例子。假设你有一个随机数据表，还有可以刷新数据或将表的背景和前景颜色更改为随机颜色的按钮（如图4-6所示）。
- en: 'Initially, there’s no data and black and white colors are used as defaults:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，没有数据，并且黑白色是默认值：
- en: '[PRE42]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The reducer is initialized at the top of the component `<RandomData>`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: reducer在组件`<RandomData>`的顶部初始化：
- en: '[PRE43]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here, we’re back to `state` being a grab-bag object of various state pieces
    (but that doesn’t need to be the case). The rest of the component is business-as-usual,
    rendering based on `state`, with one difference. Where before you’d have a button’s
    `onClick` handler be a function that updates the state, now all handlers just
    call `dispatch()`, sending information about the event:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`state`又回到了一个各种状态片段的抓包对象（但情况并非一定如此）。组件的其余部分按常规操作，根据`state`进行渲染，有一个区别。之前你可能会有一个按钮的`onClick`处理程序是一个更新状态的函数，现在所有处理程序只调用`dispatch()`，发送有关事件的信息：
- en: '[PRE44]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '![rur2 0406](Images/rur2_0406.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![rur2 0406](Images/rur2_0406.png)'
- en: Figure 4-6\. `<RandomData/>` component (*04.09.random-table-reducer.html*)
  id: totrans-187
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-6. `<RandomData/>`组件（*04.09.random-table-reducer.html*）
- en: Every dispatched event/action object has a `type` property, so the reducer function
    can identify what needs to be done. There may or may not be a `payload` specifying
    further details of the event.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 每个分派的事件/动作对象都有一个`type`属性，因此reducer函数可以确定需要执行什么操作。可能会有一个指定事件进一步细节的`payload`，也可能没有。
- en: 'Finally, the reducer. It has a number of `if`/`else` statements (or a `switch`,
    if that’s your preference) that check what type of event it was sent. Then the
    data is manipulated according to the action and a new version of the state is
    returned:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后是reducer。它有许多if/else语句（或者如果你喜欢，可以使用switch语句），用于检查发送的事件类型。然后根据操作来操作数据，并返回状态的新版本：
- en: '[PRE45]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Note how the old state is being cloned using the quick-and-dirty `clone()`
    you already know. With `useState()/setState()` this wasn’t strictly necessary
    in a lot of cases. You could often get by with modifying an existing variable
    and passing it to `setState()`. But here if you don’t clone and merely modify
    the same object in memory, React will see old and new state as pointing to the
    same object and will skip the render, thinking nothing has changed. You can try
    for yourself: remove the call to `clone()` and observe that the rerendering is
    not happening.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意如何使用你已经知道的快速脏克隆`clone()`来克隆旧状态。在使用`useState()/setState()`时，在许多情况下这并不是严格必要的。你通常可以通过修改现有变量并将其传递给`setState()`来解决问题。但是在这里，如果你不克隆，仅修改内存中的同一对象，React将看到旧状态和新状态指向同一个对象，并将跳过渲染，认为什么也没变。你可以自己试试：删除对`clone()`的调用，观察到重新渲染未发生。
- en: Unit Testing Reducers
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试Reducers
- en: 'Switching to `useReducer()` for state management makes it much easier to write
    unit tests. You don’t need to set up the component and its properties and state.
    You don’t need to get a browser involved or find another way to simulate click
    events. You don’t even need to get React involved at all. To test the state logic,
    all you need to do is pass both the old state and an action to the reducer function
    and check if the desired new state is returned. This is pure JavaScript: two objects
    in, one object out. The unit tests should not be much more complicated than testing
    the canonical example:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到`useReducer()`来进行状态管理，可以更轻松地编写单元测试。你不需要设置组件及其属性和状态。你不需要涉及浏览器或找到另一种模拟点击事件的方式。你甚至不需要完全依赖React。要测试状态逻辑，你只需将旧状态和一个动作传递给reducer函数，并检查是否返回了期望的新状态。这是纯JavaScript：输入两个对象，输出一个对象。单元测试不应比测试典型示例更复杂：
- en: '[PRE46]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'There’s a discussion on testing later in the book, but just to give you a taste,
    a sample test could look like so:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 书中稍后会讨论测试的问题，但为了让你尝试一下，一个示例测试可能是这样的：
- en: '[PRE47]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Excel Component with a Reducer
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有Reducer的Excel组件
- en: For one last example of using reducers, let’s see how you can switch from `useState()`
    to `useReducer()` in the `Excel` component.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个使用reducer的例子，让我们看看如何在`Excel`组件中从`useState()`切换到`useReducer()`。
- en: In the example from the previous section, the state managed by the reducer was
    again an object of unrelated data. It doesn’t have to be this way. You can have
    multiple reducers to separate your concerns. You can even mix and match `useState()`
    with `useReducer()`. Let’s try this with `Excel`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节的示例中，由reducer管理的状态再次是一组不相关的数据对象。不必这样做。您可以有多个reducer来分离您的关注点。甚至可以混合和匹配`useState()`和`useReducer()`。让我们尝试用`Excel`。
- en: 'Previously the `data` in the table was managed by `useState()`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以前表格中的`data`由`useState()`管理：
- en: '[PRE48]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Switching to `useReducer()` for managing `data` while leaving the rest untouched
    looks like the following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到使用`useReducer()`管理`data`，同时保持其余部分不变如下所示：
- en: '[PRE49]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Since `data` is the same, there’s no need to change anything in the rendering
    section. Changes are required only in the action handlers. For example, `filter()`
    is used to do the filtering and call `setData()`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`data`相同，渲染部分无需更改任何内容。只需在操作处理程序中进行更改。例如，使用`filter()`进行过滤并调用`setData()`：
- en: '[PRE50]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The rewritten version dispatches an action instead. The event has a `type`
    of “search” and some additional payload (what is the user searching for, and where?):'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 重写的版本改为分派动作。事件具有“search”类型和一些额外的有效载荷（用户搜索什么以及在哪里？）：
- en: '[PRE51]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Another example would be toggling the search fields:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是切换搜索字段：
- en: '[PRE52]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here you can see the mix of `setSearch()` and `dispatch()` to manage the state.
    The `!search` toggle is a flag for the UI to show or hide input boxes, while the
    `dispatch()` is for managing the data.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到`setSearch()`和`dispatch()`的混合使用来管理状态。`!search`切换是UI显示或隐藏输入框的标志，而`dispatch()`用于管理数据。
- en: 'Finally, let’s take a look at the the `reducer()` function. This is where all
    the data filtering and manipulation happens now. It’s again a series of `if`/`else`
    blocks, each handling a different action type:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看`reducer()`函数。这是现在发生所有数据过滤和操作的地方。它再次是一系列`if`/`else`块，每个块处理不同的操作类型：
- en: '[PRE53]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
