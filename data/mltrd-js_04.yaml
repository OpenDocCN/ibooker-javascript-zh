- en: Chapter 3\. Node.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章 Node.js
- en: Outside browsers, there’s only one JavaScript runtime of note, and that’s *Node.js*.^([1](ch03.xhtml#idm45995923445880))
    Although it started as a platform emphasizing single-threaded concurrency in servers
    with continuation-passing style callbacks, a lot of effort went into making it
    a general-purpose programming platform.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器之外，只有一个值得注意的 JavaScript 运行时，那就是 *Node.js*。^([1](ch03.xhtml#idm45995923445880))
    虽然它起初是一个强调单线程并发的平台，使用 continuation-passing style 回调在服务器中，但也投入了大量精力使其成为通用编程平台。
- en: Many tasks performed by Node.js programs don’t fit into its traditional use
    case of serving web requests or handling network connections. Instead, a lot of
    newer Node.js programs are command-line tools acting as build systems, or parts
    of them, for JavaScript. Such programs are typically heavy on I/O operations,
    just like servers are, but they also typically do a lot of data processing.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 许多由 Node.js 程序执行的任务不适合其传统用例，如提供 Web 请求或处理网络连接。相反，许多较新的 Node.js 程序是作为构建系统的命令行工具，或其部分，用于
    JavaScript。这些程序通常在 I/O 操作上很重，就像服务器一样，但它们也通常做大量的数据处理。
- en: For example, tools like [Babel](https://babeljs.io) and [TypeScript](https://typescriptlang.org)
    will transform your code from one language (or language version) to another. Tools
    like [Webpack](https://webpack.js.org), [Rollup](https://rollupjs.org), and [Parcel](https://parceljs.org)
    will bundle and minify your code for distribution to your web frontend or to other
    environments where load times are crucial, like serverless environments. In situations
    like these, while there’s a lot of filesystem I/O going on, there’s also a lot
    of data processing, which is generally done synchronously. These are the sorts
    of situations where parallelism is handy and might get the job done quicker.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，像[Babel](https://babeljs.io)和[TypeScript](https://typescriptlang.org)这样的工具将把您的代码从一种语言（或语言版本）转换为另一种。像[Webpack](https://webpack.js.org)、[Rollup](https://rollupjs.org)和[Parcel](https://parceljs.org)这样的工具将捆绑和缩小您的代码，以分发到您的
    Web 前端或其他负载时间至关重要的环境，如无服务器环境。在这些情况下，虽然会进行大量的文件系统 I/O，但也会进行大量的数据处理，通常是同步进行的。这些都是并行性非常方便且可能更快完成任务的情况。
- en: Parallelism can also be useful in the original Node.js use case, which is servers.
    Data processing may happen a lot, depending on your application. For example,
    *server side rendering (SSR)* involves a lot of string manipulation where the
    source data is already known. This is one of many examples where we might want
    to add parallelism to our solutions. [“When to Use”](ch08.xhtml#ch_benchmarks_sec_usage)
    examines a situation where parallelism improves template rendering time.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 并行性在 Node.js 的原始用例中也可能很有用，即服务器。数据处理可能会频繁发生，这取决于您的应用程序。例如，*服务器端渲染（SSR）*涉及大量的字符串操作，其中源数据已知。这是我们可能希望在解决方案中添加并行性的众多示例之一。[“何时使用”](ch08.xhtml#ch_benchmarks_sec_usage)探讨了并行性提高模板渲染时间的情况。
- en: Today, we have `worker_threads` for parallelizing our code. This wasn’t always
    the case, but that didn’t mean we were limited to single-threaded concurrency.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，我们拥有`worker_threads`用于并行化我们的代码。这并不总是这样，但这并不意味着我们局限于单线程并发。
- en: Before We Had Threads
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在拥有线程之前
- en: Prior to threads being available in Node.js, if you wanted to take advantage
    of CPU cores, you needed to use processes. As discussed in [Chapter 1](ch01.xhtml#ch_intro),
    we don’t get some of the benefits we’d get from threads if we use processes. That
    being said, if shared memory isn’t important (and in many cases it isn’t!) then
    processes are perfectly able to solve these kinds of problems for you.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node.js 中可用线程之前，如果想利用 CPU 核心，就需要使用进程。正如在[第一章](ch01.xhtml#ch_intro)中讨论的那样，如果使用进程，我们无法从线程中获得一些好处。话虽如此，如果共享内存不重要（在许多情况下确实如此！），那么进程完全能够解决这些问题。
- en: Consider [Figure 1-1](ch01.xhtml#fig_http_worker_threads_sequence) from [Chapter 1](ch01.xhtml#ch_intro).
    In that scenario, we have threads responding to HTTP requests sent to them from
    a main thread, which is listening on a port. While this concept is great for handling
    traffic from several CPU cores, we can also use processes to achieve a similar
    effect. It might look something like [Figure 3-1](#fig_http_processes_sequence).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 参考[第一章](ch01.xhtml#ch_intro)中的[图 1-1](ch01.xhtml#fig_http_worker_threads_sequence)。在这种情况下，我们有线程响应从主线程发送到它们的
    HTTP 请求，而主线程则监听端口。虽然这个概念对于处理来自几个 CPU 核心的流量很有用，但我们也可以使用进程来实现类似的效果。这可能看起来像[图 3-1](#fig_http_processes_sequence)。
- en: '![A web server system might offload work to processes on a round-robin basis.](Images/mtjs_0301.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![一个Web服务器系统可能会按循环轮询的方式将工作分配给进程。](Images/mtjs_0301.png)'
- en: Figure 3-1\. Processes as they might be used in an HTTP server
  id: totrans-10
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-1. 进程在HTTP服务器中的使用示意图
- en: Although we could do something like this using the `child_process` API in Node.js,
    we’re better off using `cluster`, which was purpose-built for this use case. This
    module’s purpose is to spread network traffic across several worker processes.
    Let’s go ahead and use it in a simple “Hello, World” example.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以使用Node.js中的`child_process` API来做类似的事情，但最好使用`cluster`，因为它专门为这种用例构建。这个模块的目的是将网络流量分散到几个工作进程中。让我们在一个简单的“Hello,
    World”示例中使用它。
- en: The code in [Example 3-1](#ex_nodejs_hello_world) is a standard HTTP server
    in Node.js. It simply responds to any request, regardless of path or method, with
    “Hello, World!” followed by a new line character.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 3-1](#ex_nodejs_hello_world)中的代码是Node.js中的标准HTTP服务器。它只是响应任何请求，无论路径或方法如何，都会返回“Hello,
    World!”后跟一个换行符。'
- en: Example 3-1\. A “Hello, World” server in Node.js
  id: totrans-13
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-1. Node.js中的“Hello, World”服务器
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, let’s add four processes with `cluster`. With the `cluster` module, the
    common approach is to use an `if` block to detect whether we’re in the main listening
    process or one of the worker processes. If we’re in the main process, then we
    have to do the work of spawning the worker processes. Otherwise, we just set up
    an ordinary web server as before in each of the workers. This should look something
    like [Example 3-2](#ex_nodejs_hello_world_cluster).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`cluster`添加四个进程。使用`cluster`模块时，常见的方法是使用`if`块来检测我们是在主监听进程还是工作进程之一。如果我们在主进程中，那么我们必须执行生成工作进程的工作。否则，在每个工作进程中，我们只需像以前一样设置普通的Web服务器。这应该看起来像是[示例
    3-2](#ex_nodejs_hello_world_cluster)。
- en: Example 3-2\. A “Hello, World” server in Node.js using `cluster`
  id: totrans-16
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-2. 使用`cluster`的Node.js中的“Hello, World”服务器
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](Images/1.png)](#co_node_js_CO1-1)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_node_js_CO1-1)'
- en: Require the `cluster` module.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 需要引入`cluster`模块。
- en: '[![2](Images/2.png)](#co_node_js_CO1-2)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_node_js_CO1-2)'
- en: Change code paths depending on whether we’re in the primary process.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们是否在主进程中，更改代码路径。
- en: '[![3](Images/3.png)](#co_node_js_CO1-3)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_node_js_CO1-3)'
- en: In the primary process, create four worker processes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在主进程中，创建四个工作进程。
- en: '[![4](Images/4.png)](#co_node_js_CO1-4)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_node_js_CO1-4)'
- en: In the worker processes, create a web server and listen, like in [Example 3-1](#ex_nodejs_hello_world).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在工作进程中，创建一个Web服务器并进行监听，就像[示例 3-1](#ex_nodejs_hello_world)中一样。
- en: You may notice that we’re creating web servers that listen on the same port
    in four difference processes. It seems like a mistake. After all, if we try to
    bind a server to a port that’s already being used, we usually get an error. Don’t
    worry! We’re not actually listening on the same port four times. It turns out
    Node.js does some magic for us in `cluster`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能注意到我们在四个不同的进程中创建监听同一端口的Web服务器。这看起来像是一个错误。毕竟，如果我们尝试绑定到已经使用的端口，通常会收到错误。不要担心！我们实际上并没有四次监听同一个端口。事实上，Node.js在`cluster`中为我们做了一些魔法。
- en: When worker processes are set up in a cluster, any call to `listen()` will actually
    cause Node.js to listen on the primary process rather than on the worker. Then,
    once a connection is received in the primary process, it’s handed off to a worker
    process via IPC. On most systems, this happens on a round-robin basis. This somewhat
    convoluted system is how each worker can *appear* to be listening on the same
    port, when in fact it’s just the primary process listening on that port and passing
    connections off to all the workers.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当工作进程在集群中设置时，对`listen()`的任何调用实际上会导致Node.js在主进程上而不是在工作进程上进行监听。然后，一旦主进程接收到连接，它会通过IPC传递给工作进程。在大多数系统上，这是按照循环轮询的方式进行的。这种有些复杂的系统是每个工作进程可以*看起来*在同一个端口上监听，但实际上只是主进程在那个端口上监听，并将连接传递给所有工作进程。
- en: Note
  id: totrans-28
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Historically, the `isPrimary` property on `cluster` used to be called `isMaster`,
    and for compatibility reasons, it’s still there as an alias at time of writing.
    The change was introduced in Node.js v16.0.0.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，`cluster`中的`isPrimary`属性曾被称为`isMaster`，出于兼容性的考虑，在撰写本文时它仍然作为别名存在。这个更改是在Node.js
    v16.0.0中引入的。
- en: This change was made in an effort to reduce the amount of potentially harmful
    language in Node.js. The project aims to be a welcoming community, and words with
    a given usage that are rooted in a history of slavery are antithetical to that
    goal.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这一变更旨在减少 Node.js 中潜在有害语言的使用。该项目旨在建立一个友好的社区，具有一定历史背景的特定用词与这一目标背道而驰。
- en: Processes incur some extra overhead that threads don’t, and we also don’t get
    shared memory, which helps with faster transfer of data. For that, we need the
    `worker_threads` module.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 进程比线程多一些额外的开销，并且我们也没有共享内存，这有助于更快地传输数据。为此，我们需要 `worker_threads` 模块。
- en: The worker_threads Module
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: worker_threads 模块
- en: Node.js’s support for threads is in a built-in module called `worker_threads`.
    It provides an interface to threads that mimics a lot of what you’d find in web
    browsers for web workers. Since Node.js is not a web browser, not all the APIs
    are the same, and the environment inside these worker threads isn’t the same as
    what you’d find inside web workers.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 对线程的支持是通过内置模块 `worker_threads` 实现的。它提供了一种接口，模仿了在 Web 浏览器中为 Web Worker
    找到的许多内容。由于 Node.js 不是一个 Web 浏览器，因此并非所有的 API 都相同，而这些工作线程内部的环境也不同于 Web Worker 内部的环境。
- en: 'Instead, inside Node.js worker threads you’ll find the usual Node.js API available
    via `require`, or `import` if you’re using ESM. There are a few differences in
    the API compared to the main thread though:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node.js 工作线程内部，您会发现通过 `require` 可用的常规 Node.js API，或者如果您使用 ESM，则通过 `import`。不过，与主线程相比，API
    中存在一些差异：
- en: You can’t exit the program with `process.exit()`. Instead this will just exit
    the thread.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能用 `process.exit()` 退出程序。相反，这将仅退出线程。
- en: You can’t change working directories with `process.chdir()`. In fact, this function
    is not even available.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能用 `process.chdir()` 改变工作目录。事实上，这个函数甚至不可用。
- en: You can’t handle signals with `process.on()`.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能用 `process.on()` 处理信号。
- en: Another important thing to note is that the `libuv` worker pool is shared across
    worker threads. Recall [“Hidden Threads”](ch01.xhtml#sec_hidden_threads), where
    it was noted that the `libuv` thread pool consists of a default of four threads
    to create nonblocking interfaces to low-level blocking APIs. If you’re finding
    yourself bound by that thread pool’s size (due to, for example, a lot of filesystem
    I/O), you’ll find that adding more threads via `worker_threads` won’t lighten
    the load. Instead, apart from considering various caching solutions and other
    optimizations, consider increasing your `UV_THREADPOOL_SIZE`. Likewise, you might
    find that you have little choice but to increase this when adding JavaScript threads
    via the `worker_threads` module, due to their usage of the `libuv` thread pool.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件重要的事情需要注意，即 `libuv` 工作线程池在工作线程之间是共享的。回顾“隐藏线程”一节，可以注意到 `libuv` 线程池由默认的四个线程组成，用于创建对低级阻塞
    API 的非阻塞接口。如果发现自己受制于该线程池的大小（例如，大量的文件系统 I/O），您会发现通过 `worker_threads` 添加更多线程并不会减轻负载。相反，除了考虑各种缓存解决方案和其他优化之外，考虑增加
    `UV_THREADPOOL_SIZE`。同样，当通过 `worker_threads` 模块添加 JavaScript 线程时，您可能发现没有其他选择，只能增加这一大小，因为它们使用
    `libuv` 线程池。
- en: There are other caveats too, so you’re encouraged to have a look at the [Node.js
    documentation](https://oreil.ly/CYxtz) for a full list of differences for your
    particular version of Node.js.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他注意事项，请参阅[Node.js 文档](https://oreil.ly/CYxtz)以获取特定版本 Node.js 的完整差异列表。
- en: You can create a new worker thread by using the `Worker` constructor, like in
    [Example 3-3](#ex_nodejs_new_worker).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用 `Worker` 构造函数来创建一个新的工作线程，就像在 [示例 3-3](#ex_nodejs_new_worker) 中一样。
- en: Example 3-3\. Spawning a new worker thread in Node.js
  id: totrans-41
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-3\. 在 Node.js 中生成一个新的工作线程
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[![1](Images/1.png)](#co_node_js_CO2-1)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_node_js_CO2-1)'
- en: The filename here is the entrypoint file that we want to run inside the worker
    thread. This is similar to the entrypoint in the main file that we’d specify as
    an argument to `node` on the command line.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的文件名是我们希望在工作线程内运行的入口文件。这类似于在主文件中指定作为 `node` 命令行参数的入口点。
- en: workerData
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: workerData
- en: It’s not sufficient to just be able to create a worker thread. We need to interact
    with it! The `Worker` constructor takes a second argument, an `options` object,
    that among other things allows us to specify a set of data to be passed immediately
    to the worker thread. The `options` object property is called `workerData`, and
    its contents will be copied into the worker thread via the means described in
    the [Appendix](app01.xhtml#app_sca). Inside the thread, we can access the cloned
    data via the `workerData` property of the `worker_threads` module. You can see
    how this works in [Example 3-4](#ex_nodejs_worker_data).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅创建工作线程是不够的，我们需要与其进行交互！`Worker` 构造函数接受第二个参数，即一个 `options` 对象，其中允许我们立即指定一组数据传递给工作线程。`options`
    对象的属性称为 `workerData`，其内容将通过[附录](app01.xhtml#app_sca)中描述的方式复制到工作线程中。在线程内部，我们可以通过
    `worker_threads` 模块的 `workerData` 属性访问克隆的数据。你可以在[示例3-4](#ex_nodejs_worker_data)中看到其工作原理。
- en: Example 3-4\. Passing data to a worker thread via `workerData`
  id: totrans-47
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例3-4\. 通过 `workerData` 向工作线程传递数据
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[![1](Images/1.png)](#co_node_js_CO3-1)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_node_js_CO3-1)'
- en: Rather than using a separate file for the worker thread, we can use the current
    file with `__filename` and switch the behavior based on `isMainThread`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 不必为工作线程使用单独的文件，我们可以使用当前文件的 `__filename` 并根据 `isMainThread` 切换行为。
- en: It’s important to note that the properties of the `workerData` object are *cloned*
    rather than shared between threads. Unlike in C, shared memory in JavaScript threads
    does not mean all the variables are visible. This means any changes you make in
    that object will not be visible in the other thread. They are separate objects.
    That being said, you can have memory that’s shared between threads via `SharedArrayBuffer`.
    These can be shared via `workerData` or by being sent through a `MessagePort`,
    which is covered in the next section. Additionally, `SharedArrayBuffer` is covered
    in depth in [Chapter 4](ch04.xhtml#ch_shared_mem).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，`workerData` 对象的属性是*克隆*而不是在线程之间共享的。与C语言不同，在JavaScript线程中的共享内存并不意味着所有变量都是可见的。这意味着你对该对象所做的任何更改在另一个线程中是不可见的。它们是独立的对象。话虽如此，你可以通过
    `SharedArrayBuffer` 实现线程之间的共享内存。这些可以通过 `workerData` 或通过 `MessagePort` 发送，下一节将介绍这部分内容。此外，`SharedArrayBuffer`
    在[第4章](ch04.xhtml#ch_shared_mem)中有详细介绍。
- en: MessagePort
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MessagePort
- en: A `MessagePort` is one end of a two-way data stream. By default, one is provided
    to every worker thread to provide a communication channel to and from the main
    thread. It’s available in the worker thread as the `parentPort` property of the
    `worker_threads` module.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessagePort` 是双向数据流的一端。默认情况下，每个工作线程都提供一个 `MessagePort`，用于与主线程之间的通信通道。在工作线程中，它作为
    `worker_threads` 模块的 `parentPort` 属性而可用。'
- en: To send a message via the port, the `postMesage()` method is called on it. The
    first argument is any object that can be passed, as described in the [Appendix](app01.xhtml#app_sca),
    which will end up being the message data being passed to the other end of the
    port. When a message is received on the port, the `message` event is fired, with
    the message data being the first argument to the event handler function. In the
    main thread, the event and the `postMessage()` method are on the worker instance
    itself, rather than having to get them from a `MessagePort` instance. [Example 3-5](#ex_nodejs_message_port)
    shows a simple example where messages sent to the main thread are echoed back
    to a worker thread.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过端口发送消息，需要调用 `postMessage()` 方法。第一个参数可以是任何可以传递的对象，如[附录](app01.xhtml#app_sca)所述，它最终将成为传递到端口另一端的消息数据。当在端口上接收到消息时，将触发
    `message` 事件，消息数据将作为事件处理函数的第一个参数。在主线程中，事件和 `postMessage()` 方法都在工作实例本身上，而不是必须从
    `MessagePort` 实例中获取。[示例3-5](#ex_nodejs_message_port)展示了一个简单的例子，其中将消息发送到主线程并被回送到工作线程。
- en: Example 3-5\. Bidirectional communication via the default MessagePorts
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例3-5\. 通过默认的 `MessagePort` 进行双向通信
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can also create a pair of `MessagePort` instances connected to each other
    via the `MessageChannel` constructor. You can then pass one of the ports via an
    existing message port (like the default one) or via `workerData`. You might want
    to do this in situations where neither of two threads that need to communicate
    are the main thread, or even just for organizational purposes. [Example 3-6](#ex_nodejs_message_channel)
    is the same as the previous example, except using ports created via `MessageChannel`
    and passed via `workerData`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以创建一对通过 `MessageChannel` 构造函数连接的 `MessagePort` 实例。然后可以通过现有的消息端口（例如默认的消息端口）或通过
    `workerData` 传递其中一个端口。在两个需要通信的线程都不是主线程，或者仅仅是为了组织目的时，您可能会这样做。[示例 3-6](#ex_nodejs_message_channel)
    与前一个示例相同，只是使用了通过 `MessageChannel` 创建并通过 `workerData` 传递的端口。
- en: Example 3-6\. Bidirectional communication via `MessagePort` created with `MessageChannel`
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-6\. 通过 `MessageChannel` 创建的双向通信的 `MessagePort`
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You’ll notice we used the `transferList` option when instantiating the `Worker`.
    This is a way of transferring ownership of objects from one thread to another.
    This is required when sending any `MessagePort`, `ArrayBuffer`, or `FileHandle`
    objects via `workerData` or `postMessage`. Once these objects are transferred,
    they can no longer be used on the sending side.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们在实例化 `Worker` 时使用了 `transferList` 选项。这是将对象从一个线程传递到另一个线程的一种方式。当通过 `workerData`
    或 `postMessage` 发送任何 `MessagePort`、`ArrayBuffer` 或 `FileHandle` 对象时，这是必需的。一旦这些对象被传输，它们就不能在发送方使用了。
- en: Tip
  id: totrans-61
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: In more recent versions of Node.js, Web Hypertext Application Technology Working
    Group (WHATWG) `ReadableStream` and `WritableStream` are available. You can learn
    more about them in the [Node.js documentation](https://oreil.ly/TRJf0) and in
    use by some APIs. They can be transferred via `transferList` over `MessagePorts`
    to enable another way of communicating across threads. Under the hood, these are
    implemented using a `MessagePort` to send data across.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node.js 的更新版本中，Web Hypertext Application Technology Working Group (WHATWG)
    的 `ReadableStream` 和 `WritableStream` 可用。您可以在 [Node.js 文档](https://oreil.ly/TRJf0)
    中了解更多信息，并在某些 API 中使用它们。它们可以通过 `MessagePort` 上的 `transferList` 被转移，以启用跨线程的另一种通信方式。在底层，这些是使用
    `MessagePort` 实现的，用于跨线程发送数据。
- en: 'Happycoin: Revisited'
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Happycoin：重访
- en: 'Now that we’ve seen the basics of spawning threads in Node.js and having them
    communicate with each other, we have enough to rebuild our example from [“Threads
    in C: Get Rich with Happycoin”](ch01.xhtml#ch_intro_sec_happycoin) in Node.js.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了在 Node.js 中生成线程并使它们互相通信的基础知识，我们有足够的内容来在 Node.js 中重建我们的示例，来自于 [“在 C
    语言中使用线程：用 Happycoin 致富”](ch01.xhtml#ch_intro_sec_happycoin)。
- en: 'Recall that Happycoin is our imaginary cryptocurrency, with a completely ridiculous
    proof-of-work algorithm that goes as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，Happycoin 是我们想象中的加密货币，其完全荒谬的工作证明算法如下：
- en: Generate a random unsigned 64-bit integer.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成一个随机的无符号 64 位整数。
- en: Determine whether or not the integer is happy.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定整数是否为快乐数。
- en: If it’s not happy, it’s not a Happycoin.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果不快乐，那就不是 Happycoin。
- en: If it’s not divisible by 10,000, it’s not a Happycoin.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果不能被 10,000 整除，那就不是 Happycoin。
- en: Otherwise, it’s a Happycoin.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，它就是一个 Happycoin。
- en: Much like we did in C, we’ll make a single-threaded version first, and then
    adapt the code to run on multiple threads.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在 C 语言中做的那样，我们首先创建一个单线程版本，然后再将代码适配为多线程运行。
- en: With Only the Main Thread
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仅使用主线程
- en: Let’s start with generating random numbers. First, let’s create a file called
    *happycoin.js*, in a directory called *ch3-happycoin/*. Fill it with the contents
    of [Example 3-7](#ex_happycoin_js_1).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从生成随机数开始。首先，创建一个名为 *happycoin.js* 的文件，在名为 *ch3-happycoin/* 的目录中。将其填充为 [示例 3-7](#ex_happycoin_js_1)
    的内容。
- en: Example 3-7\. *ch3-happycoin/happycoin.js*
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-7\. *ch3-happycoin/happycoin.js*
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: They `crypto` module in Node.js gives us some handy functions for getting cryptographically
    secure random numbers. We’ll definitely want this since we’re building a cryptocurrency
    after all! Luckily, it’s less of an ordeal than it is in C.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 中的 `crypto` 模块为我们提供了一些便捷的函数，用于获取加密安全的随机数。毕竟我们正在构建一个加密货币，这些函数对我们来说非常重要！幸运的是，在
    Node.js 中这比在 C 语言中要简单。
- en: The `randomFillSync` function fills a given `TypedArray` with random data. Since
    we’re looking for only a single 64-bit unsigned integer, we can use a `BigUint64Array`.
    This particular `TypedArray`, along with its cousin `BigInt64Array`, are recent
    additions to JavaScript that were made possible by the new `bigint` type, which
    stores arbitrarily large integers. Returning the first (and only) element of this
    array after we’ve filled it with random data gives us the random 64-bit unsigned
    integer that we’re looking for.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`randomFillSync` 函数会用随机数据填充给定的 `TypedArray`。因为我们只需要一个 64 位无符号整数，我们可以使用 `BigUint64Array`。这个特定的
    `TypedArray` 和它的兄弟 `BigInt64Array`，是 JavaScript 的最新补充，依赖于新的 `bigint` 类型，用于存储任意大的整数。在用随机数据填充完毕后，返回这个数组的第一个（也是唯一的）元素，即得到了我们要找的随机
    64 位无符号整数。'
- en: Now let’s add our happy number calculation. Add the contents of [Example 3-8](#ex_happycoin_js_2)
    to your file.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加我们的 Happycoin 计算。将 [示例 3-8](#ex_happycoin_js_2) 的内容添加到您的文件中。
- en: Example 3-8\. *ch3-happycoin/happycoin.js*
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-8\. *ch3-happycoin/happycoin.js*
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'These three functions, `sumDigitsSquared`, `isHappy`, and `isHappycoin`, are
    direct translations from their C counterparts in [“Threads in C: Get Rich with
    Happycoin”](ch01.xhtml#ch_intro_sec_happycoin). One thing you might notice if
    you’re not familiar with `bigint` is the `n` suffix on all the number literals
    in this code. This suffix tells JavaScript that these numbers are to be treated
    as `bigint` values, rather than values of type `number`. This is important because,
    while both types support mathematical operators like `+`, `-`, `**`, and so on,
    they cannot interoperate without doing an explicit conversion. For example, `1
    + 1n` would be invalid because it’s an attempt to add the `number` 1 to the `bigint`
    1.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个函数，`sumDigitsSquared`、`isHappy` 和 `isHappycoin`，是直接从其 C 语言对应物翻译而来，见于 [“C
    语言中的线程：用 Happycoin 致富”](ch01.xhtml#ch_intro_sec_happycoin)。如果你对 `bigint` 不熟悉，你可能会注意到代码中所有数字文字都带有
    `n` 后缀。这个后缀告诉 JavaScript 这些数字应该被视为 `bigint` 值，而不是 `number` 类型的值。这一点很重要，因为虽然这两种类型都支持像
    `+`、`-`、`**` 等数学运算符，但它们不能互操作，除非进行显式转换。例如，`1 + 1n` 是无效的，因为它试图将 `number` 1 和 `bigint`
    1 相加。
- en: Let’s finish off the file by implementing our Happycoin mining loop and outputting
    the count of found Happycoins. Add [Example 3-9](#ex_happycoin_js_3) to your file.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们通过实现我们的 Happycoin 挖掘循环并输出找到的 Happycoin 数量来完成文件。将 [示例 3-9](#ex_happycoin_js_3)
    添加到您的文件中。
- en: Example 3-9\. *ch3-happycoin/happycoin.js*
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-9\. *ch3-happycoin/happycoin.js*
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The code here is very similar to what we did in C. We loop 10,000,000 times,
    getting a random number and checking if it’s a Happycoin. If it is, we print it
    out. Note that we’re not using `console.log()` here because we don’t want to insert
    a newline character after each number found. Instead we want spaces, so we’re
    writing to the output stream directly. When we output the count after the loop,
    we need an additional newline character at the beginning of the output to separate
    it from the numbers above.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的代码与我们在 C 语言中做的非常相似。我们循环 10,000,000 次，获取一个随机数并检查它是否是 Happycoin。如果是，我们将其输出。请注意，这里我们不使用
    `console.log()`，因为我们不希望在每个找到的数字后插入换行符。相反，我们想要空格，所以我们直接写入输出流。在循环结束后输出计数时，我们需要在输出的开头加一个额外的换行符，以便与上面的数字分隔开来。
- en: 'To run this program, use the following command in your *ch3-happycoin* directory:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此程序，请在您的 *ch3-happycoin* 目录中使用以下命令：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Your output should be exactly the same as it was in C. That is, it should look
    something like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果应该与 C 语言示例完全一致。也就是说，输出应该看起来像这样：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This takes quite a bit longer than the C example. On a run-of-the-mill machine,
    this took about 1 minute and 45 seconds with Node.js v16.0.0.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这比 C 语言示例要慢得多。在一台普通机器上，使用 Node.js v16.0.0 大约需要 1 分钟 45 秒。
- en: There are a variety of reasons why this takes so much longer. When building
    applications and optimizing for performance, it’s important to figure out what
    the sources of performance overhead are. Yes, in general, JavaScript is often
    “slower than C,” but this enormous difference can’t be explained by that alone.
    Yes, we’ll get better performance in the next section when we split this into
    multiple threads of work, but as you’ll see, it’s not nearly enough to make this
    implementation compelling when compared to the C example.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多原因导致这个过程耗时如此之长。在构建应用程序并优化性能时，重要的是找出性能开销的来源。是的，一般来说，JavaScript 往往比 C 语言“慢”，但这种巨大的差距不仅仅可以用这个来解释。是的，在下一节中，当我们将其拆分为多个工作线程时，性能会得到改善，但正如你所看到的，与
    C 语言示例相比，这种实现远非引人注目。
- en: And on that note, let’s see what this looks like when we use `worker_threads`
    to split out the load.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这一点，让我们看看当我们使用 `worker_threads` 来分担负载时会发生什么。
- en: With Four Worker Threads
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用四个工作线程
- en: To add worker threads, we will start from the code we had. Copy the contents
    of *happycoin.js* to *happycoin-threads.js*. Then insert the contents of [Example 3-10](#ex_happycoin_threads_js_1)
    at the very beginning of the file, before the existing content.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加工作线程，我们将从原有的代码开始。将 *happycoin.js* 的内容复制到 *happycoin-threads.js*。然后在文件的开头插入
    [示例 3-10](#ex_happycoin_threads_js_1) 的内容，放在现有内容之前。
- en: Example 3-10\. *ch3-happycoin/happycoin-threads.js*
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-10\. *ch3-happycoin/happycoin-threads.js*
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We’ll need these parts of the `worker_threads` module, so we `require` them
    at the beginning. Now, replace everything from `let count = 0;` to the end of
    the file with [Example 3-11](#ex_happycoin_threads_js_2).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要 `worker_threads` 模块的这些部分，所以我们在开头进行 `require`。现在，将从 `let count = 0;` 到文件末尾的所有内容替换为
    [示例 3-11](#ex_happycoin_threads_js_2)。
- en: Example 3-11\. *ch3-happycoin/happycoin-threads.js*
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-11\. *ch3-happycoin/happycoin-threads.js*
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We’re splitting behavior here with an `if` block. If we’re on the main thread,
    we start four worker threads using the current file. Remember, `__filename` is
    a string containing the path and name of the current file. We then add a message
    handler for that worker. In the message handler, if the message is simply `done`,
    then the worker has completed its work, and if all other workers are done, we’ll
    output the count. If the message is a number, or more correctly, a `bigint`, then
    we assume it’s a Happycoin, and we’ll print it out and add it to the count like
    we did in the single-threaded example.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里通过一个 `if` 块来分割行为。如果我们在主线程上，我们使用当前文件启动四个工作线程。请记住，`__filename` 是一个包含当前文件路径和名称的字符串。然后我们为该工作线程添加一个消息处理程序。在消息处理程序中，如果消息仅为
    `done`，则表示工作线程已完成其工作；如果所有其他工作线程都完成了，我们将输出计数。如果消息是一个数字，或者更确切地说是一个 `bigint`，则假定它是一个
    Happycoin，并将其打印出来并添加到计数中，就像在单线程示例中所做的那样。
- en: On the `else` side of the `if` block, we’re running in one of the worker threads.
    In here, we’ll do the same sort of loop as we did in the single-threaded example,
    except we’re only looping 1/4 of the number of times we did before, since we’re
    doing the same work across four threads. Also, rather than writing directly to
    the output stream, we’re sending found Happycoins back to the main thread via
    the `MessagePort` given to us, called `parentPort`. We’ve already set up the handler
    on the main thread for this. When the loop exits, we send a `done` on the `parentPort`
    to indicate to the main thread that we won’t be finding any more Happycoins on
    this thread.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `if` 块的 `else` 部分，我们在其中一个工作线程中运行。在这里，我们将执行与单线程示例中相同类型的循环，但是我们只循环之前的 1/4 次，因为我们正在四个线程间共享同样的工作。此外，我们不直接向输出流写入，而是通过给予我们的
    `parentPort` 发送找到的 Happycoins 返回主线程。我们已经为此在主线程上设置了处理程序。当循环退出时，我们在 `parentPort`
    上发送 `done`，以指示主线程在此线程上将不再发现任何更多的 Happycoins。
- en: We could have simply printed the Happycoins to the output immediately, but just
    like with the C example, we don’t want the different threads to clobber each other
    in the output, so we need to *synchronize*. Chapters [4](ch04.xhtml#ch_shared_mem)
    and [5](ch05.xhtml#ch_adv_shared_mem) go over more advanced techniques for synchronization,
    but for now it’s enough to just send the data back to the main thread through
    the `parentPort` and let the main thread handle output.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以立即将 Happycoins 打印到输出中，但与 C 示例一样，我们不希望不同的线程在输出中互相干扰，因此我们需要*同步*。章节 [4](ch04.xhtml#ch_shared_mem)
    和 [5](ch05.xhtml#ch_adv_shared_mem) 讨论了更高级的同步技术，但目前只需将数据通过 `parentPort` 发送回主线程，让主线程处理输出就足够了。
- en: 'Now that we’re done adding threads to this example, you can run it with the
    following command in your *ch3-happycoin* directory:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了线程到这个例子中，您可以在您的 *ch3-happycoin* 目录下使用以下命令运行它：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You should see output that looks something like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似以下的输出：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Like with the C example, this code runs quite a bit faster. In a test on the
    same computer and Node.js version as the single-threaded example, it ran in about
    33 seconds. This is a huge improvement over the single-threaded example, so another
    big win for threads!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 C 示例一样，这段代码运行速度相当快。在与单线程示例相同的计算机和 Node.js 版本上进行的测试中，运行时间约为 33 秒。这比单线程示例有了显著改进，线程再次大获成功！
- en: Note
  id: totrans-108
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This is not the only way to split this kind of problem up for thread-based computation.
    For example, other synchronization techniques could be used to avoid passing data
    between threads, or the messages could be batched. Always be sure to test and
    compare to find out whether threads are an ideal solution and which thread techniques
    are most applicable to your problem, and the most efficient.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是将这种类型的问题拆分为基于线程的计算的唯一方法。例如，可以使用其他同步技术来避免在线程之间传递数据，或者可以对消息进行批处理。一定要进行测试和比较，以确定线程是否是理想的解决方案，以及哪些线程技术最适合您的问题，以及最有效的方法。
- en: Worker Pools with Piscina
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Piscina的工作池
- en: Many types of workloads will naturally lend themselves to using threads. In
    Node.js, most workloads involve processing an HTTP request. If within that code
    you find yourself doing a lot of math or synchronous data processing, it may make
    sense to offload that work to one or more threads. These types of operations involve
    submitting a single task to a thread and waiting for a result from it. In much
    the same way a threaded web server often works, it makes sense to maintain a pool
    of workers that can be sent various tasks from the main thread.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 许多类型的工作负载自然倾向于使用线程。在Node.js中，大多数工作负载涉及处理HTTP请求。如果在该代码中发现自己正在进行大量的数学或同步数据处理，将这些工作分配给一个或多个线程可能是有意义的。这些类型的操作涉及将单个任务提交给一个线程，并等待其结果。与多线程Web服务器工作方式类似，维护一个可以从主线程发送各种任务的工作线程池是有道理的。
- en: This section only takes a shallow look at thread pools, adapting the familiar
    Happycoins application and abstracting the pooling mechanism using a package.
    [“Thread Pool”](ch06.xhtml#ch_patterns_sec_threadpool) covers thread pools extensively,
    building out an implementation from scratch.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 本节仅对线程池进行浅显的讨论，使用熟悉的Happycoins应用程序，并通过一个包抽象出池化机制。[“线程池”](ch06.xhtml#ch_patterns_sec_threadpool)广泛涵盖了线程池的内容，并从头开始实现一个实现。
- en: Note
  id: totrans-113
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The concept of pooled resources isn’t unique to threads. For example, web browsers
    typically create pools of socket connections to web servers so that they can multiplex
    all the various HTTP requests required to render a web page across those connections.
    Database client libraries often do a similar thing with sockets connected to the
    database server.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 池化资源的概念并不局限于线程。例如，Web浏览器通常会创建到Web服务器的套接字连接池，以便可以通过这些连接复用渲染网页所需的各种HTTP请求。数据库客户端库通常也会对连接到数据库服务器的套接字执行类似操作。
- en: There’s a handy module available for Node.js called [*generic-pool*](https://oreil.ly/2a6ua),
    which is a helper module for dealing with arbitrary pooled resources. These resources
    could be anything, like database connections, other sockets, local caches, threads,
    or pretty much anything else that might require having multiple instances of something
    but only accessing one at a time, without caring which one it is.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js中有一个方便的模块称为[*generic-pool*](https://oreil.ly/2a6ua)，它是一个处理任意池化资源的辅助模块。这些资源可以是任何东西，比如数据库连接、其他套接字、本地缓存、线程或几乎任何需要多个实例但一次只访问一个实例的东西。
- en: For the use case of discrete tasks sent to a pool of worker threads, we have
    the [*piscina*](https://oreil.ly/0p8zi) module at our disposal. This module encapsulates
    the work of setting up a bunch of worker threads and allocating tasks to them.
    The name of the module comes from the Italian word for “pool.”
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于将离散任务发送到一组工作线程的用例，我们可以利用[*piscina*](https://oreil.ly/0p8zi)模块。该模块封装了设置一堆工作线程并将任务分配给它们的工作。该模块的名称源自意大利语中“pool”的词。
- en: The basic usage is straightforward. You create an instance of the `Piscina`
    class, passing in a `filename`, which will be used in the worker thread. Behind
    the scenes, a pool of worker threads is created, and a queue is set up to handle
    incoming tasks. You can enqueue a task by calling `.run()`, passing in a value
    containing all the data necessary to complete this task, and noting that the values
    will be cloned as they would be with `postMessage()`. This returns a promise that
    resolves once the tasks have been completed by a worker, giving a result value.
    In the file to be run in the worker, a function must be exported that takes in
    whatever is passed to `.run()` and returns the result value. This function can
    also be an `async` function, so that you can do asynchronous tasks in a worker
    thread if you need to. A basic example calculating square roots in worker threads
    is found in [Example 3-12](#ex_piscina_square_roots).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 基本用法很简单。您创建一个`Piscina`类的实例，传入一个`filename`，这将在工作线程中使用。在幕后，创建了一个工作线程池，并设置了一个队列来处理传入的任务。您可以通过调用`.run()`来排入任务，传入包含完成此任务所需数据的值，并注意这些值将被克隆，就像使用`postMessage()`一样。这将返回一个承诺，一旦任务由工作线程完成，就会解析出结果值。在要在工作线程中运行的文件中，必须导出一个函数，该函数接受传递给`.run()`的任何内容，并返回结果值。这个函数也可以是一个`async`函数，这样您就可以在工作线程中执行异步任务（如果需要的话）。在[示例 3-12](#ex_piscina_square_roots)中找到了一个在工作线程中计算平方根的基本示例。
- en: Example 3-12\. Computing square roots with `piscina`
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-12。使用`piscina`计算平方根
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[![1](Images/1.png)](#co_node_js_CO4-1)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_node_js_CO4-1)'
- en: Much like `cluster` and `worker_threads`, `piscina` provides a handy boolean
    for determining whether we’re in the main thread or a worker thread.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`cluster`和`worker_threads`一样，`piscina`提供了一个方便的布尔值，用于确定我们是否在主线程还是工作线程中。
- en: '[![2](Images/2.png)](#co_node_js_CO4-2)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_node_js_CO4-2)'
- en: We’ll use the same technique for using the same file as we did with the Happycoin
    example.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与Happycoin示例相同的文件使用相同的技术。
- en: '[![3](Images/3.png)](#co_node_js_CO4-3)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_node_js_CO4-3)'
- en: Since `.run()` returns a promise, we can just call `.then()` on it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`.run()`返回一个承诺，因此我们可以直接在其上调用`.then()`。
- en: '[![4](Images/4.png)](#co_node_js_CO4-4)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_node_js_CO4-4)'
- en: The exported function is used in the worker thread to perform the actual work.
    In this case, it’s just calculating a square root.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 导出的函数在工作线程中用于执行实际工作。在这种情况下，它只是计算一个平方根。
- en: While it’s all fine and good to run one task on the pool, we need to be able
    to run *many* tasks on the pool. Let’s say we want to calculate the square roots
    of every number less than ten million. Let’s go ahead and loop ten million times.
    We’ll also replace the logging with an assertion that we’ve gotten a numeric result,
    since logging will be quite noisy. Have a look at [Example 3-13](#ex_piscina_10m_square_roots).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在池中运行一个任务很好，但我们需要能够在池中运行*多个*任务。假设我们想计算小于一千万的每个数字的平方根。让我们继续循环一千万次。我们还将用一个断言替换日志记录，以确保我们得到了一个数值结果，因为日志记录会非常嘈杂。请看[示例 3-13](#ex_piscina_10m_square_roots)。
- en: Example 3-13\. Computing ten million square roots with `piscina`
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-13。使用`piscina`计算一千万个平方根
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This seems like it ought to work. We’re submitting ten million numbers to be
    processed by the worker pool. However, if you run this code, you’ll get a nonrecoverable
    JavaScript memory allocation error. On one trial of this with Node.js v16.0.0,
    the following output was observed.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来这应该可以工作。我们将提交一千万个数字供工作线程池处理。然而，如果您运行此代码，您将得到一个不可恢复的JavaScript内存分配错误。在使用Node.js
    v16.0.0的一个试验中，观察到了以下输出。
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: What’s going on here? It turns out the underlying task queue is not infinite.
    By default, the task queue will keep growing and growing until we run into an
    allocation error like this one. To avoid having this happen, we need to set a
    reasonable limit. The `piscina` module lets you set a limit by using a `maxQueue`
    option in its constructor, which can be set to any positive integer. Through experimentation,
    the maintainers of `piscina` have found that an ideal `maxQueue` value is the
    square of the number of worker threads it’s using. Handily, you can use this number
    without even knowing it by setting `maxQueue` to `auto`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？原来底层任务队列不是无限的。默认情况下，任务队列将继续增长，直到我们遇到类似这样的分配错误。为了避免发生这种情况，我们需要设置一个合理的限制。`piscina`模块允许您通过在其构造函数中使用`maxQueue`选项来设置限制，该选项可以设置为任何正整数。通过实验，`piscina`的维护者们发现，一个理想的`maxQueue`值是它使用的工作线程数量的平方。方便的是，您可以通过将`maxQueue`设置为`auto`来使用此数字，而无需知道它是多少。
- en: 'Once we’ve established a bound for the queue size, we need to be able to handle
    it when the queue is full. There are two ways to detect that the queue is full:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们为队列大小建立了一个限制，我们需要能够处理队列已满的情况。检测队列已满有两种方法：
- en: Compare the values of `piscina.queueSize` and `piscina.options.maxQueue`. If
    they’re equal, then the queue is full. This can be done prior to calling `piscina.run()`
    to avoid attempting to enqueue when it’s full. This is the recommended way to
    check.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较`piscina.queueSize`和`piscina.options.maxQueue`的值。如果它们相等，则队列已满。在调用`piscina.run()`之前进行此检查可以避免在队列已满时尝试入队操作。这是推荐的检查方法。
- en: If `piscina.run()` is called when the queue is full, the returned promise will
    reject with an error indicating that the queue is full. This isn’t ideal because
    by this point we’re already in a further tick of the event loop and many other
    attempts to enqueue may already have happened.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在队列已满时调用`piscina.run()`，返回的Promise将会因队列已满而被拒绝，显示队列已满的错误。这并不理想，因为在此时我们已经进入事件循环的更进一步刻度，并且可能已经尝试了许多其他入队操作。
- en: When we know that the queue is full, we need a way of knowing when it’ll be
    ready for new tasks again. Fortunately, `piscina` pools emit a `drain` event once
    the queue is empty, which is certainly an ideal time to start adding new tasks.
    In [Example 3-14](#ex_piscina_better_10m_square_roots), we put this all together
    with an `async` function around the loop that submits the tasks.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们知道队列已满时，我们需要一种方法来知道何时它会准备好接收新任务。幸运的是，`piscina`池在队列为空时会触发`drain`事件，这绝对是开始添加新任务的理想时机。在[示例 3-14](#ex_piscina_better_10m_square_roots)中，我们围绕提交任务的循环放置了一个`async`函数。
- en: Example 3-14\. Computing ten million square roots with `piscina`, without crashing
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-14\. 使用`piscina`计算一千万个平方根，无崩溃
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[![1](Images/1.png)](#manual_co_node_js_CO5-1)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#manual_co_node_js_CO5-1)'
- en: The `maxQueue` option is set to `auto`, which limits the queue size to the square
    of the number of threads that `piscina` is using.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`maxQueue`选项设置为`auto`，将队列大小限制为`piscina`使用线程数的平方。'
- en: '[![2](Images/2.png)](#manual_co_node_js_CO5-2)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#manual_co_node_js_CO5-2)'
- en: The `for` loop is wrapped in an `async` immediately invoked function expression
    (IIFE) in order to use an `await` within it.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环包装在一个立即调用的`async`函数表达式（IIFE）中，以便在其中使用`await`。'
- en: '[![3](Images/3.png)](#manual_co_node_js_CO5-3)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#manual_co_node_js_CO5-3)'
- en: When this check is true, the queue is full.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当此检查为真时，队列已满。
- en: '[![4](Images/4.png)](#manual_co_node_js_CO5-4)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#manual_co_node_js_CO5-4)'
- en: We then wait for the `drain` event before submitting any new tasks to the queue.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们等待`drain`事件，在提交任何新任务到队列之前。
- en: Running this code does *not* result in an out-of-memory crash like it did before.
    It takes a fairly long time to complete, but it does finally exit without issue.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码不会像以前一样导致内存不足崩溃。它需要相当长的时间才能完成，但最终会顺利退出。
- en: As seen here, it’s easy to fall into a trap where using a tool in what seems
    like the most sensible way isn’t the best approach. It’s important to fully understand
    tools like `piscina` when building out your multithreaded applications.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，很容易陷入陷阱，使用工具看似是最明智的方式，但并不是最佳方法。在构建多线程应用程序时，充分理解像`piscina`这样的工具是非常重要的。
- en: On that note, let’s see what happens when we try to use `piscina` to mine Happycoins.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，让我们看看当我们尝试使用`piscina`来挖掘Happycoins时会发生什么。
- en: A Pool Full of Happycoins
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一池满的Happycoins
- en: To use `piscina` to produce Happycoins, we’ll use a slightly different approach
    from what we did in the original `worker_threads` implementation. Instead of getting
    a message back every time we have a Happycoin, we’ll batch them together and send
    them all at once when we’re done. This trade-off saves us the effort of setting
    up a `MessageChannel` to send data back to the main thread with; the side effect
    is that we’ll only get our results in batches, rather than as soon as they’re
    ready. The main thread will still do the job of spawning the appropriate threads
    and retrieving all the results.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`piscina`来生成Happycoins，我们将使用与原始`worker_threads`实现略有不同的方法。我们不再在每次获得Happycoin时都返回一个消息，而是在完成时将它们批量发送。这种折衷方案节省了我们设置`MessageChannel`来将数据发送回主线程的工作；副作用是我们只能批量获取结果，而不是在准备好时立即获取。主线程仍将负责生成适当的线程并检索所有结果。
- en: To start off, copy your *happycoin-threads.js* file to a new one called *happycoin-piscina.js*.
    We’ll build off our old `worker_threads` example here. Now replace everything
    before the `require('crypto')` line with [Example 3-15](#ex_happycoin_piscina_1).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将您的*happycoin-threads.js*文件复制到一个名为*happycoin-piscina.js*的新文件中。我们将在之前的`worker_threads`示例的基础上构建。现在用[示例 3-15](#ex_happycoin_piscina_1)替换`require('crypto')`行之前的所有内容。
- en: Example 3-15\. *ch3-happycoin/happycoin-piscina.js*
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-15\. *ch3-happycoin/happycoin-piscina.js*
- en: '[PRE19]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Yep, that’s it! Now we’ll get to the more substantial stuff. Replace everything
    after the `isHappycoin()` function declaration with the contents of [Example 3-16](#ex_happycoin_piscina_2).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，就是这样！现在我们将进入更实质性的内容。用[示例 3-16](#ex_happycoin_piscina_2)中`isHappycoin()`函数声明后的内容替换一切。
- en: Example 3-16\. *ch3-happycoin/happycoin-piscina.js*
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-16\. *ch3-happycoin/happycoin-piscina.js*
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[![1](Images/1.png)](#co_node_js_CO5-1)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_node_js_CO5-1)'
- en: We’ll use the `isWorkerThread` property to check that we’re in the main thread.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`isWorkerThread`属性来检查我们是否在主线程中。
- en: '[![2](Images/2.png)](#co_node_js_CO5-2)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_node_js_CO5-2)'
- en: We’re using the same technique as earlier to create worker threads using this
    same file.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用与之前相同的技术来创建使用同一文件的工作线程。
- en: '[![3](Images/3.png)](#co_node_js_CO5-3)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_node_js_CO5-3)'
- en: We want to restrict the number of threads to be exactly four, to match our previous
    examples. We’ll want to time this and see what happens, so sticking with four
    threads reduces the number of variables here.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将线程数限制为恰好四个，以匹配我们之前的示例。我们将计时并查看发生了什么，因此保持四个线程可以减少这里的变量数量。
- en: '[![4](Images/4.png)](#co_node_js_CO5-4)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_node_js_CO5-4)'
- en: We know we have four threads, so we’ll enqueue our task four times. Each one
    will complete once it has checked its chunk of random numbers for Happycoins.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道有四个线程，因此我们将任务排队四次。每个线程在检查其随机数块是否有Happycoin后会完成任务。
- en: '[![5](Images/5.png)](#co_node_js_CO5-5)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](Images/5.png)](#co_node_js_CO5-5)'
- en: We submit the task to the queue in this `async` IIFE, so that they all get queued
    in the same event loop iteration. Don’t worry, we won’t get out-of-memory errors
    like we did before because we know we have exactly four threads and we’re only
    enqueueing four tasks. As we’ll see later, the task returns both the output string
    and the total count of Happycoins that the thread has found.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将任务提交到队列中的这个`async` IIFE中，以便它们都在同一事件循环迭代中排队。不用担心，我们不会像以前那样因为内存不足而出错，因为我们知道我们确实有四个线程，并且只排队了四个任务。后面我们会看到，任务会返回输出字符串和线程找到的Happycoin的总数。
- en: '[![6](Images/6.png)](#co_node_js_CO5-6)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](Images/6.png)](#co_node_js_CO5-6)'
- en: Much like we’ve done in previous Happycoin implementations, we’ll check that
    all threads have completed their tasks before outputting the grand total count
    of Happycoins that we’ve found.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在之前的Happycoin实现中所做的那样，我们将检查所有线程是否完成其任务，然后输出我们找到的Happycoin的总数。
- en: Next we’ll add the code from [Example 3-17](#ex_happycoin_piscina_3), which
    adds the exported function that’s used in `piscina`’s worker threads.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将添加来自[示例 3-17](#ex_happycoin_piscina_3)的代码，该示例添加了在`piscina`的工作线程中使用的导出函数。
- en: Example 3-17\. *ch3-happycoin/happycoin-piscina.js*
  id: totrans-172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-17\. *ch3-happycoin/happycoin-piscina.js*
- en: '[PRE21]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[![1](Images/1.png)](#manual_co_node_js_CO7-1)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#manual_co_node_js_CO7-1)'
- en: We’re doing our typical Happycoin-hunting loop here, but as in other parallelism
    examples, we’re dividing our total search space by the number of threads.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们正在进行典型的Happycoin搜索循环，但与其他并行性示例一样，我们将总搜索空间分割成几个线程。
- en: '[![2](Images/2.png)](#manual_co_node_js_CO7-2)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#manual_co_node_js_CO7-2)'
- en: We’re passing the string of found Happycoins and the total count of them back
    to the main thread by returning a value from this function.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过从此函数返回一个值来将找到的Happycoin的字符串和它们的总数传回主线程。
- en: 'To run this, you’ll have to install `piscina` if you haven’t done so yet for
    the earlier examples. You can use the following two commands in your *ch3-happycoin*
    directory to set up a Node.js project and add the `piscina` dependency. The third
    line can then be used to run the code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这个示例，如果你之前还没有安装`piscina`，你需要在你的*ch3-happycoin*目录中使用以下两个命令设置Node.js项目并添加`piscina`依赖项。然后可以使用第三行命令来运行代码：
- en: '[PRE22]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You should see output the same as earlier examples, with a slight twist. Rather
    than seeing each Happycoin come in one by one, you’ll see them either roughly
    all at once, or in four large groupings of them. This is the trade-off we made
    by returning the whole strings rather than the Happycoins one by one. This code
    should run in roughly the same time as *happycoin-threads.js*, since it uses the
    same principle, but with the abstraction layer that `piscina` provides us.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到与先前示例相同的输出，但有一点小变化。与其看到每个 Happycoin 一个接一个地到来，你将看到它们大致同时到达，或者以四个大组的形式到达。这是我们通过返回整个字符串而不是一个接一个地返回
    Happycoins 所做的权衡。这段代码应该在大致相同的时间内运行，就像 *happycoin-threads.js* 一样，因为它使用了`piscina`提供的相同原理的抽象层。
- en: You can see that we’re not using `piscina` in the typical manner. We’re not
    passing it a multitude of discrete tasks that end up requiring careful queueing.
    The primary reason for this is performance.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我们并没有按照典型的方式使用`piscina`。我们没有传递大量的独立任务，最终需要仔细排队。这样做的主要原因是性能。
- en: If, for example, we had a loop iterating ten million times in the main thread,
    each time adding another task to the queue and `await`-ing its response, it would
    end up being just as slow as running all the code synchronously on the main thread.
    We could *not* await the reply and just add things to the queue as soon as we
    can, but it turns out the overhead of passing messages 20 million times is a lot
    greater than simply passing eight messages.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果在主线程中进行了一千万次迭代的循环，每次都向队列添加另一个任务并等待其响应，那么最终速度将和同步运行所有代码在主线程上一样慢。我们也可以不等待回复，尽快将事物添加到队列中，但事实证明，传递消息两千万次的开销比仅仅传递八个消息要大得多。
- en: When dealing with raw data, like numbers or byte streams, there are usually
    faster ways of transferring data between threads using `SharedArrayBuffers`, and
    we’ll see more about those in the next chapter.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理原始数据，如数字或字节流时，通常可以使用`SharedArrayBuffers`在线程之间更快地传输数据，我们将在下一章节详细了解这些内容。
- en: ^([1](ch03.xhtml#idm45995923445880-marker)) Yes, other nonbrowser JavaScript
    runtimes exist, like Deno, but Node.js has such a massive amount of popularity
    and market share at time of writing that it’s the only one worth talking about
    here. This may change by the time you’re reading this, and that’s great for the
    world of JavaScript! Hopefully, there’s a newer edition of this book that covers
    your nonbrowser JavaScript runtime of choice.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch03.xhtml#idm45995923445880-marker)) 是的，其他非浏览器 JavaScript 运行时也存在，比如 Deno，但截至撰写本文时，Node.js
    的流行度和市场份额如此之大，以至于在这里只值得讨论它。希望在您阅读本文时情况可能已有所改变，这对 JavaScript 的世界来说是件好事！希望本书的新版本覆盖了您所选择的非浏览器
    JavaScript 运行时。
