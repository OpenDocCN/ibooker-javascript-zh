- en: 'Chapter 3\. Excel: A Fancy Table Component'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章。Excel：一个花哨的表格组件
- en: Now you know how to create custom React components, compose UI using generic
    DOM components as well as your own custom ones, set properties, maintain state,
    hook into the lifecycle of a component, and optimize performance by not rerendering
    when not necessary.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何创建自定义的 React 组件，使用通用 DOM 组件以及你自己的定制组件来组合 UI，设置属性，维护状态，钩入组件的生命周期，并通过在不必要时避免重新渲染来优化性能。
- en: Let’s put all of this together (and learn more about React while you’re at it)
    by creating a more powerful component—a data table. Something like an early prototype
    of Microsoft Excel that lets you edit the contents of a data table, and also sort,
    search, and export the data as downloadable files.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将所有内容整合在一起（并在此过程中学习更多关于 React 的知识），创建一个更强大的组件——数据表格。类似于 Microsoft Excel 的早期原型，它允许你编辑数据表格的内容，还可以对数据进行排序、搜索和导出为可下载的文件。
- en: Data First
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据优先
- en: 'Tables are all about the data, so the fancy table component (why not call it
    `Excel`?) should take an array of data and an array of headers that describe each
    column of data. For testing, let’s grab a list of best-selling books from [Wikipedia](https://en.wikipedia.org/wiki/List_of_best-selling_books):'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 表格关乎数据，所以这个花哨的表格组件（为什么不称它为 `Excel`？）应该接受一个数据数组和描述每列数据的表头数组。为了测试，让我们从 [Wikipedia](https://en.wikipedia.org/wiki/List_of_best-selling_books)
    获取一份畅销书列表：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, how should you go about rendering this data in a table?
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何在表格中渲染这些数据呢？
- en: Table Headers Loop
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表头循环
- en: 'The first step, just to get the new component off the ground, is to display
    only the headers of the table. Here’s what a bare-bones implementation might look
    like (*03.01.table-th-loop.html* in the book’s repository):'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步，为了让新组件能够运行起来，只显示表格的表头。以下是一个最简实现的示例（*03.01.table-th-loop.html* 在书籍的代码库中）：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now that you have a working component, here’s how to use it:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有一个工作中的组件，下面是如何使用它：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The result of this get-off-the-ground example is shown in [Figure 3-1](#FIG0301).
    There’s a little bit of CSS, which is of no concern for the purposes of this discussion,
    but you can find it in `03.table.css` in the book’s repo.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这个起步示例的结果显示在[图 3-1](#FIG0301)中。在这个讨论中，CSS 只是稍微提及了一下，不是关注的重点，但你可以在书籍仓库的 `03.table.css`
    中找到它。
- en: '![rur2 0301](Images/rur2_0301.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![rur2 0301](Images/rur2_0301.png)'
- en: Figure 3-1\. Rendering table headers
  id: totrans-14
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-1\. 渲染表头
- en: The `return` part of the component is fairly simple. It looks just like an HTML
    table except for the `headers` array.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的 `return` 部分相当简单。它看起来就像一个 HTML 表格，除了 `headers` 数组。
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you saw in the previous chapter, you can open curly braces in your JSX and
    put any JavaScript value or expression in there. If this value happens to be an
    array as in the previous case, the JSX parser treats it as if you passed each
    element of the array individually, like `{headers[0]}{headers[1]}...`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在上一章节中看到的，你可以在 JSX 中使用大括号打开并放置任何 JavaScript 值或表达式。如果这个值恰好是一个数组，就像前面的例子一样，JSX
    解析器会将其视为你单独传递了数组的每个元素，就像`{headers[0]}{headers[1]}...`。
- en: 'In this example the elements of the `headers` array contain more JSX content
    and this is perfectly fine. The loop before the `return` populates the `headers`
    array with JSX values which, if you were hardcoding the data, would look like:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`headers` 数组的元素包含更多的 JSX 内容，这完全没问题。在`return`之前的循环使用 JSX 值填充了 `headers`
    数组，如果你在硬编码数据，它看起来可能是这样的：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can have JavaScript expressions in curly braces within JSX and you can nest
    them as deep as you need. This is part of the beauty of React—all the power of
    JavaScript is available to you to create your UI. Loops and conditions all work
    as usual, and you don’t need to learn another “templating” language or syntax
    to build the UI.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 JSX 中的大括号内使用 JavaScript 表达式，你可以按需嵌套它们。这是 React 的美妙之处之一——JavaScript 的全部功能都可以用来创建你的
    UI。循环和条件语句都像往常一样工作，你不需要学习另一种“模板”语言或语法来构建 UI。
- en: Table Headers Loop, a Terse Version
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表头循环，简洁版本
- en: The preceding example worked fine (let’s call it “v1” for “version 1”) but let’s
    see how you can accomplish the same with less code. Let’s move the loop inside
    the JSX returned at the end. In essence the whole `render()` method becomes a
    single `return` (see *03.02.table-th-map.html* in the book’s repo).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子运行良好（我们称之为“v1”，代表“版本1”），但让我们看看如何用更少的代码完成相同的功能。让我们将循环移到 JSX 返回的末尾。实质上，整个
    `render()` 方法变成了一个单独的 `return`（参见书籍仓库中的 *03.02.table-th-map.html*）。
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: See how the array of header content is produced by calling `map()` on the data
    passed via `this.props.headers`. A `map()` call takes an input array, executes
    a callback function on each element, and creates a new array.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 看看如何通过调用`this.props.headers`传递的数据在`map()`上调用生成表头内容的数组。`map()`调用接受一个输入数组，在每个元素上执行一个回调函数，并创建一个新数组。
- en: In the preceding example, the callback uses the tersest *arrow functions* syntax.
    If this is a little too cryptic for your taste, let’s call it v2 and explore a
    few other options.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，回调函数使用了最简洁的*箭头函数*语法。如果这对你来说有点晦涩，我们称之为v2，并探讨一些其他选项。
- en: 'Here’s v3: a more verbose `map()` loop using generous indentation and a *function
    expression* instead of an arrow function:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是v3：使用大括号包裹回调函数体的更详细的`map()`循环和一个*函数表达式*，而不是箭头函数：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, a v4 which is a little less verbose, going back to using an arrow function:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是v4，它稍微简洁一些，回到了使用箭头函数：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This can be formatted with less indentation to v5:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以使用更少的缩进格式化为v5：
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can choose your preferred way of iterating over arrays to produce JSX output
    based on personal preference and complexity of the content to be rendered. Simple
    data is conveniently looped over inline in the JSX (v2 through v5). If the type
    of data is a little too much for an inline `map()` you may find it more readable
    to have the content generated at the top of the render function and keep the JSX
    simple, in a way separating data from presentation (v1 is an example). Sometimes
    too many inline expressions can be confusing when keeping track of all closing
    parentheses and curly braces.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据个人偏好和要渲染内容的复杂性选择适合你的方式来遍历数组生成JSX输出。简单的数据可以在JSX中方便地内联循环（从v2到v5）。如果数据类型对于内联的`map()`来说有点复杂，你可能会发现将内容生成放在渲染函数的顶部更容易阅读，保持JSX简洁，从某种意义上将数据与展示分离（v1是一个例子）。有时候太多的内联表达式会在跟踪所有的闭合括号和大括号时变得混乱。
- en: As to v2 versus v5, they are the same except v5 has extra parentheses around
    the callback arguments and curly braces wrapping the callback function body. While
    both of these are optional, they make future changes a little easier to parse
    in a diff/code review context or while debugging. For example, adding a new line
    to the function body (maybe a temporary `console.log()`) in v5 is just that simple—adding
    a new line. While in v2 a new line also requires adding curly braces and reformatting
    and reindenting the code.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 至于v2和v5的比较，它们基本相同，只是v5在回调参数周围有额外的括号，并且在回调函数体周围有大括号包裹。虽然这两者都是可选的，但它们使未来在差异/代码审查上或者在调试时更容易解析。例如，在v5中添加一个新行到函数体中（可能是一个临时的`console.log()`）非常简单——只需添加一个新行。而在v2中，添加一个新行还需要添加大括号并重新格式化和重新缩进代码。
- en: Debugging the Console Warning
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试控制台警告
- en: 'If you look in the the browser console when loading the previous two examples
    (*03.01.table-th-loop.html* and *03.01.table-th-map.html*) you can see a warning.
    It states:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在加载前面的两个示例（*03.01.table-th-loop.html* 和 *03.01.table-th-map.html*）时查看浏览器控制台，你会看到一个警告。它说：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'What is it about and how do you fix it? As the warning message reads, React
    wants you to provide a unique identifier for the array elements so it can update
    them more efficiently later on. To fix the warning, you add a `key` property to
    each header. The values of this new property can be anything as long they are
    unique for each element. Here you can use the index of the array element (0, 1,
    2…):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 它是什么问题以及如何修复它？正如警告信息所述，React 希望你为数组元素提供一个唯一的标识符，以便以后更高效地更新它们。为了解决警告，你需要为每个标题添加一个`key`属性。这个新属性的值可以是任何唯一的内容，比如数组元素的索引（0、1、2……）：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The keys need to be unique only inside each array loop, not unique in the whole
    React application, so values of 0, 1, and so on are perfectly acceptable.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 键值只需要在每个数组循环内唯一，不需要在整个 React 应用程序中唯一，因此0、1等值是完全可以接受的。
- en: 'The same fix for the inline version (v5) takes the element index from the second
    argument passed to the callback function:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于内联版本（v5）的相同修复，从回调函数的第二个参数中获取元素的索引：
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Adding <td> Content
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加 <td> 内容
- en: 'Now that you have a pretty table head, it’s time to add the body. The data
    to be rendered is a two-dimensional array (rows and columns) that looks like the
    following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了一个漂亮的表头，是时候添加表体了。要渲染的数据是一个二维数组（行和列），看起来像这样：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To pass the data to the `<Excel>`, let’s use a new prop called `initialData`.
    Why “initial” and not just “data”? As touched on briefly in the previous chapter,
    it’s about managing expectations. The caller of your `Excel` component should
    be able to pass data to initialize the table. But later, as the table lives on,
    the data will change, because the user is able to sort, edit, and so on. In other
    words, the *state* of the component will change. So let’s use `this.state.data`
    to keep track of the changes and use `this.props.initialData` to let the caller
    initialize the component.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要将数据传递给`<Excel>`，让我们使用一个名为`initialData`的新prop。为什么是“initial”而不仅仅是“data”？正如在上一章中简要提到的，这关乎管理期望。你的`Excel`组件的调用者应该能够传递数据以初始化表格。但随后，随着表格的存在，数据会发生变化，因为用户可以排序、编辑等。换句话说，组件的*状态*会改变。所以让我们使用`this.state.data`来跟踪这些变化，并使用`this.props.initialData`来让调用者初始化组件。
- en: 'Rendering a new `Excel` component would look like:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染一个新的`Excel`组件看起来像这样：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next you need to add a constructor to set the initial state from the given
    data. The constructor receives `props` as an argument and also needs to call its
    parent’s constructor via `super()`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来你需要添加一个构造函数来从给定的数据中设置初始状态。构造函数接收`props`作为参数，并且还需要通过`super()`调用其父类的构造函数。
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'On to rendering `this.state.data`. The data is two-dimensional, so you need
    two loops: one that goes through rows and one that goes through the data (cells)
    for each row. This can be accomplished using two of the same `.map()` loops you
    already know how to use:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在渲染`this.state.data`。数据是二维的，所以你需要两个循环：一个用于遍历行，另一个用于遍历每行的数据（单元格）。这可以通过使用两个相同的`.map()`循环来实现，这些循环你已经知道如何使用了：
- en: '[PRE15]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, both loops need `key={idx}`, and in this case the name `idx`
    was recycled for use as local variables within each loop.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这两个循环都需要`key={idx}`，在这种情况下，名称`idx`被重新用作每个循环内的局部变量。
- en: 'A complete implementation could look like this (and the result is shown in
    [Figure 3-2](#FIG0302)):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的实现可能看起来像这样（结果显示在[图3-2](#FIG0302)中）：
- en: '[PRE16]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![rur2 0302](Images/rur2_0302.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![rur2 0302](Images/rur2_0302.png)'
- en: Figure 3-2\. Rendering the whole table (*03.05.table-th-td.html*)
  id: totrans-56
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-2\. 渲染整个表格（*03.05.table-th-td.html*）
- en: Prop Types
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Prop Types
- en: 'The ability to specify the types of variables you work with (string, number,
    boolean, etc.) doesn’t exist in the JavaScript language. But developers coming
    from other languages, and those working on larger projects with many other developers,
    do miss it. Two popular options exist that allow you to write JavaScript with
    types: Flow and TypeScript. You can certainly use these to write React applications.
    But another option exists, which is limited to only specifying the types of props
    your component expects with *prop types*. They were a part of React itself, initially,
    but have been moved to a separate library as of React v15.5.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript语言中，无法指定你要处理的变量类型（字符串、数字、布尔值等）。但是来自其他语言的开发人员，以及在有许多其他开发人员参与的大型项目上工作的人会错过它。存在两个流行的选项，可以让你使用类型编写JavaScript：Flow和TypeScript。你当然可以使用它们来编写React应用程序。但另一个选项存在，它仅限于指定组件期望的props类型：*prop
    types*。最初它们是React本身的一部分，但从React v15.5开始已移动到一个单独的库中。
- en: 'Prop types allow you to be more specific as to what data `Excel` takes and
    as a result surface an error to the developer early on. You can set up the prop
    types like so (*03.06.table-th-td-prop-types.html*):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Prop types允许你更具体地指定`Excel`接收的数据类型，从而及早向开发人员展示错误。你可以这样设置prop types（*03.06.table-th-td-prop-types.html*）：
- en: '[PRE17]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This means that the `headers` prop is expected to be an array of strings and
    `initialData` is expected to be an array where each element is another array of
    string elements.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`headers` prop预期是一个字符串数组，`initialData`预期是一个数组，其中每个元素是另一个字符串元素的数组。
- en: 'To make this code work you need to grab the library that exposes the `PropTypes`
    global variable, just like you did in the beginning of [Chapter 1](ch01.xhtml#ch1):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这段代码工作，你需要获取暴露了全局变量`PropTypes`的库，就像你在[第1章](ch01.xhtml#ch1)开始时所做的那样：
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, in the HTML, you include the new library together with the other ones:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在HTML中，你将新库与其他库一起包含：
- en: '[PRE19]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now you can test how it all works by changing `headers`, for example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以通过修改`headers`来测试所有这些工作，例如：
- en: '[PRE20]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now when you load the page (*03.06.table-th-td-prop-types.html* in the repo)
    you can see in the console:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你加载页面时（存储库中的*03.06.table-th-td-prop-types.html*），你可以在控制台中看到：
- en: '[PRE21]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now that’s strict!
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这就严格了！
- en: To explore other `PropTypes`, type **`PropTypes`** in the console (as shown
    in [Figure 3-3](#FIG0303)).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要探索其他`PropTypes`，请在控制台中输入**`PropTypes`**（如[图3-3](#FIG0303)所示）。
- en: '![rur2 0303](Images/rur2_0303.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![rur2 0303](Images/rur2_0303.png)'
- en: Figure 3-3\. Exploring `PropTypes`
  id: totrans-73
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-3\. 探索`PropTypes`
- en: Can You Improve the Component?
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你能改进组件吗？
- en: Allowing only string data is a bit too restrictive for a generic Microsoft Excel
    spreadsheet. As an exercise for your own amusement, you can change this example
    to allow more data types (`PropTypes.any`) and then render differently depending
    on the type (e.g., align numbers to the right).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 仅允许字符串数据对于通用的 Microsoft Excel 电子表格来说有些太过于限制性。作为自己娱乐的练习，你可以改变这个例子以允许更多的数据类型（`PropTypes.any`），然后根据类型不同进行不同的渲染（例如，将数字右对齐）。
- en: Sorting
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序
- en: How many times have you seen a table on a web page that you wished was sorted
    differently? Luckily, it’s trivial to do this with React. Actually, this is an
    example where React shines, because all you need to do is sort the `data` array
    and all the UI updates are handled for you.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有多少次你看到一个网页上的表格，希望它排序方式不同？幸运的是，使用 React 做到这一点非常简单。实际上，这正是 React 突出的一个例子，因为你所需做的就是对`data`数组进行排序，所有的
    UI 更新都由它处理。
- en: 'For convenience and readability, all the sorting logic is in a `sort()` method
    in the `Excel` class. Once you create it, two bits of plumbing are necessary.
    First, add a click handler to the header row:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便和可读性，所有排序逻辑都在`Excel`类的`sort()`方法中。一旦创建，需要两个连接件。首先，在标题行中添加一个点击处理程序：
- en: '[PRE22]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And then bind `this.sort` in the constructor as you did in [Chapter 2](ch02.xhtml#ch2):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在构造函数中绑定`this.sort`，就像你在[第 2 章](ch02.xhtml#ch2)中所做的一样：
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now let’s implement the `sort()` method. You need to know which column to sort
    by, which can conveniently be retrieved by using the `cellIndex` DOM property
    of the event target (the event target is a table header `<th>`):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们实现`sort()`方法。你需要知道按哪一列排序，可以通过事件目标（表头 `<th>`）的`cellIndex` DOM 属性方便地获取：
- en: '[PRE24]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-84
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You may have rarely seen `cellIndex` used in app development. It’s a property
    defined as early as DOM Level 1 (circa 1998) as “The index of this cell in the
    row” and later on made read-only in DOM Level 2.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能很少在应用程序开发中看到使用`cellIndex`。它是一个早在 DOM Level 1（约 1998 年）定义的属性，表示“该单元格在行中的索引”，后来在
    DOM Level 2 中被定义为只读。
- en: You also need a *copy* of the data to be sorted. Otherwise, if you use the array’s
    `sort()` method directly, it modifies the array. Meaning that calling `this.state.data.sort()`
    will modify `this.state`. As you know already, `this.state` should not be modified
    directly, but only through `setState()`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要一个数据的 *副本* 进行排序。否则，如果直接使用数组的`sort()`方法，它会修改数组。意味着调用`this.state.data.sort()`会修改`this.state`。正如你已经了解的，应该避免直接修改`this.state`，而只能通过`setState()`来修改。
- en: Various ways exist in JavaScript to make a *shallow copy* of an object or an
    array (arrays are objects in JavaScript, e.g., `Object.assign()`) or using the
    spread operator `{...state}`. However there is no built-in way to do a *deep copy*
    of an object. A quick solution is to encode an object to a JSON string and then
    decode it back to an object. Let’s use this approach for brevity, though be aware
    that it fails if your object/array contains `Date` objects.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 中存在多种方法来对对象或数组进行 *浅复制*（数组在 JavaScript 中是对象，例如，`Object.assign()`）或使用扩展运算符
    `{...state}`。然而，没有内建的方法来对对象进行 *深复制*。一个快速的解决方案是将对象编码为 JSON 字符串，然后解码回对象。让我们出于简洁性使用这种方法，尽管要注意，如果你的对象/数组包含`Date`对象，这种方法会失败。
- en: '[PRE25]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With the handy `clone()` utility function you make a copy of the array before
    you start manipulating it:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 利用方便的`clone()`实用函数，在开始操作数组之前先复制它：
- en: '[PRE26]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The actual sorting is done via a callback to array’s `sort()` method:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的排序是通过对数组的`sort()`方法进行回调来完成的：
- en: '[PRE27]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, this line sets the state with the new, sorted data:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这一行设置了新排序后的状态：
- en: '[PRE28]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, when you click a header, the contents get sorted alphabetically (as shown
    in [Figure 3-4](#FIG0304)).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你点击标题时，内容按字母顺序排序（如[图 3-4](#FIG0304)所示）。
- en: '![rur2 0304](Images/rur2_0304.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![rur2 0304](Images/rur2_0304.png)'
- en: Figure 3-4\. Sorting by book title (*03.07.table-sort.html*)
  id: totrans-97
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-4\. 按书名排序 (*03.07.table-sort.html*)
- en: And this is it—you don’t have to touch the UI rendering at all. In the `render()`
    method, you’ve already defined once and for all how the component should look
    given some data. When the data changes, so does the UI; however, this is no longer
    your concern.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样——你根本不必触碰 UI 渲染。在`render()`方法中，你已经定义了组件如何根据一些数据呈现。数据变化时，UI 也随之变化；但这已经不再是你的责任。
- en: Note
  id: totrans-99
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'The example used the ECMAScript *property value shorthands* feature where `this.setState({data})`
    is a shorter way of expressing `this.setState({data: data})` by skipping the key
    when it has the same name as a variable.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '此示例使用了 ECMAScript 的 *属性值简写* 功能，其中 `this.setState({data})` 是通过跳过与变量同名的键来更简洁地表示
    `this.setState({data: data})`。'
- en: Can You Improve the Component?
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你能改进这个组件吗？
- en: The example above uses pretty simple sorting, just enough to be relevant to
    the React discussion. You can go as fancy as you need, parsing the content to
    see if the values are numeric, with or without a unit of measure and so on.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例使用了相当简单的排序，刚好足够涉及到 React 的讨论。你可以按需进行更复杂的排序，解析内容以查看值是否是数字，是否带有单位等。
- en: Sorting UI Cues
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序 UI 提示
- en: The table is nicely sorted, but it’s not clear which column it’s sorted by.
    Let’s update the UI to show arrows based on the column being sorted. And while
    you’re at it, let’s implement descending sorting too.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 表格已经很好地排序了，但是不清楚它按哪一列排序。让我们更新 UI 以显示基于正在排序的列的箭头。在此过程中，让我们也实现降序排序。
- en: 'To keep track of the new state, you need two new properties added to `this.state`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪新状态，你需要向 `this.state` 添加两个新属性：
- en: '`this.state.sortby`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`this.state.sortby`'
- en: The index of the column currently being sorted
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当前正在排序的列的索引
- en: '`this.state.descending`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`this.state.descending`'
- en: A boolean to determine ascending versus descending sorting
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一个布尔值以确定升序还是降序排序
- en: 'The constructor can now look like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在构造函数可以是这样的：
- en: '[PRE29]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the `sort()` function, you have to figure out which way to sort. Default
    is ascending (A to Z), unless the index of the new column is the same as the current
    sort-by column and the sorting is not already descending from a previous click
    on the header:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `sort()` 函数中，你需要弄清楚排序的方式。默认为升序（A 到 Z），除非新列的索引与当前按照的列相同，并且排序不是由于之前点击头部而变成降序：
- en: '[PRE30]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You also need a small tweak to the sorting callback:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要对排序回调进行小的调整：
- en: '[PRE31]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And finally, you need to set the new state:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要设置新状态：
- en: '[PRE32]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: At this point, the descending ordering works. Clicking on the table headers
    sorts the data first in ascending order, then descending, and then toggles between
    the two.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在此时，降序排序已经可以工作了。点击表头首先按升序排序数据，然后按降序排序，之后在两者之间切换。
- en: 'The only remaining task is to update the `render()` function to indicate sorting
    direction. For the currently sorted column, let’s just add an arrow symbol to
    the title. Now the `headers` loop looks like the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一剩下的任务是更新 `render()` 函数以指示排序方向。对于当前已排序的列，让我们在标题中添加一个箭头符号。现在 `headers` 循环看起来像下面这样：
- en: '[PRE33]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The sorting is feature-complete—people can sort by any column, they can click
    once for ascending and once more for descending ordering, and the UI updates with
    the visual cue (as depicted in [Figure 3-5](#FIG0305)).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 排序功能已经完备，用户可以按任何列排序，一次点击升序，再次点击降序，并且 UI 会通过视觉提示进行更新（如图 [3-5](#FIG0305) 所示）。
- en: '![rur2 0305](Images/rur2_0305.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![rur2 0305](Images/rur2_0305.png)'
- en: Figure 3-5\. Ascending/descending sorting (note the arrow next to “Published”)
  id: totrans-123
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-5\. 升序/降序排序（注意“发布日期”旁边的箭头）
- en: Editing Data
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑数据
- en: 'The next step for the `Excel` component is to give people the option to edit
    the data in the table. One solution could work like so:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`Excel` 组件的下一步是为人们提供在表格中编辑数据的选项。一个解决方案可以这样工作：'
- en: You double-click a cell. `Excel` figures out which cell was clicked and turns
    its content from simple text into an input field prefilled with the content (as
    shown in [Figure 3-6](#FIG0306)).
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你双击了一个单元格。`Excel` 确定了被点击的单元格，并将其内容从简单文本转换为预先填充内容的输入字段（如图 [3-6](#FIG0306) 所示）。
- en: You edit the content (as shown in [Figure 3-7](#FIG0307)).
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你编辑了内容（如图 [3-7](#FIG0307) 所示）。
- en: You hit Enter. The input field is gone, and the table is updated with the new
    text (as shown in [Figure 3-8](#FIG0308)).
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你按下 Enter 键。输入字段消失，表格更新为新文本（如图 [3-8](#FIG0308) 所示）。
- en: '![rur2 0306](Images/rur2_0306.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![rur2 0306](Images/rur2_0306.png)'
- en: Figure 3-6\. Table cell turns into an input field on double-click
  id: totrans-130
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-6\. 双击后表格单元格变成输入字段
- en: '![rur2 0307](Images/rur2_0307.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![rur2 0307](Images/rur2_0307.png)'
- en: Figure 3-7\. Edit the content
  id: totrans-132
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-7\. 编辑内容
- en: '![rur2 0308](Images/rur2_0308.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![rur2 0308](Images/rur2_0308.png)'
- en: Figure 3-8\. Content updated on pressing Enter
  id: totrans-134
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-8\. 按 Enter 键更新内容
- en: Editable Cell
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可编辑单元格
- en: 'The first thing to do is set up a simple event handler. On double-click, the
    component “remembers” the selected cell:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 第一件事是设置一个简单的事件处理程序。双击时，组件“记住”选定的单元格：
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note
  id: totrans-138
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Note the friendlier, easier-to-read `onDoubleClick`, as opposed to W3C’s `ondblclick`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意友好易读的 `onDoubleClick`，而不是 W3C 的 `ondblclick`。
- en: 'Let’s see what `showEditor` looks like:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `showEditor` 方法的实现：
- en: '[PRE35]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: What’s happening here?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？
- en: 'The function sets the `edit` property of `this.state`. This property is `null`
    when editing is not occurring and then turns into an object with properties `row`
    and `column`, which contain the row index and the column index of the cell being
    edited. So if you double-click the very first cell, `this.state.edit` gets the
    value `{row: 0, column: 0}`.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '函数设置了 `this.state` 的 `edit` 属性。当未进行编辑时，此属性为 `null`，然后变为一个包含正在编辑的单元格的行索引和列索引的对象。因此，如果双击第一个单元格，`this.state.edit`
    的值将为 `{row: 0, column: 0}`。'
- en: To figure out the column index, you use the same `e.target.cellIndex` as before,
    where `e.target` is the `<td>` that was double-clicked.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要确定列索引，您可以像之前一样使用 `e.target.cellIndex`，其中 `e.target` 是双击的 `<td>`。
- en: There’s no `rowIndex` coming for free in the DOM, so you need to do it yourself
    via a `data-` attribute. Each row should have a `data-row` attribute with the
    row index, which you can `parseInt()` to get the index back.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 DOM 中，并没有 `rowIndex` 可以免费获取，因此您需要通过 `data-` 属性自行完成。每一行应该有一个 `data-row` 属性来存储行索引，您可以使用
    `parseInt()` 来获取索引。
- en: 'Let’s take care of a few prerequisites. First, the `edit` property didn’t exist
    before and should also be initialized in the constructor. While dealing with the
    constructor, let’s bind the `showEditor()` and `save()` methods. The `save()`
    is the one to do the data update once the user is done editing. The updated constructor
    looks like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先处理一些先决条件。首先，`edit` 属性之前并不存在，在构造函数中也应该进行初始化。在处理构造函数时，让我们绑定 `showEditor()`
    和 `save()` 方法。`save()` 方法用于在用户编辑完成后进行数据更新。更新后的构造函数如下所示：
- en: '[PRE36]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The property `data-row` is something you need so you can keep track of row indexes.
    You can get the index from the array index while looping. Previously you saw how
    `idx` was reused as a local variable by both row and column loops. Let’s rename
    it and use `rowidx` and `columnidx` for clarity.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`data-row` 属性是您需要的，以便您可以跟踪行索引。在循环中，您可以通过数组索引获取索引。之前您看到 `idx` 被同时行和列循环中的本地变量重复使用。让我们为了清晰起见将其重命名为
    `rowidx` 和 `columnidx`。'
- en: 'The whole `<tbody>` construction could look like:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 整个 `<tbody>` 构造可能如下所示：
- en: '[PRE37]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Finally, let’s do what the `TODO` says—make an input field when required. The
    whole `render()` function is called again just because of the `setState()` call
    that sets the `edit` property. React rerenders the table, which gives you the
    chance to update the table cell that was double-clicked.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们按照 `TODO` 中的要求——在必要时创建一个输入字段。由于 `setState()` 调用设置了 `edit` 属性，整个 `render()`
    函数被再次调用，React 重新渲染了表格，这给了您更新被双击的表格单元格的机会。
- en: Input Field Cell
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入字段单元格
- en: 'Let’s look at the code to replace the `TODO` comment. First, remember the edit
    state for brevity:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看替换 `TODO` 注释的代码。首先，为了简洁起见，记住编辑状态：
- en: '[PRE38]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Check if the `edit` is set and if so, whether this is the exact cell being
    edited:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 检查是否已设置 `edit`，以及是否正在编辑此确切单元格：
- en: '[PRE39]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If this is the target cell, let’s make a form and an input field with the content
    of the cell:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是目标单元格，让我们创建一个表单和一个带有单元格内容的输入字段：
- en: '[PRE40]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As you see, it’s a form with a single input and the input is prefilled with
    the text content. When the form is submitted, the submission event is trapped
    in the `save()` method.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这是一个带有单个输入字段的表单，输入字段的内容预先填充。当提交表单时，提交事件被 `save()` 方法捕获。
- en: Saving
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存
- en: 'The last piece of the editing puzzle is saving the content changes after the
    user is done typing and has submitted the form (via the Enter key):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑过程的最后一部分是在用户完成输入并提交表单（通过 Enter 键）后保存内容更改：
- en: '[PRE41]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'After preventing the default behavior (so the page doesn’t reload), you need
    to get a reference to the input field. The event target `e.target` is the form
    and its first and only child is the input:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在阻止默认行为（以避免页面重新加载）之后，您需要获取输入字段的引用。事件目标 `e.target` 是表单，它的第一个子元素就是输入字段：
- en: '[PRE42]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Clone the data, so you don’t manipulate `this.state` directly:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 克隆数据，以避免直接操作 `this.state`：
- en: '[PRE43]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Update the piece of data given the new value and the column and row indices
    stored in the `edit` property of the `state`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 `state` 的 `edit` 属性中存储的新值以及列和行索引，更新给定的数据片段：
- en: '[PRE44]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, set the state, which causes rerendering of the UI:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，设置状态，导致 UI 重新渲染：
- en: '[PRE45]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: And with this, the table is now editable. For a complete listing, see *03.09.table-editable.html*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在表格可以编辑了。要查看完整列表，请参阅 *03.09.table-editable.html*。
- en: Conclusion and Virtual DOM Diffs
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论和虚拟 DOM 差异
- en: 'At this point, the editing feature is complete. It didn’t take too much code.
    All you needed was to:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在编辑功能已完成。不需要太多的代码。你只需要：
- en: Keep track of which cell to edit via `this.state.edit`.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 `this.state.edit` 跟踪要编辑的单元格。
- en: Render an input field when displaying the table if the row and column indices
    match the cell the user double-clicked.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在显示表格时，如果行和列索引与用户双击的单元格匹配，则渲染一个输入字段。
- en: Update the data array with the new value from the input field.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用输入字段中的新值更新数据数组。
- en: As soon as you `setState()` with the new data, React calls the component’s `render()`
    method and the UI magically updates. It may look like it won’t be particularly
    efficient to render the whole table for just one cell’s content change. And in
    fact, React only updates a single cell in the browser’s DOM.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦使用新数据调用 `setState()`，React 就会调用组件的 `render()` 方法，UI 就会神奇地更新。看起来每次只更改一个单元格的内容可能不会特别高效，因为事实上，React
    只更新浏览器 DOM 中的一个单元格。
- en: If you open your browser’s dev tools, you can see which parts of the DOM tree
    are updated as you interact with your application. In [Figure 3-9](#FIG0309),
    you can see the dev tools highlighting the DOM change after changing *The Hobbit*’s
    language from English to Elvish.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开浏览器的开发者工具，可以看到当你与应用程序交互时，DOM 树的哪些部分被更新了。在[图 3-9](#FIG0309)中，你可以看到开发工具在将《霍比特人》的语言从英语改为精灵语后，突出显示了
    DOM 的变化。
- en: Behind the scenes, React calls your `render()` method and creates a lightweight
    tree representation of the desired DOM result. This is known as a *virtual DOM
    tree*. When the `render()` method is called again (after a call to `setState()`,
    for example), React takes the virtual tree before and after and computes a diff.
    Based on this diff, React figures out the minimum required DOM operations (e.g.,
    `appendChild()`, `textContent`, etc.) to carry on that change into the browser’s
    DOM.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，React 调用您的 `render()` 方法并创建所需 DOM 结果的轻量级树表示。这被称为*虚拟 DOM 树*。当再次调用 `render()`
    方法（例如，在调用 `setState()` 后）时，React 取出前后的虚拟树并计算差异。根据这些差异，React 找出执行所需的最小 DOM 操作（例如
    `appendChild()`、`textContent` 等），将该变化传递到浏览器的 DOM 中。
- en: In [Figure 3-9](#FIG0309), there is only one change required to the cell and
    it’s not necessary to rerender the whole table. By computing the minimum set of
    changes and batching DOM operations, React “touches” the DOM lightly, as it’s
    a known problem that DOM operations are slow (compared to pure JavaScript operations,
    function calls, etc.) and are often the bottleneck in rich web applications’ rendering
    performance.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 3-9](#FIG0309)中，只需要对单元格进行一个变化，而不必重新渲染整个表格。通过计算最小的变化集并批处理 DOM 操作，React 轻轻地“触碰”
    DOM，因为已知 DOM 操作慢（与纯 JavaScript 操作、函数调用等比较），通常是丰富的 Web 应用程序渲染性能的瓶颈。
- en: '![rur2 0309](Images/rur2_0309.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![rur2 0309](Images/rur2_0309.png)'
- en: Figure 3-9\. Highlighting DOM changes
  id: totrans-182
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-9\. 突出显示 DOM 变化
- en: 'React has your back when it comes to performance and updating the UI by:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到性能和更新 UI 时，React 会给你提供支持：
- en: Touching the DOM lightly
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轻触 DOM
- en: Using event delegation for user interactions
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用事件委托处理用户交互
- en: Search
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索
- en: 'Next, let’s add a search feature to the `Excel` component that allows users
    to filter the contents of the table. Here’s the plan:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们给 `Excel` 组件添加一个搜索功能，允许用户过滤表格的内容。这是计划：
- en: Add a button to toggle the new feature on and off (as in [Figure 3-10](#FIG0309_2)).
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个按钮来切换新功能的开关状态（如[图 3-10](#FIG0309_2)）。
- en: If the search is on, add a row of inputs where each one searches in the corresponding
    column (as in [Figure 3-11](#FIG0310)).
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果搜索开启，在每个输入框处添加一行输入框，每个输入框都在相应的列中搜索（如[图 3-11](#FIG0310)）。
- en: As a user types in an input box, filter the array of `state.data` to show only
    the matching content (as in [Figure 3-12](#FIG0311)).
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户在输入框中输入时，过滤 `state.data` 数组以仅显示匹配的内容（如[图 3-12](#FIG0311)）。
- en: '![rur2 0310](Images/rur2_0310.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![rur2 0310](Images/rur2_0310.png)'
- en: Figure 3-10\. Search button
  id: totrans-192
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-10\. 搜索按钮
- en: '![rur2 0311](Images/rur2_0311.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![rur2 0311](Images/rur2_0311.png)'
- en: Figure 3-11\. Row of search/filter inputs
  id: totrans-194
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-11\. 搜索/筛选输入行
- en: '![rur2 0312](Images/rur2_0312.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![rur2 0312](Images/rur2_0312.png)'
- en: Figure 3-12\. Search results
  id: totrans-196
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-12\. 搜索结果
- en: State and UI
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态和用户界面
- en: 'The first thing to do is update the constructor by:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是更新构造函数：
- en: Adding a `search` property to the `this.state` object to keep track of whether
    the search feature is on
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向`this.state`对象添加一个`search`属性，以跟踪搜索功能的开关状态
- en: 'Binding two new methods: `this.toggleSearch()` to turn search boxes on and
    off and `this.search()` to do the actual searching'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定了两个新方法：`this.toggleSearch()`用于打开和关闭搜索框，以及`this.search()`用于实际执行搜索。
- en: Setting up a new class property `this.preSearchData`
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置一个新的类属性`this.preSearchData`
- en: Updating the incoming initial data with a consecutive ID to help identify the
    rows when editing contents of filtered data
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用连续的ID更新传入的初始数据，以帮助标识编辑已过滤数据内容的行
- en: '[PRE46]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The cloning and updating of the `initialData` changes the data used in the state
    by adding a sort of *record ID*. This will prove handy when editing data that
    was already filtered. You `map()` the data, adding an additional column which
    is an integer ID.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 克隆和更新`initialData`通过添加一种*记录ID*，改变了状态中使用的数据。当编辑已经过滤的数据时，这将非常方便。您使用`map()`函数映射数据，添加了一个额外的列，即整数ID。
- en: '[PRE47]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As a result, `this.state.data` now looks like the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`this.state.data`现在看起来如下：
- en: '[PRE48]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This change also requires changes in the `render()` method, namely to use this
    record ID to identify rows, regardless of whether we’re looking at all the data
    or a filtered subset of it (as a result of a search):'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改还需要更改`render()`方法，即使用此记录ID来标识行，无论是查看所有数据还是查看其过滤子集（作为搜索结果）：
- en: '[PRE49]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Next comes updating the UI with a search button. Where before there was a `<table>`
    as the root, now let’s have a `<div>` with a search button and the same table.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是用搜索按钮更新UI。在此之前，根元素是`<table>`，现在我们使用一个`<div>`来包含搜索按钮和相同的表格。
- en: '[PRE50]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: As you see, the search button label is dynamic, to reflect whether the search
    is on or off (`this.state.search` is `true` or `false`).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，搜索按钮的标签是动态的，以反映搜索功能的开启或关闭（`this.state.search`为`true`或`false`）。
- en: Next comes the row of search boxes. You can add it to the increasingly large
    chunk of JSX, or you can have it composed up front and added to a constant which
    is to be included in the main JSX. Let’s go the second route. If the search feature
    is not on, you don’t need to render anything, so `searchRow` is just `null`. Otherwise
    a new table row is created where each cell is an input element.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是搜索框的行。您可以将其添加到越来越大的JSX块中，或者可以直接组合并添加到常量中，然后包含在主JSX中。我们选择第二种方法。如果搜索功能关闭，则不需要渲染任何内容，因此`searchRow`只是`null`。否则，将创建一个新的表格行，其中每个单元格都是一个输入元素。
- en: '[PRE51]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note
  id: totrans-215
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Using `(_, idx)` is an illustration of a convention where an unused variable
    in a callback is named with an underscore `_` to signal to the reader of the code
    that it’s not used.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`(_, idx)`是一个约定的示例，其中回调中未使用的变量用下划线`_`命名，以向代码读者表明它未被使用。
- en: 'The row of search inputs is just another child node before the main `data`
    loop (the one that creates all the table rows and cells). Include `searchRow`
    there:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索输入框的行只是在主`data`循环（创建所有表格行和单元格的循环）之前的另一个子节点。在那里包括`searchRow`：
- en: '[PRE52]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'At this point, that’s all for the UI updates. Let’s take a look at the meat
    of the feature, the “business logic,” if you will: the actual search.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，UI更新就完成了。现在让我们来看看功能的核心部分，“业务逻辑”，如果您愿意的话：实际的搜索功能。
- en: Filtering Content
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤内容
- en: 'The search feature is going to be fairly simple: call the `Array.prototype.filter()`
    method on the array of data, and return a filtered array with the elements that
    match the search string. The UI still uses `this.state.data` to do the rendering,
    but `this.state.data` is a reduced version of itself.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索功能将非常简单：在数据数组上调用`Array.prototype.filter()`方法，并返回一个匹配搜索字符串的过滤后数组。UI仍然使用`this.state.data`进行渲染，但`this.state.data`已经是其自身的减少版本。
- en: You need a reference to the data before the search, so that you don’t lose the
    data forever. This allows the user to go back to the full table or change the
    search string to get different matches. Let’s call this reference `this.preSearchData`.
    Now that there’s data in two places, the `save()` method will need an update,
    so both places are updated should the user decide to edit the data, regardless
    of whether it’s been filtered or not.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行搜索之前，您需要引用数据，以免永久丢失数据。这样用户就可以返回到完整的表格或更改搜索字符串以获取不同的匹配项。我们将这个引用称为`this.preSearchData`。
- en: 'When the user clicks the “search” button, the `toggleSearch()` function is
    invoked. This function’s task is to turn the search feature on and off. It does
    its task by:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户单击“搜索”按钮时，将调用`toggleSearch()`函数。此函数的任务是打开和关闭搜索功能。它通过以下方式执行其任务：
- en: Setting the `this.state.search` to `true` or `false` accordingly
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`this.state.search`设置为相应的`true`或`false`
- en: When enabling the search, “remembering” the current data
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用搜索时，“记住”当前数据
- en: When disabling the search, reverting to the remembered data
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当禁用搜索时，恢复到记住的数据
- en: 'Here’s how this function can be written:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以编写如下：
- en: '[PRE53]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The last thing to do is implement the `search()` function, which is called
    every time something in the search row changes, meaning the user is typing in
    one of the inputs. Here’s the complete implementation, followed by some more details:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要做的是实现`search()`函数，每当搜索行中的内容发生变化时调用该函数，这意味着用户正在输入其中一个输入框。以下是完整的实现方式，随后是一些更多细节：
- en: '[PRE54]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You get the search string from the change event’s target (which is the input
    box). Let’s call it “needle” as we’re looking for a needle in a haystack of data:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 从更改事件的目标（即输入框）获取搜索字符串。让我们称之为“needle”，因为我们正在一堆数据中寻找针：
- en: '[PRE55]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If there’s no search string (the user erased what they typed), the function
    takes the original, cached data, and this data becomes the new state:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有搜索字符串（用户删除了他们输入的内容），该函数会获取原始缓存数据，并将此数据作为新的状态：
- en: '[PRE56]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If there is a search string, filter the original data and set the filtered
    results as the new state of the data:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在搜索字符串，则将原始数据进行过滤，并将过滤后的结果设置为数据的新状态：
- en: '[PRE57]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'And with this, the search feature is complete. To implement the feature, all
    you needed to do was:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个功能，搜索功能就完成了。要实现这个功能，您需要做的只是：
- en: Add search UI
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加搜索 UI
- en: Show/hide the new UI upon request
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据请求显示/隐藏新 UI
- en: 'The actual “business logic”: a simple array `filter()` call'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际的“业务逻辑”：一个简单的数组`filter()`调用
- en: As always, you worry only about the state of your data and let React take care
    of rendering (and all the associated grunt DOM work) whenever the state of the
    data changes.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，您只需关注数据的状态，并让 React 在数据状态更改时进行渲染（以及所有相关的 DOM 工作）。
- en: Update the save() Method
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新`save()`方法
- en: Previously there was only `state.data` to be cloned and updated, but now you
    also have the “remembered” `preSearchData`. If the user is editing (even while
    searching), now the two pieces of data need an update. That’s the whole reason
    for adding a record ID—so you can find the real row even in a filtered state.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 以前只需克隆和更新`state.data`，但现在还有“remembered”`preSearchData`。如果用户正在编辑（甚至在搜索时），现在这两个数据片段都需要更新。这正是添加记录
    ID 的全部原因——这样你就可以在过滤状态下找到真正的行。
- en: Updating the `preSearchData` is just like in the previous `save()` implementation;
    just find the row and column. Updating the state data requires the additional
    step of finding the record ID of the row and matching it to the row currently
    being edited (`this.state.edit.row`).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`preSearchData`与之前的`save()`实现方式类似；只需找到行和列。更新状态数据需要额外的步骤，找到正在编辑的行的记录 ID（`this.state.edit.row`）并与之匹配。
- en: '[PRE58]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: See *03.10.table-search.html* in the book’s repo for the complete code.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在书的存储库中查看*03.10.table-search.html*以获取完整代码。
- en: Can You Improve the Search?
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 您能改进搜索吗？
- en: This was a simple working example for illustration. Can you improve the feature?
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个简单的工作示例以进行说明。您能改进这个功能吗？
- en: Try to implement an *additive search* in multiple boxes, filtering the already
    filtered data. If the user types “Eng” in the language row and then searches using
    a different search box, why not search in the search results of the previous search
    only? How would you implement this feature?
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在多个框中实现*增量搜索*，过滤已经过滤过的数据。如果用户在语言行中输入“Eng”，然后使用另一个搜索框进行搜索，为什么不仅在前一个搜索的搜索结果中搜索呢？您如何实现这个功能？
- en: Instant Replay
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 即时重播
- en: As you know now, your components worry about their state and let React render
    and rerender whenever appropriate. This means that given the same data (state
    and properties), the application will look exactly the same, no matter what changed
    before or after this particular data state. This gives you a great debugging-in-the-wild
    opportunity.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道了，您的组件关心它们的状态，并让 React 在适当时渲染和重新渲染。这意味着在给定相同数据（状态和属性）的情况下，应用程序看起来完全相同，无论在这特定数据状态之前还是之后发生了什么变化。这为您提供了一个在实际环境中进行优秀调试的机会。
- en: Imagine someone encounters a bug while using your app—they can click a button
    to report the bug without needing to explain what happened. The bug report can
    just send you back a copy of `this.state` and `this.props`, and you should be
    able to re-create the exact application state and see the visual result.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 想象有人在使用你的应用程序时遇到了一个 bug —— 他们可以点击一个按钮报告这个 bug，而不需要解释发生了什么。Bug 报告可以直接发送给你`this.state`和`this.props`的副本，你应该能够重新创建确切的应用程序状态并看到视觉结果。
- en: 'An “undo” could be another feature, since React renders your app the same way
    given the same props and state. In fact, the “undo” implementation is somewhat
    trivial: you just need to go back to the previous state.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '"撤销"功能可能是另一个功能，因为 React 根据相同的 props 和 state 渲染你的应用程序。实际上，"撤销"的实现有点微不足道：你只需回到上一个状态。'
- en: Let’s take that idea a bit further, just for fun. Let’s record each state change
    in the `Excel` component and then replay it. It’s fascinating to watch all your
    actions played back in front of you. The question of *when* the change occurred
    is not that important, so let’s “play” the app state changes at 1-second intervals.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步发展这个想法，只是为了好玩。让我们记录`Excel`组件中的每个状态变化，然后回放它。看到所有你的操作在你面前回放是很迷人的。变化发生的*时间*并不那么重要，所以让我们以1秒的间隔“播放”应用状态变化。
- en: To implement this feature, you need to add a `logSetState()` method which first
    logs the new state to a `this.log` array and then calls `setState()`. Everywhere
    in the code you called `setState()` should now be changed to call `logSetState()`.
    First, search and replace all calls to `setState()` with calls to the new function.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这个功能，你需要添加一个`logSetState()`方法，它首先将新状态记录到`this.log`数组中，然后调用`setState()`。代码中所有调用`setState()`的地方现在都应该改为调用这个新函数。
- en: All calls to…
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 所有对…
- en: '[PRE59]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '…become:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '…变成:'
- en: '[PRE60]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Now let’s move on to the constructor. You need to bind the two new functions,
    `logSetState()` and `replay()`, declare `this.log` array, and assign the initial
    state to it.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续构造函数。你需要绑定两个新函数`logSetState()`和`replay()`，声明`this.log`数组，并将初始状态赋给它。
- en: '[PRE61]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The `logSetState` needs to do two things: log the new state and then pass it
    over to `setState()`. Here’s one example implementation where you make a deep
    copy of the state and append it to `this.log`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`logSetState`需要做两件事情：记录新状态然后将其传递给`setState()`。这里有一个示例实现，你可以对状态进行深拷贝然后将其附加到`this.log`：'
- en: '[PRE62]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now that all state changes are logged, let’s play them back. To trigger the
    playback, let’s add a simple event listener that captures keyboard actions and
    invokes the `replay()` function. The place for events listeners like this is in
    the `componentDidMount()` lifecycle method:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有的状态变化都已经被记录下来，让我们回放它们。为了触发回放，让我们添加一个简单的事件监听器，捕获键盘动作并调用`replay()`函数。像这样的事件监听器应该放在`componentDidMount()`生命周期方法中：
- en: '[PRE63]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Finally, consider the `replay()` method. It uses `setInterval()` and once per
    second it reads the next object from the log and passes it to `setState()`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，考虑一下`replay()`方法。它使用`setInterval()`，每秒读取一次日志中的下一个对象并将其传递给`setState()`：
- en: '[PRE64]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: And with this, the new feature is complete (*03.11.table-replay.html* in the
    repo). Play around with the component, sort, edit… Then press Alt+Shift+R (or
    Option-Shift-R on Mac) to see the past unfold before you.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，新功能完成了（*03.11.table-replay.html* 在库中）。尝试一下这个组件，排序、编辑... 然后按下 Alt+Shift+R（或在
    Mac 上是 Option-Shift-R）来看看过去是如何展开的。
- en: Cleaning Up Event Handlers
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清理事件处理程序
- en: 'The replay feature needs a bit of cleanup. When this component is the only
    thing happening on the page, cleanup isn’t necessary; in a real application, components
    get added and removed from the DOM more frequently. When removing from the DOM
    a “good citizen” component should clean up after itself. In the example above
    there are two items that need cleaning up: the `keydown` event listener and the
    replay interval callback.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 回放功能需要进行一些清理。当这个组件是页面上唯一的活动内容时，清理并不是必需的；在实际应用中，组件更频繁地被添加和移除。当从 DOM 中移除时，“良好的公民”组件应该在自己之后进行清理。在上面的例子中，有两个需要清理的地方：`keydown`事件监听器和回放间隔的回调。
- en: If you don’t clean up the `keydown` event listener function, it will linger
    on in memory after the component is gone. And because it’s using `this`, the whole
    `Excel` instance needs to be retained in memory. This is in effect a memory leak.
    Too many of those and the user may run out of memory and your application may
    crash the browser tab. As to the interval, well, the callback function will continue
    executing after the component is gone and cause another memory leak. The callback
    will also attempt to call `setState()` on a non-existing component (which React
    handles gracefully by giving you a warning).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不清理 `keydown` 事件监听器函数，它将在组件消失后仍然留在内存中。而且因为它使用了 `this`，整个 `Excel` 实例需要保留在内存中。这实际上是一种内存泄漏。如果出现太多这样的情况，用户可能会耗尽内存，你的应用程序可能会崩溃浏览器标签页。至于间隔，回调函数将在组件消失后继续执行，并引起另一个内存泄漏。回调还会尝试在不存在的组件上调用
    `setState()`（React 会通过警告优雅地处理这种情况）。
- en: 'You can test the latter behavior by removing the component from the DOM while
    the replay is still going. To remove the component from the DOM you can just replace
    it (e.g., run the “Hello world” from [Chapter 1](ch01.xhtml#ch1) in the console):'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在重放仍在进行时从 DOM 中移除组件来测试后一种行为。要从 DOM 中移除组件，你可以简单地替换它（例如，在控制台中运行 [第一章](ch01.xhtml#ch1)
    的“Hello world”）：
- en: '[PRE65]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: You can also log a timestamp to the console in the interval callback to see
    that it keeps on being executed.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在间隔回调中向控制台记录时间戳，以查看它是否持续执行。
- en: '[PRE66]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Now when you replace the component during replay, you see an error from React
    and the timestamps of the interval callback still being logged as evidence that
    the callback is still running (as shown in [Figure 3-13](#FIG0313)).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在重播期间替换组件时，你会看到来自 React 的错误，并且间隔回调的时间戳仍在记录，证明回调仍在运行中（如 [图 3-13](#FIG0313)
    所示）。
- en: '![rur2 0313](Images/rur2_0313.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![rur2 0313](Images/rur2_0313.png)'
- en: Figure 3-13\. Memory leak in action
  id: totrans-278
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-13\. 内存泄漏实例
- en: Similarly, you can test the event listener memory leak by pressing Alt+Shift+R
    after the component has been removed from the DOM.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，当组件从 DOM 中移除后，你可以通过按下 Alt+Shift+R 键来测试事件监听器的内存泄漏。
- en: Cleaning Solution
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清理解决方案
- en: Taking care of these memory leaks is fairly straightforward. You need to keep
    references to the handlers and intervals/timeouts you want to clean up. Then clean
    them up in `componentWillUnmount()`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这些内存泄漏非常简单。你需要保留对你想要清理的处理程序和间隔/超时的引用。然后在 `componentWillUnmount()` 中进行清理。
- en: 'For the event handler, have it as a class method, as opposed to an inline function:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 对于事件处理程序，将其作为类方法而不是内联函数：
- en: '[PRE67]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Then `componentDidMount()` becomes the simpler:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 然后 `componentDidMount()` 变得更简单：
- en: '[PRE68]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'For the interval replay ID, have it as a class property as opposed to a local
    variable:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 对于间隔重播 ID，将其作为类属性而不是局部变量：
- en: '[PRE69]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'You need to, of course, bind the new method and add the new property in the
    constructor:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你需要在构造函数中绑定新方法并添加新属性：
- en: '[PRE70]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'And, finally, the cleanup in the `componentWillUnmount()`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`componentWillUnmount()`函数中进行清理：
- en: '[PRE71]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Now all the leaks are plugged (See *03.12.table-replay-clean.html* in the book’s
    repository).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有的泄漏问题都已解决（参见书中仓库中的 *03.12.table-replay-clean.html*）。
- en: Can You Improve the Replay?
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你能改进回放吗？
- en: How about implementing an undo/redo feature? Say, when the person uses the Alt+Z
    keyboard shortcut, you go back one step in the state log and on Alt+Shift+Z you
    go forward.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 关于实现撤销/重做功能怎么样？比如，当用户使用 Alt+Z 键盘快捷键时，你可以回退到状态日志中的上一步，在 Alt+Shift+Z 上则前进。
- en: An Alternative Implementation?
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另一种实现方式？
- en: Is there another way to implement replay/undo functionality without changing
    all your `setState()` calls? Maybe use an appropriate lifecycle method ([Chapter 2](ch02.xhtml#ch2))?
    Try this on your own.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 是否有其他实现回放/撤销功能的方法，而不需要改变所有你的 `setState()` 调用？也许可以使用适当的生命周期方法（参见 [第二章](ch02.xhtml#ch2)）？你可以自己尝试一下。
- en: Download the Table Data
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载表格数据
- en: After all the sorting, editing, and searching, the user is finally happy with
    the state of the data in the table. It would be nice if they could download the
    data, the result of all their labor, to use at a later time.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有排序、编辑和搜索之后，用户终于对表格中数据的状态感到满意。如果他们能够下载这些数据，即他们所有努力的结果，以便以后使用，那将是很好的。
- en: Luckily, there’s nothing easier in React. All you need to do is grab the current
    `this.state.data` and give it back—for example in JSON or comma-separated value
    (CSV) format.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在 React 中没有比这更简单的事情了。你所需要做的就是获取当前的 `this.state.data` 并返回它——例如以 JSON 或逗号分隔值（CSV）的格式。
- en: '[Figure 3-14](#FIG0314) shows the end result when a user clicks “Export CSV,”
    downloads the file called *data.csv* (see the bottom left of the browser window),
    and opens this file in Numbers (on a Mac, or Microsoft Excel on a PC or Mac).'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击“导出 CSV”后，下载名为 *data.csv* 的文件（请查看浏览器窗口左下角），然后在 Numbers（Mac 上）或 Microsoft
    Excel（PC 或 Mac 上）中打开，结果见 [图 3-14](#FIG0314)。
- en: '![rur2 0314](Images/rur2_0314.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![rur2 0314](Images/rur2_0314.png)'
- en: Figure 3-14\. Export table data to Numbers via CSV
  id: totrans-302
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-14\. 通过 CSV 导出表格数据到 Numbers
- en: 'The first thing to do is add new options to the toolbar (where the Search button
    is). Let’s use some HTML magic that forces `<a>` links to trigger file downloads,
    so the new “buttons” have to be links disguised as buttons with some CSS:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是将新选项添加到工具栏（搜索按钮所在位置）。让我们使用一些 HTML 魔法来强制 `<a>` 链接触发文件下载，因此新的“按钮”必须是通过一些
    CSS 伪装为按钮的链接：
- en: '[PRE72]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'As you see, you need `downloadJSON()` and `downloadCSV()` methods. These have
    some repeating logic, so they can be done by a single `download()` function bound
    with the `format` (meaning file type) argument. The `download()` method’s signature
    could be like:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，你需要 `downloadJSON()` 和 `downloadCSV()` 方法。这些方法有一些重复逻辑，因此可以通过一个带有 `format`
    参数的单一 `download()` 函数来处理。`download()` 方法的签名可能如下所示：
- en: '[PRE73]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'In the constructor you can bind this method twice, like so:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，你可以像这样绑定该方法两次：
- en: '[PRE74]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'All the React work is done. Now for the `download()` function. While exporting
    to JSON is trivial, CSV needs a little bit more work. In essence, it’s just a
    loop over all rows and all cells in a row, producing a long string. Once this
    is done, the function initiates the downloads via the `download` attribute and
    the `href` blob created by `window.URL`:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的 React 工作都已完成。现在来看 `download()` 函数。导出为 JSON 很简单，但 CSV 需要更多工作。基本上，它只是遍历所有行和每行中的所有单元格，生成一个长字符串。完成后，该函数通过
    `download` 属性和 `href` Blob（由 `window.URL` 创建）启动下载：
- en: '[PRE75]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The complete code is in *03.13.table-download.html* in the repo.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码位于仓库中的 *03.13.table-download.html*。
- en: Fetching Data
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取数据
- en: All through the chapter, the `Excel` component had access to the `data` in the
    same file. But what if the data lives elsewhere, on a server, and needs to be
    fetched? There are various solutions to this and you’ll see more later in the
    book, but let’s try one of the simplest—fetching the data in `componentDidMount()`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在整章中，`Excel` 组件在同一文件中具有对 `data` 的访问权。但是如果数据存在于服务器上并需要获取呢？有多种解决方案，你将在本书的后面部分看到更多，但让我们先尝试其中一个最简单的解决方案——在
    `componentDidMount()` 中获取数据。
- en: 'Let’s say the `Excel` component is created with an empty `initialData` property:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `Excel` 组件是以空的 `initialData` 属性创建的：
- en: '[PRE76]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The component can gracefully render an intermediate state to let the user know
    that data is coming. In the `render()` method you can have a condition and render
    a different table body if data is not there:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 组件可以优雅地呈现中间状态，让用户知道数据即将到来。在 `render()` 方法中，如果数据不存在，可以根据条件呈现不同的表体：
- en: '[PRE77]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: While waiting for the data, the user sees a loading indicator (as in [Figure 3-15](#FIG0315)),
    in this case a simple text, though you can have an animation if you like.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 当等待数据时，用户会看到加载指示器（如 [图 3-15](#FIG0315) 所示），在这种情况下是一个简单的文本，当然你也可以使用动画。
- en: '![rur2 0315](Images/rur2_0315.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![rur2 0315](Images/rur2_0315.png)'
- en: Figure 3-15\. Waiting for the data to be fetched
  id: totrans-320
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-15\. 等待数据获取
- en: 'Now let’s fetch the data. Using the [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API),
    make a request to a server and once the response arrives, set the state with the
    new data. You also need to take care of adding the record ID, which was previously
    the job of the constructor. The updated `componentDidMount()` can look like:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们获取数据。使用 [Fetch API](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API)，向服务器发出请求，一旦响应到达，使用新数据更新状态。同时，需要负责添加记录
    ID，之前由构造函数处理。更新后的 `componentDidMount()` 可以如下所示：
- en: '[PRE78]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The complete code is in *03.14.table-fetch.html* in the repo.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码位于仓库中的 *03.14.table-fetch.html*。
