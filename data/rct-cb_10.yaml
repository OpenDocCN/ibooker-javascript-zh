- en: Chapter 10\. Performance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章 性能
- en: One of us had a computer science lecturer who began one class by saying, “You
    should never, ever, ever try to optimize your code. But when you do optimize your
    code, here’s how you should do it.”
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们中的一位计算机科学讲师曾在一堂课上开头说过：“你永远不应该、绝对不应该试图优化你的代码。但当你确实需要优化你的代码时，这是你应该如何做的方法。”
- en: Premature optimization, as Donald Knuth once said, is the root of all evil.
    It would be best if you first made your code work. Then make your code maintainable.
    And only then—if you have a problem—should you worry about making your code fast.
    Slow code that works will always beat fast code that doesn’t.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正如Donald Knuth曾经说过的那样，过早优化是万恶之源。你应该先让你的代码工作起来。然后让你的代码易于维护。只有在有问题时，你才应该考虑让你的代码快速运行。慢速但工作正常的代码永远比快速但不可用的代码好。
- en: That said, there are times when performance can be a significant issue. If your
    application takes more than a few seconds to load, you may lose users who will
    never return. Slow can become unusable on low-powered devices. This chapter will
    take what we like to call an *essentialist* approach to performance. You should
    rarely tune your code, but when you do, you should tune the right code. We look
    at various tools and techniques that will allow you to track down and measure
    performance bottlenecks so that if you do need to apply performance fixes, they
    will be in the right place, and you will have some way of measuring the difference
    they make.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，性能可能成为重要问题的时候。如果你的应用加载时间超过几秒，可能会失去永不返回的用户。在低功率设备上，慢速可能导致无法使用。本章将采用我们称之为*本质主义*的性能方法。你应该很少调整你的代码，但当你需要时，你应该调整正确的代码。我们将看看各种工具和技术，让你能够追踪和测量性能瓶颈，以便在必要时应用性能修复，确保它们应用在正确的地方，并且有一些方法来衡量它们带来的改变。
- en: All performance fixes come at a cost. If you make your client code faster, it
    might cost more memory or more server time. You will almost always have to add
    more code and more complexity.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 所有性能修复都会带来成本。如果使客户端代码更快，可能会消耗更多内存或更多服务器时间。你几乎总是需要添加更多的代码和更多的复杂性。
- en: The recipes in this chapter follow the order in which we would suggest you approach
    performance problems. We begin with high-level measurements in the browser and
    look at ways that you can objectively identify performance bottlenecks. If you
    find a bottleneck, we will show you how you can use React’s built-in `Profiler`
    component to track down the individual components that are the source of the problem.
    We then look at lower-level and more precise ways of measuring performance down
    to the sub-millisecond level.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例按照我们建议的处理性能问题的顺序排列。我们从浏览器中的高级测量开始，探讨如何客观地识别性能瓶颈。如果找到了瓶颈，我们将向您展示如何使用React内置的`Profiler`组件来跟踪导致问题的各个组件。然后，我们会深入探讨更低级别和更精确的性能测量方法，精确到亚毫秒级别。
- en: Only once you can precisely measure performance can you even think about improving
    the speed of your code.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在您能够精确测量性能之后，才能考虑提高代码的速度。
- en: We then show you just a few ways that you can improve the performance of your
    application. Some are simple, such as splitting your code into smaller bundles
    or combining asynchronous network calls. Others are more complex, such as pre-rendering
    your pages on a server.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来将向您展示一些改善应用性能的简单方法。有些方法很简单，比如将代码拆分成更小的包或组合异步网络调用。其他方法则更为复杂，比如在服务器上预渲染页面。
- en: 'In summary: this chapter is far more about performance measurement than performance
    tuning. Because you should never, ever, ever optimize your code, but when you
    do, you should begin with measurement.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下：本章更多关注的是性能测量而不是性能调优。因为你永远不应该、绝对不应该优化你的代码，但当你确实需要时，你应该从测量开始。
- en: Use Browser Performance Tools
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用浏览器性能工具
- en: Problem
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: It is worth delaying performance tuning until you know you have a problem. In
    a sense, the only time you have a problem is if a user notices that your application
    isn’t performing. But if you wait until a user notices, that might be too late.
    For that reason, it would be helpful to have some objective measure for when an
    application needs tuning, something that realistically measures performance and
    isn’t just looking for code that could run faster. You can almost always make
    code faster, and many developers have wasted many hours tuning code that results
    in no noticeable effect on the user experience.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，在确信存在问题之前，最好延迟性能调优。从某种意义上说，只有当用户注意到你的应用程序性能不佳时，你才真正面临问题。但如果等到用户注意到了，可能为时已晚。因此，有必要设定一些客观的度量标准，用以判断何时需要对应用程序进行调优，而不只是寻找可能运行更快的代码。几乎总能使代码运行更快，许多开发人员花费了大量时间调优代码，却没有对用户体验产生显著影响。
- en: It would be helpful to have a tool that will focus on where you might need to
    optimize your code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最好有一个工具，可以专注于在哪些地方可能需要优化你的代码。
- en: Solution
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: The best way to check for performance is by using a browser. In the end, the
    user’s experience is the only thing that matters. So, we will look at the various
    in-browser tools that will provide objective measures and find potential bottlenecks
    in your code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 检查性能的最佳方法是使用浏览器。最终，用户的体验是唯一重要的。因此，我们将查看各种内置于浏览器的工具，这些工具将提供客观的度量，并找出代码潜在的瓶颈。
- en: The first thing we will look at is a tool built into Chrome called Lighthouse.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先看一下 Chrome 中名为 Lighthouse 的内置工具。
- en: Google produces an add-in for Firefox called Google Lighthouse. Although this
    works well, it is simply a frontend for the Google Page Speed service, so you
    can use it only on public-facing web pages. However, you can use the Lighthouse
    extension in Chrome on any page that Chrome can read.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌为 Firefox 生产了一个名为 Google Lighthouse 的附加组件。虽然它效果很好，但它只是 Google Page Speed 服务的前端，因此只能用于公开的
    Web 页面。但是，你可以在 Chrome 上的任何页面上使用 Lighthouse 扩展。
- en: The Lighthouse extension is a great way to check the basic road-worthiness of
    your application. As well as checking performance, Lighthouse will look at the
    accessibility of your web page and whether you are following best practices for
    the web. It will check whether your pages are optimized for search engine robots
    and will look to see if your web application meets the standards required to consider
    it a progressive web application (see [Figure 10-1](#ch10_image_1)).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Lighthouse 扩展是检查应用程序基本适用性的好方法。除了检查性能外，Lighthouse 还会审查网页的可访问性以及是否遵循最佳网络实践。它还将检查您的页面是否为搜索引擎机器人优化，并查看您的
    Web 应用程序是否符合被视为渐进式 Web 应用程序的标准（见[图 10-1](#ch10_image_1)）。
- en: '![](Images/recb_1001.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_1001.png)'
- en: Figure 10-1\. The metrics checked by Lighthouse
  id: totrans-19
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-1\. Lighthouse 检查的指标
- en: 'You can run a Lighthouse audit in two ways: either on the command line or in
    a browser.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以以两种方式运行 Lighthouse 审计：在命令行上或在浏览器中。
- en: 'If you want to run audits on the command line, you will first need to install
    the Lighthouse command:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在命令行上运行审计，你首先需要安装 Lighthouse 命令：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can then run an audit with the `lighthouse` command:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用 `lighthouse` 命令来运行审核：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The command-line version of Lighthouse is simply an automated script for the
    Google Chrome browser. It has the advantage that it generates an HTML report of
    the audit, which makes it suitable for use on a continuous integration server.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Lighthouse 的命令行版本只是 Google Chrome 浏览器的自动化脚本。它的优势在于生成审核的 HTML 报告，适合在持续集成服务器上使用。
- en: You can also use Lighthouse interactively, within Google Chrome. It’s best to
    do this in an incognito window, as this will reduce the likelihood of other extensions
    and storage interfering with the Lighthouse audit. Once you have started Chrome
    and opened your application, go to developer tools and then switch to the Lighthouse
    tab (see [Figure 10-2](#ch10_image_2)).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在 Google Chrome 中交互地使用 Lighthouse。最好在隐身窗口中进行此操作，这样可以减少其他扩展程序和存储与 Lighthouse
    审计的干扰。一旦启动了 Chrome 并打开了你的应用程序，进入开发者工具，然后切换到 Lighthouse 标签（见[图 10-2](#ch10_image_2)）。
- en: '![](Images/recb_1002.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_1002.png)'
- en: Figure 10-2\. The Lighthouse tab with Chrome DevTools
  id: totrans-28
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-2\. 带有 Chrome 开发工具的 Lighthouse 标签页
- en: Then click the Generate audit button. Lighthouse will refresh your page several
    times and perform a series of audits. The performance audit will concentrate on
    six different metrics (see [Figure 10-3](#ch10_image_3)).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然后点击生成审核按钮。 Lighthouse将刷新您的页面多次并执行一系列审核。性能审核将集中在六个不同的指标上（见[图 10-3](#ch10_image_3)）。
- en: '![](Images/recb_1003.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_1003.png)'
- en: Figure 10-3\. The six web vitals measured by the Lighthouse performance audit
  id: totrans-31
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-3. Lighthouse性能审核测量的六个Web核心指标
- en: These metrics are known as *web vitals*. The web vitals are metrics that you
    can use to track performance when applications are running in production.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指标被称为*Web核心指标*。Web核心指标是您在应用程序运行中跟踪性能的指标。
- en: The *First Contentful Paint* (FCP) is the time taken for the browser to start
    to render content. The FCP will significantly affect the user’s perception of
    performance. Before the FCP, the user will see only a blank screen, and if this
    lasts for too long, the user might close down the browser and go elsewhere.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*首次内容绘制*（FCP）是浏览器开始渲染内容所需的时间。FCP将显著影响用户对性能的感知。在FCP之前，用户将只看到空白屏幕，如果这种情况持续时间过长，用户可能会关闭浏览器并转向其他地方。'
- en: Lighthouse measures the time taken for the FCP and then compares that against
    the performance statistics Google records globally. If your application is in
    the top 25% of FCPs globally, it will mark you as green. Currently, a green rating
    means that the first content renders within two seconds. If you are within the
    top 75%, it will give you an orange grade, which means your page started to render
    within four seconds. Lighthouse will give anything else a red grade.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Lighthouse测量FCP所需时间，然后将其与Google全球记录的性能统计数据进行比较。如果您的应用程序在全球FCP的前25%中，它将标记为绿色。目前，绿色评级意味着第一个内容在两秒内呈现。如果在前75%内，它将给您一个橙色等级，这意味着您的页面开始在四秒内呈现。Lighthouse将为其他情况给出红色评分。
- en: The *Speed Index* (SI) measures how long it takes until your page stabilizes
    visually. It performs this check visually by recording a video and checking for
    differences between frames.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*速度指数*（SI）衡量页面视觉稳定化所需的时间。它通过录制视频并检查帧之间的差异来进行视觉检查。'
- en: Lighthouse will compare the SI metric to website performance globally. If the
    SI takes less than 4.3 seconds, you are in the top 25% of web pages globally,
    and Lighthouse will give a green rating. If you take less than 5.8 seconds, you
    will be in the top 75%, and Lighthouse will give you an orange rating. It will
    give everything else a red grade.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Lighthouse将SI指标与全球网站性能进行比较。如果SI小于4.3秒，则您在全球网页的前25%中，Lighthouse将给出绿色评级。如果小于5.8秒，则您将在前75%中，并获得橙色评级。其他情况下都会被评为红色。
- en: The *Largest Contentful Paint* (LCP) occurs when the browser’s viewport is completely
    loaded. Other content might still be loading out of view, but the LCP is when
    the user will feel that the page is visible. To be rated green, the LCP needs
    to be within 2.5 seconds. It needs to be less than 4 seconds for an orange rating.
    Everything else is rated red. Server-side rendering can significantly improve
    the LCP rating.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*最大内容绘制*（LCP）发生在浏览器视口完全加载时。其他内容可能仍在视野之外加载，但LCP是用户感觉到页面可见的时候。要获得绿色评级，LCP需要在2.5秒内完成。对于橙色评级，它需要少于4秒。其他情况下都会被评为红色。服务器端渲染可以显著提高LCP评级。'
- en: '*Time to interactive* (TTI) is how long it takes before you can interact with
    the page using the mouse and keyboard. In React, this happens after the first
    complete render, when React has attached the event handlers. You want this to
    be less than 3.8 seconds to get a green rating. If you can get a TTI of 7.3 or
    less, you will be rated orange. Everything else is rated red. You can improve
    the TTI by deferring the loading of third-party JavaScript or by code splitting.^([1](ch10.xhtml#idm46634384214840))'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*交互时间*（TTI）是在您可以使用鼠标和键盘与页面交互之前所需的时间。在React中，这发生在第一个完整渲染之后，当React附加了事件处理程序时。您希望这个时间少于3.8秒以获得绿色评级。如果您可以获得7.3秒或更少的TTI，您将获得橙色评级。其他情况下都会被评为红色。您可以通过延迟加载第三方JavaScript或代码分割来改善TTI。^([1](ch10.xhtml#idm46634384214840))'
- en: '*Total blocking time* (TBT) is the sum of all blocking tasks that occur between
    the FCP and TTI. A blocking task is anything that takes longer than 50 ms. That’s
    about how long it takes to display a frame in a movie, and anything longer than
    50 ms starts to become noticeable. If you have too many blocking tasks, the browser
    will start to feel like it’s freezing up. For this reason, the grades for TBT
    cover short periods. If TBT is less than 300 ms, Lighthouse will grade your page
    as green. Anything up to 600 ms is orange, and everything else is graded red.
    A high TBT score will feel to the user like the browser is being overloaded. TBT
    is generally improved by running less JavaScript code or reducing the number of
    scans of the DOM. The most effective technique is probably code splitting.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*总阻塞时间*（TBT）是在FCP和TTI之间发生的所有阻塞任务的总和。阻塞任务是任何超过50毫秒的任务。这大约是电影中显示一帧所需的时间，超过50毫秒的任何事情开始变得显著。如果阻塞任务过多，浏览器将开始感觉像是冻结。因此，TBT的等级涵盖了较短的时间段。如果TBT小于300毫秒，Lighthouse将评估您的页面为绿色。600毫秒以内为橙色，其他情况为红色。高TBT分数会使用户感觉浏览器超负荷运行。通常通过减少JavaScript代码运行或减少DOM扫描次数来改善TBT。最有效的技术可能是代码拆分。'
- en: '*Cumulative Layout Shift* (CLS) is a measure of the *jumpiness* or visual stability
    of your web page. If your application inserts additional content that moves other
    content around during a page load, this will start to affect the CLS metric. The
    CLS is the proportion of the page that moves during loading.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*累积布局偏移*（CLS）衡量的是您网页的*跳动性*或视觉稳定性。如果您的应用在页面加载期间插入额外内容并移动其他内容，这将开始影响CLS指标。CLS是页面在加载期间移动的比例。'
- en: Not included in the Lighthouse report is the *First Input Delay* (FID) metric,
    which is how long it takes between a user sending an event to the page—such as
    by clicking a button—and the JavaScript handler receiving the event. You want
    an FID of no more than 300 ms. The FID is closely related to the TBT because blocking
    events are typically created by event handlers.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Lighthouse 报告中未包括的*首次输入延迟*（FID）指标是用户向页面发送事件（例如点击按钮）和JavaScript处理程序接收事件之间所需的时间。您希望FID不超过300毫秒。FID与TBT密切相关，因为阻塞事件通常由事件处理程序创建。
- en: As well as providing an audit of the primary metrics of your page, the Lighthouse
    report will also include advice for how to fix any problems it finds.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供页面主要指标的审计外，Lighthouse报告还将包括修复任何发现问题的建议。
- en: Lighthouse is an excellent starting point when checking for performance issues.
    It’s not an exhaustive check, but it will highlight problems that you might not
    otherwise notice.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Lighthouse是检查性能问题的绝佳起点。它并非详尽检查，但会突出显示您可能没有注意到的问题。
- en: Many factors (bandwidth, memory, CPU, and so on) can affect a Lighthouse audit,
    so expect your results to vary from run to run. Online services such as [WebPageTest](https://www.webpagetest.org)
    and [GTmetrix](https://gtmetrix.com) can run audits on your application from various
    locations around the world, which will give you a more realistic view of your
    application’s speed than a Lighthouse audit running against *http://localhost:3000*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 许多因素（带宽、内存、CPU等）都会影响Lighthouse的审核结果，因此您可以预期结果会因运行而异。像[WebPageTest](https://www.webpagetest.org)和[GTmetrix](https://gtmetrix.com)这样的在线服务可以从世界各地的多个位置对您的应用程序进行审核，这将为您提供比针对*http://localhost:3000*运行的Lighthouse审核更真实的应用程序速度视图。
- en: While Lighthouse is good at highlighting the existence of performance problems,
    it’s less helpful at finding the cause of those problems. It might be that code
    for a web page is too large or too slow. It might be that the server is responding
    sluggishly. It might even be a resource problem, such as low memory or large cache
    size.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Lighthouse 擅长突出性能问题的存在，但在找出问题的根本原因方面不太有帮助。可能是网页的代码过大或速度太慢。也可能是服务器响应迟缓。甚至可能是资源问题，如内存不足或缓存大小过大。
- en: To find out *why* a bottleneck exists, we can next visit the performance tools
    of the browser itself.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出瓶颈存在的*原因*，我们接下来可以访问浏览器本身的性能工具。
- en: If you are using Firefox or Chrome, you can get to the performance console by
    opening your page in an incognito window and then going to the Performance tab
    in the development tools (see [Figure 10-4](#ch10_image_4)).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用Firefox或Chrome，您可以通过在隐身窗口中打开您的页面，然后转到开发工具中的性能选项卡（见[图10-4](#ch10_image_4)）来访问性能控制台。
- en: '![](Images/recb_1004.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_1004.png)'
- en: Figure 10-4\. The Performance tab within the browser DevTools
  id: totrans-49
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-4\. 浏览器开发工具中的性能选项卡
- en: The Performance tab is like the engine management system of the browser. There,
    you can track the memory usage, any CPU blockers, the number of elements within
    the DOM, and so on. To gather statistics, you will need to click the Record button
    on the toolbar and then interact with your page for a few seconds before stopping
    the recording. The performance system will trace everything you selected. In the
    example in [Figure 10-5](#ch10_image_5), you can see that a blocking operation
    (see TBT earlier) occurred when the user clicked a button, and the browser blocked
    for 60.92 ms until the event handler returned.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 性能选项卡就像浏览器的引擎管理系统。在那里，您可以跟踪内存使用情况、任何CPU阻塞程序、DOM中的元素数量等等。要收集统计信息，您需要单击工具栏上的记录按钮，然后与页面进行交互几秒钟，然后停止录制。性能系统将追踪您选择的所有内容。例如，在[图 10-5](#ch10_image_5)的示例中，您可以看到当用户单击按钮时发生了阻塞操作（请参阅早期的TBT），浏览器在事件处理程序返回之前阻塞了60.92毫秒。
- en: '![](Images/recb_1005.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_1005.png)'
- en: Figure 10-5\. Zooming in to investigate a long-running task
  id: totrans-52
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-5\. 放大以调查长时间运行的任务
- en: The Performance tab gives you all the statistics you are ever likely to want
    when performance tuning. It probably has far more detail than you are ever likely
    to need. For that reason, you might want to install the React Developer Tools,
    which are available for [Chrome](https://oreil.ly/vvCLp) and [Firefox](https://oreil.ly/mw1yn).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 性能选项卡为您提供了在性能调优时可能需要的所有统计数据。它可能包含的细节远远超出您可能需要的范围。因此，您可能希望安装React开发者工具，它们适用于[Chrome](https://oreil.ly/vvCLp)和[Firefox](https://oreil.ly/mw1yn)。
- en: When you install the React Developer Tools, you may find that they cannot run
    in incognito mode by default. It’s worth enabling them to have access (see [Figure 10-6](#ch10_image_6)
    for Chrome and [Figure 10-7](#ch10_image_7) for Firefox).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 安装React开发者工具后，您可能会发现它们默认情况下无法在隐身模式中运行。启用它们是值得的（参见Chrome的[图 10-6](#ch10_image_6)和Firefox的[图 10-7](#ch10_image_7)）。
- en: '![](Images/recb_1006.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_1006.png)'
- en: Figure 10-6\. Enabling React Dev Tools in incognito mode in Chrome
  id: totrans-56
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-6\. 在Chrome的隐身模式中启用React Dev工具
- en: '![](Images/recb_1007.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_1007.png)'
- en: Figure 10-7\. Enabling React Dev Tools in private mode in Firefox
  id: totrans-58
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-7\. 在Firefox的私密模式中启用React Dev工具
- en: In a similar way to the browser’s performance tools, the React Developer Tools
    need you to record a performance session by clicking the Record button in the
    top left of the developer panel (see [Figure 10-8](#ch10_image_8)).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 与浏览器的性能工具类似，React开发者工具需要您通过单击开发者面板左上角的记录按钮来记录性能会话（参见[图 10-8](#ch10_image_8)）。
- en: '![](Images/recb_1008.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_1008.png)'
- en: Figure 10-8\. The React Profiler tab in Chrome DevTools
  id: totrans-61
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-8\. Chrome DevTools中的React Profiler选项卡
- en: Once you have recorded a session, the performance statistics will be displayed
    and related to the React components that rendered the web page. If a component
    took a long time to display, you can hover over it in the performance results
    and see it highlighted on the page (see [Figure 10-9](#ch10_image_9)).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 记录会话后，性能统计数据将显示，并与呈现网页的React组件相关联。如果某个组件显示时间过长，您可以将鼠标悬停在性能结果上，并在页面上看到其高亮显示（请参见[图 10-9](#ch10_image_9)）。
- en: The React Developer Tools are often the best interactive tool to identify the
    underlying cause of a performance issue. But, as ever, you should consider tuning
    performance only if a user or some higher-level tool such as Lighthouse discovers
    that a performance bottleneck exists.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: React开发者工具通常是识别性能问题根本原因的最佳交互工具。但是，如同往常一样，如果用户或像Lighthouse这样的更高级别工具发现存在性能瓶颈，您应该考虑调优性能。
- en: '![](Images/recb_1009.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_1009.png)'
- en: Figure 10-9\. If you hover over a component in the flamegraph, it will be highlighted
    on the page
  id: totrans-65
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-9\. 如果您在火焰图中悬停在一个组件上，它将在页面上被高亮显示
- en: Discussion
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: If you are taking an *essentialist* approach to performance, you should always
    begin in the browser, either by using the application or by using one of the built-in
    tools or extensions we discuss here.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在性能方面采取了“本质主义”的方法，您应该始终从浏览器开始，无论是使用应用程序还是使用我们在此处讨论的内置工具或扩展。
- en: Track Rendering with Profiler
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Profiler跟踪渲染
- en: Problem
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Browser tools provide a wealth of performance detail, and they should always
    be the first place you look to discover the cause of underlying performance problems.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器工具提供了丰富的性能详细信息，它们应该始终是您寻找底层性能问题原因的首选位置。
- en: Once you have identified a problem, it can be helpful to get more detailed performance
    statistics for a small part of the application. The only way to boost performance
    is by gathering actual performance figures before and after a change. That can
    be difficult to do with browser extensions because they will flood you with information
    about everything.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您确定了问题，获取应用程序的某个部分的更详细的性能统计信息可能会有所帮助。在进行更改前后收集实际的性能数据是提升性能的唯一途径。使用浏览器扩展可能会很难做到这一点，因为它们会向您提供关于所有内容的大量信息。
- en: How do we get performance statistics for the part of the application we are
    tuning?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何获取我们正在调优的应用程序部分的性能统计信息？
- en: Solution
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'We are going to use the React `Profiler` component. You can wrap the `Profiler`
    component around any part of your application that you will tune. It will record
    performance statistics whenever React renders it and will tell you several vital
    pieces of information:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用React的`Profiler`组件。您可以将`Profiler`组件包装在您要调优的应用程序的任何部分周围。每当React渲染它时，它将记录性能统计信息，并向您显示几个重要的信息：
- en: '| Statistic | Purpose |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 统计 | 目的 |'
- en: '| --- | --- |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Phase | Whether a mount or an update caused the render |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 阶段 | 是安装还是更新引起了渲染 |'
- en: '| Actual duration | How long the render would take to complete if no internal
    caching was applied |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 实际持续时间 | 如果不应用内部缓存，渲染完成所需的时间 |'
- en: '| Base duration | How long the render took with caching |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 基础持续时间 | 使用缓存进行渲染所花费的时间 |'
- en: '| Start time | The number of milliseconds since the page loaded |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 开始时间 | 页面加载后的毫秒数 |'
- en: '| Commit time | When the results of the render find their way into the browser’s
    DOM |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 提交时间 | 当渲染结果进入浏览器的DOM时 |'
- en: '| Interactions | Any event handlers that we are currently tracing |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 交互 | 我们当前正在跟踪的任何事件处理程序 |'
- en: To see how the `Profiler` component works, let’s start to examine the example
    application you can see in [Figure 10-10](#ch10_image_10).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解`Profiler`组件的工作原理，让我们开始检查您可以在[图 10-10](#ch10_image_10)中看到的示例应用程序。
- en: '![](Images/recb_1010.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_1010.png)'
- en: Figure 10-10\. The example Calendar application
  id: totrans-85
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-10\. 示例日历应用程序
- en: 'This is the code for the `App` component:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`App`组件的代码：
- en: '[PRE2]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The application displays two buttons: one for moving forward a year and one
    for moving back.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序显示两个按钮：一个用于向前移动一年，另一个用于向后移动。
- en: 'We can begin by wrapping the buttons and the calendar component in a `Profiler`
    component:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以首先将按钮和日历组件包装在`Profiler`组件中：
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `Profiler` takes an `id` and a callback function `onRender`. Each time
    the `Profiler` is rendered, it sends back statistics to the `onRender` function.
    So, let’s fill out the details of the `onRender` function a little more:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`Profiler`接受一个`id`和一个回调函数`onRender`。每次`Profiler`被渲染时，它都会将统计信息发送回`onRender`函数。因此，让我们更详细地填写`onRender`函数的细节：'
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `tracker` function will record each of the results from the `Profiler` in
    an array called `renders`. We’ve also added a button to the interface, which will
    display the renders in the console in tabular format whenever we click it.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`tracker`函数将在名为`renders`的数组中记录`Profiler`的每个结果。我们还在界面上添加了一个按钮，每当我们点击它时，它将以表格格式在控制台中显示渲染结果。'
- en: If we reload the page and click the Previous and Next buttons a few times, followed
    by the Stats button, we will see the profile statistics on the console (see [Figure 10-11](#ch10_image_11)).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重新加载页面并点击几次“前进”和“后退”按钮，然后点击“统计”按钮，我们将在控制台上看到概要统计信息（见[图 10-11](#ch10_image_11)）。
- en: The data is in tabular format, which makes it a little easier to read. It also
    means that we can sort by any of the columns. We can also copy the entire table
    and paste it into a spreadsheet for more analysis.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 数据以表格格式呈现，这使得阅读起来稍微容易一些。这还意味着我们可以按任何列排序。我们还可以复制整个表格并将其粘贴到电子表格中进行更多分析。
- en: '![](Images/recb_1011.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_1011.png)'
- en: Figure 10-11\. The render statistics displayed in the JavaScript console
  id: totrans-97
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-11\. JavaScript控制台中显示的渲染统计信息
- en: 'You will notice that the *interactions* column is always an empty array. That’s
    because we are not currently tracking any event handlers or other pieces of code.
    If we want to see which event handlers are currently running during a render,
    we can import a tracing function and wrap it around any piece of code that we
    want to track. For example, this is how we can start to track the user clicking
    the Previous button:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到*交互*列始终是一个空数组。这是因为我们目前没有追踪任何事件处理程序或其他代码片段。如果我们想要查看在渲染过程中当前正在运行的事件处理程序，我们可以导入一个跟踪函数并将其包装在我们想要追踪的任何代码周围。例如，这是我们如何开始跟踪用户点击“上一页”按钮的方式：
- en: '[PRE5]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `trace` function takes a label, a timestamp, and a callback containing the
    code it is tracing. The timestamp could be a date, but it is often better to use
    the milliseconds returned from `performance.now()`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`trace` 函数接受一个标签、一个时间戳和一个包含它正在追踪的代码的回调函数。时间戳可以是一个日期，但通常最好使用从 `performance.now()`
    返回的毫秒数。'
- en: If we reload the web page, click Next a few times, and then click Previous a
    few times, we will start to see the interactions appearing in the table of results
    (see [Figure 10-12](#ch10_image_12)).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重新加载网页，点击几次“下一页”，然后点击几次“上一页”，我们将开始看到这些交互出现在结果表格中（见[图 10-12](#ch10_image_12)）。
- en: '![](Images/recb_1012.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_1012.png)'
- en: Figure 10-12\. Traced interactions are shown as JSON strings within the results
    table
  id: totrans-103
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-12\. 在结果表格中显示跟踪的交互作为 JSON 字符串
- en: 'We stringify the output because `trace` stores interactions as JavaScript sets,
    which often don’t display correctly in the console. Even though the interaction
    data looks truncated in the table, you can still copy the results. Here is the
    example of the data returned by a single trace interaction:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对输出进行字符串化，因为 `trace` 将交互存储为 JavaScript 集合，这些集合通常在控制台中不正确显示。尽管交互数据在表格中看起来被截断，但您仍然可以复制结果。以下是单个跟踪交互返回的数据示例：
- en: '[PRE6]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Discussion
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The `Profiler` component has been in React since version 16.4.3\. The `trace`
    function is still experimental, but it is tremendously powerful. Although we are
    using it for only a simple event handler in our example, it can also provide real-world
    timing for larger pieces of code, such as network requests. React container components
    will often have many network requests “in-flight” during a render, and the `trace`
    function gives you the ability to see what was going on at the time of a particularly
    slow render. It will also give you some idea of how many renders resulted from
    a whole chain of different network processes.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`Profiler` 组件从 React 版本 16.4.3 开始存在。`trace` 函数仍处于实验阶段，但它具有巨大的功能。虽然在我们的示例中仅使用了一个简单的事件处理程序，但它还可以为更大的代码块（例如网络请求）提供真实的时间信息。React
    容器组件在渲染期间通常会有许多正在进行中的网络请求，“trace” 函数使您能够查看在特定慢渲染时发生了什么。它还能让您大致了解多少次渲染是由一整套不同的网络流程链导致的。'
- en: You can download the source for this recipe from the [GitHub site](https://oreil.ly/XhJLR).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[GitHub 网站](https://oreil.ly/XhJLR)下载此示例的源代码。
- en: Create Profiler Unit Tests
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建性能分析单元测试
- en: Problem
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: The React `Profiler` is a powerful tool. It gives you access to the same profiling
    information that is available within the React Developer Tools. It has the advantage
    that you can focus on the code that you are trying to optimize.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: React 的 `Profiler` 是一个强大的工具。它让您可以访问 React 开发者工具中提供的相同性能分析信息。它的优势在于您可以专注于正在尝试优化的代码。
- en: However, it still relies on the interactions that you make with the web page.
    You will want to test performance before and after you make a code change. But
    how can you be sure that the timings you take before and after are measuring the
    same things? If you perform a manual test, how can you guarantee that you will
    perform the same set of actions each time?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它仍然依赖于您与网页的交互。在进行代码更改之前和之后，您会想测试性能。但是如何确保您在之前和之后测量的时间是相同的？如果进行手动测试，如何保证每次执行相同的一组操作？
- en: Solution
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: This recipe will look at how to create unit tests that call the `Profiler` code.
    Automated tests will allow us to create repeatable performance tests that we can
    run to check that any optimizations we make are having a real impact on performance.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 本文将介绍如何创建调用 `Profiler` 代码的单元测试。自动化测试将允许我们创建可重复运行的性能测试，以验证我们所做的任何优化是否真正对性能产生影响。
- en: In a unit test, we can render a React component outside of a web browser because
    the Testing Library provides a headless implementation of the DOM.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元测试中，我们可以在 Web 浏览器之外渲染 React 组件，因为 Testing Library 提供了一个无头 DOM 的实现。
- en: To see how to use the `Profiler`, we will take another look at the example calendar
    application (see [Figure 10-13](#ch10_image_13)).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何使用 `Profiler`，我们将再次查看示例日历应用程序（参见 [图 10-13](#ch10_image_13)）。
- en: '![](Images/recb_1010.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_1010.png)'
- en: Figure 10-13\. The example Calendar application
  id: totrans-118
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-13\. 示例日历应用程序
- en: 'We can add a `Profiler` component to the main code for the `App` component
    and then allow any other code to pass in an `onRender` method that can be used
    to track render performance:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 `Profiler` 组件添加到 `App` 组件的主要代码中，然后允许任何其他代码传递一个 `onRender` 方法，该方法可用于跟踪渲染性能：
- en: '[PRE7]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can also pass the `onRender` function down to child components to track their
    render performance. In the preceding code, we’re passing `onRender` to `YearCalendar`,
    which can then use it in its own `Profiler` component or pass it further down
    the component tree.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将 `onRender` 函数传递给子组件，以跟踪它们的渲染性能。在上述代码中，我们将 `onRender` 传递给 `YearCalendar`，它可以在其自己的
    `Profiler` 组件中使用它，或者将其传递到组件树的更深层次。
- en: You can avoid the need to pass the `onRender` to child components by creating
    a provider component that will inject the `onRender` into the current context.
    We are not doing that here to keep the code simple. But there are various other
    examples using providers elsewhere in the book. For example, see the `SecurityProvider`
    in [“Secure Requests, Not Routes”](ch07.xhtml#ch07-01).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建提供程序组件，可以避免将 `onRender` 传递给子组件并将其注入到当前上下文中。我们这里没有这样做是为了保持代码的简单性。但书中其他地方有各种提供程序的例子。例如，参见
    [“安全请求，而不是路由”](ch07.xhtml#ch07-01) 中的 `SecurityProvider`。
- en: 'The `Profiler` component must be given an `id` property and an `onRender` property.
    When the application is run normally, no `onRender` property will be passed to
    the `App` component, so we need to provide a default function:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`Profiler` 组件必须具有 `id` 属性和 `onRender` 属性。当应用程序正常运行时，`App` 组件不会传递 `onRender`
    属性，因此我们需要提供一个默认函数：'
- en: '[PRE8]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `Profiler` component is relatively lightweight and does not generally slow
    down the application’s performance. If you forget to remove the `Profiler` from
    your code, it won’t matter. The `Profiler` runs only in development mode. It will
    be removed from the code when you create a production build.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`Profiler` 组件相对轻量，通常不会减慢应用程序的性能。如果忘记从代码中移除 `Profiler`，也没有关系。`Profiler` 仅在开发模式下运行。创建生产版本时，将从代码中删除它。'
- en: 'We can now start to build a unit test:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始构建单元测试：
- en: '[PRE9]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Tests that last longer than five seconds are likely to breach the Jest timeout
    limit. The easiest way to avoid this limit is by adding a timeout parameter to
    the `it` function call, as we do here, to set the timeout to 30,000 ms. You will
    need to adjust this value according to the complexity of your test.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 测试时间超过五秒钟可能会违反 Jest 的超时限制。避免此限制的最简单方法是在 `it` 函数调用中添加超时参数，就像我们在这里做的那样，将超时设置为
    30,000 毫秒。您需要根据测试的复杂性调整此值。
- en: When you run this test, an enormous amount of data is captured in the console
    (see [Figure 10-14](#ch10_image_14)).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此测试时，在控制台中会捕获大量数据（参见 [图 10-14](#ch10_image_14)）。
- en: '![](Images/recb_1014.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_1014.png)'
- en: Figure 10-14\. The unit test will capture an enormous amount of rendering information
  id: totrans-131
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-14\. 单元测试将捕获大量的渲染信息
- en: Notably, the test is *repeatable*. It will perform the same actions each time.
    We’ve found that unit tests tend to be far more consistent than code run in the
    browser. Repeated runs of the previous test gave overall times of 2,100 ms +/–
    20 ms. That’s a variation of less than 1%. They also produced exactly 2,653 profile
    scores each time.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，该测试是*可重复*的。每次执行时都会执行相同的操作。我们发现单元测试通常比在浏览器中运行的代码更一致。前一个测试的重复运行总时间为 2,100
    毫秒 +/- 20 毫秒。这个变化小于 1%。它们每次还产生了确切的 2,653 个分析分数。
- en: It’s unlikely that we’d get repeatable results in a browser with a manual test.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中进行手动测试，很难获得可重复的结果。
- en: In the example here, we are simply displaying the capture results. In an actual
    performance situation, you might want to process the results in some way to find
    the average render time of a particular component, for example. Then, when you
    start to tune the component, you can be more confident that any performance gains
    result from actual performance changes rather than variations in the browser’s
    behavior.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里的示例中，我们只是显示捕获的结果。在实际性能情况下，您可能希望以某种方式处理结果，以找到特定组件的平均渲染时间，例如。然后，当您开始调整组件时，可以更有信心地确保任何性能提升都是由于实际性能变化而不是浏览器行为的变化。
- en: Discussion
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Even though we are writing this performance testing code in a Jest unit test,
    it is not a *test* in the same way that a regular functional test is; we are not
    performing any assertions. Assertions can still be helpful,^([2](ch10.xhtml#idm46634382891336))
    but it is not good to write performance tests that assert that some operation
    is faster than a given time. Performance tests are highly dependent upon the environment.
    If you write a test on a development that asserts that something will take less
    than three seconds, you should not be surprised if it fails on an integration
    server, where it took nine seconds.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们在 Jest 单元测试中编写了这段性能测试代码，它并不像常规功能测试那样是一个*测试*；我们没有执行任何断言。断言仍然可能有所帮助，^([2](ch10.xhtml#idm46634382891336))但编写断言某些操作比给定时间快的性能测试并不好。性能测试高度依赖于环境。如果您在开发环境上编写了一个断言某些事情将花费少于三秒的测试，那么如果它在集成服务器上花费了九秒，您不应感到惊讶。
- en: If you do want to track performance automatically, you might consider adding
    regression checks. A regression check will record a set of performance statistics
    in some central repository and record the ID of the environment that produced
    them. You can check that future runs in the same environment are not significantly
    slower than historic runs in the same environment.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您确实想要自动跟踪性能，您可以考虑添加回归检查。回归检查将在某个中央存储库中记录一组性能统计信息，并记录生成这些统计信息的环境的 ID。您可以检查将来在相同环境中运行的速度是否显著慢于在相同环境中历史运行的速度。
- en: In general, though, it is better to report performance results rather than assert
    what you want the performance to be.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，报告性能结果比断言所需的性能更为重要。
- en: You can download the source for this recipe from the [GitHub site](https://oreil.ly/XhJLR).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[GitHub 网站](https://oreil.ly/XhJLR)下载此配方的源代码。
- en: Measure Time Precisely
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 精确测量时间
- en: Problem
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: 'Once you get to the point where you need to optimize quite low-level JavaScript
    code, what should you use to measure performance? You could, for example, use
    the `Date()` function to create a timestamp at the start and end of some JavaScript
    code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您需要优化非常底层的 JavaScript 代码，您应该使用什么来测量性能？例如，您可以使用`Date()`函数在某些 JavaScript 代码的开头和结尾创建时间戳：
- en: '[PRE10]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We can convert each date into milliseconds, so we can see how long it takes
    if we subtract one date from another.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将每个日期转换为毫秒，这样我们就可以看到从一个日期减去另一个日期需要多长时间。
- en: 'This was such a common technique that the `console` object was given to new
    methods called `time` and `timeEnd`, to make the code shorter:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种常见的技术，`console`对象被赋予了称为`time`和`timeEnd`的新方法，以缩短代码：
- en: '[PRE11]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `time` function accepts a label parameter, and if we call `timeEnd` with
    the same label, it displays the results on the console. Let’s run the code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`time`函数接受一个标签参数，如果我们使用相同的标签调用`timeEnd`，它会在控制台上显示结果。让我们运行代码：'
- en: '[PRE12]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: That’s a problem. React applications rarely contain long-running functions,
    so you typically need to optimize small pieces of JavaScript code only if the
    browser calls them many times. For example, you might want to optimize game code
    that is rendering animation on a screen. It can be hard to measure short pieces
    of code because they might run in less than a millisecond. We can’t measure the
    performance with `Date` objects because they resolve down to the millisecond only,
    even though the machine’s internal clock is far more precise than that.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个问题。React 应用程序很少包含长时间运行的函数，因此您通常只需要优化浏览器多次调用它们的小段 JavaScript 代码。例如，您可能希望优化在屏幕上渲染动画的游戏代码。由于短代码片段可能运行时间少于一毫秒，因此很难测量它们的性能。我们不能使用`Date`对象来测量性能，因为它们只能精确到毫秒，即使机器的内部时钟要精确得多。
- en: We need something that we can use for measuring times of less than a millisecond.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些可以用来测量少于一毫秒时间的东西。
- en: Solution
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'We are going to use `performance.now()`. This function call returns a high-resolution
    timestamp measured in fractions of milliseconds. For example, if you open the
    Chrome console and type `performance.now()`, you will see something like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`performance.now()`。此函数调用返回以毫秒分数表示的高分辨率时间戳。例如，如果您打开 Chrome 控制台并键入`performance.now()`，您将看到类似于这样的内容：
- en: '[PRE13]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The time is measured differently from the time in JavaScript dates. JavaScript
    dates measure time from January 1, 1970\. Instead, `performance.now()` measures
    time from when the current web page loaded.^([3](ch10.xhtml#idm46634382807608))
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 与 JavaScript 日期中的时间测量方式不同。JavaScript 日期从 1970 年 1 月 1 日开始测量时间。相反，`performance.now()`从当前网页加载时开始计时。^([3](ch10.xhtml#idm46634382807608))
- en: 'An interesting thing happens if you try to run `performance.now()` inside Firefox:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试在 Firefox 中运行`performance.now()`，会发生一件有趣的事情：
- en: '[PRE14]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: By default, Firefox will return only whole numbers of milliseconds for `performance.now()`,
    effectively removing most of the advantages of using it. Firefox rounds to the
    whole milliseconds because of security. Technically, if JavaScript can time tiny
    amounts of code precisely, this can provide a signature for the browser.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Firefox 仅返回`performance.now()`的整数毫秒部分，有效地删除了使用它的大部分优势。Firefox 四舍五入到整数毫秒，这是出于安全考虑。从技术上讲，如果
    JavaScript 可以精确地计时微小的代码量，这可以为浏览器提供签名。
- en: 'You can enable high-resolution time within Firefox by opening `about:config`,
    searching for the property called `privacy.reduceTimerPrecision`, and setting
    it to `false`. If you do this, you will start to get high-resolution times:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过打开`about:config`，搜索名为`privacy.reduceTimerPrecision`的属性，并将其设置为`false`来在
    Firefox 中启用高分辨率时间。如果您这样做，将开始获得高分辨率时间：
- en: '[PRE15]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Be sure you disable this property if you want to avoid third parties using it
    to track you.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望避免第三方使用它来跟踪您，请确保禁用此属性。
- en: 'To go back to our example code, we can measure the time taken to perform loops
    like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要回到我们的示例代码，我们可以测量执行类似于这样的循环所花费的时间：
- en: '[PRE16]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When we run this code, we see the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行此代码时，我们看到以下结果：
- en: '[PRE17]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: These answers are far more precise and provide more information about the underlying
    performance of JavaScript. In this case, we can see that adding more iterations
    to a loop does not scale linearly, which suggests that the JavaScript engine starts
    to optimize the code on the fly once it realizes that each of the loop iterations
    is the same.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这些答案更为精确，并提供有关 JavaScript 底层性能的更多信息。在这种情况下，我们可以看到向循环添加更多迭代并不会线性扩展，这表明 JavaScript
    引擎在意识到每个循环迭代相同时开始即时优化代码。
- en: Discussion
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: '`performance.now()` has several advantages over JavaScript dates. Aside from
    the additional precision, it is unaffected by clock changes, which is good if
    you decide to add some performance monitoring to long-running code. It also starts
    at zero when the page starts to load, which is useful for optimizing page load
    times.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`performance.now()`相比于 JavaScript 日期具有几个优点。除了额外的精度外，它不受时钟更改的影响，这在决定添加一些性能监控到长时间运行的代码时非常有用。它还会在页面加载时从零开始计时，这对于优化页面加载时间非常有用。'
- en: 'One word of caution when using `performance.now()`: be wary of using it to
    build some higher-level timing function. For example, we once created a simple
    JavaScript generator function to make it a little easier to use `performance.now()`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`performance.now()`时需要注意一点：谨慎使用它来构建某些高级定时功能。例如，我们曾经创建了一个简单的 JavaScript 生成器函数，使使用`performance.now()`变得更容易：
- en: '[PRE18]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This function was created to avoid the need to calculate the difference between
    start and end times. Instead of writing this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 创建此函数是为了避免需要计算开始和结束时间之间差异的需求。而不是写成这样：
- en: '[PRE19]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'we could instead write this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以这样编写：
- en: '[PRE20]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: No need for all of those ugly `before` and `after` variables. The time would
    reset to zero after each call to `t.next().value`, doing away with the need for
    the calculation.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 没有必要使用所有那些丑陋的`before`和`after`变量。每次调用`t.next().value`后时间将重置为零，不再需要计算。
- en: 'The problem? The act of wrapping the `performance.now()` call inside another
    function adds a significant amount of time to the measure, destroying the precision
    of `performance.now()`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，将`performance.now()`调用包装在另一个函数内会显著增加测量时间，从而破坏`performance.now()`的精度：
- en: '[PRE21]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this case, even though it takes only 1.69 ms to run 100,000 loops, the function
    reports the time as over 19 ms.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，即使运行 100,000 次循环仅需 1.69 毫秒，该函数也会报告超过 19 毫秒的时间。
- en: Never hide a call to `performance.now()` inside another function if you want
    it to be accurate.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果希望准确，请勿将对`performance.now()`的调用隐藏在另一个函数中。
- en: You can download the source for this recipe from the [GitHub site](https://oreil.ly/baiOr).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[GitHub 网站](https://oreil.ly/baiOr)下载此配方的源代码。
- en: Shrink Your App with Code Splitting
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用代码拆分来缩小您的应用程序
- en: Problem
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: One of the biggest drains on performance for an SPA is the amount of JavaScript
    code that needs to be downloaded and run. Not only does the JavaScript take time
    to render, but the amount of network bandwidth required can slow your app down
    significantly on devices connected to a mobile network.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: SPA 的性能损耗之一是需要下载和运行的 JavaScript 代码量。 JavaScript 不仅需要时间来渲染，而且所需的网络带宽量可能会显著减慢连接到移动网络的设备上的应用程序速度。
- en: Let’s consider the *synchronized routes* application we used in [Chapter 2](ch02.xhtml#chapter02)
    (see [Figure 10-15](#ch10_image_15)).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑我们在 [第 2 章](ch02.xhtml#chapter02) 中使用的 *同步路由* 应用程序（参见 [图 10-15](#ch10_image_15)）。
- en: '![](Images/recb_1015.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_1015.png)'
- en: Figure 10-15\. The synchronized routes application
  id: totrans-185
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-15\. 同步路由应用程序
- en: 'The example application is tiny, but it contains some quite large JavaScript
    bundles:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 示例应用程序很小，但包含一些相当大的 JavaScript 捆绑包：
- en: '[PRE22]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The largest (*2.4db4d779.chunk.js*) contains the main React framework code,
    and the app-specific code is limited to the small *main.e8a3e1cb.chunk.js* file.
    That means this application is about as small as a React application can be. Most
    React applications will be significantly larger: often totaling 1 Mb in size,
    which will be a significant problem for users on slow connections.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的 (*2.4db4d779.chunk.js*) 包含主要的 React 框架代码，而应用程序特定的代码仅限于小的 *main.e8a3e1cb.chunk.js*
    文件。 这意味着该应用程序几乎是一个 React 应用程序可以达到的最小尺寸。 大多数 React 应用程序通常会更大：通常总计 1 Mb 的大小，这对于使用慢速连接的用户来说将是一个显著问题。
- en: So, what can we do to reduce the size of JavaScript bundles in React?
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在 React 中，我们可以做些什么来减少 JavaScript 捆绑包的大小呢？
- en: Solution
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: We will use *code splitting*, which involves breaking the main code for our
    application into several smaller bundles. The browser will then load these bundles
    *lazily*. A particular bundle will load only when one of the components it contains
    is needed.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 *代码拆分*，它涉及将应用程序的主要代码拆分为几个较小的捆绑包。 然后，浏览器将 *延迟加载* 这些捆绑包。 只有当需要其中一个包含的组件时，才会加载特定的捆绑包。
- en: The example application we are using for this recipe is most certainly *not*
    one that requires code splitting. As with all performance changes, you should
    only really try to split your code if doing so makes a significant change to web
    performance. We will split the code in this application because it will be easier
    to see how it works.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为本示例应用程序使用的应用程序肯定不需要代码拆分。 与所有性能更改一样，只有在拆分代码确实显著改善了 Web 性能时，才应该尝试拆分代码。 我们将在这个应用程序中拆分代码，因为这样做更容易看到它的工作原理。
- en: 'We split code in React with a function called `lazy`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `lazy` 函数在 React 中拆分代码：
- en: '[PRE23]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `lazy` function accepts a factory function, which, when called, will import
    a component. The `lazy` function returns a placeholder component, which will do
    nothing until the browser renders it. The placeholder component will run the factory
    function and dynamically load whichever bundle contains the actual component.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`lazy` 函数接受一个工厂函数，调用时将导入一个组件。 `lazy` 函数返回一个占位符组件，在浏览器渲染它之前什么也不做。 占位符组件将运行工厂函数并动态加载包含实际组件的任何捆绑包。'
- en: 'To see how this works, consider this component from our example application:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这是如何工作的，请考虑我们示例应用程序中的这个组件：
- en: '[PRE24]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The browser will render the `People` and `Offices` components only when the
    user visits a given route. If the application is currently on the path */about/people*,
    the `Offices` component will not render, which means that we could potentially
    delay loading the `Offices` component until later. We can do this with the `lazy`
    function.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户访问特定路由时，浏览器将仅渲染 `People` 和 `Offices` 组件。 如果应用程序当前位于路径 */about/people*，则 `Offices`
    组件将不会渲染，这意味着我们可以推迟加载 `Offices` 组件直至稍后。 我们可以通过 `lazy` 函数实现这一点。
- en: 'We’ll replace the import of the `Offices` component with a call to `lazy`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `Offices` 组件的导入替换为调用 `lazy`：
- en: '[PRE25]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The object now stored in the `Offices` variable will appear to the rest of the
    application as just another component. It’s a lazy placeholder. Internally it
    contains a reference to the factory function, which it will call when the browser
    renders it.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在存储在 `Offices` 变量中的对象将在应用程序的其余部分中显示为另一个组件。 它是一个惰性占位符。 在内部，它包含对工厂函数的引用，在浏览器渲染时将调用该函数。
- en: If we try to refresh the web page, we will see an error (see [Figure 10-16](#ch10_image_16)).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尝试刷新网页，将会看到一个错误（参见 [图 10-16](#ch10_image_16)）。
- en: '![](Images/recb_1016.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_1016.png)'
- en: Figure 10-16\. You will get a lazy loading error if you forget to add a Suspense
    component
  id: totrans-204
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-16\. 如果忘记添加 Suspense 组件，您将收到延迟加载错误
- en: The placeholder will not wait for the actual component to load before returning.
    Instead, it will substitute some other HTML while it is waiting for the actual
    component to load.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 占位符在返回之前不会等待实际组件加载。相反，它会在等待实际组件加载时替换一些其他 HTML。
- en: 'We can set this “loading” interface with the `Suspense` container:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 `Suspense` 容器设置这个“加载”界面：
- en: '[PRE26]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `lazy` placeholder will check its context to find the `fallback` component
    provided by `Suspense`, and it will display this on the page while waiting for
    the additional JavaScript bundle to load.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`lazy` 占位符将检查其上下文，找到由 `Suspense` 提供的 `fallback` 组件，并在等待额外的 JavaScript 包加载时在页面上显示它。'
- en: We are using a simple “Loading…” message here, but there’s no reason why you
    can’t instead show some fake replacement interface to give the impression that
    the new component has loaded before it has. YouTube uses the same technique on
    its front page. When YouTube is loading content, it displays a set of blocks and
    rectangles in place of the videos it’s about to load (see [Figure 10-17](#ch10_image_17)).
    Videos will often take two to three seconds to load, but this technique gives
    the user the impression that they load instantly.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了一个简单的“加载中…”消息，但你完全可以显示一些假的替代界面，以给人一种新组件已加载的假象。YouTube 在其首页也使用了同样的技术。当
    YouTube 加载内容时，它会显示一组块和矩形，代替即将加载的视频（参见[图 10-17](#ch10_image_17)）。视频通常需要两到三秒才能加载完毕，但这种技术让用户感觉它们几乎瞬间加载完成。
- en: '![](Images/recb_1017.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_1017.png)'
- en: Figure 10-17\. YouTube renders a fake front page while loading recommendations
  id: totrans-211
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-17\. YouTube 在加载推荐内容时呈现一个假的首页
- en: In our application, if you refresh the page now, you should see the application
    go back to normal, as shown in [Figure 10-18](#ch10_image_18).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，如果现在刷新页面，你应该看到应用程序恢复正常，就像[图 10-18](#ch10_image_18)所示。
- en: '![](Images/recb_1015.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_1015.png)'
- en: Figure 10-18\. Adding a `Suspense` component removes the error
  id: totrans-214
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-18\. 添加 `Suspense` 组件可以消除错误
- en: Behind the scenes, the Webpack development server will split off the `Offices`
    code into a separate JavaScript bundle.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，Webpack 开发服务器将 `Offices` 代码拆分为一个单独的 JavaScript 捆绑包。
- en: Webpack will also split out the bundles when you generate a build. It will use
    tree shaking to identify which components can safely appear in which JavaScript
    bundles.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当生成构建时，Webpack 还会拆分捆绑包。它将使用 tree shaking 来确定哪些组件可以安全地出现在哪些 JavaScript 捆绑包中。
- en: '*Tree shaking* is a process that recursively analyzes which code files are
    imported by other files, starting from some initial file, such as *index.js*.
    This allows Webpack to avoid adding code into a bundle that is never imported
    by any other code. The calls to `React.lazy` will not be tracked by the tree shaking
    process, and so the lazily loaded code will not be included in the initial JavaScript
    bundle. Webpack will instead run a separate tree shaking process for each lazily
    loaded file, which will result in a large number of small code bundles in the
    production application.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '*Tree shaking* 是一个递归分析代码文件之间导入关系的过程，从某个初始文件（如 *index.js*）开始。这允许 Webpack 避免将从未被任何其他代码导入的代码添加到捆绑包中。`React.lazy`
    的调用不会被 tree shaking 进程跟踪，因此延迟加载的代码不会包含在初始 JavaScript 捆绑包中。相反，Webpack 将为每个延迟加载的文件运行单独的
    tree shaking 进程，这将导致生产应用程序中大量的小代码包。'
- en: 'If we generate a new build and then look at the generated JavaScript code,
    we will now see some extra files:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们生成一个新的构建，然后查看生成的 JavaScript 代码，现在会看到一些额外的文件：
- en: '[PRE27]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Because this is such a small application, this is unlikely to affect the performance,
    but let’s check anyway.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个非常小的应用程序，这不太可能影响性能，但无论如何让我们检查一下。
- en: Loading performance is easiest to check using Chrome’s Lighthouse tool. You
    can see the performance of the original version of this application in [Figure 10-19](#ch10_image_19).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Chrome 的 Lighthouse 工具可以最方便地检查加载性能。你可以在[图 10-19](#ch10_image_19)中看到该应用程序原始版本的性能。
- en: '![](Images/recb_1019.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_1019.png)'
- en: Figure 10-19\. The application’s performance without code splitting
  id: totrans-223
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-19\. 应用程序在不进行代码拆分时的性能
- en: If we add some lazy loading, we do get a slight performance increase, primarily
    because of the time taken to complete the FCP (see [Figure 10-20](#ch10_image_20)).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们添加一些懒加载，性能会有所提升，主要是因为完成 FCP 所需的时间（参见[图 10-20](#ch10_image_20)）。
- en: '![](Images/recb_1020.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_1020.png)'
- en: Figure 10-20\. The application’s performance with code splitting
  id: totrans-226
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-20\. 应用程序在进行代码拆分后的性能
- en: It’s not a massive increase in performance, but it does indicate that you can
    get some benefit from lazy loading even in tiny applications.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是性能上的巨大提升，但它确实表明，即使在小型应用程序中，您也可以从延迟加载中获益。
- en: Discussion
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: All optimizations have a price, but code splitting takes minimal effort to implement,
    and it’s the one that we find we use most often. It will often improve web-vitals
    metrics for FCP and TTI. You should avoid using it too aggressively because the
    framework needs to do more work to download and evaluate each of the scripts.
    But for most reasonably large applications, you will get some immediate benefit
    from splitting the code.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 所有优化都有一个代价，但代码拆分需要最少的实现工作量，并且我们发现这是我们最常用的方法。它通常会改善 FCP 和 TTI 的 Web-vitals 指标。您应该避免过于激进地使用它，因为框架需要下载和评估每个脚本。但对于大多数相当大的应用程序，您将从拆分代码中获得一些即时的好处。
- en: It is often best to split code at the route level. Routes control which components
    are visible and so are a good place to divide the code you need to load now from
    the code you need to load later. It will also mean that if anyone bookmarks a
    location in your application, they will only download the code required for that
    location when they return to it.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 最好在路由级别进行代码拆分。路由控制哪些组件可见，因此是将需要现在加载的代码与需要稍后加载的代码分开的好地方。这也意味着，如果有人在您的应用程序中书签一个位置，当他们返回时，他们只会下载该位置所需的代码。
- en: You can download the source for this recipe from the [GitHub site](https://oreil.ly/Pj2Bu).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 [GitHub 站点](https://oreil.ly/Pj2Bu) 下载此示例的源代码。
- en: Combine Network Promises
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并网络 promises
- en: Problem
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Many React applications make asynchronous network calls, and a lot of application
    lethargy results from waiting for responses to those asynchronous requests. The
    application is probably doing very little during those calls, so the application
    is not busy; it’s just waiting.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 React 应用程序进行异步网络调用，许多应用程序的不活跃结果来自于等待这些异步请求的响应。在这些调用期间，应用程序可能做的事情很少，因此应用程序并不忙碌；它只是在等待。
- en: Over time, client applications have become more complex, and server APIs have
    become simpler. In the case of *serverless* applications, the server APIs are
    so generic that no custom code is required, which leads to an increase in the
    number of API calls that the client code makes.^([4](ch10.xhtml#idm46634381506968))
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，客户端应用程序变得更加复杂，而服务器 API 变得更加简单。在 *无服务器* 应用程序的情况下，服务器 API 如此通用，无需自定义代码，这导致客户端代码发起的
    API 调用数量增加了^([4](ch10.xhtml#idm46634381506968))。
- en: 'Let’s look at an example. We have an application that reads the details of
    several people from a backend API. The server has an end point that, if a browser
    sends a `GET` request to */people/1234*, will return the details of a person with
    the id of 1234\. The developer has written a hook to make these requests:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子。我们有一个应用程序从后端 API 读取几个人的详细信息。服务器有一个端点，如果浏览器发送 `GET` 请求到 */people/1234*，将返回
    id 为 1234 的人的详细信息。开发人员编写了一个 hook 来进行这些请求：
- en: '[PRE28]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The hook is called like this:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 钩子的调用方式如下：
- en: '[PRE29]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The code calls the server for each ID. It waits for each response to complete
    before storing the results in an array. If the API endpoint takes 5 seconds to
    respond, the `usePeopleSlow` hook will take 20 seconds to return all of the data.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码为每个 ID 调用服务器。它在存储结果到数组之前等待每个响应完成。如果 API 端点需要 5 秒来响应，那么 `usePeopleSlow` 钩子将需要
    20 秒才能返回所有数据。
- en: Is there anything we can do to speed things up?
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能做些什么来加快速度吗？
- en: Solution
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: We will combine asynchronous promises so that multiple API requests can be in
    flight at the same time.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将组合异步 promises，以便可以同时进行多个 API 请求。
- en: 'Most asynchronous request libraries work by returning promises. If you wait
    for a promise, it will return the payload of the response. But in the example
    `usePeopleSlow` code earlier, these promises are waited for in sequence:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数异步请求库通过返回 promises 来工作。如果你等待一个 promise，它会返回响应的载荷。但在前面的示例 `usePeopleSlow`
    代码中，这些 promises 是按顺序等待的：
- en: '[PRE30]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The request for the second person is not even sent until the response for the
    first person is received, which is why a 5-second delay results in a 20-second
    response time when we are reading the details of four people.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在收到第一个人的响应之前，第二个人的请求甚至都没有发送，这就是为什么在读取四个人的详细信息时，5 秒延迟会导致 20 秒的响应时间。
- en: There is another way we can do this. We could send the requests without waiting
    and have all of them in-flight simultaneously. We then need to wait for all the
    responses, and when we receive the last one, we can return the data from the hook.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是我们可以这样做。我们可以发送请求而不等待，并同时将它们全部发送出去。然后我们需要等待所有的响应，当我们收到最后一个响应时，我们可以从钩子中返回数据。
- en: You can make parallel requests with a JavaScript function called `Promise.all`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用名为`Promise.all`的JavaScript函数进行并行请求。
- en: 'The `Promise.all` function accepts a list of promises and combines them into
    a single promise. That means we could combine several `get()` calls like this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise.all`函数不仅接受一组Promises，还将它们组合成单个Promise。这意味着我们可以像这样组合多个`get()`调用：'
- en: '[PRE31]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`Promise.all` combines not just promises, but also results. If you wait for
    an array of promises with `Promise.all`, you will receive an array containing
    each of the promises.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise.all`不仅组合Promises，还组合结果。如果您等待一个由`Promise.all`返回的Promise数组，您将收到一个包含每个Promise的数组。'
- en: 'We can now write a new version of the `usePeopleSlow` hook, using `Promise.all`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写`usePeopleSlow`钩子的新版本，使用`Promise.all`：
- en: '[PRE32]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The key to this code is these three lines:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的关键在于这三行：
- en: '[PRE33]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: By *mapping* the `id`s into an array of the promises returned by network requests,
    we can wait for the `Promise.all` result and receive an array of all the responses.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`id`映射为网络请求返回的一组Promise数组，我们可以等待`Promise.all`的结果，并接收所有响应的数组。
- en: 'If you time the two hooks, then `usePeopleFast` will read the details of four
    people in just over five seconds. Effectively, we have made five requests in the
    time taken to make one. In the example application, these were the comparative
    timings of the two versions of the code:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您计时两个钩子，那么`usePeopleFast`将在五秒多的时间内读取四个人的详细信息。事实上，我们已经在一个请求的时间内完成了五次请求。在示例应用程序中，这些是代码两个版本之间的比较时间：
- en: '| Version | Time Taken (ms) |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| 版本 | 耗时（毫秒） |'
- en: '| --- | --- |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| usePeopleSlow | 5000.99999998929 |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| usePeopleSlow | 5000.99999998929 |'
- en: '| usePeopleFast | 20011.224999994738 |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| usePeopleFast | 20011.224999994738 |'
- en: Discussion
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: This approach will significantly improve performance if you have multiple independent
    asynchronous requests. If you make many parallel requests, then the browser, the
    network card, or the server might start to queue responses. However, it will still
    generate a response more rapidly than a series of independent responses.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有多个独立的异步请求，这种方法将显著提高性能。如果您进行了许多并行请求，那么浏览器、网络卡或服务器可能会开始排队响应。但是，它仍然会比一系列独立的响应更快地生成响应。
- en: If you send parallel requests, it will intensify the load on the server, but
    this is unlikely to be a huge issue. First, as we just noted, servers often queue
    requests when they are busy. Second, the server will still be performing the same
    total amount of work. All you are doing is concentrating that work into a shorter
    period.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发送并行请求，将加重服务器的负载，但这不太可能成为一个巨大的问题。首先，正如我们刚刚注意到的那样，服务器在繁忙时通常会排队请求。其次，服务器仍将执行相同数量的工作。您所做的只是将该工作集中到一个较短的时间段内。
- en: You can download the source for this recipe from the [GitHub site](https://oreil.ly/LhVY8).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从[GitHub 网站](https://oreil.ly/LhVY8)下载此示例的源代码。
- en: Use Server-Side Rendering
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用服务器端渲染
- en: Problem
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: SPAs do a great job of making websites as feature-rich as desktop applications.
    If you use an application like Google Docs, the experience is almost indistinguishable
    from using a desktop word processor.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 单页应用（SPA）非常擅长使网站像桌面应用程序一样丰富多彩。如果您使用像谷歌文档这样的应用程序，体验几乎与使用桌面文字处理器无异。
- en: 'But all things come at a price. One of the major performance issues for SPAs
    is that the browser has to download a large bundle of JavaScript code before it
    can build an interface. If you create a React application with a tool like `create-react-app`,
    the only thing you will have in the body of the HTML is an empty `DIV` called
    `root`:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 但是所有的事情都是有代价的。单页应用的一个主要性能问题之一是，浏览器必须在构建界面之前下载大量的JavaScript代码包。如果您使用像`create-react-app`这样的工具创建React应用程序，则HTML正文中唯一的东西是一个名为`root`的空的`DIV`：
- en: '[PRE34]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: That empty `DIV` is all the browser will see until the JavaScript engine downloads
    the code, runs it, and updates the DOM.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 直到JavaScript引擎下载代码、运行并更新DOM之前，浏览器将看到的只是空的`DIV`。
- en: Even if we reduce the bundle size with code splitting and the browser has cached
    the JavaScript, it can still take a couple of seconds to read the code and set
    up the interface.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们通过代码拆分减少包大小并且浏览器已经缓存了JavaScript，读取代码并设置界面仍可能需要几秒钟。
- en: Building the entire interface from JavaScript means that SPAs typically suffer
    from two main issues. First, and most important, the user experience can degrade,
    particularly for large React applications. Second, your application will have
    poor search engine optimization (SEO). Search engine robots will often not wait
    for the JavaScript to render an interface when scanning your site. They will download
    the basic HTML of the page and index its contents. For many business applications,
    this might not matter. But if you are building, say, a shopping site, you will
    probably want as many of the pages indexed as possible to capture passing traffic.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 从JavaScript构建整个界面意味着SPA通常会遇到两个主要问题。首先，最重要的是，用户体验可能会下降，特别是对于大型React应用程序。其次，您的应用程序在搜索引擎优化（SEO）方面将表现不佳。搜索引擎机器人在扫描站点时通常不会等待JavaScript渲染界面。它们将下载页面的基本HTML并索引其内容。对于许多业务应用程序来说，这可能并不重要。但是，如果您正在构建比如购物网站，您可能希望尽可能多地索引页面以捕获流量。
- en: Therefore, it would be helpful if, instead of displaying an empty `DIV` when
    the HTML is loaded, we could begin by including the initial HTML of our page *before*
    the browser downloads and runs the application’s JavaScript.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果在HTML加载时不显示空的`DIV`，而是在浏览器下载并运行应用程序的JavaScript之前包含页面的初始HTML，这将是有帮助的。
- en: Solution
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: We will look at using server-side rendering to replace the empty `DIV` of a
    React page with a prerendered HTML version. We’ll be able to do this because of
    the way that React interacts with the DOM of a web page.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨如何使用服务器端渲染来将React页面的空的`DIV`替换为预渲染的HTML版本。这是因为React与Web页面的DOM交互方式。
- en: 'When you render a component in React, you are not directly updating the DOM.
    Instead, when you run a piece of code like this:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在React中渲染组件时，您并不直接更新DOM。相反，当您运行类似以下代码的一段代码时：
- en: '[PRE35]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: the `render` method updates a virtual DOM, which, at intervals, we will synchronize
    with the actual HTML elements on the page. React does this efficiently, so it
    will only update elements in the real DOM that don’t match the elements in the
    virtual DOM.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`render` 方法会更新虚拟DOM，然后我们会定期将其与页面上的实际HTML元素同步。React会以高效的方式进行此操作，因此它只会更新在实际DOM中与虚拟DOM中不匹配的元素。'
- en: 'Server-side rendering works by rendering not to the React virtual DOM, but
    to a string. When the browser sends a request for the HTML page to the server,
    we will render a version of the React contents to a string and then insert that
    string into the HTML, before returning it to the browser. This means that the
    browser will immediately render HTML of the page before it even starts to download
    the JavaScript of the application. Our server-side code will look something like
    this:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端渲染的工作方式是不将内容渲染到React虚拟DOM，而是渲染到一个字符串。当浏览器向服务器发送HTML页面请求时，我们将把React内容的一个版本渲染为一个字符串，然后将该字符串插入到HTML中，然后返回给浏览器。这意味着浏览器在开始下载应用程序的JavaScript之前会立即渲染页面的HTML。我们的服务器端代码将类似于以下内容：
- en: '[PRE36]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Let’s begin by creating an application with `create-react-app` to see how this
    works in more detail.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先使用 `create-react-app` 创建一个应用程序，以便更详细地了解其工作原理。
- en: 'There are many React tools and frameworks that support server-side rendering.
    `create-react-app` is *not* one of those tools. So looking at how to convert a
    `create-react-app` application will allow us to understand all the steps required
    to enable SSR in React:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多React工具和框架支持服务器端渲染，但 `create-react-app` 不是这些工具之一。因此，查看如何将 `create-react-app`
    应用程序转换为支持SSR的应用程序，将帮助我们理解在React中启用SSR所需的所有步骤：
- en: '[PRE37]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We’ll be building a server to host the SSR code. Let’s start by creating a
    folder for the server code:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个用于托管SSR代码的服务器。让我们首先创建一个服务器代码的文件夹：
- en: '[PRE38]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We’ll build the server using Express. Our server code will be rendering the
    components of our application.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Express构建服务器。我们的服务器代码将渲染应用程序的组件。
- en: 'We’ll need some additional libraries that will be useful when loading the React
    components. In the main application directory (not the *server* subdirectory),
    install the following:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载React组件时，我们将需要一些额外的库。在主应用程序目录中（而不是*server*子目录），安装以下内容：
- en: '[PRE39]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `create-react-app` tool generates code that uses a lot of modern JavaScript
    features that are not available out of the box, so the first thing we’ll need
    to do in our server code is enable those JavaScript features for the server to
    run our React components. Within the new *server* folder, create a file called
    *index.js* and put this into it:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`create-react-app`工具生成的代码使用了许多现代JavaScript特性，这些特性不是开箱即用的，因此我们在服务器代码中需要做的第一件事就是为服务器启用这些JavaScript特性，以便运行我们的React组件。在新的*server*文件夹中创建一个名为*index.js*的文件，并将以下内容放入其中：'
- en: '[PRE40]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This file will configure language features that we are going to use in the server
    code. We’re loading the `preset-react` Babel plugin that is installed automatically
    in every `create-react-app` application. At the end of the script, we load a file
    called *ssr.js*, where we’ll put our main server code.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件将配置我们将在服务器代码中使用的语言特性。我们加载了`preset-react` Babel插件，它会自动安装在每个`create-react-app`应用程序中。在脚本的末尾，我们加载了一个名为*ssr.js*的文件，我们将在其中放置我们的主服务器代码。
- en: 'Create the *server/ssr.js* file and add the following code to it:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 创建*server/ssr.js*文件，并将以下代码添加到其中：
- en: '[PRE41]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Our custom server will work similarly to the development server that comes
    with `create-react-app`. It creates a web server with this line:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的自定义服务器将类似于`create-react-app`提供的开发服务器。它使用以下行创建Web服务器：
- en: '[PRE42]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If the server receives a request for a JavaScript, stylesheet, or image file,
    it will look for the file in the *build* directory. The *build* directory is where
    `create-react-app` generates the deployable version of our application:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器收到对JavaScript、样式表或图像文件的请求，它将在*build*目录中查找文件。*build*目录是`create-react-app`生成的可部署版本的应用程序所在地：
- en: '[PRE43]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If we receive a request for anything else, we will return the contents of the
    *build/index.html* file:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们收到对任何其他内容的请求，我们将返回*build/index.html*文件的内容：
- en: '[PRE44]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, we start the server running on port 8000:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在8000端口上启动服务器：
- en: '[PRE45]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Before we can run this server, we need to build the application. We can do
    this with the following command:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行此服务器之前，我们需要构建应用程序。我们可以使用以下命令来完成这个过程：
- en: '[PRE46]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Building the application generates all of the static files in the *build* directory
    that our server will need. We can now run the server itself:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 构建应用程序将生成所有静态文件，并存放在*build*目录中，这些文件是我们服务器所需的。现在我们可以启动服务器本身：
- en: '[PRE47]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: If we open a browser at *http://localhost:8000*, we will see our React application
    (see [Figure 10-21](#ch10_image_21)).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在*http://localhost:8000*处打开浏览器，我们将看到我们的React应用程序（见[Figure 10-21](#ch10_image_21)）。
- en: '![](Images/recb_0101.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_0101.png)'
- en: Figure 10-21\. The application running on our new server
  id: totrans-309
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-21\. 我们新服务器上运行的应用程序
- en: 'So far, so good. But we aren’t actually doing any server-side rendering. For
    that, we will need to load some React code to load and render the `App` component:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。但实际上我们并没有进行任何服务器端渲染。为此，我们需要加载一些React代码来加载和渲染`App`组件：
- en: '[PRE48]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This new code uses the `renderToString` function from React’s SSR library `react-dom/server`.
    The `renderToString` function does what you would expect. Instead of rendering
    the `App` component into a virtual DOM, it simply renders it into a string. We
    can replace the empty `DIV` in the *index.html* content with the HTML generated
    from the `App` component. If you restart the server and then reload the web browser,
    you will find that the application still works. Mostly (see [Figure 10-22](#ch10_image_22)).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这段新代码使用了React的SSR库`react-dom/server`中的`renderToString`函数。`renderToString`函数会像你期望的那样工作。它不会将`App`组件呈现为虚拟DOM，而是将其呈现为字符串。我们可以用从`App`组件生成的HTML替换*index.html*内容中的空`DIV`。如果重新启动服务器并重新加载Web浏览器，您会发现应用程序仍然可以工作。大部分时间（见[Figure 10-22](#ch10_image_22)）。
- en: '![](Images/recb_1022.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_1022.png)'
- en: Figure 10-22\. The React application showing a broken SVG image
  id: totrans-314
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-22\. React应用程序显示损坏的SVG图像
- en: 'Instead of seeing the rotating React logo, we instead see a broken image symbol.
    We can see what happens if we look at the generated HTML returned by the server:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是看到旋转的React标志，我们看到了一个损坏的图像符号。如果查看服务器返回的生成HTML，我们可以看到发生了什么：
- en: '[PRE49]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Something odd has happened to the `img` element. Instead of rendering an SVG
    image, it tries to load the URL “[object Object].” What’s happening here?
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`img`元素出现了一些奇怪的问题。它没有呈现SVG图像，而是尝试加载URL“[object Object]”。这里发生了什么？'
- en: 'In the React code, we are loading the logo like this:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在React代码中，我们像这样加载标志：
- en: '[PRE50]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This code relies on some Webpack configuration from `create-react-app`. When
    you access the application through the development server, Webpack will use a
    library called *svgr* to replace any imports of SVG files with generated React
    components that contain the raw SVG contents. *svgr* allows SVG images to be loaded
    just like any other React components. That’s what allows us to import them as
    we might import a *.js* file.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码依赖于`create-react-app`的一些Webpack配置。当您通过开发服务器访问应用程序时，Webpack将使用一个称为*svgr*的库，将SVG文件的任何导入替换为包含原始SVG内容的生成的React组件。*svgr*允许像导入*.js*文件一样导入SVG图像。
- en: 'However, in our hand-built server, we have no such Webpack configuration. Instead
    of going to the trouble of configuring Webpack, we can avoid the problem by copying
    the *logo.svg* file to the *public* folder and then changing the code in the `App`
    component to the following:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在我们手动构建的服务器上，我们没有这样的Webpack配置。我们可以通过将*logo.svg*文件复制到*public*文件夹中，然后更改`App`组件中的代码来避免配置Webpack的麻烦：
- en: '[PRE51]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'If we now rebuild the application and restart the server:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在重新构建应用程序并重新启动服务器：
- en: '[PRE52]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: the SSR application will display the application correctly (see [Figure 10-23](#ch10_image_23)).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: SSR应用程序将正确显示应用程序（参见[图 10-23](#ch10_image_23)）。
- en: '![](Images/recb_0101.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_0101.png)'
- en: Figure 10-23\. The application now displays the SVG image correctly
  id: totrans-327
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-23\. 应用程序现在正确显示SVG图像
- en: 'There is actually just one step left, which we should implement. In the *src/index.js*
    file, we render the single-page version of the application like this:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，还有最后一步需要实现。在*src/index.js*文件中，我们像这样渲染应用程序的单页版本：
- en: '[PRE53]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Remember, this code will still run, even when we access our application through
    the SSR server. The browser will download the prerendered version of the web page,
    and it will then download the JavaScript for the SPA. When the SPA code runs,
    it will execute the preceding code from *index.js*. The browser still needs to
    load and run the JavaScript to make the interface interactive. The `ReactDOM.render`
    method may replace all of our prerendered HTML when it doesn’t need to. So if
    we replace the call to `ReactDOM.render` with `ReactDOM.hydrate`, we will only
    replace the HTML in the DOM if it is different from the HTML in the virtual DOM.
    For our server-side rendered page, the content of the static web page and the
    content of the virtual DOM should be the same. The result is that `hydrate` will
    not update the elements on the page; it will just attach a set of event listeners
    to make the page interactive.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，即使通过SSR服务器访问我们的应用程序，此代码仍将运行。浏览器将下载预渲染版本的网页，然后再下载SPA的JavaScript。当SPA代码运行时，它将执行*index.js*中的前述代码。浏览器仍然需要加载和运行JavaScript才能使界面交互。当不需要时，`ReactDOM.render`方法可能会替换所有我们的预渲染HTML。因此，如果我们将调用`ReactDOM.render`替换为`ReactDOM.hydrate`，那么只有在DOM中的HTML与虚拟DOM中的HTML不同时，才会替换HTML。对于我们的服务器端渲染页面，静态网页的内容和虚拟DOM的内容应该是相同的。结果是，`hydrate`不会更新页面上的元素；它只会附加一组事件监听器以使页面交互。
- en: So, we now have a server-side rendered application. But has it made the page
    load any faster?
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在有了一个服务器端渲染的应用程序。但这是否使页面加载速度更快了？
- en: The simplest way to test page load time is to run a Lighthouse performance audit
    within Chrome. Lighthouse, remember, performs a basic audit of a web page, checking
    performance, accessibility, and a bunch of other features. It will give us a metric
    that we can use to compare the two versions of the application.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 测试页面加载时间的最简单方法是在Chrome中运行Lighthouse性能审计。请记住，Lighthouse执行网页的基本审计，检查性能、可访问性和一些其他功能。它将给我们一个指标，我们可以用来比较应用程序的两个版本。
- en: When we tried this on a development laptop when accessing the ordinary React
    development server that comes bundled with `create-react-app`, we got a performance
    grade of 91 out of 100 and a *first contentful paint* (FCP) time of 1.2 seconds
    (see [Figure 10-24](#ch10_image_24)).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在开发笔记本上尝试时，通过访问`create-react-app`捆绑的普通React开发服务器，我们获得了91分的性能评分和*首次内容绘制*（FCP）时间为1.2秒（参见[图 10-24](#ch10_image_24)）。
- en: '![](Images/recb_1024.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_1024.png)'
- en: Figure 10-24\. Base performance of the application, without server-side rendering
  id: totrans-335
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-24\. 应用程序的基本性能，不包括服务器端渲染
- en: That’s not a bad performance score. But we are running a small React application.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是一个糟糕的性能评分。但我们运行的是一个小型React应用程序。
- en: What happens when we test the SSR version of the application? After all, the
    server will still have to spend some time rendering the React code. Will it run
    any faster? You can see the results of our test in [Figure 10-25](#ch10_image_25).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们测试应用程序的SSR版本时会发生什么？毕竟，服务器仍然需要花费一些时间来渲染React代码。它会运行得更快吗？您可以在[图10-25](#ch10_image_25)中查看我们的测试结果。
- en: 'The overall score has increased to 99 out of 100\. The time to FCP has dropped
    to 0.6 seconds: half that of our original version. Also, if you load the original
    SPA version of the application in a browser and keep hitting Refresh, you will
    see the page will often flash white for a moment before rendering the web page.
    The flash occurs because the downloaded HTML is just an empty `DIV`, which the
    browser displays as a white page before the JavaScript can render the application.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 总体分数已提高到100分中的99分。FCP时间降至0.6秒：是原始版本的一半。此外，如果您在浏览器中加载应用程序的原始SPA版本并不断点击刷新按钮，您会看到页面在渲染网页之前经常会闪白屏。闪白屏是因为下载的HTML只是一个空的`DIV`，浏览器在JavaScript渲染应用程序之前将其显示为白色页面。
- en: '![](Images/recb_1025.png)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_1025.png)'
- en: Figure 10-25\. Performance of the application with server-side rendering
  id: totrans-340
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-25\. 应用程序的服务器端渲染性能
- en: Compare that to the SSR version of the application. If you keep hitting Refresh
    on the SSR version, the only thing you should notice is that the rotation of the
    logo keeps resetting. You will see almost no flashing.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 将其与应用程序的SSR版本进行比较。如果您在SSR版本上不断点击刷新按钮，您唯一会注意到的是徽标的旋转会不断重置。您几乎看不到任何闪烁。
- en: Even though there is still a render process occurring on the server, the time
    needed to render a string version of the HTML is less than the time needed to
    render the same set of DOM elements.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 即使服务器仍然会发生渲染过程，但生成HTML字符串所需的时间比渲染相同一组DOM元素所需的时间少。
- en: Discussion
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: In this recipe, we have taken you through the basics of how you might set up
    basic server-side rendering for your application. The details for *your* application
    are likely to vary quite a lot, dependent upon which additional libraries your
    application uses.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们已经介绍了如何为应用程序设置基本的服务器端渲染的基础知识。对于*您的*应用程序，具体细节可能会因应用程序使用的附加库而有所不同。
- en: 'Most React applications use some form of routing, for example. If you are using
    `react-router`, then you will need to add some additional code on the server side
    to handle the fact that different components will need to be rendered, based upon
    the path that the browser has requested. For example, we can use the `StaticRouter`
    from `react-router` like this:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数React应用程序都使用某种形式的路由，例如。如果您使用`react-router`，那么您需要在服务器端添加一些额外的代码来处理浏览器请求的路径不同而需要渲染不同组件的情况。例如，我们可以像这样使用`react-router`中的`StaticRouter`：
- en: '[PRE54]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `StaticRouter` renders its child components for a single, specific route.
    In this case, we use the `originalURL` route from the browser request. If the
    browser asks for */person/1234*, the `StaticRouter` will render the `App` component
    for this route. Notice that we can also use the `StaticRouter` to pass any additional
    context for the rest of the application. We could use the context to pass content
    to the rest of the application.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`StaticRouter`为单个特定路由渲染其子组件。在这种情况下，我们使用浏览器请求的`originalURL`路由。如果浏览器请求*/person/1234*，`StaticRouter`将为此路由渲染`App`组件。请注意，我们还可以使用`StaticRouter`传递任何其他上下文以供应用程序其余部分使用。'
- en: If you are using code splitting in your application with `React.lazy`, you need
    to be aware that this will not work on the server side. Fortunately, there is
    a workaround. The [Loadable Components](https://oreil.ly/v8zan) library does the
    same job as `React.lazy`, but it can also run on the server side. Therefore, Loadable
    Components gives you all of the advantages of server-side rendering with all the
    benefits of code splitting.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在应用程序中使用了`React.lazy`进行代码拆分，您需要注意这在服务器端是无法工作的。幸运的是，有一个解决方法。[Loadable Components](https://oreil.ly/v8zan)库与`React.lazy`完成相同的工作，但也可以在服务器端运行。因此，Loadable
    Components为您提供了服务器端渲染的所有优势以及代码拆分的所有好处。
- en: As with all optimizations, there is a price to pay with server-side rendering.
    It will require additional complexity in your code, and it will also require additional
    load on your server. You can deploy an SPA as static code on any web server. That’s
    not true for server-side rendered code. It will need a JavaScript server and may
    well increase your cloud hosting costs.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 就像所有优化一样，服务器端渲染是有代价的。它将需要在您的代码中增加复杂性，并且还将增加服务器的额外负载。您可以将SPA部署为任何Web服务器上的静态代码。而对于服务器端渲染的代码，则不是这样。它将需要一个JavaScript服务器，并可能增加您的云托管成本。
- en: Also, if you know from the outset that you want to use server-side rendering
    for your application, you should probably consider a tool like Razzle or Next.js
    for your application and build server-side rendering from day one.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您从一开始就知道要为应用程序使用服务器端渲染，那么您应该考虑使用工具如Razzle或Next.js，并从第一天开始构建服务器端渲染。
- en: Finally, there are alternative approaches to SSR that can boost the performance
    of your web page without the need for server-side rendering. Consider using Gatsby.
    Gatsby can prerender your pages at *build time*, giving you many of the advantages
    of SSR without needing server-side code.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有替代的SSR方法可以提升网页性能，而无需服务器端渲染。考虑使用Gatsby。 Gatsby可以在*构建时*预渲染页面，带来了许多SSR的优点，而无需服务器端代码。
- en: You can download the source for this recipe from the [GitHub site](https://oreil.ly/Mfzex).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[GitHub站点](https://oreil.ly/Mfzex)下载此配方的源代码。
- en: Use Web Vitals
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Web Vitals
- en: Problem
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: It is more important to have code that works and is readable than it is to have
    highly tuned code. Tuning, as we’ve seen, always comes with an associated cost.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有运行良好且可读性高的代码比高度调整的代码更为重要。正如我们所看到的，调整总是伴随着相关的成本。
- en: But if there *are* noticeable performance issues, it is essential to become
    aware of them and fix them as quickly as possible. Much of the Internet relies
    upon *passing trade*. If people go to your website and it doesn’t immediately
    respond, they may leave and never return.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果存在显著的性能问题，必须尽快意识到并尽快修复。互联网的很多依赖于*经过的交易*。如果人们访问您的网站，但它不立即响应，他们可能会离开并永远不会回来。
- en: Developers often track server performance using trackers—known as *beacons*—embedded
    within the code. If there’s a performance issue, the beacons can generate an alert,
    and the developer can fix the problem before it affects a lot of users.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员通常使用内嵌在代码中的*信标*跟踪服务器性能。如果存在性能问题，这些信标可以生成警报，开发人员可以在影响大量用户之前修复问题。
- en: But how do we embed a tracking beacon into our client code?
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们如何在客户端代码中嵌入跟踪信标呢？
- en: Solution
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: We’re going to look at how to track *web vitals*. We mentioned web vitals in
    [“Use Browser Performance Tools”](#ch10-01). They are a small set of metrics that
    measure your application’s most important performance features, such as the *Cumulative
    Layout Shift* (CLS), which measures how much your application jumps around when
    it first loads.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看看如何跟踪*Web vitals*。我们在[“使用浏览器性能工具”](#ch10-01)中提到了Web vitals。它们是衡量您应用程序最重要的性能特征的一小组指标，例如*累计布局转移*（CLS），它衡量的是应用程序首次加载时的跳动程度。
- en: Several tools, such as the Lighthouse Chrome extension, track web vitals. The
    name *web vitals* is intended to remind you of vital signs, like heart rate and
    blood pressure, because they tell you about an underlying issue that you need
    to address.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如Lighthouse Chrome扩展程序之类的多种工具用于跟踪Web关键性能指标。 *Web vitals* 这个名字旨在提醒您关注关键指标，如心率和血压，因为它们告诉您需要解决的潜在问题。
- en: 'If you created your application with `create-react-app`, you probably already
    have code embedded that can automatically track the web vitals of your application.
    If you look in the *src/index.js* file, you will see a call to report the web
    vitals at the end:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用`create-react-app`创建应用程序，可能已经嵌入了自动跟踪应用程序Web vitals的代码。如果查看*src/index.js*文件，您将看到在末尾调用报告Web
    vitals的代码：
- en: '[PRE55]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `reportWebVitals` function can be given a callback function that can be
    used to track the various metrics while the application is running. For example,
    if you pass it `console.log`:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '`reportWebVitals`函数可以接受一个回调函数，该函数在应用程序运行时用于跟踪各种度量指标。例如，如果将`console.log`传递给它：'
- en: '[PRE56]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: you will then see metrics appearing in your JavaScript console as a series of
    JSON objects (see [Figure 10-26](#ch10_image_26)).
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您将在JavaScript控制台中看到度量指标以一系列JSON对象的形式出现（参见[图 10-26](#ch10_image_26)）。
- en: '![](Images/recb_1026.png)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_1026.png)'
- en: Figure 10-26\. The web vitals in the JavaScript console
  id: totrans-368
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-26\. JavaScript控制台中的Web vitals
- en: 'This is not really how you are intended to track web vitals. A better option
    is to send the data back to some backend store. For example, you might choose
    to `POST` them to send API endpoint:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是跟踪Web Vital的预期方式。更好的选择是将数据发送回某些后端存储。例如，您可以选择将它们`POST`到发送API端点：
- en: '[PRE57]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Many browsers have a built-in function that is intended for use when recording
    vital measurements. The browser will cancel normal network requests, such as those
    made by calling `fetch`, if the user leaves the page. Given that the most important
    web vitals happen when the page loads, it would be a pity to lose these metrics.
    For that reason, you should consider using the `navigator.sendBeacon` function
    when it’s available:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 许多浏览器都有内置功能，用于记录关键测量。如果用户离开页面，浏览器将取消正常的网络请求，例如通过调用`fetch`发出的请求。考虑到页面加载时最重要的Web
    Vital，如果失去这些指标将是一种遗憾。因此，在可用时应考虑使用`navigator.sendBeacon`函数：
- en: '[PRE58]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: If the user briefly opens the page and then goes elsewhere, the `navigator.sendBeacon`
    will be allowed to complete its `POST` request before dying.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户打开页面后立即离开，`navigator.sendBeacon`将允许完成其`POST`请求再终止。
- en: Discussion
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: There are commercial tracking services available that you can use to record
    web vitals, such as [sentry.io](https://sentry.io). If you have a performance
    monitoring system installed, you might also be able to wire it up using web vitals
    to provide additional performance monitoring for your system.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 有商业跟踪服务可用于记录Web Vital，例如[sentry.io](https://sentry.io)。如果已安装性能监控系统，则可能还能够通过Web
    Vital来提供额外的性能监控。
- en: Finally, consider tracking web vitals with Google Analytics as described on
    the [`create-react-app` site](https://oreil.ly/wImZt).
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，考虑像在[`create-react-app` site](https://oreil.ly/wImZt)中描述的那样使用Google Analytics跟踪Web
    Vital指标。
- en: ^([1](ch10.xhtml#idm46634384214840-marker)) See [“Shrink Your App with Code
    Splitting”](#ch10-05).
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch10.xhtml#idm46634384214840-marker)) 请参阅[“使用代码分割来缩小您的应用程序”](#ch10-05)。
- en: ^([2](ch10.xhtml#idm46634382891336-marker)) For example, by checking that the
    component is in a particular state before performing some action.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch10.xhtml#idm46634382891336-marker)) 例如，在执行某些操作之前，先检查组件是否处于特定状态。
- en: ^([3](ch10.xhtml#idm46634382807608-marker)) If you run it in Node, `performance.now()`
    measures the time from the start of the current process.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch10.xhtml#idm46634382807608-marker)) 如果在Node中运行，`performance.now()`将从当前进程的启动时间开始计时。
- en: ^([4](ch10.xhtml#idm46634381506968-marker)) An exception to this is in the case
    of GraphQL services. In GraphQL, the client can make a complex query to the backend,
    and a standardized query resolver will “stitch together” the results of low-level
    queries on the server. GraphQL can produce faster network responses without needing
    to tune the client.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch10.xhtml#idm46634381506968-marker)) 这在GraphQL服务的情况下有一个例外。在GraphQL中，客户端可以向后端发出复杂查询，标准化的查询解析器将在服务器上将低级查询的结果“拼接”在一起。GraphQL可以生成更快的网络响应，而无需调整客户端。
