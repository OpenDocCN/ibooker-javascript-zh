- en: Chapter 3\. Type Inference
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章. 类型推断
- en: 'For programming languages used in industry, “statically typed” and “explicitly
    typed” have traditionally been synonymous. C, C++, Java: they all made you write
    out your types. But academic languages never conflated these two things: languages
    like ML and Haskell have long had sophisticated type inference systems, and in
    the past decade this has begun to work its way into industry languages. C++ has
    added `auto`, and Java has added `var`.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在工业中使用的编程语言，“静态类型”和“显式类型”传统上是同义的。C、C++、Java：它们都要求你明确地写出你的类型。但学术语言从未将这两个概念混为一谈：像
    ML 和 Haskell 这样的语言长期以来就有复杂的类型推断系统，并且在过去的十年中开始渗透到工业语言中。C++ 添加了 `auto`，Java 添加了
    `var`。
- en: TypeScript makes extensive use of type inference. Used well, this can dramatically
    reduce the number of type annotations your code requires to get full type safety.
    One of the easiest ways to tell a TypeScript beginner from a more experienced
    user is by the number of type annotations. An experienced TypeScript developer
    will use relatively few annotations (but use them to great effect), while a beginner
    may drown their code in redundant type annotations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 广泛使用类型推断。合理使用它可以显著减少代码中所需的类型注释。要从一个 TypeScript 初学者和经验丰富的用户中区分开来，最简单的方法之一就是看类型注释的数量。一个有经验的
    TypeScript 开发者会使用相对较少的注释（但用得很有效），而初学者可能会在代码中大量使用冗余的类型注释。
- en: This chapter shows you some of the problems that can arise with type inference
    and how to fix them. After reading it, you should have a good understanding of
    how TypeScript infers types, when you still need to write type declarations, and
    when it’s a good idea to write type declarations even when a type can be inferred.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向你展示了类型推断可能出现的问题以及如何解决。阅读完本章后，你应该对 TypeScript 如何推断类型、仍需编写类型声明的时机以及在可以推断类型时编写类型声明是否明智有了深刻的理解。
- en: 'Item 19: Avoid Cluttering Your Code with Inferable Types'
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'Item 19: 避免用可推断的类型使你的代码杂乱无章'
- en: The first thing that many new TypeScript developers do when they convert a codebase
    from JavaScript is fill it with type annotations. TypeScript is about *types*,
    after all! But in TypeScript many annotations are unnecessary. Declaring types
    for all your variables is counterproductive and is considered poor style.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个代码库从 JavaScript 转换为 TypeScript 时，许多新的 TypeScript 开发者会做的第一件事就是用类型注释填充它。毕竟，TypeScript
    是关于*类型*的！但在 TypeScript 中，许多注释都是不必要的。为所有变量声明类型是适得其反的，也被认为是不良风格。
- en: 'Don’t write:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 不要写：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Instead, just write:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，只需写：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you mouse over `x` in your editor, you’ll see that its type has been inferred
    as `number` (as shown in [Figure 3-1](#efts-3in1)).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在编辑器中将鼠标悬停在`x`上，你会发现它的类型被推断为`number`（如图 [3-1](#efts-3in1) 所示）。
- en: '![efts 03in01](assets/efts_03in01.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![efts 03in01](assets/efts_03in01.png)'
- en: Figure 3-1\. A text editor showing that the inferred type of x is number.
  id: totrans-12
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-1. 一个文本编辑器显示了 x 的推断类型为 number。
- en: The explicit type annotation is redundant. Writing it just adds noise. If you’re
    unsure of the type, you can check it in your editor.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 显式类型注释是多余的。额外添加它只会增加噪音。如果你对类型不确定，可以在编辑器中检查它。
- en: 'TypeScript will also infer the types of more complex objects. Instead of:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 还可以推断出更复杂对象的类型。而不是：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'you can just write:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以简单地写：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Again, the types are exactly the same. Writing the type in addition to the value
    just adds noise here. ([Item 21](#widening) has more to say on the types inferred
    for object literals.)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这些类型完全相同。在这里除了值之外再写上类型只会增加噪音。([Item 21](#widening) 进一步讨论了对象字面量的类型推断。)
- en: 'What’s true for objects is also true for arrays. TypeScript has no trouble
    figuring out the return type of this function based on its inputs and operations:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数组来说，对象的情况也是如此。TypeScript 没有任何问题来基于其输入和操作来推断此函数的返回类型：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'TypeScript may infer something more precise than what you expected. This is
    generally a good thing. For example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 可能会推断出比你预期的更精确的内容。这通常是件好事。例如：
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`"y"` is a more precise type for the `axis` variable. [Item 21](#widening)
    gives an example of how this can fix a type error.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`"y"`对于`axis`变量来说是更精确的类型。[Item 21](#widening) 提供了一个示例，展示了如何修复类型错误。'
- en: 'Allowing types to be inferred can also facilitate refactoring. Say you have
    a `Product` type and a function to log it:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 允许类型被推断也有助于重构。假设你有一个`Product`类型和一个用于记录它的函数：
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'At some point you learn that product IDs might have letters in them in addition
    to numbers. So you change the type of `id` in `Product`. Because you included
    explicit annotations on all the variables in `logProduct`, this produces an error:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，你发现产品ID可能除了数字外还包含字母。因此，你改变了`Product`中`id`的类型。因为你在`logProduct`中的所有变量上都包含了显式注释，这导致了一个错误：
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Had you left off all the annotations in the `logProduct` function body, the
    code would have passed the type checker without modification.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在`logProduct`函数体中省略了所有注释，代码将通过类型检查器而不需要修改。
- en: 'A better implementation of `logProduct` would use destructuring assignment
    ([Item 58](ch08.html#write-modern-js)):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的`logProduct`实现会使用解构赋值（[Item 58](ch08.html#write-modern-js)）：
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This version allows the types of all the local variables to be inferred. The
    corresponding version with explicit type annotations is repetitive and cluttered:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本允许推断所有局部变量的类型。相应的带有显式类型注释的版本是重复的和混乱的：
- en: '[PRE9]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Explicit type annotations are still required in some situations where TypeScript
    doesn’t have enough context to determine a type on its own. You have seen one
    of these before: function parameters.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些情况下，TypeScript仍然需要显式的类型注释，因为它没有足够的上下文来自动确定类型。你之前见过其中之一：函数参数。
- en: Some languages will infer types for parameters based on their eventual usage,
    but TypeScript does not. In TypeScript, a variable’s type is generally determined
    when it is first introduced.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言会根据参数的最终使用情况推断类型，但TypeScript不会。在TypeScript中，变量的类型通常在首次引入时确定。
- en: Ideal TypeScript code includes type annotations for function/method signatures
    but not for the local variables created in their bodies. This keeps noise to a
    minimum and lets readers focus on the implementation logic.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 理想的TypeScript代码包括函数/方法签名的类型注释，但不包括在其主体中创建的局部变量。这样可以将噪音降到最低，让读者专注于实现逻辑。
- en: 'There are some situations where you can leave the type annotations off of function
    parameters, too. When there’s a default value, for example:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一些情况下，你可以省略函数参数的类型注释。例如，当有默认值时：
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here the type of `base` is inferred as `number` because of the default value
    of `10`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这里`base`的类型被推断为`number`，因为默认值为`10`。
- en: 'Parameter types can usually be inferred when the function is used as a callback
    for a library with type declarations. The declarations on `request` and `response`
    in this example using the express HTTP server library are not required:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数被用作带有类型声明的库的回调时，参数类型通常可以被推断。在这个使用express HTTP服务器库的例子中，`request`和`response`上的声明是不需要的：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[Item 26](#context-inference) goes into more depth on how context is used in
    type inference.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[Item 26](#context-inference)更深入地探讨了上下文在类型推断中的使用。'
- en: There are a few situations where you may still want to specify a type even where
    it can be inferred.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些情况下，即使类型可以被推断，你仍然可能想要指定一个类型。
- en: 'One is when you define an object literal:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一种情况是当你定义一个对象字面量时：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When you specify a type on a definition like this, you enable excess property
    checking ([Item 11](ch02_split_001.html#excess-property-checking)). This can help
    catch errors, particularly for types with optional fields.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在定义中指定类型时，你启用了多余属性检查（[Item 11](ch02_split_001.html#excess-property-checking)）。这可以帮助捕捉错误，特别是对于具有可选字段的类型。
- en: 'You also increase the odds that an error will be reported in the right place.
    If you leave off the annotation, a mistake in the object’s definition will result
    in a type error where it’s used, rather than where it’s defined:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你还增加了错误报告在正确位置的几率。如果省略注释，对象定义中的错误将导致类型错误在使用它的地方而不是定义它的地方报告：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With an annotation, you get a more concise error in the place where the mistake
    was made:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用注释，你可以在错误发生的地方得到更简洁的错误提示：
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Similar considerations apply to a function’s return type. You may still want
    to annotate this even when it can be inferred to ensure that implementation errors
    don’t leak out into uses of the function.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的考虑也适用于函数的返回类型。即使可以推断出类型，你可能仍然想要注释这一点，以确保实现错误不会泄漏到函数的使用中。
- en: 'Say you have a function which retrieves a stock quote:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个用于获取股票报价的函数：
- en: '[PRE15]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You decide to add a cache to avoid duplicating network requests:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你决定添加一个缓存以避免重复的网络请求：
- en: '[PRE16]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'There’s a mistake in this implementation: you should really be returning `Promise.resolve(cache[ticker])`
    so that `getQuote` always returns a Promise. The mistake will most likely produce
    an error…but in the code that calls `getQuote`, rather than in `getQuote` itself:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中有一个错误：你应该真正返回 `Promise.resolve(cache[ticker])` 以确保 `getQuote` 总是返回一个 Promise。这个错误很可能会产生一个错误...
    但是在调用 `getQuote` 的代码中，而不是在 `getQuote` 本身：
- en: '[PRE17]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Had you annotated the intended return type (`Promise<number>`), the error would
    have been reported in the correct place:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经注释了预期的返回类型（`Promise<number>`），错误将会在正确的位置报告：
- en: '[PRE18]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When you annotate the return type, it keeps implementation errors from manifesting
    as errors in user code. (See [Item 25](#use-async-await) for a discussion of async
    functions, which are an effective way to avoid this specific error with Promises.)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当你注释返回类型时，它可以防止实现错误表现为用户代码中的错误（请参阅 [条目 25](#use-async-await) 讨论 async 函数，这是避免与
    Promise 相关特定错误的有效方法）。
- en: 'Writing out the return type may also help you think more clearly about your
    function: you should know what its input and output types are *before you implement
    it*. While the implementation may shift around a bit, the function’s contract
    (its type signature) generally should not. This is similar in spirit to test-driven
    development (TDD), in which you write the tests that exercise a function before
    you implement it. Writing the full type signature first helps get you the function
    you want, rather than the one the implementation makes expedient.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 写出返回类型还可以帮助你更清晰地思考你的函数：在实现之前，你应该知道它的输入和输出类型是什么。虽然实现可能会有些变化，但函数的契约（其类型签名）通常不应该改变。这与测试驱动开发（TDD）的精神类似，即在实现之前编写测试来测试一个函数。首先写出完整的类型签名有助于获得你想要的函数，而不是实现使其变得方便的函数。
- en: 'A final reason to annotate return values is if you want to use a named type.
    You might choose not to write a return type for this function, for example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注释返回值的最后一个原因是，如果你想使用一个命名类型。例如，你可能选择不为这个函数写返回类型：
- en: '[PRE19]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'TypeScript infers the return type as `{ x: number; y: number; }`. This is compatible
    with `Vector2D`, but it may be surprising to users of your code when they see
    `Vector2D` as a type of the input and not of the output (as shown in [Figure 3-2](#efts-03in02)).'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 'TypeScript 推断返回类型为 `{ x: number; y: number; }`。这与 `Vector2D` 兼容，但当用户看到 `Vector2D`
    作为输入类型而不是输出类型时（如 [图 3-2](#efts-03in02) 所示），可能会感到惊讶。'
- en: '![efts 03in02](assets/efts_03in02.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![efts 03in02](assets/efts_03in02.png)'
- en: Figure 3-2\. The parameters to the add function have named types, while the
    inferred return value does not.
  id: totrans-65
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-2\. `add` 函数的参数有命名类型，而推断的返回值没有。
- en: If you annotate the return type, the presentation is more straightforward. And
    if you’ve written documentation on the type ([Item 48](ch06.html#use-tsdoc)) then
    it will be associated with the returned value as well. As the complexity of the
    inferred return type increases, it becomes increasingly helpful to provide a name.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你给返回类型加上注释，演示就会更加直观。如果你在类型的文档中写了文档（[条目 48](ch06.html#use-tsdoc)），那么它也将与返回值关联起来。随着推断的返回类型复杂性增加，提供一个名称将变得越来越有帮助。
- en: If you are using a linter, the eslint rule `no-inferrable-types` (note the variant
    spelling) can help ensure that all your type annotations are really necessary.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在使用 linter，eslint 规则 `no-inferrable-types`（注意变体拼写）可以帮助确保所有的类型注释确实是必要的。
- en: Things to Remember
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记住的事情
- en: Avoid writing type annotations when TypeScript can infer the same type.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 TypeScript 可以推断相同类型时，避免写入类型注释。
- en: Ideally your code has type annotations in function/method signatures but not
    on local variables in their bodies.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理想情况下，你的代码在函数/方法签名中有类型注释，但在其主体中的局部变量则没有。
- en: Consider using explicit annotations for object literals and function return
    types even when they can be inferred. This will help prevent implementation errors
    from surfacing in user code.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑在对象字面量和函数返回类型上使用显式注释，即使它们可以被推断。这将有助于防止实施错误在用户代码中显现。
- en: 'Item 20: Use Different Variables for Different Types'
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条目 20：使用不同的变量来表示不同的类型
- en: 'In JavaScript it’s no problem to reuse a variable to hold a differently typed
    value for a different purpose:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，重用一个变量以保存不同类型的值用于不同的目的是没有问题的：
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In TypeScript, this results in two errors:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 中，这会导致两个错误：
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Hovering over the first `id` in your editor gives a hint as to what’s going
    on (see [Figure 3-3](#efts-03in03)).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑器中悬停在第一个`id`上会给出关于正在发生的提示（参见 [图 3-3](#efts-03in03)）。
- en: '![efts 03in03](assets/efts_03in03.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![efts 03in03](assets/efts_03in03.png)'
- en: Figure 3-3\. The inferred type of id is string.
  id: totrans-79
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-3。id 的推断类型为字符串。
- en: Based on the value `"12-34-56"`, TypeScript has inferred `id`’s type as `string`.
    You can’t assign a `number` to a `string` and hence the error.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 基于值 `"12-34-56"`，TypeScript 推断出 `id` 的类型为 `string`。您不能将 `number` 分配给 `string`，因此会出错。
- en: 'This leads us to a key insight about variables in TypeScript: *while a variable’s
    value can change, its type generally does not*. The one common way a type can
    change is to narrow ([Item 22](#narrowing)), but this involves a type getting
    smaller, not expanding to include new values. There are some important exceptions
    to this rule ([Item 41](ch05.html#evolving-any)), but they are the exceptions
    and not the rule.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们得出 TypeScript 中变量的一个关键见解：*虽然变量的值可以改变，但其类型通常不会改变*。类型可以变窄（[Item 22](#narrowing)），但这涉及到类型变得更小，而不是扩展以包括新值。这个规则有一些重要的例外情况（[Item
    41](ch05.html#evolving-any)），但它们是例外而不是规则。
- en: 'How can you use this idea to fix the example? In order for `id`’s type to not
    change, it must be broad enough to encompass both `string`s and `number`s. This
    is the very definition of the union type, `string|number`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如何使用这个想法修复示例？为了使 `id` 的类型不改变，它必须足够广泛以包括 `string` 和 `number`。这正是联合类型 `string|number`
    的定义：
- en: '[PRE22]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This fixes the errors. It’s interesting that TypeScript has been able to determine
    that `id` is really a `string` in the first call and really a `number` in the
    second. It has narrowed the union type based on the assignment.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这修复了错误。有趣的是 TypeScript 能够确定第一次调用中 `id` 真正是一个 `string`，而在第二次调用中真正是一个 `number`。它根据赋值缩小了联合类型。
- en: While a union type does work, it may create more issues down the road. Union
    types are harder to work with than simple types like `string` or `number` because
    you usually have to check what they are before you do anything with them.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然联合类型确实有效，但它可能会在以后引起更多问题。与简单类型（如 `string` 或 `number`）相比，联合类型更难处理，因为通常必须在对它们进行任何操作之前检查它们的类型。
- en: 'The better solution is to introduce a new variable:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的解决方案是引入一个新变量：
- en: '[PRE23]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the previous version, the first and second `id` were not semantically related
    to one another. They were only related by the fact that you reused a variable.
    This was confusing for the type checker and would be confusing for a human reader,
    too.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的版本中，第一个和第二个 `id` 在语义上并不相关。它们只是通过变量重用相关联。这对类型检查器来说很令人困惑，对人类读者也是如此。
- en: 'The version with two variables is better for a number of reasons:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个变量的版本在很多方面都更好：
- en: It disentangles two unrelated concepts (ID and serial number).
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它解开了两个不相关的概念（ID 和序列号）。
- en: It allows you to use more specific variable names.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许您使用更具体的变量名。
- en: It improves type inference. No type annotations are needed.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它改善了类型推断。不需要类型注解。
- en: It results in simpler types (`string` and `number`, rather than `string|number`).
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它导致更简单的类型（`string` 和 `number`，而不是 `string|number`）。
- en: It lets you declare the variables `const` rather than `let`. This makes them
    easier for people and the type checker to reason about.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许您将变量声明为 `const` 而不是 `let`。这样更容易让人和类型检查器理解。
- en: Try to avoid type-changing variables. If you can use different names for different
    concepts, it will make your code clearer both to human readers and to the type
    checker.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量避免改变类型的变量。如果可以为不同的概念使用不同的名称，将使您的代码对人类读者和类型检查器更清晰。
- en: 'This is not to be confused with “shadowed” variables as in this example:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这与此示例中的“遮蔽”变量不同，请注意区分。
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: While these two `id`s share a name, they are actually two distinct variables
    with no relationship to one another. It’s fine for them to have different types.
    While TypeScript is not confused by this, your human readers might be. In general
    it’s better to use different names for different concepts. Many teams choose to
    disallow this sort of shadowing via linter rules.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这两个 `id` 共享一个名称，但它们实际上是两个彼此无关的变量。它们具有不同的类型是可以的。尽管 TypeScript 不会对此感到困惑，但您的人类读者可能会。总的来说，最好为不同的概念使用不同的名称。许多团队选择通过
    linter 规则禁止此类变量遮蔽。
- en: This item focused on scalar values, but similar considerations apply to objects.
    For more on that, see [Item 23](#all-at-once).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此项专注于标量值，但类似的考虑也适用于对象。有关更多信息，请参阅 [Item 23](#all-at-once)。
- en: Things to Remember
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 要记住的事情
- en: While a variable’s value can change, its type generally does not.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然变量的值可以改变，但其类型通常不会改变。
- en: To avoid confusion, both for human readers and for the type checker, avoid reusing
    variables for differently typed values.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了避免混淆，无论是对人类读者还是对类型检查器，都应避免为不同类型的值重用变量。
- en: 'Item 21: Understand Type Widening'
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第21条：理解类型扩展
- en: As [Item 7](ch02_split_000.html#types-as-sets) explained, at runtime every variable
    has a single value. But at static analysis time, when TypeScript is checking your
    code, a variable has a set of *possible* values, namely, its type. When you initialize
    a variable with a constant but don’t provide a type, the type checker needs to
    decide on one. In other words, it needs to decide on a set of possible values
    from the single value that you specified. In TypeScript, this process is known
    as *widening*. Understanding it will help you make sense of errors and make more
    effective use of type annotations.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 正如[第7条](ch02_split_000.html#types-as-sets)所解释的，在运行时，每个变量只有一个值。但在静态分析时，当TypeScript检查你的代码时，变量有一组*可能的*值，即它的类型。当你用常量初始化一个变量但没有提供类型时，类型检查器需要决定一个。换句话说，它需要从你指定的单一值中确定一组可能的值。在TypeScript中，这个过程称为*扩展*。理解这一点将帮助你理解错误并更有效地使用类型注解。
- en: 'Suppose you’re writing a library to work with vectors. You write out a type
    for a 3D vector and a function to get the value of any of its components:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在编写一个用于处理向量的库。你定义了一个三维向量的类型以及一个获取其任何分量值的函数：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'But when you try to use it, TypeScript flags an error:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当你尝试使用它时，TypeScript会标记一个错误：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This code runs fine, so why the error?
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以正常运行，那么为什么会有错误呢？
- en: The issue is that `x`’s type is inferred as `string`, whereas the `getComponent`
    function expected a more specific type for its second argument. This is widening
    at work, and here it has led to an error.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于`x`的类型被推断为`string`，而`getComponent`函数期望其第二个参数有更具体的类型。这就是扩展的工作方式，这里导致了一个错误。
- en: 'This process is ambiguous in the sense that there are many possible types for
    any given value. In this statement, for example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程在某种意义上是模糊的，因为对于任何给定值，可能有许多可能的类型。例如，在这个声明中：
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'what should the type of `mixed` be? Here are a few possibilities:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`mixed`的类型应该是什么呢？以下是一些可能性：'
- en: '`(''x'' | 1)[]`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(''x'' | 1)[]`'
- en: '`[''x'', 1]`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[''x'', 1]`'
- en: '`[string, number]`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[string, number]`'
- en: '`readonly [string, number]`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readonly [string, number]`'
- en: '`(string|number)[]`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(string|number)[]`'
- en: '`readonly (string|number)[]`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readonly (string|number)[]`'
- en: '`[any, any]`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[any, any]`'
- en: '`any[]`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`any[]`'
- en: Without more context, TypeScript has no way to know which one is “right.” It
    has to guess at your intent. (In this case, it guesses `(string|number)[]`.) And
    smart as it is, TypeScript can’t read your mind. It won’t get this right 100%
    of the time. The result is inadvertent errors like the one we just looked at.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 没有更多的上下文，TypeScript无法知道哪一个是“正确”的。它必须猜测你的意图。（在这种情况下，它猜测为`(string|number)[]`。）虽然TypeScript很聪明，但它无法读取你的思想。它不会在100%的情况下做出正确的猜测。结果是意外的错误，就像我们刚才看到的那个。
- en: 'In the initial example, the type of `x` is inferred as `string` because TypeScript
    chooses to allow code like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始示例中，`x`的类型被推断为`string`，因为TypeScript选择允许这样的代码存在：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'But it would also be valid JavaScript to write:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你将其作为JavaScript来写也是有效的：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In inferring the type of `x` as `string`, TypeScript attempts to strike a balance
    between specificity and flexibility. The general rule is that a variable’s type
    shouldn’t change after it’s declared ([Item 20](#one-var-one-type)), so `string`
    makes more sense than `string|RegExp` or `string|string[]` or `any`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当TypeScript将`x`的类型推断为`string`时，它试图在具体性和灵活性之间取得平衡。一般规则是变量的类型在声明后不应更改（[第20条](#one-var-one-type)），因此`string`比`string|RegExp`、`string|string[]`或`any`更合理。
- en: 'TypeScript gives you a few ways to control the process of widening. One is
    `const`. If you declare a variable with `const` instead of `let`, it gets a narrower
    type. In fact, using `const` fixes the error in our original example:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript提供了一些方法来控制扩展的过程。其中之一是`const`。如果你用`const`声明一个变量，而不是`let`，它的类型会更窄。事实上，使用`const`修复了我们原始示例中的错误：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Because `x` cannot be reassigned, TypeScript is able to infer a narrower type
    without risk of inadvertently flagging errors on subsequent assignments. And because
    the string literal type `"x"` is assignable to `"x"|"y"|"z"`, the code passes
    the type checker.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`x`不能重新赋值，TypeScript能够在没有风险地不经意地标记后续赋值错误的情况下推断出更窄的类型。而且因为字符串文字类型`"x"`可以分配给`"x"|"y"|"z"`，所以代码通过了类型检查器。
- en: '`const` isn’t a panacea, however. For objects and arrays, there is still ambiguity.
    The `mixed` example here illustrates the issue for arrays: should TypeScript infer
    a tuple type? What type should it infer for the elements? Similar issues arise
    with objects. This code is fine in JavaScript:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`const`并非万能良药。对于对象和数组，仍然存在模糊性。这里的`mixed`示例说明了数组的问题：TypeScript应该推断一个元组类型吗？它应该为元素推断什么类型？类似的问题也会出现在对象上。这段代码在JavaScript中是可以的：
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The type of `v` could be inferred anywhere along the spectrum of specificity.
    At the specific end is `{readonly x: 1}`. More general is `{x: number}`. More
    general still would be `{[key: string]: number}` or `object`. In the case of objects,
    TypeScript’s widening algorithm treats each element as though it were assigned
    with `let`. So the type of `v` comes out as `{x: number}`. This lets you reassign
    `v.x` to a different number, but not to a `string`. And it prevents you from adding
    other properties. (This is a good reason to build objects all at once, as explained
    in [Item 23](#all-at-once).)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '变量 `v` 的类型可以在特异性的光谱中的任何位置被推断出来。特定端是 `{readonly x: 1}`。更一般的是 `{x: number}`。更一般的还包括
    `{[key: string]: number}` 或 `object`。对于对象来说，TypeScript 的扩展算法将每个元素视为使用 `let` 分配的。因此，变量
    `v` 的类型最终变为 `{x: number}`。这使您可以重新赋值 `v.x` 为不同的数字，但不能为字符串。并且阻止您添加其他属性。（这是一种一次性构建对象的好理由，详见[条目
    23](#all-at-once)。）'
- en: 'So the last three statements are errors:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最后三个语句是错误的：
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Again, TypeScript is trying to strike a balance between specificity and flexibility.
    It needs to infer a specific enough type to catch errors, but not so specific
    that it creates false positives. It does this by inferring a type of `number`
    for a property initialized to a value like `1`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，TypeScript 正在努力在特异性和灵活性之间取得平衡。它需要推断出足够具体的类型以捕捉错误，但不能太具体以至于造成误报。它通过推断出对于像
    `1` 这样初始化的属性的类型为 `number` 来实现这一点。
- en: 'If you know better, there are a few ways to override TypeScript’s default behavior.
    One is to supply an explicit type annotation:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您了解更多，请覆盖 TypeScript 的默认行为的几种方法之一是提供显式的类型注解：
- en: '[PRE33]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Another is to provide additional context to the type checker (e.g., by passing
    the value as the parameter of a function). For much more on the role of context
    in type inference, see [Item 26](#context-inference).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是为类型检查器提供额外的上下文（例如，将值作为函数参数传递）。关于上下文在类型推断中的作用，详见[条目 26](#context-inference)。
- en: 'A third way is with a `const` assertion. This is not to be confused with `let`
    and `const`, which introduce symbols in value space. This is a purely type-level
    construct. Look at the different inferred types for these variables:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种方法是使用 `const` 断言。这与 `let` 和 `const` 不同，它引入值空间中的符号。这是一个纯粹的类型级别构造。查看这些变量的不同推断类型：
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When you write `as const` after a value, TypeScript will infer the narrowest
    possible type for it. There is *no* widening. For true constants, this is typically
    what you want. You can also use `as const` with arrays to infer a tuple type:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在值后面写上 `as const` 时，TypeScript 将为其推断出最窄可能的类型。没有扩展。对于真正的常量，这通常是您想要的。您还可以在数组中使用
    `as const` 来推断元组类型：
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If you’re getting incorrect errors that you think are due to widening, consider
    adding some explicit type annotations or `const` assertions. Inspecting types
    in your editor is the key to building an intuition for this (see [Item 6](ch02_split_000.html#editor)).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您因扩展而得到错误的错误消息，请考虑添加一些显式的类型注解或 `const` 断言。检查编辑器中的类型是建立对此直觉的关键（参见[条目 6](ch02_split_000.html#editor)）。
- en: Things to Remember
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 要记住的事情
- en: Understand how TypeScript infers a type from a constant by widening it.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 TypeScript 如何通过扩展推断常量的类型。
- en: 'Familiarize yourself with the ways you can affect this behavior: `const`, type
    annotations, context, and `as const`.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉您可以影响此行为的方式：`const`、类型注解、上下文和 `as const`。
- en: 'Item 22: Understand Type Narrowing'
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条目 22：理解类型缩小
- en: 'The opposite of widening is narrowing. This is the process by which TypeScript
    goes from a broad type to a narrower one. Perhaps the most common example of this
    is null checking:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展的反义是缩小。这是 TypeScript 从广泛类型到较窄类型的过程。这个过程中最常见的例子可能是空值检查：
- en: '[PRE36]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If `el` is `null`, then the code in the first branch won’t execute. So TypeScript
    is able to exclude `null` from the type union within this block, resulting in
    a narrower type which is much easier to work with. The type checker is generally
    quite good at narrowing types in conditionals like these, though it can occasionally
    be thwarted by aliasing ([Item 24](#avoid-aliasing)).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `el` 是 `null`，则第一个分支中的代码将不会执行。因此，TypeScript 能够从此块中的类型联合中排除 `null`，从而导致一个更窄的类型，更容易处理。类型检查器通常在这类条件语句中缩小类型方面表现良好，尽管有时可能会被别名所挫败（详见[条目
    24](#avoid-aliasing)）。
- en: 'You can also narrow a variable’s type for the rest of a block by throwing or
    returning from a branch. For example:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过在分支中抛出或返回来缩小变量在块的其余部分的类型。例如：
- en: '[PRE37]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'There are many ways that you can narrow a type. Using `instanceof` works:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以缩小类型。使用 `instanceof` 是有效的：
- en: '[PRE38]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'So does a property check:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 属性检查也是如此：
- en: '[PRE39]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Some built-in functions such as `Array.isArray` are able to narrow types:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一些内置函数如 `Array.isArray` 能够缩小类型：
- en: '[PRE40]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'TypeScript is generally quite good at tracking types through conditionals.
    Think twice before adding an assertion—it might be onto something that you’re
    not! For example, this is the wrong way to exclude `null` from a union type:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在条件语句中，TypeScript 通常非常擅长跟踪类型。在添加断言之前，考虑两次——它可能会捕捉到你所未见的东西！例如，这是排除 `null` 从联合类型中的错误方法：
- en: '[PRE41]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Because `typeof null` is `"object"` in JavaScript, you have not, in fact, excluded
    `null` with this check! Similar surprises can come from falsy primitive values:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在 JavaScript 中，`typeof null` 是 `"object"`，所以实际上这种检查并没有排除 `null`！类似的意外可能来自假值原始值：
- en: '[PRE42]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Because the empty string and `0` are both falsy, `x` could still be a `string`
    or `number` in that branch. TypeScript is right!
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 因为空字符串和 `0` 都是假值，因此在该分支中 `x` 仍然可能是 `string` 或 `number`。TypeScript 是正确的！
- en: 'Another common way to help the type checker narrow your types is by putting
    an explicit “tag” on them:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种帮助类型检查器缩小类型范围的常见方法是为它们显式地打上“标签”：
- en: '[PRE43]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This pattern is known as a “tagged union” or “discriminated union,” and it is
    ubiquitous in TypeScript.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式称为“标记联合”或“辨识联合”，在 TypeScript 中是无处不在的。
- en: 'If TypeScript isn’t able to figure out a type, you can even introduce a custom
    function to help it out:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 TypeScript 无法推断类型，甚至可以引入自定义函数来帮助它：
- en: '[PRE44]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This is known as a “user-defined type guard.” The `el is HTMLInputElement` as
    a return type tells the type checker that it can narrow the type of the parameter
    if the function returns true.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为“用户定义的类型保护”。`el is HTMLInputElement` 作为返回类型告诉类型检查器，如果函数返回 true，则可以缩小参数的类型。
- en: 'Some functions are able to use type guards to perform type narrowing across
    arrays or objects. If you do some lookups in an array, for instance, you may wind
    up with an array of nullable types:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一些函数能够使用类型保护来跨数组或对象执行类型缩小。例如，如果在数组中进行一些查找，可能会得到一个可空类型的数组：
- en: '[PRE45]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If you filter out the `undefined` values using `filter`, TypeScript isn’t able
    to follow along:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 `filter` 过滤掉 `undefined` 值，TypeScript 将无法跟踪：
- en: '[PRE46]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'But if you use a type guard, it can:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果使用类型保护，它可以：
- en: '[PRE47]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As always, inspecting types in your editor is key to building an intuition for
    how narrowing works.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如常，在编辑器中检查类型是建立对缩小工作原理直觉的关键。
- en: Understanding how types in TypeScript narrow will help you build an intuition
    for how type inference works, make sense of errors, and generally have a more
    productive relationship with the type checker.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 TypeScript 中类型缩小的原理将帮助你建立对类型推断工作的直觉，理解错误，并通常更有效地与类型检查器交互。
- en: Things to Remember
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需要记住的事项
- en: Understand how TypeScript narrows types based on conditionals and other types
    of control flow.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 TypeScript 如何根据条件和其他类型控制流缩小类型范围。
- en: Use tagged/discriminated unions and user-defined type guards to help the process
    of narrowing.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标记/辨识联合和用户定义的类型保护来帮助缩小过程。
- en: 'Item 23: Create Objects All at Once'
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条款 23：一次性创建对象
- en: As [Item 20](#one-var-one-type) explained, while a variable’s value may change,
    its type in TypeScript generally does not. This makes some JavaScript patterns
    easier to model in TypeScript than others. In particular, it means that you should
    prefer creating objects all at once, rather than piece by piece.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 [Item 20](#one-var-one-type) 所述，虽然变量的值可能会改变，在 TypeScript 中它的类型通常不会改变。这使得一些
    JavaScript 模式在 TypeScript 中更容易建模。特别是，这意味着你应该更倾向于一次性创建对象，而不是逐步创建。
- en: 'Here’s one way to create an object representing a two-dimensional point in
    JavaScript:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在 JavaScript 中表示二维点对象的一种方式：
- en: '[PRE48]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In TypeScript, this will produce errors on each assignment:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 中，这将在每次赋值时产生错误：
- en: '[PRE49]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This is because the type of `pt` on the first line is inferred based on its
    value `{}`, and you may only assign to known properties.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为第一行中 `pt` 的类型是根据其值 `{}` 推断出来的，并且你只能分配已知的属性。
- en: 'You get the opposite problem if you define a `Point` interface:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果定义了一个 `Point` 接口，你会得到相反的问题：
- en: '[PRE50]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The solution is to define the object all at once:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是一次性定义对象：
- en: '[PRE51]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'If you must build the object piecemeal, you may use a type assertion (`as`)
    to silence the type checker:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果必须逐步构建对象，可以使用类型断言（`as`）来消除类型检查器的警告：
- en: '[PRE52]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'But the better way is by building the object all at once and using a declaration
    (see [Item 9](ch02_split_000.html#prefer-declarations-to-assertions)):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 但更好的方式是一次性构建对象，并使用声明（参见 [Item 9](ch02_split_000.html#prefer-declarations-to-assertions)）：
- en: '[PRE53]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If you need to build a larger object from smaller ones, avoid doing it in multiple
    steps:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要从较小的对象构建一个较大的对象，避免分步进行：
- en: '[PRE54]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You can build the larger object all at once instead using the *object spread
    operator*, `...`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 *对象扩展操作符* `...` 一次性构建更大的对象：
- en: '[PRE55]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'You can also use the object spread operator to build up objects field by field
    in a type-safe way. The key is to use a new variable on every update so that each
    gets a new type:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用对象扩展操作符以一种类型安全的方式逐个字段地构建对象。关键是在每次更新时使用一个新变量，以便每个变量都获得一个新类型：
- en: '[PRE56]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: While this is a roundabout way to build up such a simple object, it can be a
    useful technique for adding properties to an object and allowing TypeScript to
    infer a new type.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是一种绕弯子的方式来构建这样一个简单的对象，但它可以是一种有用的技术，用于向对象添加属性并允许 TypeScript 推断出新类型。
- en: 'To conditionally add a property in a type-safe way, you can use object spread
    with `null` or `{}`, which add no properties:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要以类型安全的方式有条件地向对象添加属性，你可以使用带有 `null` 或 `{}` 的对象扩展：
- en: '[PRE57]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'If you mouse over `president` in your editor, you’ll see that its type is inferred
    as a union:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在编辑器中悬停鼠标在`president`上，你会看到它的类型被推断为一个联合类型：
- en: '[PRE58]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This may come as a surprise if you wanted `middle` to be an optional field.
    You can’t read `middle` off this type, for example:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望 `middle` 是一个可选字段，这可能会让你感到惊讶。例如，你无法从这种类型中读取 `middle`：
- en: '[PRE59]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'If you’re conditionally adding multiple properties, the union does more accurately
    represent the set of possible values ([Item 32](ch04.html#union-of-interfaces)).
    But an optional field would be easier to work with. You can get one with a helper:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在有条件地添加多个属性，联合类型确实更准确地表示可能的值集合（[条款 32](ch04.html#union-of-interfaces)）。但可选字段会更容易处理。你可以用一个辅助函数来获取它：
- en: '[PRE60]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Sometimes you want to build an object or array by transforming another one.
    In this case the equivalent of “building objects all at once” is using built-in
    functional constructs or utility libraries like Lodash rather than loops. See
    [Item 27](#well-typed-libs) for more on this.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你想通过转换另一个对象或数组来构建一个对象或数组。在这种情况下，“一次性构建对象”的等价方法是使用内置的函数式构造或类似 Lodash 这样的实用库，而不是使用循环。详见
    [条款 27](#well-typed-libs) 了解更多信息。
- en: Things to Remember
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需要记住的事情
- en: Prefer to build objects all at once rather than piecemeal. Use object spread
    (`{...a, ...b}`) to add properties in a type-safe way.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最好一次性构建对象，而不是逐步构建。使用对象扩展 (`{...a, ...b}`) 以一种类型安全的方式添加属性。
- en: Know how to conditionally add properties to an object.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道如何有条件地向对象添加属性。
- en: 'Item 24: Be Consistent in Your Use of Aliases'
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条款 24：在使用别名时要保持一致性
- en: 'When you introduce a new name for a value:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为一个值引入一个新名称时：
- en: '[PRE61]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'you have created an *alias*. Changes to properties on the alias will be visible
    on the original value as well:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经创建了一个 *别名*。对别名上属性的更改也会在原始值上可见：
- en: '[PRE62]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Aliases are the bane of compiler writers in all languages because they make
    control flow analysis difficult. If you’re deliberate in your use of aliases,
    TypeScript will be able to understand your code better and help you find more
    real errors.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 别名是所有语言中编译器编写者的祸根，因为它们使得控制流分析变得困难。如果你在使用别名时考虑周到，TypeScript 将能够更好地理解你的代码并帮助你找到更多真正的错误。
- en: 'Suppose you have a data structure that represents a polygon:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个表示多边形的数据结构：
- en: '[PRE63]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The geometry of the polygon is specified by the `exterior` and `holes` properties.
    The `bbox` property is an optimization that may or may not be present. You can
    use it to speed up a point-in-polygon check:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 多边形的几何形状由 `exterior` 和 `holes` 属性指定。`bbox` 属性是一种可能有可能没有的优化。你可以用它来加速点在多边形内的检查：
- en: '[PRE64]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This code works (and type checks) but is a bit repetitive: `polygon.bbox` appears
    five times in three lines! Here’s an attempt to factor out an intermediate variable
    to reduce duplication:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以工作（并且类型检查通过），但有点重复：`polygon.bbox` 在三行中出现了五次！下面试图因子化一个中间变量以减少重复：
- en: '[PRE65]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: (I’m assuming you’ve enabled `strictNullChecks`.)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: （我假设你已经启用了 `strictNullChecks`。）
- en: This code still works, so why the error? By factoring out the `box` variable,
    you’ve created an alias for `polygon.bbox`, and this has thwarted the control
    flow analysis that quietly worked in the first example.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码仍然可以工作，那么为什么会有错误？通过因子化 `box` 变量，你创建了一个对 `polygon.bbox` 的别名，这阻碍了在第一个示例中悄悄工作的控制流分析。
- en: 'You can inspect the types of `box` and `polygon.bbox` to see what’s happening:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以检查 `box` 和 `polygon.bbox` 的类型，看看发生了什么：
- en: '[PRE66]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The property check refines the type of `polygon.bbox` but not of `box` and
    hence the errors. This leads us to the golden rule of aliasing: *if you introduce
    an alias, use it* *consistently*.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 属性检查精化了`polygon.bbox`的类型，但未精化`box`，从而导致错误。这带我们来到别名的黄金法则：*如果你引入了一个别名，请一致地使用它*。
- en: 'Using `box` in the property check fixes the error:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在属性检查中使用`box`修复了错误：
- en: '[PRE67]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The type checker is happy now, but there’s an issue for human readers. We’re
    using two names for the same thing: `box` and `bbox`. This is a distinction without
    a difference ([Item 36](ch04.html#language-of-domain)).'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 类型检查器现在很满意，但对于人类读者来说存在问题。我们为同一事物使用了两个名称：`box`和`bbox`。这是一个没有实质差别的区分（[Item 36](ch04.html#language-of-domain)）。
- en: 'Object destructuring syntax rewards consistent naming with a more compact syntax.
    You can even use it on arrays and nested structures:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 对象解构语法通过更紧凑的语法奖励一致的命名。你甚至可以在数组和嵌套结构上使用它：
- en: '[PRE68]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'A few other points:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 还有几点需要注意：
- en: This code would have required more property checks if the `x` and `y` properties
    had been optional, rather than the whole `bbox` property. We benefited from following
    the advice of [Item 31](ch04.html#null-values-to-perimeter), which discusses the
    importance of pushing null values to the perimeter of your types.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`x`和`y`属性是可选的而不是整个`bbox`属性，那么这段代码将需要更多的属性检查。我们受益于遵循[Item 31](ch04.html#null-values-to-perimeter)的建议，该建议讨论了将空值推送到类型的边缘的重要性。
- en: An optional property was appropriate for `bbox` but would not have been appropriate
    for `holes`. If `holes` was optional, then it would be possible for it to be either
    missing or an empty array (`[]`). This would be a distinction without a difference.
    An empty array is a fine way to indicate “no holes.”
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`bbox`来说，可选属性是合适的，但对于`holes`来说则不适用。如果`holes`是可选的，那么它可能会不存在，或者是一个空数组（`[]`）。这是一个没有实质差别的区分。空数组是表示“没有孔”的良好方式。
- en: 'In your interactions with the type checker, don’t forget that aliasing can
    introduce confusion at runtime, too:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在与类型检查器的交互中，不要忘记别名可能会引入运行时的混淆：
- en: '[PRE69]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'TypeScript’s control flow analysis tends to be quite good for local variables.
    But for properties you should be on guard:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript的控制流分析对局部变量而言通常非常好。但对于属性，你应该保持警惕：
- en: '[PRE70]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The call to `fn(polygon)` could very well un-set `polygon.bbox`, so it would
    be safer for the type to revert to `BoundingBox | undefined`. But this would get
    frustrating: you’d have to repeat your property checks every time you called a
    function. So TypeScript makes the pragmatic choice to assume the function does
    not invalidate its type refinements. But it *could*. If you’d factored out a local
    `bbox` variable instead of using `polygon.bbox`, the type of `bbox` would remain
    accurate, but it might no longer be the same value as `polygon.box`.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用`fn(polygon)`可能会导致`polygon.bbox`被取消设置，因此将类型回归为`BoundingBox | undefined`会更安全。但这样会变得很烦人：每次调用函数时都需要重复进行属性检查。因此，TypeScript作出了务实的选择，假设函数不会使其类型精化失效。但它*可能*会。如果你将局部变量`bbox`拆分出来，而不是使用`polygon.bbox`，那么`bbox`的类型将保持准确，但它可能不再是`polygon.box`的相同值。
- en: Things to Remember
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需要记住的事情
- en: Aliasing can prevent TypeScript from narrowing types. If you create an alias
    for a variable, use it consistently.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 别名可能会阻止TypeScript缩小类型范围。如果为变量创建了一个别名，请一致使用它。
- en: Use destructuring syntax to encourage consistent naming.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用解构语法来鼓励一致的命名。
- en: Be aware of how function calls can invalidate type refinements on properties.
    Trust refinements on local variables more than on properties.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意函数调用如何使属性的类型精化失效。相信对局部变量的精化胜过对属性的精化。
- en: 'Item 25: Use async Functions Instead of Callbacks for Asynchronous Code'
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目25：使用异步函数而不是回调来处理异步代码
- en: 'Classic JavaScript modeled asynchronous behavior using callbacks. This leads
    to the infamous “pyramid of doom”:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 经典JavaScript使用回调函数模拟异步行为。这导致了臭名昭著的“金字塔形式的嵌套”：
- en: '[PRE71]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: As you can see from the logs, the execution order is the opposite of the code
    order. This makes callback code hard to read. It gets even more confusing if you
    want to run the requests in parallel or bail when an error occurs.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从日志中看到的那样，执行顺序与代码顺序相反。这使得回调代码难以阅读。如果你想要并行运行请求或在出现错误时放弃执行，情况会更加混乱。
- en: 'ES2015 introduced the concept of a Promise to break the pyramid of doom. A
    Promise represents something that will be available in the future (they’re also
    sometimes called “futures”). Here’s the same code using Promises:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ES2015引入了Promise的概念来打破嵌套的金字塔形式。Promise表示将来会可用的东西（它们有时也被称为“期货”）。以下是使用Promise的相同代码：
- en: '[PRE72]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Now there’s less nesting, and the execution order more directly matches the
    code order. It’s also easier to consolidate error handling and use higher-order
    tools like `Promise.all`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在嵌套更少，执行顺序更直接地匹配代码顺序。同时更容易整合错误处理和使用`Promise.all`这样的高阶工具。
- en: 'ES2017 introduced the `async` and `await` keywords to make things even simpler:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ES2017引入了`async`和`await`关键字，使得事情变得更简单：
- en: '[PRE73]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The `await` keyword pauses execution of the `fetchPages` function until each
    Promise resolves. Within an `async` function, `await`ing a Promise that throws
    an exception. This lets you use the usual try/catch machinery:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`await`关键字暂停`fetchPages`函数的执行，直到每个Promise解决。在`async`函数中，`await`一个抛出异常的Promise。这让你可以使用通常的try/catch机制：'
- en: '[PRE74]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: When you target ES5 or earlier, the TypeScript compiler will perform some elaborate
    transformations to make `async` and `await` work. In other words, whatever your
    runtime, with TypeScript you can use `async`/`await`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的目标是ES5或更早版本时，TypeScript编译器将执行一些复杂的转换使`async`和`await`工作。换句话说，无论你的运行时是什么，使用TypeScript你都可以使用`async`/`await`。
- en: 'There are a few good reasons to prefer Promises or `async`/`await` to callbacks:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个好的理由优先选择Promises或`async`/`await`而不是回调：
- en: Promises are easier to compose than callbacks.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Promises比回调更容易组合。
- en: Types are able to flow through Promises more easily than callbacks.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型更容易通过Promises流动而不是回调。
- en: 'If you want to fetch the pages in parallel, for example, you can compose Promises
    with `Promise.all`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想并行获取页面，你可以使用`Promise.all`组合Promises：
- en: '[PRE75]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Using destructuring assignment with `await` is particularly nice in this context.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用`await`与解构赋值特别好。
- en: 'TypeScript is able to infer the types of each of the three `response` variables
    as `Response`. The equivalent code to do the requests in parallel with callbacks
    requires more machinery and a type annotation:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript能够推断每个`response`变量的类型为`Response`。与回调一起并行请求的等效代码需要更多的机制和类型注释：
- en: '[PRE76]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Extending this to include error handling or to be as generic as `Promise.all`
    is challenging.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 将错误处理扩展到包括或作为`Promise.all`一样通用是有挑战的。
- en: 'Type inference also works well with `Promise.race`, which resolves when the
    first of its input Promises resolves. You can use this to add timeouts to Promises
    in a general way:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 类型推断与`Promise.race`一起工作良好，它在其输入Promise中第一个解决时解决。你可以用这个通用方式为Promises添加超时：
- en: '[PRE77]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The return type of `fetchWithTimeout` is inferred as `Promise<Response>`, no
    type annotations required. It’s interesting to dig into why this works: the return
    type of `Promise.race` is the union of the types of its inputs, in this case `Promise<Response
    | never>`. But taking a union with `never` (the empty set) is a no-op, so this
    gets simplified to `Promise<Response>`. When you work with Promises, all of TypeScript’s
    type inference machinery works to get you the right types.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetchWithTimeout`的返回类型被推断为`Promise<Response>`，不需要类型注释。深入研究为什么这样工作是有趣的：`Promise.race`的返回类型是其输入类型的联合，这种情况下是`Promise<Response
    | never>`。但与`never`（空集）的联合是一个无操作，因此这简化为`Promise<Response>`。当你使用Promises时，所有的TypeScript类型推断机制都会为你获取正确的类型。'
- en: 'There are some times when you need to use raw Promises, notably when you are
    wrapping a callback API like `setTimeout`. But if you have a choice, you should
    generally prefer `async`/`await` to raw Promises for two reasons:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你需要使用原始的Promises，尤其是在包装回调API像`setTimeout`的时候。但如果可以选择，通常你应该优先选择`async`/`await`，因为有两个原因：
- en: It typically produces more concise and straightforward code.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通常产生更简洁和直接的代码。
- en: It enforces that `async` functions always return Promises.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它强制`async`函数总是返回Promises。
- en: 'An `async` function always returns a `Promise`, even if it doesn’t involve
    `await`ing anything. TypeScript can help you build an intuition for this:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`async`函数总是返回一个`Promise`，即使它不涉及`await`任何东西。TypeScript可以帮助你建立这种直觉：'
- en: '[PRE78]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'You can also create `async` arrow functions:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以创建`async`箭头函数：
- en: '[PRE79]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The raw Promise equivalent is:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的Promise等价物是：
- en: '[PRE80]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'While it may seem odd to return a Promise for an immediately available value,
    this actually helps enforce an important rule: a function should either always
    be run synchronously or always be run asynchronously. It should never mix the
    two. For example, what if you want to add a cache to the `fetchURL` function?
    Here’s an attempt:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管对于一个立即可用的值返回Promise可能看起来有些奇怪，但这实际上有助于强制执行一个重要的规则：一个函数应该要么总是同步运行，要么总是异步运行。它不应该混合两者。例如，如果你想给`fetchURL`函数添加缓存会怎样？这里是一个尝试：
- en: '[PRE81]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'While this may seem like an optimization, the function is now extremely difficult
    for a client to use:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这看起来像是一种优化，但函数现在对客户端使用变得极其困难：
- en: '[PRE82]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: What will the value of `requestStatus` be after calling `getUser`? It depends
    entirely on whether the profile is cached. If it’s not, `requestStatus` will be
    set to “success.” If it is, it’ll get set to “success” and then set back to “loading.”
    Oops!
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`getUser`后，`requestStatus`的值将是什么？这完全取决于是否缓存了配置文件。如果没有，`requestStatus`将设置为“success”。如果有，它将设置为“success”，然后再设置回“loading”。糟糕！
- en: 'Using `async` for both functions enforces consistent behavior:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有函数都使用`async`强制保持一致的行为：
- en: '[PRE83]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Now it’s completely transparent that `requestStatus` will end in “success.”
    It’s easy to accidentally produce half-synchronous code with callbacks or raw
    Promises, but difficult with `async`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在完全明确`requestStatus`将以“success”结尾。使用回调或原始Promise很容易意外生成半同步代码，但使用`async`则不同。
- en: 'Note that if you return a Promise from an `async` function, it will not get
    wrapped in another Promise: the return type will be `Promise<T>` rather than `Promise<Promise<T>>`.
    Again, TypeScript will help you build an intuition for this:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你从`async`函数返回一个Promise，它不会被包装在另一个Promise中：返回类型将是`Promise<T>`而不是`Promise<Promise<T>>`。再次强调，TypeScript会帮助你建立对此的直觉：
- en: '[PRE84]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Things to Remember
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记住的事情
- en: Prefer Promises to callbacks for better composability and type flow.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了更好地组合和类型流动，推荐使用Promise而不是回调函数。
- en: Prefer `async` and `await` to raw Promises when possible. They produce more
    concise, straightforward code and eliminate whole classes of errors.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能使用`async`和`await`而不是原始的Promise。它们产生更简洁、直接的代码，并消除了许多错误。
- en: If a function returns a Promise, declare it `async`.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果函数返回一个Promise，声明它为`async`。
- en: 'Item 26: Understand How Context Is Used in Type Inference'
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条款26：理解上下文在类型推断中的使用方式
- en: TypeScript doesn’t just infer types based on values. It also considers the context
    in which the value occurs. This usually works well but can sometimes lead to surprises.
    Understanding how context is used in type inference will help you identify and
    work around these surprises when they do occur.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript不仅基于值推断类型，还考虑值出现的上下文。这通常效果很好，但有时会带来意外。理解上下文在类型推断中的使用方式将帮助你识别并解决这些意外。
- en: 'In JavaScript you can factor an expression out into a constant without changing
    the behavior of your code (so long as you don’t alter execution order). In other
    words, these two statements are equivalent:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，你可以将表达式提取为常量而不改变代码行为（只要不改变执行顺序）。换句话说，以下两个语句是等价的：
- en: '[PRE85]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'In TypeScript, this refactor still works:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript中，这种重构仍然有效：
- en: '[PRE86]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Now suppose you take to heart the advice of [Item 33](ch04.html#avoid-strings)
    and replace the string type with a more precise union of string literal types:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设你真心接受了[条款33](ch04.html#avoid-strings)的建议，并用更精确的字符串字面量类型替换了字符串类型：
- en: '[PRE87]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: What went wrong? With the inline form, TypeScript knows from the function declaration
    that the parameter is supposed to be of type `Language`. The string literal `'JavaScript'`
    is assignable to this type, so this is OK. But when you factor out a variable,
    TypeScript must infer its type at the time of assignment. In this case it infers
    `string`, which is not assignable to `Language`. Hence the error.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？使用内联形式时，TypeScript可以从函数声明中知道参数应该是`Language`类型。字符串字面量`'JavaScript'`可以赋值给这种类型，所以没问题。但是当你提取一个变量时，TypeScript必须在赋值时推断其类型。在这种情况下，它推断为`string`，这与`Language`类型不兼容，因此出错。
- en: (Some languages are able to infer types for variables based on their eventual
    usage. But this can also be confusing. Anders Hejlsberg, the creator of TypeScript,
    refers to it as “spooky action at a distance.” By and large, TypeScript determines
    the type of a variable when it is first introduced. For a notable exception to
    this rule, see [Item 41](ch05.html#evolving-any).)
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: （某些语言能够根据变量的最终使用推断类型。但这也可能令人困惑。TypeScript的创建者Anders Hejlsberg将其称为“远距离的不可思议行为”。总的来说，TypeScript通常在变量首次引入时确定其类型。关于此规则的一个显著例外，请参阅[条款41](ch05.html#evolving-any)。）
- en: 'There are two good ways to solve this problem. One is to constrain the possible
    values of `language` with a type declaration:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种解决这个问题的好方法。一种是使用类型声明约束`language`的可能值：
- en: '[PRE88]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: This also has the benefit of flagging an error if there’s a typo in the language—for
    example `'Typescript'` (it should be a capital “S”).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这也有助于在语言拼写错误时标记错误，例如`'Typescript'`（应为大写“S”）。
- en: 'The other solution is to make the variable constant:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解决方案是将变量声明为常量：
- en: '[PRE89]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: By using `const`, we’ve told the type checker that this variable cannot change.
    So TypeScript can infer a more precise type for `language`, the string literal
    type `"JavaScript"`. This is assignable to `Language` so the code type checks.
    Of course, if you do need to reassign `language`, then you’ll need to use the
    type declaration. (For more on this, see [Item 21](#widening).)
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `const`，我们告诉类型检查器这个变量是不可变的。因此 TypeScript 可以推断出更精确的类型 `language`，即字符串字面量类型
    `"JavaScript"`。这是可分配给 `Language` 的，因此代码通过类型检查。当然，如果你确实需要重新分配 `language`，那么你需要使用类型声明。（更多信息请参见
    [项目 21](#widening)。）
- en: The fundamental issue here is that we’ve separated the value from the context
    in which it’s used. Sometimes this is OK, but often it is not. The rest of this
    item walks through a few cases where this loss of context can cause errors and
    shows you how to fix them.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的根本问题是我们已将值从其使用的上下文中分离出来。有时这样做没问题，但通常不行。本条目的其余部分将逐步介绍几种情况，其中这种上下文丢失可能会导致错误，并向你展示如何修复它们。
- en: Tuple Types
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组类型
- en: 'In addition to string literal types, problems can come up with tuple types.
    Suppose you’re working with a map visualization that lets you programmatically
    pan the map:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 除了字符串字面量类型外，元组类型也可能出现问题。假设你正在使用一个地图可视化工具，可以编程地移动地图：
- en: '[PRE90]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: As before, you’ve separated a value from its context. In the first instance
    `[10, 20]` is assignable to the tuple type `[number, number]`. In the second,
    TypeScript infers the type of `loc` as `number[]` (i.e., an array of numbers of
    unknown length). This is not assignable to the tuple type, since many arrays have
    the wrong number of elements.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，你已将值从其上下文中分离出来。在第一个例子中 `[10, 20]` 可以赋值给元组类型 `[number, number]`。而在第二个例子中，TypeScript
    推断出 `loc` 的类型为 `number[]`（即一个未知长度的数字数组）。这不能赋值给元组类型，因为许多数组具有错误的元素数量。
- en: 'So how can you fix this error without resorting to `any`? You’ve already declared
    it `const`, so that won’t help. But you can still provide a type declaration to
    let TypeScript know precisely what you mean:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如何在不使用 `any` 的情况下修复这个错误？你已经声明它为 `const`，所以这行不通。但是你仍然可以提供一个类型声明，让 TypeScript
    精确地了解你的意图：
- en: '[PRE91]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Another way is to provide a “const context.” This tells TypeScript that you
    intend the value to be deeply constant, rather than the shallow constant that
    `const` gives:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是提供一个“常量上下文”。这告诉 TypeScript 你打算使值在深层次上是常量的，而不是 `const` 给出的浅层常量：
- en: '[PRE92]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'If you hover over `loc` in your editor, you’ll see that its type is now inferred
    as `readonly [10, 20]`, rather than `number[]`. Unfortunately this is *too* precise!
    The type signature of `panTo` makes no promises that it won’t modify the contents
    of its `where` parameter. Since the `loc` parameter has a `readonly` type, this
    won’t do. The best solution here is to add a `readonly` annotation to the `panTo`
    function:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在编辑器中悬停在 `loc` 上，你会看到它的类型现在被推断为 `readonly [10, 20]`，而不是 `number[]`。不幸的是，这太精确了！`panTo`
    函数的类型签名没有承诺不修改其 `where` 参数的内容。由于 `loc` 参数有一个 `readonly` 类型，这行不通。在这里的最佳解决方案是为 `panTo`
    函数添加一个 `readonly` 注解：
- en: '[PRE93]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: If the type signature is outside your control, then you’ll need to use an annotation.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类型签名不在你的控制之外，那么你需要使用一个注解。
- en: '`const` contexts can neatly solve issues around losing context in inference,
    but they do have an unfortunate downside: if you make a mistake in the definition
    (say you add a third element to the tuple) then the error will be flagged at the
    call site, not at the definition. This may be confusing, especially if the error
    occurs in a deeply nested object:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`const` 上下文可以很好地解决推断中丢失上下文的问题，但它们确实有一个不幸的缺点：如果在定义中出现错误（比如你向元组添加了第三个元素），那么错误将在调用点而不是定义处标记。这可能会令人困惑，特别是如果错误发生在深度嵌套的对象中：'
- en: '[PRE94]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Objects
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象
- en: 'The problem of separating a value from its context also comes up when you factor
    out a constant from a larger object that contains some string literals or tuples.
    For example:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将常量从包含一些字符串字面量或元组的大对象中分离出来时，也会出现分离值与其使用上下文的问题。例如：
- en: '[PRE95]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'In the `ts` object, the type of `language` is inferred as `string`. As before,
    the solution is to add a type declaration (`const ts: GovernedLanguage = ...`)
    or use a const assertion (`as const`).'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '在 `ts` 对象中，`language` 的类型被推断为 `string`。与之前一样，解决方案是添加类型声明 (`const ts: GovernedLanguage
    = ...`) 或使用常量断言 (`as const`)。'
- en: Callbacks
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回调函数
- en: 'When you pass a callback to another function, TypeScript uses context to infer
    the parameter types of the callback:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将回调函数传递给另一个函数时，TypeScript 使用上下文来推断回调的参数类型：
- en: '[PRE96]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The types of `a` and `b` are inferred as `number` because of the type declaration
    for `callWithRandom`. If you factor the callback out into a constant, you lose
    that context and get `noImplicitAny` errors:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`callWithRandom`的类型声明，`a`和`b`的类型被推断为`number`。如果您将回调函数提取为常量，则会失去此上下文，并出现`noImplicitAny`错误：
- en: '[PRE97]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The solution is either to add type annotations to the parameters:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下的解决方案都是为参数添加类型注释：
- en: '[PRE98]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: or to apply a type declaration to the entire function expression if one is available.
    See [Item 12](ch02_split_001.html#type-entire-functions).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 或者应用于整个函数表达式的类型声明（如果有的话）。请参见[Item 12](ch02_split_001.html#type-entire-functions)。
- en: Things to Remember
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记住的事情
- en: Be aware of how context is used in type inference.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意上下文在类型推断中的使用方式。
- en: If factoring out a variable introduces a type error, consider adding a type
    declaration.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果将变量分解引入类型错误，请考虑添加类型声明。
- en: If the variable is truly a constant, use a const assertion (`as const`). But
    be aware that this may result in errors surfacing at use, rather than definition.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果变量确实是常量，请使用常量断言 (`as const`)。但请注意，这可能导致错误在使用时而非定义时浮出水面。
- en: 'Item 27: Use Functional Constructs and Libraries to Help Types Flow'
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'Item 27: 使用函数构造和库帮助类型流动'
- en: JavaScript has never included the sort of standard library you find in Python,
    C, or Java. Over the years many libraries have tried to fill the gap. jQuery provided
    helpers not just for interacting with the DOM but also for iterating and mapping
    over objects and arrays. Underscore focused more on providing general utility
    functions, and Lodash built on this effort. Today libraries like Ramda continue
    to bring ideas from functional programming into the JavaScript world.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 从未包含像 Python、C 或 Java 中那样的标准库。多年来，许多库试图填补这一空白。jQuery 不仅提供了与 DOM 交互的帮助程序，还提供了对对象和数组进行迭代和映射的功能。Underscore
    更专注于提供通用的实用函数，而 Lodash 在此基础上进行了扩展。今天，像 Ramda 这样的库继续将函数式编程的思想引入到 JavaScript 世界中。
- en: Some features from these libraries, such as `map`, `flatMap`, `filter`, and
    `reduce`, have made it into the JavaScript language itself. While these constructs
    (and the other ones provided by Lodash) are helpful in JavaScript and often preferable
    to a hand-rolled loop, this advantage tends to get even more lopsided when you
    add TypeScript to the mix. This is because their type declarations ensure that
    types flow through these constructs. With hand-rolled loops, you’re responsible
    for the types yourself.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这些库的一些功能，如`map`、`flatMap`、`filter`和`reduce`，已经融入到 JavaScript 语言本身中。尽管这些构造（以及
    Lodash 提供的其他构造）在 JavaScript 中非常有帮助，通常比手动编写的循环更可取，但是当您将 TypeScript 加入到混合中时，这种优势往往更加明显。这是因为它们的类型声明确保类型在这些构造中流动。对于手动编写的循环，您需要自己负责类型。
- en: 'For example, consider parsing some CSV data. You could do it in plain JavaScript
    in a somewhat imperative style:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑解析一些 CSV 数据。您可以在纯 JavaScript 中以某种命令式风格完成它：
- en: '[PRE99]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'More functionally minded JavaScripters might prefer to build the row objects
    with `reduce`:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 更注重功能的 JavaScript 开发者可能更喜欢使用 `reduce` 来构建行对象：
- en: '[PRE100]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'This version saves three lines (almost 20 non-whitespace characters!) but may
    be more cryptic depending on your sensibilities. Lodash’s `zipObject` function,
    which forms an object by “zipping” up a keys and values array, can tighten it
    even further:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本节省了三行（几乎 20 个非空格字符！），但根据您的感受可能更加神秘。Lodash 的 `zipObject` 函数可以进一步缩短它，通过“压缩”键和值数组来形成对象：
- en: '[PRE101]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: I find this the clearest of all. But is it worth the cost of adding a dependency
    on a third-party library to your project? If you’re not using a bundler and the
    overhead of doing this is significant, then the answer may be “no.”
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这是所有方法中最清晰的。但是，为了将第三方库添加到您的项目中是否值得增加依赖的成本？如果您没有使用捆绑器且这样做的开销很大，那么答案可能是“不”。
- en: When you add TypeScript to the mix, it starts to tip the balance more strongly
    in favor of the Lodash solution.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将 TypeScript 加入到混合中时，它开始更加倾向于 Lodash 解决方案。
- en: 'Both vanilla JS versions of the CSV parser produce the same error in TypeScript:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: CSV 解析器的两个原始 JS 版本在 TypeScript 中产生相同的错误：
- en: '[PRE102]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The solution in each case is to provide a type annotation for `{}`, either
    `{[column: string]: string}` or `Record<string, string>`.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '在每种情况下的解决方案是为`{}`提供类型注释，可以是`{[column: string]: string}`或`Record<string, string>`。'
- en: 'The Lodash version, on the other hand, passes the type checker without modification:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Lodash 版本通过类型检查器而无需修改：
- en: '[PRE103]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '`Dictionary` is a Lodash type alias. `Dictionary<string>` is the same as `{[key:
    string]: string}` or `Record<string, string>`. The important thing here is that
    the type of `rows` is exactly correct, no type annotations needed.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dictionary` 是 Lodash 的一个类型别名。`Dictionary<string>` 等同于 `{[key: string]: string}`
    或 `Record<string, string>`。这里重要的是，`rows` 的类型完全正确，无需类型注释。'
- en: 'These advantages get more pronounced as your data munging gets more elaborate.
    For example, suppose you have a list of the rosters for all the NBA teams:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 随着数据处理变得更加复杂，这些优势变得更加显著。例如，假设您有所有 NBA 球队阵容的列表：
- en: '[PRE104]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'To build a flat list using a loop, you might use `concat` with an array. This
    code runs fine but does not type check:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用循环构建一个扁平化的列表，您可以使用 `concat` 和一个数组。这段代码可以正常运行，但无法通过类型检查：
- en: '[PRE105]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'To fix the error you need to add a type annotation to `allPlayers`:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 要修复错误，您需要为 `allPlayers` 添加类型注释：
- en: '[PRE106]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'But a better solution is to use `Array.prototype.flat`:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 但更好的解决方案是使用 `Array.prototype.flat`：
- en: '[PRE107]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: The `flat` method flattens a multidimensional array. Its type signature is something
    like `T[][] => T[]`. This version is the most concise and requires no type annotations.
    As an added bonus you can use `const` instead of `let` to prevent future mutations
    to the `allPlayers` variable.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`flat` 方法可以将多维数组扁平化。其类型签名大致为 `T[][] => T[]`。这个版本最简洁，不需要类型注释。作为额外的奖励，您可以使用 `const`
    而不是 `let` 来防止将来对 `allPlayers` 变量的突变。'
- en: Say you want to start with `allPlayers` and make a list of the highest-paid
    players on each team ordered by salary.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想从 `allPlayers` 开始，按薪水排序制作每支球队中薪水最高的球员列表。
- en: 'Here’s a solution without Lodash. It requires a type annotation where you don’t
    use functional constructs:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个没有使用 Lodash 的解决方案。在不使用函数式构造的情况下，它需要一个类型注释：
- en: '[PRE108]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Here’s the output:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出结果：
- en: '[PRE109]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Here’s the equivalent with Lodash:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用 Lodash 的等效方法：
- en: '[PRE110]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'In addition to being half the length, this code is clearer and requires only
    a single non-null assertion (the type checker doesn’t know that the `players`
    array passed to `_.maxBy` is non-empty). It makes use of a “chain,” a concept
    in Lodash and Underscore that lets you write a sequence of operations in a more
    natural order. Instead of writing:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 除了长度减半外，这段代码更清晰，并且仅需要一个非空断言（类型检查器不知道传递给 `_.maxBy` 的 `players` 数组是非空的）。它利用了“链”，这是
    Lodash 和 Underscore 中的一个概念，让您按照更自然的顺序编写一系列操作。而不是写成：
- en: '[PRE111]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'you write:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 您写：
- en: '[PRE112]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: The `_(v)` “wraps” the value, and the `.value()` “unwraps” it.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`_(v)` “包装”值，`.value()` “解包”值。'
- en: You can inspect each function call in the chain to see the type of the wrapped
    value. It’s always correct.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以检查链中的每个函数调用以查看包装值的类型。它始终是正确的。
- en: 'Even some of the quirkier shorthands in Lodash can be modeled accurately in
    TypeScript. For instance, why would you want to use `_.map` instead of the built-in
    `Array.prototype.map`? One reason is that instead of passing in a callback you
    can pass in the name of a property. These calls all produce the same result:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至在 Lodash 中一些更奇特的快捷方式也可以在 TypeScript 中准确地建模。例如，为什么要使用 `_.map` 而不是内置的 `Array.prototype.map`？一个原因是，您可以传递属性的名称而不是回调函数。这些调用都会产生相同的结果：
- en: '[PRE113]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: It’s a testament to the sophistication of TypeScript’s type system that it can
    model a construct like this accurately, but it naturally falls out of the combination
    of string literal types and index types (see [Item 14](ch02_split_001.html#map-between-types)).
    If you’re used to C++ or Java, this sort of type inference can feel quite magical!
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 的类型系统之所以能够准确地模拟这样的构造，这是其复杂性的证明，但它自然地由字符串文字类型和索引类型的组合而来（参见 [Item 14](ch02_split_001.html#map-between-types)）。如果您习惯于
    C++ 或 Java，这种类型推断可能会感觉非常神奇！
- en: '[PRE114]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: It’s not a coincidence that types flow so well through built-in functional constructs
    and those in libraries like Lodash. By avoiding mutation and returning new values
    from every call, they are able to produce new types as well ([Item 20](#one-var-one-type)).
    And to a large extent, the development of TypeScript has been driven by an attempt
    to accurately model the behavior of JavaScript libraries in the wild. Take advantage
    of all this work and use them!
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 类型在内置的函数式构造和像 Lodash 这样的库中如此流畅并不是巧合。通过避免突变并从每次调用中返回新值，它们能够生成新的类型（参见 [Item 20](#one-var-one-type)）。在很大程度上，TypeScript
    的发展驱动力是试图准确地模拟 JavaScript 库在实际应用中的行为。利用所有这些工作并加以利用！
- en: Things to Remember
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 要记住的事情
- en: Use built-in functional constructs and those in utility libraries like Lodash
    instead of hand-rolled constructs to improve type flow, increase legibility, and
    reduce the need for explicit type annotations.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内置的功能性构造和像 Lodash 这样的实用库中的构造，而不是手工编写的构造，可以改善类型流动，增加可读性，并减少显式类型注解的需要。
