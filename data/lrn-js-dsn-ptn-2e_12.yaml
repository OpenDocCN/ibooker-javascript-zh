- en: Chapter 12\. React.js Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 12 章。React.js 设计模式
- en: Over the years, there has been an increased demand for straightforward ways
    to compose UIs using JavaScript. Frontend developers look for out-of-the-box solutions
    provided by many different libraries and frameworks. React’s popularity in this
    area has persevered for a long time now since its original release in 2013\. This
    chapter will look at design patterns that are helpful in the React universe.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，使用 JavaScript 组合 UI 的简单方法的需求不断增加。前端开发人员寻找由许多不同的库和框架提供的开箱即用的解决方案。React 在这个领域的流行程度已经持续很长一段时间，自从它在
    2013 年首次发布以来。本章将讨论在 React 宇宙中有帮助的设计模式。
- en: '[React](https://oreil.ly/7Z-65), also referred to as React.js, is an open source
    JavaScript library designed by Facebook to build UIs or UI components. It is,
    of course, not the only UI library out there. [Preact](https://oreil.ly/jXmKM),
    [Vue](https://oreil.ly/fMoMp), [Angular](https://oreil.ly/G_Oyv), [Svelte](https://oreil.ly/scSoT),
    [Lit](https://oreil.ly/5UgxC), and many others are also great for composing interfaces
    from reusable elements. Given React’s popularity, however, we have chosen it for
    our discussion on design patterns for the current decade.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[React](https://oreil.ly/7Z-65)，也称为 React.js，是由 Facebook 设计的开源 JavaScript 库，用于构建
    UI 或 UI 组件。当然，并不是唯一的 UI 库。[Preact](https://oreil.ly/jXmKM)、[Vue](https://oreil.ly/fMoMp)、[Angular](https://oreil.ly/G_Oyv)、[Svelte](https://oreil.ly/scSoT)、[Lit](https://oreil.ly/5UgxC)
    等等也非常适合使用可重用元素来组成界面。然而，鉴于 React 的流行度，我们选择它来讨论当前十年的设计模式。'
- en: An Introduction to React
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React 入门
- en: 'When frontend developers talk about code, it’s most often in the context of
    designing interfaces for the web. And the way we think of interface composition
    is in elements like buttons, lists, navigation, etc. React provides an optimized
    and simplified way of expressing interfaces in these elements. It also helps build
    complex and tricky interfaces by organizing your interface into three key concepts:
    components, props, and state.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 前端开发人员谈论代码时，通常是在设计 Web 界面的上下文中。我们将界面组合看作是按钮、列表、导航等元素。React 提供了一种优化和简化的方式来表达这些元素中的界面。它还通过将界面组织成组件、属性和状态三个关键概念，帮助构建复杂和棘手的界面。
- en: Because React is composition-focused, it can perfectly map to the elements of
    your design system. So, designing for React rewards you for thinking in a modular
    way. It allows you to develop individual components before putting together a
    page or view so that you fully understand each component’s scope and purpose—a
    process referred to as componentization.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 React 专注于组合，它可以完美地映射到设计系统的元素。因此，为 React 设计奖励您以模块化的方式思考。它允许您在将页面或视图组合在一起之前开发单独的组件，以便您充分理解每个组件的范围和目的——这个过程被称为组件化。
- en: Terminology Used
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用的术语
- en: 'We will use the following terms frequently in this chapter. Let’s quickly look
    at what each of them means:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将经常使用以下术语。让我们快速看看它们各自的含义：
- en: React/React.js/ReactJS
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: React/React.js/ReactJS
- en: React library, created by Facebook in 2013
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由 Facebook 于 2013 年创建的 React 库
- en: ReactDOM
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: ReactDOM
- en: The `react-dom` package providing DOM-specific methods for client and server
    rendering
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 提供面向客户端和服务器渲染的 DOM 特定方法的 `react-dom` 包
- en: JSX
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: JSX
- en: Syntax extension to JavaScript
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的语法扩展
- en: Redux
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Redux
- en: Centralized state container
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 集中式状态容器
- en: Hooks
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Hooks
- en: A new way to use state and other React features without writing a class
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一种在不编写类的情况下使用状态和其他 React 特性的新方法
- en: ReactNative
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ReactNative
- en: The library to develop cross-platform native apps with JavaScript
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 用 JavaScript 开发跨平台原生应用程序的库
- en: webpack
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: webpack
- en: JavaScript module bundler, popular in React community
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 模块打包工具，在 React 社区中很受欢迎
- en: Single-page application (SPA)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 单页应用程序（SPA）
- en: A web app that loads new content on the same page without a full page refresh/reload.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一页上加载新内容而无需进行完整的页面刷新/重新加载的 Web 应用程序
- en: Basic Concepts
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本概念
- en: 'Before we discuss React design patterns, it would be helpful to understand
    some basic concepts used in React:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论 React 设计模式之前，了解一些在 React 中使用的基本概念将会很有帮助：
- en: JSX
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: JSX
- en: JSX is an extension to JavaScript that embeds template HTML in JS using XML-like
    syntax. It is meant to be transformed into valid JavaScript, though the semantics
    of that transformation are implementation-specific. JSX rose to popularity with
    the React library but has also seen other implementations.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: JSX 是 JavaScript 的扩展，它使用类似 XML 的语法将模板 HTML 嵌入到 JS 中。它意图被转换为有效的 JavaScript，虽然这种转换的语义是特定于实现的。JSX
    随着 React 库的流行而兴起，但也看到了其他实现。
- en: Components
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 组件
- en: Components are the building blocks of any React app. They are like JavaScript
    functions that accept arbitrary input (Props) and return React elements describing
    what should be displayed on the screen. Everything on screen in a React app is
    part of a component. Essentially, a React app is just components within components
    within components. So developers don’t build pages in React; they build components.
    Components let you split your UI into independent, reusable pieces. If you’re
    used to designing pages, thinking from a component perspective might seem like
    a significant change. But if you use a design system or style guide, this might
    be a smaller paradigm shift than it looks.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是任何 React 应用程序的构建块。它们类似于接受任意输入（属性）并返回描述应该显示在屏幕上的 React 元素的 JavaScript 函数。React
    应用程序中的所有内容都是组件的一部分。基本上，React 应用程序只是组件中的组件中的组件。因此，开发人员不是在 React 中构建页面；他们构建组件。组件让您将
    UI 拆分为独立的、可重用的部分。如果您习惯设计页面，从组件的角度思考可能看起来像是一个重大变化。但如果您使用设计系统或样式指南，这可能比看起来的范式转变要小。
- en: Props
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 属性
- en: 'Props are a short form for properties, and they refer to the internal data
    of a component in React. They are written inside component calls and are passed
    into components. They also use the same syntax as HTML attributes, e.g., `prop
    = value`. Two things worth remembering about props are: (1) we determine the value
    of a prop and use it as part of the blueprint before the component is built, and
    (2) the value of a prop will never change, i.e., props are read-only once passed
    into components. You access a prop by referencing it via the `this.props` property
    that every component can access.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 属性是 React 组件的内部数据的简写形式。它们写在组件调用内部，并传递给组件。它们还使用与 HTML 属性相同的语法，例如，`prop = value`。关于属性值值得记住的两件事是：（1）我们确定属性值并在构建组件之前将其作为蓝图的一部分使用，（2）属性值永远不会改变，即一旦传递给组件，属性就是只读的。您可以通过每个组件都可以访问的
    `this.props` 属性引用来访问属性。
- en: State
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 状态
- en: State is an object that holds information that may change over the component’s
    lifetime. It is the current snapshot of data stored in a component’s props. The
    data can change over time, so techniques to manage data changes become necessary
    to ensure the component looks the way engineers want it to, at just the right
    time—this is called state management.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 状态是一个保存可能随组件生命周期而变化的信息的对象。它是存储在组件属性中的数据的当前快照。数据随时间变化，因此需要技术来管理数据变化，以确保组件在工程师希望的时间看起来正确——这称为状态管理。
- en: Client-side rendering
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端渲染
- en: In client-side rendering (CSR), the server renders only the bare bones HTML
    container for a page. The logic, data fetching, templating, and routing required
    to display content on the page are handled by JavaScript code that executes on
    the client. CSR became popular as a method of building SPAs. It helped to blur
    the difference between websites and installed applications and works best for
    highly interactive applications. With React by default, most of the application
    logic is executed on the client. It interacts with the server through API calls
    to fetch or save data.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端渲染（CSR）中，服务器仅为页面渲染基本的 HTML 容器。显示页面内容所需的逻辑、数据获取、模板化和路由由在客户端执行的 JavaScript
    代码处理。CSR 作为构建单页面应用程序的一种方法变得流行。它有助于模糊网站和安装应用程序之间的差异，并且最适用于高度交互式应用程序。默认情况下，大部分应用程序逻辑在客户端执行。它通过
    API 调用与服务器交互以获取或保存数据。
- en: Server-side rendering
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端渲染
- en: SSR is one of the oldest methods of rendering web content. SSR generates the
    complete HTML for the page content to be rendered in response to a user request.
    The content may include data from a data store or external API. React can be rendered
    isomorphically, which means that it can function both on the browser and other
    platforms like the server. Thus, UI elements may be rendered on the server using
    React.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: SSR 是最古老的网页内容渲染方法之一。SSR 生成完整的 HTML，用于响应用户请求时渲染页面内容。内容可能包括来自数据存储或外部 API 的数据。React
    可以进行同构渲染，这意味着它可以在浏览器和服务器等其他平台上运行。因此，可以使用 React 在服务器上渲染 UI 元素。
- en: Hydration
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 水合
- en: In a server-rendered application, HTML for the current navigation is generated
    on the server and sent to the client. Since the server generated the markup, the
    client can quickly parse this and display it on the screen. The JavaScript required
    to make the UI interactive is loaded after this. The event handlers that will
    make UI elements like buttons interactive get attached only once the JavaScript
    bundle is loaded and processed. This process is called hydration. React checks
    the current DOM nodes and hydrates them with the corresponding JavaScript.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器渲染的应用程序中，当前导航的 HTML 是在服务器上生成并发送到客户端的。由于服务器生成了标记，客户端可以快速解析它并在屏幕上显示。UI 变得交互式所需的
    JavaScript 在此之后加载。只有在 JavaScript 捆绑包加载和处理后，才会附加使按钮等 UI 元素变得交互式的事件处理程序。这个过程称为水合。React
    检查当前的 DOM 节点并用相应的 JavaScript 进行水合处理。
- en: Creating a new app
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的应用程序
- en: Older documentation suggests using Create React App (CRA) to build a new client-only
    SPA for learning React. It is a CLI tool to create a scaffolding React app for
    bootstrapping a project. However, CRA offers a restricted development experience,
    which is too limiting for many modern web applications. React recommends using
    a production-grade React-powered framework such as Next.js or Remix to build new
    web apps or websites. These frameworks provide features that most apps and sites
    eventually need, such as static HTML generation, file-based routing, SPA navigations,
    and real client code.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 较旧的文档建议使用 Create React App（CRA）来构建一个新的仅客户端的单页面应用程序来学习 React。这是一个 CLI 工具，用于为启动项目创建
    React 应用程序的脚手架。然而，CRA 提供了一种受限的开发体验，这对许多现代 Web 应用程序来说太过局限。React 建议使用生产级别的 React
    驱动框架，如 Next.js 或 Remix 来构建新的 Web 应用程序或网站。这些框架提供了大多数应用程序和网站最终需要的功能，如静态 HTML 生成、基于文件的路由、SPA
    导航和真正的客户端代码。
- en: 'React has evolved over the years. Different features introduced to the library
    gave rise to various ways of solving common problems. Here are some popular design
    patterns for React that we will look into in detail in the following sections:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: React 在多年来已经发生了变化。引入到库中的不同特性催生了解决常见问题的各种方式。以下是我们将在接下来的章节中详细探讨的 React 的一些流行设计模式：
- en: '[“Higher-Order Components”](#higher-order-components)'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“高阶组件”](#higher-order-components)'
- en: '[“Render Props Pattern”](#render-props-pattern)'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“渲染属性模式”](#render-props-pattern)'
- en: '[“Hooks Pattern”](#hooks-pattern)'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“Hooks 模式”](#hooks-pattern)'
- en: '[“Static Import”](#static-import)'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“静态导入”](#static-import)'
- en: '[“Dynamic Import”](#dynamic-import)'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“动态导入”](#dynamic-import)'
- en: '[“Code-Splitting”](#code-splitting)'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“代码分割”](#code-splitting)'
- en: '[“PRPL Pattern”](#prpl-pattern)'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“PRPL 模式”](#prpl-pattern)'
- en: '[“Loading Prioritization”](#loading-prioritization)'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“加载优先级”](#loading-prioritization)'
- en: Higher-Order Components
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高阶组件
- en: We may often want to use the same logic in multiple components within our application.
    This logic can include applying specific styling to components, requiring authorization,
    or adding a global state. One way to reuse the same logic in multiple components
    is by using the Higher-Order Component (HOC) pattern. This pattern allows us to
    reuse component logic throughout our application.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常希望在应用程序中的多个组件中使用相同的逻辑。这种逻辑可以包括向组件应用特定样式、需要授权或添加全局状态。通过使用高阶组件（HOC）模式，我们可以在多个组件中重用相同的逻辑。这种模式允许我们在整个应用程序中重用组件逻辑。
- en: An HOC is a component that receives another component. The HOC can contain a
    specific feature that can be applied to a component we pass to it as a parameter.
    The HOC returns the component with the additional feature applied to it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶组件（HOC）是一个接收另一个组件的组件。HOC 可以包含一个特定功能，该功能可以应用于我们传递给它的组件。HOC 返回应用了附加功能的组件。
- en: 'Say that we always wanted to add particular styling to multiple components
    in our application. Instead of creating a style object locally each time, we can
    create an HOC that adds the style objects to the component it received as a parameter:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们始终希望向应用程序中的多个组件添加特定样式。我们可以创建一个高阶组件（HOC），将样式对象添加到作为参数传递的组件中，而不是每次在本地创建样式对象：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We just created a `StyledButton` and `StyledText` component, the modified versions
    of the `Button` and `Text` component. They now both contain the style that got
    added in the `withStyles` HOC.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了`StyledButton`和`StyledText`组件，这是`Button`和`Text`组件的修改版本。它们现在都包含了在`withStyles`高阶组件中添加的样式。
- en: To take it further, let us look at an application that renders a list of dog
    images fetched from an API. When fetching the data, we want to show the user a
    “Loading…​” screen. Instead of adding it to the `DogImages` component directly,
    we can use an HOC that adds this logic.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步来看，让我们看一个从API获取的狗图片列表的应用程序。在获取数据时，我们希望向用户显示“Loading…​”屏幕。我们可以使用一个高阶组件添加这个逻辑，而不是直接将其添加到`DogImages`组件中。
- en: 'Let’s create an HOC called `withLoader`. An HOC should receive a component
    and return that component. In this case, the `withLoader` HOC should receive the
    element which should display `Loading…` until the data is fetched. To make the
    `withLoader` HOC very reusable, we won’t hardcode the Dog API URL in that component.
    Instead, we can pass the URL as an argument to the `withLoader` HOC, so this loader
    can be used on any component that needs a loading indicator while fetching data
    from a different API endpoint:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`withLoader`的高阶组件。一个高阶组件应该接收一个组件并返回该组件。在这种情况下，`withLoader`高阶组件应该接收应该显示`Loading…`直到数据被获取的元素。为了使`withLoader`高阶组件非常可重用，我们不会在该组件中硬编码狗API
    URL。相反，我们可以将URL作为参数传递给`withLoader`高阶组件，因此在从不同API端点获取数据时，可以使用此加载器在任何需要加载指示器的组件上：
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'An HOC returns an element, a functional component `props ⇒ {}` in this case,
    to which we want to add the logic that allows us to display a text with `Loading…`
    as the data is still being fetched. Once the data has been fetched, the component
    should pass the fetched data as a prop. The complete code for `withLoader` looks
    like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶组件返回一个元素，一个函数组件`props ⇒ {}`在这种情况下，我们希望在数据仍在获取时显示一个带有`Loading…`文本的逻辑。一旦数据被获取，组件应该将获取的数据作为属性传递。完整的`withLoader`代码如下所示：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We just created an HOC that can receive any component and URL:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了一个可以接收任何组件和URL的高阶组件：
- en: In the `useEffect` hook, the `withLoader` HOC fetches the data from the API
    endpoint that we pass as the value of `url`. While the data is being fetched,
    we return the element containing the `Loading…​` text.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`useEffect`钩子中，`withLoader`高阶组件从我们传递的API端点获取数据。在数据正在获取的时候，我们返回包含`Loading…`文本的元素。
- en: Once the data has been fetched, we set data equal to the data that has been
    fetched. Since data is no longer `null`, we can display the element that we passed
    to the HOC.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦数据被获取，我们将数据设置为已获取的数据。由于数据不再为`null`，我们可以显示传递给高阶组件的元素。
- en: 'Now to show the `Loading…​` indicator on the `DogImages` list, we will export
    the “wrapped” `withLoading` HOC around the `DogImages` component. The `withLoader`
    HOC also expects the `url` to know which endpoint to fetch the data from. In this
    case, we want to add the Dog API endpoint. Since the `withLoader` HOC returned
    the element with an extra data prop, `DogImages` in this case, we can access the
    data prop in the `DogImages` component:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了在`DogImages`列表上显示`Loading…`指示器，我们将“包装好的”`withLoading`高阶组件导出到`DogImages`组件周围。`withLoader`高阶组件还期望`url`，以了解从哪个端点获取数据。在这种情况下，我们想要添加狗API端点。由于`withLoader`高阶组件返回了带有额外数据属性的元素，因此在`DogImages`组件中，我们可以访问数据属性：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The HOC pattern allows us to provide the same logic to multiple components while
    keeping all the logic in one place. The `withLoader` HOC doesn’t care about the
    component or URL it receives; as long as it’s a valid component and a valid API
    endpoint, it’ll simply pass the data from that API endpoint to the component that
    we pass.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶组件模式允许我们为多个组件提供相同的逻辑，同时将所有逻辑保存在一个地方。`withLoader`高阶组件不关心接收的组件或URL；只要是有效的组件和有效的API端点，它将简单地将来自该API端点的数据传递给我们传递的组件。
- en: Composing
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合
- en: We can also compose multiple HOCs. Let’s say we also want to add functionality
    that shows a hovering text box when the user hovers over the `DogImages` list.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以组合多个高阶组件。比如说，我们还想添加一个功能，当用户悬停在`DogImages`列表上时显示一个悬停文本框。
- en: We must create a HOC that provides a hovering prop to the element we pass. Based
    on that prop, we can conditionally render the text box based on whether the user
    is hovering over the `DogImages` list.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须创建一个高阶组件（HOC），为我们传递的元素提供一个悬停属性。基于这个属性，我们可以根据用户是否悬停在`DogImages`列表上来有条件地渲染文本框。
- en: 'We can now wrap the `withHover` HOC around the `withLoader` HOC:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将`withHover`高阶组件包装在`withLoader`高阶组件外部：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `DogImages` element now contains all props we passed from `withHover` and
    `withLoader`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`DogImages`元素包含了我们从`withHover`和`withLoader`传递的所有属性。
- en: 'We can also use the Hooks pattern to achieve similar results in some cases.
    We will discuss this pattern in detail later in this chapter, but for now, let’s
    just say that using Hooks can reduce the depth of the component tree, while using
    the HOC pattern, it’s easy to end up with a deeply nested component tree. The
    best use cases for HOC are those where the following are true:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们还可以使用 Hooks 模式来实现类似的结果。我们将在本章稍后详细讨论这种模式，但现在，让我们简单地说，使用 Hooks 可以减少组件树的深度，而使用
    HOC 模式则很容易导致组件树深度嵌套。适合使用 HOC 的最佳情况是以下情况为真：
- en: The same uncustomized behavior needs to be used by many components throughout
    the application.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序中许多组件需要使用相同的未定制行为。
- en: The component can work standalone without the added custom logic.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件可以独立工作，无需添加自定义逻辑。
- en: Pros
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优点
- en: Using the HOC pattern allows us to keep logic we want to reuse all in one place.
    This reduces the risk of accidentally spreading bugs throughout the application
    by duplicating code repeatedly, potentially introducing new bugs. By keeping the
    logic in one place, we can keep our code DRY and efficiently enforce the separation
    of concerns.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 HOC 模式可以将我们想要重用的逻辑集中在一处。这样做可以减少通过重复复制代码而在应用程序中意外传播错误的风险，从而可能引入新的错误。通过将逻辑集中在一处，我们可以保持代码的
    DRY，并有效地强制执行关注点的分离。
- en: Cons
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缺点
- en: 'The prop’s name that a HOC can pass to an element can cause a naming collision.
    For example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶组件可以向元素传递的道具名称可能会导致名称冲突。例如：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this case, the `withStyles` HOC adds a prop called `style` to the element
    we pass to it. However, the `Button` component already had a prop called `style`,
    which will be overwritten! Make sure the HOC can handle accidental name collision
    by either renaming or merging the props:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`withStyles` 高阶组件（HOC）向我们传递的元素添加了一个名为 `style` 的属性。然而，`Button` 组件已经有一个名为
    `style` 的属性，这将被覆盖！确保高阶组件能够通过重命名或合并属性来处理意外的名称冲突：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When using multiple composed HOCs that all pass props to the element wrapped
    within them, it can be challenging to figure out which HOC is responsible for
    which prop. This can hinder debugging and scaling an application easily.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用多个组合的高阶组件时，它们都将道具传递给包装在其中的元素时，找出哪个高阶组件负责哪个道具可能是具有挑战性的。这可能会阻碍调试和轻松扩展应用程序。
- en: Render Props Pattern
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染道具模式
- en: In the section on HOCs, we saw that reusing component logic can be convenient
    if multiple components need access to the same data or contain the same logic.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在高阶组件部分，我们看到如果多个组件需要访问相同的数据或包含相同的逻辑，重用组件逻辑将是方便的。
- en: Another way of making components reusable is by using the Render Prop pattern.
    A render prop is a prop on a component whose value is a function that returns
    a JSX element. The component itself does not render anything besides the render
    prop. It simply calls the render prop instead of implementing its own rendering
    logic.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种使组件可重用的方法是使用渲染道具模式。渲染道具是组件上的一个属性，其值是一个返回 JSX 元素的函数。组件本身除了调用渲染道具而不实现自己的渲染逻辑外，不渲染任何内容。
- en: 'Imagine that we have a `Title` component that should just render the value
    we pass. We can use a render prop for this. Let’s pass the value we want the `Title`
    component to render to the render prop:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个 `Title` 组件，应该只渲染我们传递的值。我们可以为此使用渲染道具。让我们将想要 `Title` 组件渲染的值传递给渲染道具：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can render this data within the `Title` component by returning the invoked
    render prop:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过返回调用的渲染道具来在 `Title` 组件中渲染这些数据：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We have to pass a prop called `render` to the Component element, which is a
    function that returns a React element:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须向组件元素传递一个名为 `render` 的道具，这是一个返回 React 元素的函数：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The cool thing about render props is that the component receiving the prop is
    reusable. We can use it multiple times, passing different values to the render
    prop each time.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染道具的有趣之处在于接收该道具的组件是可重用的。我们可以多次使用它，每次传递不同的值给渲染道具。
- en: 'Although they’re called render props, a render prop doesn’t have to be called
    render. Any prop that renders JSX is considered a render prop. Thus we have three
    render props in the following example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们被称为渲染道具，但渲染道具不一定要被称为 `render`。任何渲染 JSX 的道具都被视为渲染道具。因此，在下面的示例中，我们有三个渲染道具：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We’ve just seen that we can use render props to make a component reusable, as
    we can pass different data to the render prop each time.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到，我们可以使用渲染道具使组件可重用，因为我们每次可以传递不同的数据给渲染道具。
- en: 'A component that takes a render prop usually does much more than simply invoking
    the render prop. Instead, we typically want to pass data from the component that
    takes the render prop to the element we pass as a render prop:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用渲染属性的组件通常不仅仅调用渲染属性。相反，我们通常希望从接受渲染属性的组件传递数据到作为渲染属性传递的元素：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The render prop can now receive this value that we passed as its argument:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在渲染属性可以接收我们传递的这个值作为其参数：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Lifting State
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提升状态
- en: Before we look at another use case for the Render Props pattern, let’s understand
    the concept of “Lifting state up” in React.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看另一个使用渲染属性模式的用例之前，让我们先了解在 React 中“状态提升”的概念。
- en: 'Let’s say we have a temperature converter where you can provide the input in
    Celsius in one stateful input element. The corresponding `Fahrenheit` and `Kelvin`
    values are reflected instantly in two other components. For the input element
    to be able to share its state with other components, we will have to move the
    state up to the closest common ancestor of the components that need it. This is
    called “Lifting state up”:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个温度转换器，您可以在一个有状态的输入元素中提供摄氏度输入。两个其他组件中的对应的 `Fahrenheit` 和 `Kelvin` 值会立即反映出来。为了能够与其他组件共享其状态，我们将不得不将状态移至需要它的组件的最近公共祖先。这就是所谓的“状态提升”：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Lifting state is a valuable React state management pattern because sometimes
    we want a component to be able to share its state with sibling components. In
    the case of small applications with a few components, we can avoid using a state
    management library like Redux or React Context and use this pattern instead to
    lift the state up to the closest common ancestor.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 状态提升是一种有价值的 React 状态管理模式，因为有时我们希望一个组件能够与其兄弟组件共享其状态。在具有少量组件的小型应用中，我们可以避免使用 Redux
    或 React Context 这样的状态管理库，而是使用这种模式将状态提升到最近的共同祖先组件中。
- en: 'Although this is a valid solution, lifting the state in larger applications
    with components that handle many children can be tricky. Each state change could
    cause a re-render of all the children, even those that don’t handle the data,
    which could negatively affect your app’s performance. We can use the Render Props
    pattern to work around this problem. We will change the `Input` component such
    that it can receive render props:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个有效的解决方案，但是在处理许多子组件的大型应用中提升状态可能会比较棘手。每次状态更改都可能导致所有子组件重新渲染，即使这些组件不处理数据，也可能对应用程序的性能产生负面影响。我们可以使用渲染属性模式来解决这个问题。我们将改变
    `Input` 组件，使其能够接收渲染属性：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Children as a Function
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将子元素作为函数
- en: Besides regular JSX components, we can pass functions as children to React components.
    This function is available to us through the children prop, which is technically
    also a render prop.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 除了常规的 JSX 组件外，我们还可以将函数作为子元素传递给 React 组件。通过 `children` 属性，我们可以访问到这个函数，技术上也算是一个渲染属性。
- en: 'Let’s change the `Input` component. Instead of explicitly passing the render
    prop, we’ll pass a function as a child for the `Input` component:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们改变 `Input` 组件。我们不再显式地传递渲染属性，而是将一个函数作为 `Input` 组件的子元素：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We have access to this function through the `props.children` prop that’s available
    on the `Input` component. Instead of calling `props.render` with the user input
    value, we’ll call `props.children` with the value of the user input:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 `props.children` 属性访问到这个函数，该属性在 `Input` 组件上是可用的。我们不再使用用户输入值调用 `props.render`，而是使用用户输入的值调用
    `props.children`：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This way, the `Kelvin` and `Fahrenheit` components have access to the value
    without worrying about the name of the render prop.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`Kelvin` 和 `Fahrenheit` 组件可以访问该值，而不用担心渲染属性的名称。
- en: Pros
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优点
- en: Sharing logic and data among several components is straightforward with the
    Render Props pattern. Components can be made reusable by using a render or children
    prop. Although the HOC pattern mainly solves the same issues, namely reusability
    and sharing data, the Render Props pattern solves some problems we could encounter
    using the HOC pattern.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用渲染属性模式可以轻松地在多个组件之间共享逻辑和数据。通过使用渲染属性或子元素属性，组件可以被设计为可重用。虽然高阶组件模式主要解决相同的问题，即可重用性和数据共享，但渲染属性模式解决了在使用高阶组件模式时可能遇到的一些问题。
- en: The issue of naming collisions that we can run into by using the HOC pattern
    no longer applies by using the Render Props pattern since we don’t automatically
    merge props. We explicitly pass the props down to the child components with the
    value provided by the parent component.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用渲染属性模式，我们不再自动合并属性，从而避免了使用高阶组件模式可能遇到的命名冲突问题。我们会显式地通过父组件提供的值将属性传递给子组件。
- en: Since we explicitly pass props, we solve the HOC’s implicit props issue. The
    props that should get passed down to the element are all visible in the render
    prop’s arguments list. This way, we know exactly where specific props come from.
    We can separate our app’s logic from rendering components through render props.
    The stateful component that receives a render prop can pass the data onto stateless
    components, which merely render the data.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们明确传递props，我们解决了HOC的隐式props问题。应该传递到元素的props都在渲染属性的参数列表中是可见的。通过这种方式，我们确切地知道特定props来自何处。我们可以通过渲染属性将应用程序的逻辑与渲染组件分离。接收渲染属性的有状态组件可以将数据传递给仅仅渲染数据的无状态组件。
- en: Cons
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缺点
- en: React Hooks have mostly resolved the issues we tried to solve with render props.
    As Hooks changed how we can add reusability and data sharing to components, they
    can replace the Render Props pattern in many cases.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: React Hooks 在很大程度上解决了我们尝试使用渲染属性解决的问题。由于Hooks改变了我们向组件添加可重用性和数据共享的方式，它们可以在许多情况下替代渲染属性模式。
- en: Since we can’t add lifecycle methods to a render prop, we can use it only on
    components that don’t need to alter the data they receive.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们无法向渲染属性添加生命周期方法，因此只能在不需要修改接收到的数据的组件上使用它。
- en: Hooks Pattern
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hooks 模式
- en: React 16.8 introduced a new feature called [Hooks](https://oreil.ly/6qnHk).
    Hooks make it possible to use React state and lifecycle methods without using
    an ES2015 class component. Although Hooks is not necessarily a design pattern,
    Hooks plays a vital role in your application design. Hooks can replace many traditional
    design patterns.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: React 16.8引入了一个名为[Hooks](https://oreil.ly/6qnHk)的新功能。Hooks使得可以在不使用ES2015类组件的情况下使用React状态和生命周期方法。虽然Hooks不一定是一个设计模式，但Hooks在应用程序设计中扮演了重要角色。Hooks可以替代许多传统的设计模式。
- en: Let’s see how class components enabled the addition of state and lifecycle methods.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看类组件是如何实现添加状态和生命周期方法的。
- en: Class Components
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类组件
- en: 'Before Hooks were introduced in React, we had to use class components to add
    state and lifecycle methods to components. A typical class component in React
    can look something like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在React引入Hooks之前，我们必须使用类组件向组件添加状态和生命周期方法。React中的典型类组件可能如下所示：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'A class component can contain the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 类组件可以包含以下内容：
- en: A state in its constructor
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数中的状态
- en: Lifecycle methods such as `componentDidMount` and `componentWillUnmount` to
    perform side effects based on a component’s lifecycle
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生命周期方法如`componentDidMount`和`componentWillUnmount`用于根据组件的生命周期执行副作用。
- en: Custom methods to add extra logic to a class
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加额外逻辑到类的自定义方法
- en: 'Although we can still use class components after the introduction of React
    Hooks, using class components can have some downsides. For example, consider the
    following example where a simple `div` functions as a button:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在引入React Hooks后我们仍然可以使用类组件，但使用类组件可能会有一些缺点。例如，考虑以下示例，其中一个简单的`div`作为按钮：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Instead of always displaying disabled, we want to change it to enabled and
    add some extra CSS styling to the button when the user clicks on it. To do that,
    we need to add state to the component to know whether the status is enabled or
    disabled. This means we’d have to refactor the functional component entirely and
    make it a class component that keeps track of the button’s state:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是始终显示为禁用状态，我们希望在用户单击按钮时将其更改为启用状态，并为按钮添加一些额外的CSS样式。为此，我们需要向组件添加状态来知道状态是启用还是禁用。这意味着我们必须完全重构功能组件，并使其成为一个保持按钮状态的类组件：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this example, the component is minimal, and refactoring didn’t need much
    effort. However, your real-life components probably consist of many more lines
    of code, making refactoring the component much more difficult.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，组件很简单，重构并不需要太多的工作。然而，你的真实组件可能包含更多的代码行，这使得重构组件变得更加困难。
- en: Besides ensuring you don’t accidentally change any behavior while refactoring
    the component, you must also understand how ES2015+ classes work. Knowing how
    to refactor a component properly without accidentally changing the data flow can
    be challenging.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 除了确保在重构组件时不要意外改变任何行为之外，还必须理解ES2015+类的工作方式。在不意外更改数据流的情况下正确重构组件可能是具有挑战性的。
- en: Restructuring
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构
- en: The standard way to share code among several components is using the HOC or
    Render Props pattern. Although both patterns are valid and using them is a good
    practice, adding those patterns at a later point in time requires you to restructure
    your application.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在几个组件之间共享代码的标准方法是使用HOC或Render Props模式。虽然这两种模式都是有效的，并且使用它们是一种良好的实践，但在以后的某个时候添加这些模式需要重新构造应用程序。
- en: 'Besides restructuring your app, which is trickier the bigger your components
    are, having many wrapping components to share code among deeper nested components
    can lead to something that’s best referred to as a “wrapper hell.” It’s not uncommon
    to open your dev tools and see a structure similar to the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 除了重构应用程序外，组件越大，使用许多包装组件在更深层嵌套组件之间共享代码也会导致一种被称为“包装地狱”的情况。在开发工具中看到以下类似结构并不罕见：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The wrapper hell can make it difficult to understand how data flows through
    your application, making it harder to figure out why unexpected behavior is happening.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 包装地狱可能会使您难以理解数据在应用程序中的流动方式，从而更难弄清为什么会发生意外行为。
- en: Complexity
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复杂性
- en: As we add more logic to class components, the size of the component increases
    fast. Logic within that component can get tangled and unstructured, making it
    difficult for developers to understand where certain logic is used in the class
    component. This can make debugging and optimizing performance more difficult.
    Lifecycle methods also require quite a lot of duplication in the code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们向类组件添加更多逻辑，组件的大小会迅速增加。组件内部的逻辑可能会变得混乱和无结构，使开发人员难以理解类组件中某些逻辑的使用位置。这可能会使调试和优化性能变得更加困难。生命周期方法在代码中也需要大量重复。
- en: Hooks
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 钩子
- en: 'Class components aren’t always a great feature in React. To solve the common
    issues that React developers can run into when using class components, React introduced
    React Hooks. React Hooks are functions you can use to manage a component’s state
    and lifecycle methods. React Hooks make it possible to:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中，并非总是使用类组件是一个很好的特性。为了解决React开发人员在使用类组件时可能遇到的常见问题，React引入了React Hooks。React
    Hooks是您可以用来管理组件状态和生命周期方法的函数。React Hooks使得：
- en: Add state to a functional component
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加状态到函数组件
- en: Manage a component’s lifecycle without having to use lifecycle methods such
    as `componentDidMount` and `componentWillUnmount`
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不使用`componentDidMount`和`componentWillUnmount`等生命周期方法的情况下管理组件的生命周期
- en: Reuse the same stateful logic among multiple components throughout the app
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在整个应用程序中重用相同的有状态逻辑
- en: First, let’s look at how we can add state to a functional component using React
    Hooks.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看如何使用React Hooks向函数组件添加状态。
- en: State Hook
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态钩子
- en: React provides a Hook called `useState` that manages state within a functional
    component.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: React提供了一个名为`useState`的Hook，用于在函数组件内部管理状态。
- en: 'Let’s see how a class component can be restructured into a functional component
    using the `useState` Hook. We have a class component called `Input`, which renders
    an input field. The value of input in the state updates whenever the user types
    anything in the input field:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`useState`钩子将类组件重构为函数组件。我们有一个名为`Input`的类组件，它渲染一个输入字段。当用户在输入字段中键入任何内容时，输入状态中的值会更新：
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To use the `useState` Hook, we need to access React’s `useState` method. The
    `useState` method expects an argument: this is the initial value of the state,
    an empty string in this case.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`useState`钩子，我们需要访问React的`useState`方法。`useState`方法期望一个参数：这是状态的初始值，在本例中是一个空字符串。
- en: 'We can destructure two values from the `useState` method:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从`useState`方法中解构出两个值：
- en: The *current value* of the state
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态的*当前值*
- en: 'The *method with which we can update* the state:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*我们可以更新状态的方法*：'
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can compare the first value to a class component’s `this.state.[value]`.
    The second value can be compared to a class component’s `this.setState` method.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将第一个值与类组件的`this.state.[value]`进行比较。第二个值可以与类组件的`this.setState`方法进行比较。
- en: 'Since we’re dealing with the value of an input, let’s call the current value
    of the state input and the method to update the state `setInput`. The initial
    value should be an empty string:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们处理输入的值，让我们称状态的当前值为输入，用于更新状态的方法称为`setInput`。初始值应为空字符串：
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can now refactor the `Input` class component into a stateful functional
    component:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将`Input`类组件重构为有状态的函数组件：
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The input field’s value is equal to the current value of the input state, just
    like in the class component example. When the user types in the input field, the
    value of the input state updates accordingly using the `setInput` method:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 输入字段的值等于输入状态的当前值，就像在类组件示例中一样。当用户在输入字段中输入时，输入状态的值相应地更新，使用`setInput`方法：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Effect Hook
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Effect Hook
- en: We’ve seen we can use the `useState` component to handle state within a functional
    component. Still, another benefit of class components was the possibility of adding
    lifecycle methods to a component.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到可以使用`useState`组件在函数组件内处理状态。但是，类组件的另一个好处是可以将生命周期方法添加到组件中。
- en: 'With the `useEffect` Hook, we can “hook into” a component’s lifecycle. The
    `useEffect` Hook effectively combines the `componentDidMount`, `componentDidUpdate`,
    and `componentWillUnmount` lifecycle methods:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`useEffect`钩子，我们可以“挂接”到组件的生命周期。`useEffect`钩子有效地结合了`componentDidMount`、`componentDidUpdate`和`componentWillUnmount`生命周期方法：
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Let’s use the input example we used in the state Hook section. Whenever the
    user is typing anything in the input field, the value should also be logged to
    the console.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用状态钩子部分中使用的输入示例。每当用户在输入字段中输入任何内容时，该值也应该记录到控制台中。
- en: 'We need a `useEffect` Hook that “listens” to the input value. We can do so
    by adding input to the dependency array of the `useEffect` Hook. The dependency
    array is the second argument that the `useEffect` Hook receives:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个`useEffect`钩子来“监听”输入值。我们可以通过将输入添加到`useEffect`钩子的依赖数组中来实现这一点。依赖数组是`useEffect`钩子接收的第二个参数：
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The value of the input now gets logged to the console whenever the user types
    a value.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户键入值时，输入字段的值现在会记录到控制台中。
- en: Custom Hooks
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义钩子
- en: Besides the built-in Hooks that React provides (`useState`, `useEffect`, `useReducer`,
    `useRef`, `useContext`, `useMemo`, `useImperativeHandle`, `useLayoutEffect`, `useDebugValue`,
    `useCallback`), we can easily create our own custom Hooks.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 除了React提供的内置钩子（`useState`，`useEffect`，`useReducer`，`useRef`，`useContext`，`useMemo`，`useImperativeHandle`，`useLayoutEffect`，`useDebugValue`，`useCallback`），我们还可以轻松创建自己的自定义钩子。
- en: You may have noticed that all Hooks start with “use.” It’s essential to begin
    your Hooks with “use” for React to check if it violates the rules of Hooks.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到所有的钩子都以“use”开头。重要的是要以“use”开头，以便React检查是否违反了Hooks的规则。
- en: Let’s say we want to keep track of specific keys the user may press when writing
    the input. Our custom Hook should be able to receive the key we want to target
    as its argument.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想追踪用户在输入时可能按下的特定键。我们的自定义钩子应该能够接收我们想要定位的键作为参数。
- en: 'We want to add a `keydown` and `keyup` event listener to the key that the user
    passed as an argument. If the user presses that key, meaning the `keydown` event
    gets triggered, the state within the Hook should toggle to true. Otherwise, when
    the user stops pressing that button, the `keyup` event gets triggered and the
    state toggles to false:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望为用户传递的参数添加`keydown`和`keyup`事件侦听器。如果用户按下该键，则`keydown`事件将被触发，Hook内的状态应该切换为true。否则，当用户停止按下该按钮时，将触发`keyup`事件，并且状态将切换为false：
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can use this custom Hook in our input application. Let’s log to the console
    whenever the user presses the q, l, or w key:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们的输入应用程序中使用这个自定义钩子。当用户按下q、l或w键时，让我们将其记录到控制台中：
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Instead of keeping the key press logic local to the `Input` component, we can
    reuse the `useKeyPress` Hook with multiple components without having to rewrite
    the same code repeatedly.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重复使用`useKeyPress`钩子，而不必重复编写相同的代码，而是将键按逻辑局限于“Input”组件。
- en: Another great advantage of Hooks is that the community can build and share Hooks.
    We wrote the `useKeyPress` Hook ourselves, but that wasn’t necessary. The Hook
    was already built by someone else and ready to use in our application if we had
    just installed it.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Hooks的另一个重要优势是社区可以构建和共享Hooks。我们自己编写了`useKeyPress`钩子，但这并不是必要的。如果我们安装了它，别人已经构建并准备在我们的应用程序中使用该钩子。
- en: 'The following are some websites that list all the Hooks built by the community
    and ready to use in your application:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些列出社区构建的所有钩子并准备在您的应用程序中使用的网站：
- en: '[React Use](https://oreil.ly/Ya94L)'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[React Use](https://oreil.ly/Ya94L)'
- en: '[useHooks](https://oreil.ly/ZMTcR)'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[useHooks](https://oreil.ly/ZMTcR)'
- en: '[Collection of React Hooks](https://oreil.ly/jlksC)'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[React钩子集合](https://oreil.ly/jlksC)'
- en: Additional Hooks Guidance
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 额外的钩子指导
- en: 'Like other components, special functions are used when you want to add Hooks
    to the code you have written. Here’s a brief overview of some common Hook functions:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他组件一样，特殊函数是在你想要向编写的代码添加钩子时使用的。以下是一些常见钩子函数的简要概述：
- en: '`useState`'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`useState`'
- en: The `useState` Hook enables developers to update and manipulate state inside
    function components without needing to convert it to a class component. One advantage
    of this Hook is that it is simple and does not require as much complexity as other
    React Hooks.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`useState` 钩子使开发人员能够在函数组件内更新和操作状态，而无需将其转换为类组件。该钩子的一个优点是它简单，并且不需要像其他 React Hooks
    那样复杂。'
- en: '`useEffect`'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`useEffect`'
- en: The `useEffect` Hook is used to run code during major lifecycle events in a
    function component. The main body of a function component does not allow mutations,
    subscriptions, timers, logging, and other side effects. It could lead to confusing
    bugs and inconsistencies within the UI if they are allowed. The `useEffect` Hook
    prevents all of these “side effects” and allows the UI to run smoothly. It combines
    `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount`, all in
    one place.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`useEffect` 钩子用于在函数组件中的主要生命周期事件期间运行代码。函数组件的主体不允许突变、订阅、计时器、日志记录和其他副作用。如果允许这些副作用，可能会导致
    UI 内的混乱错误和一致性问题。`useEffect` 钩子防止所有这些“副作用”，并允许 UI 顺畅运行。它将 `componentDidMount`、`componentDidUpdate`
    和 `componentWillUnmount` 结合到一个地方。'
- en: '`useContext`'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`useContext`'
- en: The `useContext` Hook accepts a context object, the value returned from `React.createcontext`,
    and returns the current context value for that context. The `useContext` Hook
    also works with the React Context API to share data throughout the app without
    passing your app props down through various levels. Note that the argument passed
    to the `useContext` Hook must be the context object itself and any component calling
    the `useContext` always rerenders whenever the context value changes.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`useContext` 钩子接受一个上下文对象，即 `React.createcontext` 返回的值，并返回该上下文的当前值。`useContext`
    钩子还与 React 上下文 API 配合使用，通过各种层级共享数据，而无需将应用程序的 props 传递给其他组件。请注意，传递给 `useContext`
    钩子的参数必须是上下文对象本身，任何调用 `useContext` 的组件在上下文值更改时都会重新渲染。'
- en: '`useReducer`'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`useReducer`'
- en: The `useReducer` Hook gives an alternative to `setState`. It is especially preferable
    when you have complex state logic that involves multiple subvalues or when the
    next state depends on the previous one. It takes on a reducer function and an
    initial state input and returns the current state and a dispatch function as output
    using array destructuring. `useReducer` also optimizes the performance of components
    that trigger deep updates.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`useReducer` 钩子提供了一种替代 `setState` 的方法。特别适合处理涉及多个子值或下一个状态依赖于上一个状态的复杂状态逻辑。它使用数组解构接受一个
    reducer 函数和一个初始状态输入，并返回当前状态和一个调度函数作为输出。`useReducer` 还优化了触发深度更新的组件的性能。'
- en: Pros and Cons of Using Hooks
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Hooks 的优缺点
- en: 'Here are some benefits of making use of Hooks:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Hooks 的一些好处如下：
- en: Fewer lines of code
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 代码行数较少
- en: Hooks allow you to group code by concern and functionality, not by lifecycle.
    This makes the code not only cleaner and concise but also shorter. What follows
    is a comparison of a simple stateful component of a searchable product data table
    using React and how it looks in Hooks after using the `useState` keyword.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Hooks 允许您按关注点和功能组织代码，而不是按生命周期组织。这不仅使代码更清晰简洁，而且更短。以下是使用 React 的可搜索产品数据表的简单有状态组件的比较，以及在使用
    `useState` 关键字后使用 Hooks 的外观。
- en: 'Stateful component:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 有状态组件：
- en: '[PRE30]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here’s the same component with Hooks:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用 Hooks 的同一组件：
- en: '[PRE31]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Simplifies complex components
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 简化复杂组件
- en: JavaScript classes can be challenging to manage, can be hard to use with hot
    reloading, and may need to be minified better. React Hooks solves these problems
    and ensures functional programming is made easy. With the implementation of Hooks,
    we don’t need to have class components.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 类可能很难管理，与热重载结合使用可能会很困难，并且可能需要更好的缩小。React Hooks 解决了这些问题，并确保函数式编程变得更容易。使用
    Hooks，我们不需要类组件。
- en: Reusing stateful logic
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 重复使用有状态逻辑
- en: Classes in JavaScript encourage multiple levels of inheritance that quickly
    increase overall complexity and potential for errors. However, Hooks allow you
    to use state and other React features without writing a class. With React, you
    can always reuse stateful logic without needing to rewrite the code repeatedly.
    This reduces the chances of errors and allows for composition with plain functions.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，类鼓励多级继承，这会快速增加整体复杂性和错误的潜在可能性。然而，Hooks 允许您在不编写类的情况下使用状态和其他 React
    功能。使用 React，您始终可以重复使用有状态逻辑，而无需重复编写代码。这降低了错误发生的机会，并允许使用普通函数进行组合。
- en: Sharing nonvisual logic
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 共享非可视逻辑
- en: Until the implementation of Hooks, React had no way of extracting and sharing
    nonvisual logic. This eventually led to more complexities, such as the HOC patterns
    and Render Props, to solve a common problem. The introduction of Hooks has solved
    this problem because it allows for extracting stateful logic to a simple JavaScript
    function.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Hooks 实现之前，React 没有提取和共享非可视逻辑的方法。这最终导致了更多的复杂性，例如 HOC 模式和 Render Props，用于解决常见问题。引入
    Hooks 解决了这个问题，因为它允许将有状态的逻辑提取到一个简单的 JavaScript 函数中。
- en: 'There are, of course, some potential downsides to Hooks worth keeping in mind:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，使用 Hooks 也有一些潜在的缺点需要牢记：
- en: Have to respect its rules. With a linter plug-in, knowing which rule has been
    broken is easier.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须遵守其规则。使用 linter 插件，更容易知道哪个规则被破坏了。
- en: Need considerable time practicing to use correctly (e.g., `useEffect`).
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要花费相当多的时间练习以正确使用（例如 `useEffect`）。
- en: Need to be aware of the wrong use (e.g., `useCallback`, `useMemo`).
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要注意错误的使用（例如 `useCallback`、`useMemo`）。
- en: React Hooks Versus Classes
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React Hooks 与类比较
- en: 'When Hooks were introduced to React, it created a new problem: how do we know
    when to use function components with Hooks and class components? With the help
    of Hooks, it is possible to get state and partial lifecycle Hooks even in function
    components. Hooks allow you to use local state and other React features without
    writing a class. Here are some differences between Hooks and classes to help you
    decide:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Hooks 被引入到 React 中时，它带来了一个新问题：我们如何知道何时使用带有 Hooks 和类组件的函数组件？借助 Hooks，即使在函数组件中，也可以获取状态和部分生命周期
    Hooks。Hooks 允许您在不编写类的情况下使用本地状态和其他 React 功能。以下是帮助您做出决定的一些 Hooks 和类之间的区别：
- en: Hooks help avoid multiple hierarchies and make the code clearer. With classes,
    generally, when you use HOC or Render Props, you have to restructure your app
    with multiple hierarchies when you try to see it in DevTools.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hooks 帮助避免多层次结构，并使代码更清晰。通常情况下，当您在 DevTools 中查看时，如果使用 HOC 或 Render Props，则必须重构应用程序以包含多个层次结构。
- en: Hooks provide uniformity across React components. Classes confuse humans and
    machines due to the need to understand binding and the context in which functions
    are called.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hooks 提供了在 React 组件之间的统一性。类由于需要理解绑定和函数调用的上下文，使人类和机器感到困惑。
- en: Static Import
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态导入
- en: The `import` keyword allows us to import code that another module has exported.
    By default, all modules we’re statically importing get added to the initial bundle.
    A module imported using the default ES2015+ import syntax, `import module from
    [module]`, is statically imported. In this section, we will learn the use of static
    imports in the React.js context.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`import` 关键字允许我们导入另一个模块导出的代码。默认情况下，我们静态导入的所有模块都会添加到初始捆绑包中。使用默认的 ES2015+ 导入语法
    `import module from [module]` 导入的模块是静态导入的。在本节中，我们将学习在 React.js 上下文中使用静态导入的用法。'
- en: 'Let’s look at an example. A simple chat app contains a `Chat` component, in
    which we are statically importing and rendering three components: `UserProfile`,
    a `ChatList`, and a `ChatInput` to type and send messages. Within the `ChatInput`
    module, we’re statically importing an `EmojiPicker` component to show the emoji
    picker when the user toggles the emoji. We will use [webpack](https://oreil.ly/37e9F)
    to bundle our module dependencies:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子。一个简单的聊天应用包含一个 `Chat` 组件，在其中我们静态导入并渲染三个组件：`UserProfile`、`ChatList` 和
    `ChatInput`，用于输入和发送消息。在 `ChatInput` 模块中，我们静态导入一个 `EmojiPicker` 组件，在用户切换表情符号时显示表情符号选择器。我们将使用
    [webpack](https://oreil.ly/37e9F) 来捆绑我们的模块依赖项：
- en: '[PRE32]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The modules get executed as soon as the engine reaches the line on which we
    import them. When you open the console, you can see the order in which the modules
    were loaded.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 模块在引擎到达导入它们的行时立即执行。当您打开控制台时，您可以看到模块加载的顺序。
- en: 'Since the components were statically imported, webpack bundled the modules
    into the initial bundle. We can see the bundle that webpack creates after building
    the application:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 由于组件是静态导入的，webpack 将这些模块捆绑到初始捆绑包中。我们可以在构建应用程序后查看 webpack 创建的捆绑包：
- en: '| Asset | main.bundle.js |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| 资源 | main.bundle.js |'
- en: '| Size | 1.5 MiB |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| 大小 | 1.5 MiB |'
- en: '| Chunks | main [emitted] |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| 块 | 主 [已发布] |'
- en: '| Chunk Names | main |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| 块名称 | 主 |'
- en: 'Our chat application’s source code gets bundled into one bundle: *main.bundle.js*.
    A large bundle size can significantly affect our application’s loading time depending
    on the user’s device and network connection. Before the `App` component can render
    its contents to the user’s screen, it must first load and parse all modules.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的聊天应用程序源代码被捆绑成一个捆绑包：*main.bundle.js*。大捆绑包大小可以根据用户的设备和网络连接显著影响我们应用程序的加载时间。在
    `App` 组件可以将其内容呈现到用户屏幕之前，必须首先加载和解析所有模块。
- en: 'Luckily, there are many ways to speed up the loading time! We don’t always
    have to import all modules at once: there may be modules that should only get
    rendered based on user interaction, like the EmojiPicker in this case, or rendered
    further down the page. Instead of importing all components statically, we can
    dynamically import the modules after the `App` component has rendered its contents,
    and the user can interact with our application.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有许多方法可以加快加载时间！我们不必总是一次性导入所有模块：可能有基于用户交互的模块只应该在需要时才导入，就像本例中的 EmojiPicker
    或在页面下方渲染的模块。与其静态导入所有组件，不如在 `App` 组件呈现其内容后动态导入模块，用户可以与我们的应用程序交互。
- en: Dynamic Import
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态导入
- en: 'The chat application discussed in the previous section on Static Imports had
    four key components: `UserInfo`, `ChatList`, `ChatInput`, and `EmojiPicker`. However,
    only three of these components are used instantly on the initial page load: `UserInfo`,
    `ChatList`, and `ChatInput`. The EmojiPicker isn’t directly visible and may only
    be rendered if the user clicks on the Emoji to toggle the EmojiPicker. This implies
    that we unnecessarily added the EmojiPicker module to our initial bundle, potentially
    increasing the loading time.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在“静态导入”一节讨论的聊天应用程序中，有四个关键组件：`UserInfo`、`ChatList`、`ChatInput` 和 `EmojiPicker`。然而，只有这些组件中的三个在初始页面加载时立即使用：`UserInfo`、`ChatList`
    和 `ChatInput`。EmojiPicker 不直接可见，只有在用户点击表情符号以切换 EmojiPicker 时才可能渲染。这意味着我们不必要地将
    EmojiPicker 模块添加到初始捆绑包中，可能增加了加载时间。
- en: 'To solve this, we can dynamically import the `EmojiPicker` component. Instead
    of statically importing it, we’ll import it only when we want to show the EmojiPicker.
    An easy way to dynamically import components in React is by using React Suspense.
    The `React.Suspense` component receives the component that should be dynamically
    loaded, making it possible for the `App` component to render its contents faster
    by suspending the import of the EmojiPicker module. When the user clicks on the
    Emoji, the `EmojiPicker` component gets rendered for the first time. The `EmojiPicker`
    component renders a `Suspense` component, which receives the lazily imported module:
    the EmojiPicker in this case. The `Suspense` component accepts a fallback prop,
    which receives the component that should get rendered while the suspended component
    is still loading!'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以动态导入 `EmojiPicker` 组件。我们不再静态导入它，而是仅在想要显示 EmojiPicker 时才导入它。在 React
    中动态导入组件的一种简单方法是使用 React Suspense。`React.Suspense` 组件接收应该动态加载的组件，使得 `App` 组件能够通过暂停
    EmojiPicker 模块的导入来更快地渲染其内容。当用户点击表情符号时，EmojiPicker 组件首次被渲染。EmojiPicker 组件呈现一个 `Suspense`
    组件，该组件接收懒加载的模块：在本例中是 EmojiPicker。`Suspense` 组件接受一个 fallback 属性，该属性接收在挂起组件加载时应显示的组件！
- en: Instead of unnecessarily adding EmojiPicker to the initial bundle, we can split
    it up into its own bundle and reduce the size of the initial bundle.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 不必将 EmojiPicker 不必要地添加到初始捆绑包中，我们可以将其拆分成自己的捆绑包，并减少初始捆绑包的大小。
- en: 'A smaller initial bundle size means a faster initial load: the user doesn’t
    have to stare at a blank loading screen for as long. The fallback component lets
    the user know that our application hasn’t frozen: they need to wait a little while
    for the module to be processed and executed.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 较小的初始捆绑包大小意味着更快的初始加载速度：用户不必在空白加载屏幕上等待太久。fallback 组件让用户知道我们的应用程序没有冻结：他们需要等待一小段时间，直到模块被处理和执行。
- en: '| Asset | Size | Chunks | Chunk names |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| 资源 | 大小 | 块 | 块名称 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| *emoji-picker.bundle.js* | 1.48 KiB | 1 [emitted] | emoji-picker |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| *emoji-picker.bundle.js* | 1.48 KiB | 1 [emitted] | emoji-picker |'
- en: '| *main.bundle.js* | 1.33 MiB | main [emitted] | main |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| *main.bundle.js* | 1.33 MiB | main [emitted] | main |'
- en: '| *vendors~emoji-picker.bundle.js* | 171 KiB | 2 [emitted] | vendors~emoji-picker
    |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| *vendors~emoji-picker.bundle.js* | 171 KiB | 2 [emitted] | vendors~emoji-picker
    |'
- en: 'Whereas previously, the initial bundle was 1.5 MiB, we’ve reduced it to 1.33
    MiB by suspending the import of the EmojiPicker. In the console, you can see that
    the EmojiPicker gets executed once we’ve toggled the EmojiPicker:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，初始捆绑包大小为 1.5 MiB，现在通过暂停 EmojiPicker 的导入，我们将其减小为 1.33 MiB。在控制台中，您可以看到一旦切换到
    EmojiPicker，EmojiPicker 就会执行：
- en: '[PRE33]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When building the application, we can see the different bundles that webpack
    created. By dynamically importing the `EmojiPicker` component, we reduced the
    initial bundle size from 1.5 MiB to 1.33 MiB! Although the user may still have
    to wait a while until the EmojiPicker has been fully loaded, we have improved
    the UX by making sure the application is rendered and interactive while the user
    waits for the component to load.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 构建应用程序时，我们可以看到 webpack 创建的不同捆绑包。通过动态导入 `EmojiPicker` 组件，我们将初始捆绑包大小从 1.5 MiB
    减小到 1.33 MiB！虽然用户可能仍需等待 EmojiPicker 完全加载，但通过确保应用程序在用户等待组件加载时仍可呈现和交互，我们改善了用户体验。
- en: Loadable Components
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可加载组件
- en: 'SSR doesn’t support React Suspense (yet). An excellent alternative to React
    Suspense is the *loadable-components* library, which you can use in SSR applications:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: SSR 尚不支持 React Suspense。React Suspense 的一个很好的替代方案是 *loadable-components* 库，您可以在
    SSR 应用程序中使用它：
- en: '[PRE34]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Like React Suspense, we can pass the lazily imported module to the loadable,
    which will import the module only once the EmojiPicker module is requested. While
    the module is loaded, we can render a fallback component.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 像 React Suspense 一样，我们可以将懒加载的模块传递给可加载组件，它将在请求 EmojiPicker 模块时导入该模块。在模块加载期间，我们可以渲染一个回退组件。
- en: 'Although loadable components are a great alternative to React Suspense for
    SSR applications, they’re also helpful in CSR applications to suspend module imports:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可加载组件在 SSR 应用程序中是 React Suspense 的一个很好的替代方案，但它们在 CSR 应用程序中也很有帮助，用于暂停模块的导入：
- en: '[PRE35]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Import on Interaction
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交互导入
- en: In the chat application example, we dynamically imported the `EmojiPicker` component
    when the user clicked on the Emoji. This type of dynamic import is called *Import
    on Interaction*. We triggered the component import on interaction by the user.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在聊天应用程序示例中，当用户点击表情符号时，我们动态导入了 `EmojiPicker` 组件。这种类型的动态导入称为 *交互导入*。我们通过用户的交互触发组件的导入。
- en: Import on Visibility
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**可见性导入**'
- en: Besides user interaction, we often have components that need not be visible
    on the initial page load. An excellent example of this is lazy-loading images
    or components that aren’t directly visible in the viewport and get loaded only
    once the user scrolls down. Triggering a dynamic import when the user scrolls
    down to a component and it becomes visible is called *Import on Visibility*.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 除了用户交互外，我们经常有一些组件在初始页面加载时不需要可见。一个很好的例子是延迟加载图像或在视口中直接不可见的组件，只有当用户向下滚动到组件并使其可见时才加载。当用户滚动到组件并使其可见时触发动态导入的操作称为
    *可见性导入*。
- en: 'To know whether components are currently in our viewport, we can use the IntersectionObserver
    API or libraries such as `react-loadable-visibility` or `react-lazyload` to add
    Import on Visibility to our application quickly. We can now look at the chat application
    example where the EmojiPicker is imported and loaded when it becomes visible to
    the user:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 要知道组件当前是否在我们的视口中，我们可以使用 IntersectionObserver API 或诸如 `react-loadable-visibility`
    或 `react-lazyload` 这样的库，以快速将可见性导入添加到我们的应用程序中。现在我们可以看一下聊天应用程序示例，当用户看到 EmojiPicker
    时，它会被导入和加载：
- en: '[PRE36]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Code-Splitting
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码拆分
- en: In the previous section, we saw how we could dynamically import components when
    needed. In a complex application with multiple routes and components, we must
    ensure that our code is bundled and split optimally to allow for a mix of static
    and dynamic imports at the right time.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们看到了如何在需要时动态导入组件。在具有多个路由和组件的复杂应用程序中，我们必须确保我们的代码在适当的时间进行优化捆绑和拆分，以允许静态和动态导入的混合使用。
- en: You can use the route-based splitting pattern to split your code or rely on
    modern bundlers such as webpack or Rollup to split and bundle your application’s
    source code.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用基于路由的拆分模式来拆分您的代码，或者依赖于现代打包工具如 webpack 或 Rollup 来拆分和捆绑您应用程序的源代码。
- en: Route-based Splitting
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于路由的拆分
- en: 'Specific resources may be required only on certain pages or routes, and we
    can request resources that are needed only for particular routes by adding route-based
    splitting. By combining React Suspense or *loadable-components* with libraries
    such as `react-router`, we can dynamically load components based on the current
    route. For example:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 特定资源可能仅在特定页面或路由上才需要，我们可以通过添加基于路由的分割来请求仅在特定路由上需要的资源。通过结合React Suspense或*loadable-components*等库与`react-router`，我们可以根据当前路由动态加载组件。例如：
- en: '[PRE37]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: By lazily loading the components per route, we’re only requesting the bundle
    that contains the code necessary for the current route. Since most people are
    used to the fact that there may be some loading time during a redirect, it’s the
    perfect place to load components lazily.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 通过按路由懒加载组件，我们只请求包含当前路由所需代码的捆绑包。由于大多数人已经习惯在重定向期间可能有一些加载时间，这是延迟加载组件的理想场所。
- en: Bundle Splitting
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捆绑拆分
- en: When building a modern web application, bundlers such as webpack or Rollup take
    an application’s source code and bundle this together into one or more bundles.
    When a user visits a website, the bundles required to display the data and features
    to the user are requested and loaded.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建现代Web应用时，像webpack或Rollup这样的捆绑工具会将应用的源代码捆绑成一个或多个捆绑包。当用户访问网站时，会请求并加载用于向用户显示数据和功能的捆绑包。
- en: JavaScript engines such as V8 can parse and compile data requested by the user
    as it’s being loaded. Although modern browsers have evolved to parse and compile
    the code as quickly and efficiently as possible, the developer is still in charge
    of optimizing the loading and execution time of the requested data. We want to
    keep the execution time as short as possible to prevent blocking the main thread.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript引擎（如V8）可以在用户请求数据时解析和编译数据。尽管现代浏览器已经进化到尽可能快速和高效地解析和编译代码，但开发人员仍然负责优化请求数据的加载和执行时间。我们希望尽可能缩短执行时间，以防止阻塞主线程。
- en: Even though modern browsers can stream the bundle as it arrives, it can still
    take a significant time before the first pixel is painted on the user’s device.
    The bigger the bundle, the longer it can take before the engine reaches the line
    on which the first rendering call is made. Until then, the user has to stare at
    a blank screen, which can be frustrating.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然现代浏览器可以在捆绑包到达时即时流式传输，但在用户设备上绘制第一个像素点之前可能仍需相当长的时间。捆绑包越大，在引擎到达进行第一次渲染调用的行之前所需的时间就越长。在此之前，用户必须盯着空白屏幕，这可能会令人沮丧。
- en: We want to display data to the user as quickly as possible. A larger bundle
    leads to an increased amount of loading time, processing time, and execution time.
    It would be great if we could reduce the size of this bundle to speed things up.
    Instead of requesting one giant bundle that contains unnecessary code, we can
    split the bundle into multiple smaller bundles. There are some essential metrics
    that we need to consider when deciding the size of our bundles.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望尽快向用户展示数据。较大的捆绑包会导致加载时间、处理时间和执行时间增加。如果能够减小捆绑包的大小以加快速度，那将是极好的。我们可以将一个包含不必要代码的巨型捆绑包分割成多个较小的捆绑包来代替。在确定我们捆绑包大小时，有一些关键指标是必须考虑的。
- en: By bundle-splitting the application, we can reduce the time it takes to load,
    process, and execute a bundle. This, in turn, reduces the time it takes for the
    first content to be painted on the user’s screen, known as the First Contentful
    Paint (FCP). It also reduces the time for the largest component to be rendered
    to the screen or the Largest Contentful Paint (LCP) metric.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对应用程序进行捆绑拆分，我们可以减少加载、处理和执行捆绑包所需的时间。这反过来减少了在用户屏幕上绘制第一个内容（称为首次内容呈现，FCP）的时间，也减少了用于将最大组件呈现到屏幕上的时间或最大内容呈现时间（LCP）指标。
- en: Although seeing data on our screen is excellent, we want to see more than just
    the content. To have a fully functioning application, we want users to be able
    to interact with it as well. The UI becomes interactive only after the bundle
    has been loaded and executed. The time it takes for all content to be painted
    on the screen and become interactive is called the Time to Interactive (TTI).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在屏幕上看到数据很好，但我们希望看到的不仅仅是内容。为了拥有完全功能的应用程序，我们希望用户也能与其进行交互。只有在捆绑包加载和执行后，UI才变得可交互。所有内容在屏幕上绘制并变得可交互所需的时间称为交互时间（TTI）。
- en: A larger bundle doesn’t necessarily mean a longer execution time. It could happen
    that we loaded a ton of code that the user may not even use. Some parts of the
    bundle will get executed on only a specific user interaction, which the user may
    or may not do.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 更大的捆绑包不一定意味着更长的执行时间。可能发生的情况是，我们加载了用户甚至可能根本不使用的大量代码。捆绑包的某些部分将仅在特定用户交互上执行，用户可能会执行或不执行。
- en: The engine still has to load, parse, and compile code that’s not even used on
    the initial render before the user can see anything on their screen. Although
    the parsing and compilation costs can be practically ignored due to the browser’s
    performant way of handling these two steps, fetching a larger bundle than necessary
    can hurt the performance of your application. Users on low-end devices or slower
    networks will see a significant increase in loading time before the bundle is
    fetched.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 引擎仍然必须加载、解析和编译甚至在用户可以在屏幕上看到任何内容之前都没有使用的代码。尽管由于浏览器处理这两个步骤的高效方式，解析和编译成本实际上可以忽略不计，但获取比必要更大的捆绑包可能会影响应用程序的性能。在低端设备或较慢网络上的用户在捆绑包被获取之前将看到加载时间显著增加。
- en: Instead of initially requesting parts of the code that don’t have a high priority
    in the current navigation, we can separate this code from the code needed to render
    the initial page.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 不要最初请求当前导航中优先级不高的代码部分，我们可以将这些代码与渲染初始页面所需的代码分开。
- en: PRPL Pattern
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PRPL 模式
- en: Making applications accessible to a global user base can be a challenge. The
    application should be performant on low-end devices and in regions with poor internet
    connectivity. To make sure our application can load as efficiently as possible
    under challenging conditions, we can use the Push Render Pre-cache Lazy-load (PRPL)
    pattern.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 使应用程序对全球用户群体可访问可能是一个挑战。应用程序应在低端设备和网络连接质量差的地区表现出色。为了确保我们的应用程序在恶劣条件下能够尽可能高效地加载，我们可以使用推送渲染预缓存懒加载（PRPL）模式。
- en: 'The PRPL pattern focuses on four primary performance considerations:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: PRPL 模式专注于四个主要性能考虑因素：
- en: '*Pushing* critical resources efficiently minimizes the number of roundtrips
    to the server and reduces loading time.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*高效推送*关键资源可以最小化与服务器之间的往返次数并减少加载时间。'
- en: '*Rendering* the initial route as soon as possible to improve the UX.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽快*渲染*初始路由以改善用户体验。
- en: '*Pre-caching* assets in the background for frequently visited routes to minimize
    the number of requests to the server and enable a better offline experience.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在后台*预缓存*经常访问的路由的资产，以最小化对服务器的请求次数并实现更好的离线体验。
- en: '*Lazily loading* routes or assets that aren’t requested as frequently.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*懒加载*不经常请求的路由或资源。'
- en: When we visit a website, the browser requests the server for the required resources.
    The file the entry point points to gets returned from the server, usually our
    application’s initial HTML file. The browser’s HTML parser starts to parse this
    data as soon as it starts receiving it from the server. If the parser discovers
    that more resources are needed, such as stylesheets or scripts, additional HTTP
    requests are sent to the server to get those resources.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们访问一个网站时，浏览器会向服务器请求所需的资源。入口点指向的文件通常是从服务器返回的，通常是我们应用程序的初始 HTML 文件。浏览器的 HTML
    解析器在从服务器接收数据时立即开始解析这些数据。如果解析器发现需要更多资源，比如样式表或脚本，将向服务器发送额外的 HTTP 请求以获取这些资源。
- en: Requesting resources repeatedly isn’t optimal, as we are trying to minimize
    the number of round trips between the client and the server.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 反复请求资源并不理想，因为我们试图最小化客户端和服务器之间的往返次数。
- en: We used HTTP/1.1 for a long time to communicate between the client and the server.
    Although HTTP/1.1 introduced many improvements compared to HTTP/1.0, such as keeping
    the TCP connection between the client and the server alive before a new HTTP request
    gets sent with the keep-alive header, there were still some issues that had to
    be solved. HTTP/2 introduced significant changes compared to HTTP/1.1, allowing
    us to optimize the message exchange between the client and the server.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们长时间使用 HTTP/1.1 在客户端和服务器之间通信。尽管与 HTTP/1.0 相比，HTTP/1.1 引入了许多改进，比如在发送带有保持活动标头的新
    HTTP 请求之前保持客户端和服务器之间的 TCP 连接活动，仍然存在一些问题需要解决。HTTP/2 相对于 HTTP/1.1 引入了重大变化，使我们能够优化客户端和服务器之间的消息交换。
- en: 'Whereas HTTP/1.1 used a newline delimited plaintext protocol in the requests
    and responses, HTTP/2 splits the requests and responses into smaller frames. An
    HTTP request that contains headers and a body field gets split into at least two
    frames: a headers frame and a data frame.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然HTTP/1.1在请求和响应中使用换行分隔的纯文本协议，但HTTP/2将请求和响应拆分为更小的帧。包含头部和主体字段的HTTP请求至少分为两个帧：头部帧和数据帧。
- en: HTTP/1.1 had a maximum amount of six TCP connections between the client and
    the server. Before you can send a new request over the same TCP connection, the
    previous request must be resolved. If the last request takes a long time to resolve,
    this request is blocking the other requests from being sent. This common issue
    is called head-of-line blocking and can increase the loading time of specific
    resources.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/1.1在客户端和服务器之间最多允许六个TCP连接。在可以通过同一TCP连接发送新请求之前，必须解决上一个请求。如果最后一个请求解决时间较长，这个请求将阻塞其他请求的发送。这种常见问题称为先行线阻塞，会增加特定资源的加载时间。
- en: HTTP/2 uses bidirectional streams. A single TCP connection with multiple bidirectional
    streams can carry multiple request and response frames between the client and
    the server. Once the server has received all request frames for that specific
    request, it reassembles them and generates response frames. These response frames
    are sent back to the client, which reassembles them. Since the stream is bidirectional,
    we can send both request and response frames over the same stream.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/2使用双向流。单个TCP连接可以在客户端和服务器之间传输多个请求和响应帧。一旦服务器接收到该特定请求的所有请求帧，它将重新组装它们并生成响应帧。这些响应帧被发送回客户端，客户端重新组装它们。由于流是双向的，我们可以通过同一流发送请求和响应帧。
- en: HTTP/2 solves head-of-line blocking by allowing multiple requests to get sent
    on the same TCP connection before the previous request resolves! HTTP/2 also introduced
    a more optimized way of fetching data, called server push. Instead of explicitly
    asking for resources each time by sending an HTTP request, the server can send
    the additional resources automatically by “pushing” these resources.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/2通过允许在上一个请求解决之前在同一TCP连接上发送多个请求来解决先行线阻塞问题！HTTP/2还引入了一种更优化的数据获取方式，称为服务器推送。服务器可以通过“推送”这些资源自动发送额外资源，而不是每次通过发送HTTP请求显式请求资源。
- en: After the client has received the additional resources, the resources will get
    stored in the browser cache. When the resources are discovered while parsing the
    entry file, the browser can quickly get the resources from the cache instead of
    making an HTTP request to the server.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端接收到额外资源后，这些资源将被存储在浏览器缓存中。当解析入口文件时发现这些资源时，浏览器可以快速从缓存获取资源，而不是向服务器发出HTTP请求。
- en: Although pushing resources reduces the time to receive additional resources,
    server push is not HTTP cache-aware. The pushed resources won’t be available to
    us the next time we visit the website and will have to be requested again. To
    solve this, the PRPL pattern uses service workers after the initial load to cache
    those resources to ensure the client isn’t making unnecessary requests.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然推送资源减少了接收额外资源的时间，但服务器推送并不具备HTTP缓存感知性。推送的资源在下次访问网站时将不可用，必须再次请求。为了解决这个问题，PRPL模式在初始加载后使用服务工作线程缓存这些资源，以确保客户端不会发出不必要的请求。
- en: As site authors, we usually know what resources are critical to fetch early
    on, while browsers do their best to guess this. We can help the browser by adding
    a preload resource hint to the critical resources.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 作为网站作者，我们通常清楚哪些资源是在早期获取的关键资源，而浏览器则尽力猜测。通过添加预加载资源提示到关键资源，我们可以帮助浏览器。
- en: By telling the browser that you’d like to preload a specific resource, you’re
    telling the browser that you would like to fetch it sooner than the browser would
    otherwise discover it. Preloading is a great way to optimize the time it takes
    to load resources critical for the current route.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 通过告诉浏览器您希望预加载特定资源，您正在告诉浏览器您希望比浏览器正常发现时更早获取它。预加载是优化加载当前路由关键资源所需时间的一个很好的方式。
- en: Although preloading resources is a great way to reduce the number of roundtrips
    and optimize loading time, pushing too many files can be harmful. The browser’s
    cache is limited, and you may unnecessarily use bandwidth by requesting resources
    the client didn’t need. The PRPL pattern focuses on optimizing the initial load.
    No other resources get loaded before the initial route is completely rendered.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管预加载资源是减少往返次数和优化加载时间的好方法，但过多地推送文件可能会有害。浏览器的缓存是有限的，通过请求客户端不需要的资源，您可能会不必要地使用带宽。PRPL模式侧重于优化初始加载。在完全呈现初始路由之前，不会加载其他任何资源。
- en: We can achieve this by code-splitting our application into small, performant
    bundles. These bundles should allow users to load only the resources they need
    when they need them while also maximizing cache use.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将应用程序拆分为小型、高效的捆包来实现这一点。这些捆包应允许用户在需要时仅加载他们所需的资源，同时最大化缓存使用。
- en: Caching larger bundles can be an issue. Multiple bundles may share the same
    resources.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存较大的捆包可能会成为问题。多个捆包可能共享相同的资源。
- en: A browser needs help identifying which parts of the bundle are shared between
    multiple routes and cannot cache these resources. Caching resources is vital to
    reducing the number of round trips to the server and to making our application
    offline-friendly.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器需要帮助识别哪些捆绑资源在多个路由之间共享，因此无法缓存这些资源。缓存资源对于减少与服务器的往返次数以及使我们的应用支持离线至关重要。
- en: When working with the PRPL pattern, we need to ensure that the bundles we’re
    requesting contain the minimal amount of resources we need at that time and are
    cachable by the browser. In some cases, this could mean that having no bundles
    at all would be more performant, and we could simply work with unbundled modules.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用PRPL模式时，我们需要确保请求的捆包包含我们在该时刻需要的最小资源量，并且浏览器可以缓存这些资源。在某些情况下，这可能意味着根本不使用任何捆包会更高效，我们可以简单地使用未捆绑的模块。
- en: 'The benefit of dynamically requesting minimal resources by bundling an application
    can easily be mocked by configuring the browser and server to support HTTP/2 push
    and caching the resources efficiently. For browsers that don’t support HTTP/2
    server push, we can create an optimized build to minimize the number of roundtrips.
    The client doesn’t have to know whether it’s receiving a bundled or unbundled
    resource: the server delivers the appropriate build for each browser.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将应用程序捆绑为最小资源动态请求的好处可以通过配置浏览器和服务器以支持HTTP/2推送和有效缓存资源轻松模拟。对于不支持HTTP/2服务器推送的浏览器，我们可以创建优化的构建以最小化往返次数。客户端无需知道它是否接收到捆绑或未捆绑的资源：服务器会为每个浏览器提供适当的构建。
- en: The PRPL pattern often uses an app shell as its main entry point, a minimal
    file containing most of the application’s logic and shared between routes. It
    also includes the application’s router, which can dynamically request the necessary
    resources.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: PRPL模式通常将应用外壳作为其主要入口点，这是一个包含大部分应用逻辑并在多个路由之间共享的最小文件。它还包括应用的路由器，可以动态请求所需资源。
- en: The PRPL pattern ensures that no other resources get requested or rendered before
    the initial route is visible on the user’s device. Once the initial route has
    been loaded successfully, a service worker can get installed to fetch the resources
    for the other frequently visited routes in the background.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: PRPL模式确保在用户设备上看到初始路由之前不会请求或呈现任何其他资源。一旦成功加载初始路由，服务工作线程可以安装以在后台获取其他经常访问路由的资源。
- en: Since this data is being fetched in the background, the user won’t experience
    any delays. If a user wants to navigate to a frequently visited route cached by
    the service worker, the service worker can quickly get the required resources
    from the cache instead of sending a request to the server.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些数据是在后台获取的，用户不会遇到任何延迟。如果用户想要访问由服务工作线程缓存的经常访问路由，则服务工作线程可以快速从缓存中获取所需资源，而无需向服务器发送请求。
- en: Resources for routes that aren’t as frequently visited can be dynamically imported.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不经常访问的路由，可以动态导入资源。
- en: Loading Prioritization
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载优先级
- en: The Loading Prioritization pattern encourages you to explicitly prioritize the
    requests for specific resources you know will be required earlier.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 加载优先级模式鼓励您明确优先处理特定资源的请求，这些资源您知道将较早需要。
- en: 'Preload (`<link rel="preload">`) is a browser optimization that allows critical
    resources (that browsers may discover late) to be requested earlier. If you are
    comfortable thinking about how to order the loading of your key resources manually,
    it can have a positive impact on loading performance and metrics in the Core Web
    Vitals (CWV). That said, preload is not a panacea and requires an awareness of
    some trade-offs:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 预加载（`<link rel="preload">`）是浏览器的优化，允许较晚发现的关键资源提前请求。如果您习惯手动思考如何排序关键资源的加载，它可能对核心Web
    Vitals（CWV）中的加载性能和指标产生积极影响。然而，预加载并非万能药，需要考虑一些权衡：
- en: '[PRE38]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: When optimizing for metrics like Time to Interactive (TTI) or First Input Delay
    (FID), preload can be helpful to load JavaScript bundles (or chunks) necessary
    for interactivity. Remember that great care is needed when using preload because
    you want to avoid improving interactivity at the cost of delaying resources (like
    hero images or fonts) necessary for First Contentful Paint (FCP) or Largest Contentful
    Paint (LCP).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 当优化像交互时间 (TTI) 或首次输入延迟 (FID) 这样的指标时，预加载对于加载JavaScript包（或块）以实现交互性是有帮助的。请记住，在使用预加载时需要格外小心，因为您希望在改善交互性的同时避免延迟必要的资源（如主要图像或字体），这些资源对于首次内容绘制
    (FCP) 或最大内容绘制 (LCP) 是必要的。
- en: If you’re trying to optimize the loading of first-party JavaScript, consider
    using `<script defer>` in the document `<head>` versus `<body>` to help with the
    early discovery of these resources.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您试图优化第一方JavaScript的加载，请考虑在文档`<head>`中使用`<script defer>`而不是`<body>`，以帮助提前发现这些资源。
- en: Preload in Single-Page Apps
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单页应用中的预加载
- en: While prefetching is a great way to cache resources that may be requested sometime
    soon, we can preload resources that need to be used instantly. It could be a specific
    font used on the initial render or certain images the user sees immediately.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然预取是缓存即将请求的资源的好方法，但我们可以预加载需要立即使用的资源。这可能是在初始渲染中使用的特定字体或用户立即看到的某些图片。
- en: 'Say our `EmojiPicker` component should be visible instantly on the initial
    render. Although you should not include it in the main bundle, it should get loaded
    in parallel. Like prefetch, we can add a magic comment to inform webpack that
    this module should be preloaded:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的`EmojiPicker`组件在初始渲染时应立即可见。虽然您不应将其包含在主包中，但应并行加载它。与预取一样，我们可以添加魔法注释，告知webpack此模块应预加载：
- en: '[PRE39]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'After building the application, we can see that the `EmojiPicker` will be prefetched.
    The actual output is visible as a `link` tag with `rel="preload"` in the head
    of our document:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建应用程序后，我们可以看到`EmojiPicker`将被预取。实际输出在我们文档头部具有`rel="preload"`的`link`标签中可见：
- en: '[PRE40]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The preloaded `EmojiPicker` could be loaded in parallel with the initial bundle.
    Unlike prefetch, where the browser still had a say in whether it’s got a good
    enough internet connection and bandwidth to prefetch the resource, a preloaded
    resource will get preloaded no matter what.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 预加载的`EmojiPicker`可以与初始包并行加载。与预取不同，浏览器在预取资源时仍需判断其网络连接和带宽是否足够，而预加载的资源将无论如何都会预加载。
- en: Instead of waiting until the `EmojiPicker` gets loaded after the initial render,
    the resource will be available to us instantly. As we’re loading assets with more
    thoughtful ordering, the initial loading time may increase significantly depending
    on your user’s device and internet connection. Only preload the resources that
    must be visible approximately 1 second after the initial render.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是在初始渲染后等待`EmojiPicker`加载完成，资源将立即可用于我们。随着我们以更考虑周到的顺序加载资产，初始加载时间可能会显著增加，这取决于用户的设备和互联网连接。仅预加载那些在初始渲染后约1秒钟必须可见的资源。
- en: Preload + the async Hack
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预加载 + 异步Hack
- en: 'Should you wish for browsers to download a script as high priority but not
    block the parser waiting for a script, you can take advantage of the preload +
    `async` hack shown here. The preload, in this case, may delay the download of
    other resources, but this is a trade-off a developer has to make:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望浏览器高优先级下载脚本但不阻塞解析器等待脚本，你可以利用此处展示的预加载 + `async` 技巧。在这种情况下，预加载可能会延迟其他资源的下载，但这是开发者需要权衡的一个折衷：
- en: '[PRE41]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Preload in Chrome 95+
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Chrome 95+中的预加载
- en: 'The feature is slightly safer thanks to some fixes to preload’s queue-jumping
    behavior in Chrome 95+. Pat Meenan of Chrome’s new recommendations for preload
    suggests the following:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Chrome 95+中预加载队列跳过行为的一些修复，该功能现在稍微更安全。Chrome关于预加载的新建议由Chrome的Pat Meenan提出：
- en: Putting it in HTTP headers will jump ahead of everything else.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其放在 HTTP 标头中将超越其他一切。
- en: Generally, preloads will load in the order the parser gets to them for anything
    greater than or equal to Medium, so be careful putting preloads at the beginning
    of the HTML.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一般来说，预加载将按照解析器处理它们的顺序进行加载，适用于中等及以上的任何情况，因此在 HTML 开头放置预加载时要小心。
- en: Font preloads are probably best toward the end of the head or the beginning
    of the body.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字体预加载可能最好放在头部的末尾或者主体的开头。
- en: Import preloads should be done after the `script` tag that needs the import
    (so the actual script gets loaded/parsed first).
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入预加载应该在需要导入的 `script` 标签之后进行（这样实际脚本会首先加载/解析）。
- en: Image preloads will have a low priority and should be ordered relative to `async`
    scripts and other low/lowest priority tags.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像预加载的优先级较低，应相对于 `async` 脚本和其他低/最低优先级标签进行排序。
- en: List Virtualization
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表虚拟化
- en: List virtualization helps improve the rendering performance of large lists of
    data. You render only visible rows of content in a dynamic list instead of the
    entire list. The rows rendered are only a small subset of the full list, with
    what is visible (the window) moving as the user scrolls. In React, you can achieve
    this using [`react-virtualized`](https://oreil.ly/3XThZ). It’s a windowing library
    by [Brian Vaughn](https://oreil.ly/hCqQq) that renders only the items currently
    visible in a list (within a scrolling viewport). This means you don’t need to
    pay the cost of thousands of rows of data being rendered at once.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 列表虚拟化有助于提高大型数据列表的渲染性能。在动态列表中，您仅渲染可见的内容行，而不是整个列表。渲染的行仅是完整列表的一个小子集，而可见的内容（窗口）随用户滚动而移动。在
    React 中，您可以通过 [`react-virtualized`](https://oreil.ly/3XThZ) 来实现这一点。这是由 [Brian
    Vaughn](https://oreil.ly/hCqQq) 开发的窗口化库，仅在滚动视口中渲染当前可见的项目。这意味着您无需支付一次性渲染成千上万行数据的成本。
- en: How Does Windowing/Virtualization Work?
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 窗口化/虚拟化如何工作？
- en: 'Virtualizing a list of items involves maintaining and moving a window around
    your list. Windowing in `react-virtualized` works by:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟化项目列表涉及维护和移动列表周围的窗口。`react-virtualized` 中的窗口化通过以下方式工作：
- en: Having a small container DOM element (e.g., `<ul>`) with relative positioning
    (window).
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有一个小的容器 DOM 元素（例如，`<ul>`），具有相对定位（窗口）。
- en: Having a big DOM element for scrolling.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有一个用于滚动的大 DOM 元素。
- en: Absolutely positioning children inside the container, setting their styles for
    top, left, width, and height.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绝对定位容器内的子元素，设置它们的样式为 top、left、width 和 height。
- en: Rather than rendering thousands of elements from a list at once (which can cause
    slower initial rendering or impact scroll performance), virtualization focuses
    on rendering just items visible to the user.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 而不是一次性渲染列表中的成千上万个元素（可能导致较慢的初始渲染或影响滚动性能），虚拟化专注于仅渲染对用户可见的项目。
- en: This can help keep list rendering fast on mid- to low-end devices. You can fetch/display
    more items as the user scrolls, unloading previous entries and replacing them
    with new ones.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以帮助在中低端设备上保持列表渲染速度快。随着用户滚动，您可以获取/显示更多项目，卸载先前的条目并替换为新条目。
- en: '[`react-window`](https://oreil.ly/H_Rx7) is a rewrite of `react-virtualized`
    by the same author aiming to be smaller, faster, and more tree-shakeable. In a
    tree-shakeable library, size is a function of which API surfaces you choose to
    use. I’ve seen approximately 20 to 30 KB (gzipped) savings using it in place of
    `react-virtualized`. The APIs for both packages are similar; `react-window` tends
    to be simpler where they differ.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '[`react-window`](https://oreil.ly/H_Rx7) 是由相同作者重写的 `react-virtualized`，旨在更小、更快且更易于树抖动。在可树抖动库中，尺寸取决于您选择使用的哪些
    API 表面。使用它代替 `react-virtualized`，我看到大约 20 到 30 KB（经过压缩）的节省。这两个包的 API 大致相似；在它们不同的地方，`react-window`
    倾向于更简单。'
- en: The following are the main components in the case of `react-window`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `react-window` 案例中，以下是主要组件。
- en: Lists
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表
- en: Lists render a windowed list (row) of elements meaning that only the visible
    rows are displayed to users. Lists use a Grid (internally) to render rows, relaying
    props to that inner Grid. The following code snippets show the difference between
    rendering lists in React versus using `react-window`.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 列表渲染一个窗口化列表（行）的元素，这意味着仅显示给用户可见的行。列表使用一个网格（内部）来渲染行，将属性传递给该内部网格。以下代码片段展示了在 React
    中渲染列表与使用 `react-window` 的区别。
- en: 'Rendering a list of simple data (`itemsArray`) using React:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 React 渲染简单数据的列表（`itemsArray`）：
- en: '[PRE42]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Rendering a list using `react-window`:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `react-window` 渲染列表：
- en: '[PRE43]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Grid
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网格
- en: Grid renders tabular data with virtualization along the vertical and horizontal
    axes. It only renders the `Grid` cells needed to fill itself based on current
    horizontal/vertical scroll positions.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: Grid在垂直和水平轴向上使用虚拟化渲染表格数据。它只根据当前水平/垂直滚动位置需要渲染填充自身的Grid单元格。
- en: 'If we wanted to render the same list as earlier with a grid layout, assuming
    our input is a multidimensional array, we could accomplish this using `FixedSizeGrid`
    as follows:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要使用网格布局渲染与之前相同的列表，假设我们的输入是多维数组，我们可以使用`FixedSizeGrid`来实现如下：
- en: '[PRE44]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Improvements in the Web Platform
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Web平台的改进
- en: Some modern browsers now support [CSS `content-visibility`](https://oreil.ly/l-B70).
    `content-visibility:auto` allows you to skip rendering and painting off-screen
    content until needed. Consider trying the property out if you have a lengthy HTML
    document with costly rendering.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 一些现代浏览器现在支持[CSS `content-visibility`](https://oreil.ly/l-B70)。`content-visibility:auto`允许您在需要之前跳过渲染和绘制屏幕外内容。如果您有一个包含昂贵渲染的长HTML文档，请考虑尝试此属性。
- en: For rendering lists of dynamic content, I still recommend using a library like
    `react-window`. It would be hard to have a `content-visbility:hidden` version
    of such a library that beats a version aggressively using `display:none` or removing
    DOM nodes when off-screen like many list virtualization libraries may do today.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 对于渲染动态内容列表，我仍然建议使用像`react-window`这样的库。要比使用`content-visibility:hidden`版本或像许多列表虚拟化库今天可能做的那样，依据屏幕外条件使用`display:none`或移除DOM节点更具侵略性的版本。
- en: Conclusions
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: Again, use preload sparingly and always measure its impact on production. If
    the preload for your image is earlier in the document than it is, this can help
    browsers discover it (and order relative to other resources). When misused, preloading
    can cause your image to delay FCP (e.g., CSS, fonts)—the opposite of what you
    want. Also note that for such reprioritization efforts to be effective, it also
    depends on servers prioritizing requests correctly.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，使用预加载要谨慎，并始终评估其在生产环境中的影响。如果您的图片预加载早于其他资源，这可以帮助浏览器发现它（并相对其他资源进行排序）。当使用不当时，预加载可能会导致图片延迟FCP（例如CSS、字体），这与您的意图相反。此外，请注意，为了使这种重新排序效果有效，还取决于服务器正确地优先处理请求。
- en: 'You may also find `<link rel="preload">` helpful for cases where you need to
    fetch scripts without executing them. A variety of the following [web.dev articles](https://oreil.ly/kgnfa)
    touch on how to use preload to:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要获取但不执行脚本的情况下，您可能会发现`<link rel="preload">`有帮助。以下的[web.dev文章](https://oreil.ly/kgnfa)讨论了如何使用预加载来：
- en: '[Preload key scripts required for interactivity](https://oreil.ly/bwZC9)'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[加载交互所需的关键脚本](https://oreil.ly/bwZC9)'
- en: '[Preload your LCP image](https://oreil.ly/4N3VO)'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[预加载您的LCP图像](https://oreil.ly/4N3VO)'
- en: '[Load fonts while preventing layout shifts](https://oreil.ly/Up2iQ)'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[在防止布局移位的同时加载字体](https://oreil.ly/Up2iQ)'
- en: Summary
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed some essential considerations that drive the architecture
    and design of modern web applications. We also saw the different ways in which
    React.js design patterns address these concerns.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了推动现代Web应用程序架构和设计的一些关键考虑因素。我们还看到了React.js设计模式如何解决这些问题的不同方式。
- en: Earlier in this chapter, we introduced the concepts of CSR, SSR, and hydration.
    JavaScript can have a significant impact on page performance. The choice of rendering
    techniques can affect how and when the JavaScript is loaded or executed in the
    page lifecycle. A discussion on Rendering patterns is thus significant when discussing
    JavaScript patterns and the topic of our next chapter.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 本章前面，我们介绍了CSR、SSR和hydration的概念。JavaScript对页面性能有重大影响。渲染技术的选择会影响JavaScript在页面生命周期中的加载或执行时间点。因此，在讨论JavaScript模式和下一章主题时，讨论渲染模式非常重要。
