- en: Chapter 6\. Component Libraries
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。组件库
- en: If you are building an application of any size, you are likely to need a component
    library. The data types that native HTML supports are somewhat limited, and the
    implementations can vary from browser to browser. For example, a date input field
    looks very different on Chrome, Firefox, and Edge browsers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在构建任何大小的应用程序，则可能需要一个组件库。本机HTML支持的数据类型有些受限，并且实现可能因浏览器而异。例如，日期输入字段在Chrome、Firefox和Edge浏览器上看起来非常不同。
- en: Component libraries allow you to create a consistent feel for your application.
    They will often adapt well when switching between desktop and mobile clients.
    Most importantly, component libraries often give your application a usability
    boost. They have been either generated from design standards that have been thoroughly
    tested (such as Material Design) or developed over several years. Any rough corners
    have generally been smoothed out.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 组件库允许您为应用程序创建一致的外观。在切换桌面和移动客户端时，它们通常能很好地适应。最重要的是，组件库通常会提升您的应用程序的可用性。它们要么是根据经过深入测试的设计标准生成的（如Material
    Design），要么是多年来开发的。任何粗糙的地方通常都已经被修复了。
- en: 'Be aware: there is no such thing as the *perfect* component library. They all
    have strengths and weaknesses, and you need to choose a library that best meets
    your needs. If you have a large UX team and a robust set of preexisting design
    standards, you will likely want a library that allows for a lot of *tweaking*
    to adapt the library to match your corporate themes. An example would be Material-UI,
    which allows you to modify its components quite significantly. If you have a small
    UX team or no UX team at all, you would probably want to consider something like
    Semantic UI, which is clean and functional and gets you up and running quickly.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意：并不存在*完美*的组件库。它们各有优势和劣势，您需要选择一个最符合您需求的库。如果您有一个庞大的用户体验团队和一套健全的设计标准，您可能希望选择一个允许大量*微调*以适应公司主题的库。一个例子是Material-UI，它允许您对其组件进行相当大的修改。如果您的用户体验团队很小或根本没有用户体验团队，您可能会考虑像Semantic
    UI这样的库，它简洁而功能齐全，并可以快速启动您的项目。
- en: Whichever library you choose, always remember that the essential thing in UX
    is not how your application looks but how it behaves. Users will soon ignore whatever
    flashy graphics you add to the interface, but they will never forget (or forgive)
    some part of the interface that irritates them each time they use it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您选择哪个库，始终要记住用户体验中最重要的不是应用程序的外观，而是其行为。用户很快会忽略您添加到界面的任何花哨图形，但他们永远不会忘记（或原谅）每次使用时使他们感到烦恼的界面的某些部分。
- en: Use Material Design with Material-UI
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Material Design与Material-UI
- en: Problem
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Many applications are now available on both the web and as native applications
    on mobile devices. Google created Material Design to provide a seamless experience
    across all platforms. Material Design will seem familiar to your users if they
    also use Android phones or anything created by Google. Material Design is just
    a specification, and there are several implementations available. One such is
    the Material-UI library for React. But what are the steps involved in using Material-UI,
    and how do you install it?
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 现在许多应用程序既可在Web上使用，也可作为移动设备上的原生应用程序使用。谷歌创建Material Design旨在在所有平台上提供无缝体验。如果您的用户也使用安卓手机或任何由谷歌创建的产品，Material
    Design对他们来说会很熟悉。Material Design只是一个规范，有几种可用的实现。其中一种是React的Material-UI库。但是，使用Material-UI的步骤是什么，如何安装呢？
- en: Solution
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Let’s begin by installing the core Material-UI library:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从安装核心Material-UI库开始：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The core library includes the main components, but it omits one notable feature:
    the standard typeface. To make Material-UI feel the same as it does in a native
    mobile application, you should also install Google’s Roboto typeface:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 核心库包含主要组件，但遗漏了一个显著的功能：标准字体。为了使Material-UI在原生移动应用程序中感觉相同，您还应安装谷歌的Roboto字体：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Material Design also specifies a large set of standard icons. These provide
    a common visual language for standard tasks such as editing tasks, creating new
    items, sharing content, etc. To use high-quality versions of these icons, you
    should also install the Material-UI icon library:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Material Design还规定了一组大量的标准图标。这些图标为标准任务（如编辑任务、创建新项目、共享内容等）提供了共同的视觉语言。为了使用这些图标的高质量版本，您还应安装Material-UI图标库：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now that we have Material-UI up and running, what can we do with it? We can’t
    look in detail at all of the available components here, but we will look at some
    of the more popular features.^([1](ch06.xhtml#idm46634408664616))
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好使用Material-UI了，我们可以做些什么呢？我们不能在这里详细查看所有可用的组件，但我们将看一些更流行的功能^([1](ch06.xhtml#idm46634408664616))。
- en: 'We’ll begin by looking at the basics of styling within Material-UI. To ensure
    that Material-UI components look the same across different browsers, they have
    included a `CssBaseline` component, which will normalize the basic styling of
    your application. It will remove margins and apply standard background colors.
    You should add a `CssBaseline` component somewhere near the start of your application.
    For example, if you are using `create-react-app`, you should probably add it to
    your *App.js*:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从Material-UI内部样式的基础开始。为了确保Material-UI组件在不同的浏览器中看起来相同，它们包括了一个`CssBaseline`组件，它将规范应用程序的基本样式。它将删除边距并应用标准的背景颜色。您应该在应用程序的开头附近添加一个`CssBaseline`组件。例如，如果您使用的是`create-react-app`，您可能应该将其添加到您的*App.js*中：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Next, we’ll take a look at the Material Design `AppBar` and `Toolbar` components.
    These provide the standard heading you see in most Material Design applications
    and are where other features such as hamburger menus and drawer panels will appear.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看一下Material Design的`AppBar`和`Toolbar`组件。这些提供了大多数Material Design应用程序中看到的标准标题，也是其他功能（如汉堡菜单和抽屉面板）将出现的地方。
- en: 'We’ll place an `AppBar` at the top of the screen and put a `Toolbar` inside.
    This will give us a chance to look at the way that typography is handled inside
    Material-UI:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在屏幕顶部放置一个`AppBar`，并在其中放置一个`Toolbar`。这将让我们看看Material-UI内部如何处理排版：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Although you can insert ordinary textual content inside Material-UI applications,
    it is generally better to display it inside `Typography`. A `Typography` component
    will ensure that the text matches the Material Design standards. We can also use
    it to display text inside the appropriate markup elements. In this case, we’re
    going to display the text in the `Toolbar` as an `h1` element. That’s what the
    `Typography` `component` attribute specifies: the HTML element that should be
    used to wrap the text. However, we can also tell Material-UI to *style* the text
    as if it’s an `h6` heading. That will make it a little smaller and less overpowering
    as a page heading.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以在Material-UI应用程序中插入普通文本内容，但通常最好在`Typography`内显示它。`Typography`组件将确保文本符合Material
    Design标准。我们还可以使用它在适当的标记元素内显示文本。在这种情况下，我们将在`Toolbar`中将文本显示为`h1`元素。这就是`Typography`
    `component`属性指定的：应用于包装文本的HTML元素。然而，我们也可以告诉Material-UI将文本*样式*设定为`h6`标题。这将使其稍小，作为页面标题时不会过于突出。
- en: Next, let’s look at how Material-UI styles the output. It uses *themes*. A theme
    is a JavaScript object that defines a hierarchy of CSS styles. You can define
    themes centrally, and this allows you to control the overall appearance of your
    application.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一下Material-UI如何处理输出的样式。它使用*主题*。主题是定义CSS样式层次结构的JavaScript对象。您可以集中定义主题，这使您可以控制应用程序的整体外观。
- en: 'Themes are extensible. We’ll import a function called `makeStyles`, which will
    allow us to create a modified version of the default theme:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 主题是可扩展的。我们将导入一个名为`makeStyles`的函数，它将允许我们创建默认主题的修改版本：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We’re going to make our example application display a gallery of images, so
    we will want to create styles for gallery items, descriptions, and so on. We can
    create styles for these different screen elements with `makeStyles`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使我们的示例应用程序显示一个图像库，因此我们将希望为图库项、描述等创建样式。我们可以使用`makeStyles`为这些不同的屏幕元素创建样式：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this simplified example, we extend the base theme to include styles for
    the classes `galleryGrid` and `galleryItemDescription`. Either we can add CSS
    attributes literally or (in the case of `paddingTop` in the `galleryGrid`) we
    can reference some value in the current theme: in this case `theme.spacing(4)`.
    So, we can defer parts of the styling to a centralized theme, where we can change
    it later.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简化的示例中，我们扩展了基础主题以包含`galleryGrid`和`galleryItemDescription`类的样式。我们可以直接添加CSS属性，或者（在`galleryGrid`的`paddingTop`的情况下）我们可以引用当前主题中的某个值：在这种情况下是`theme.spacing(4)`。因此，我们可以将样式的某些部分推迟到一个集中的主题中，稍后可以更改它。
- en: The `useStyles` returned by `makeStyles` is a hook that will generate a set
    of CSS classes and then return their names so we can refer to them inside our
    component.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`makeStyles`返回的`useStyles`是一个钩子，它将生成一组CSS类，然后返回它们的名称，以便我们可以在组件内部引用它们。'
- en: 'For example, we will want to display a grid of images, using `Container` and
    `Grid` components.^([2](ch06.xhtml#idm46634408268808)) We can attach the styles
    to them from the theme like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们希望使用`Container`和`Grid`组件显示图像网格。^([2](ch06.xhtml#idm46634408268808)) 我们可以像这样从主题中为它们附加样式：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Each `Grid` component is either a *container* or an *item*. We will display
    a gallery image within each item.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Grid`组件都是一个*容器*或一个*项目*。我们将在每个项目中显示一个图库图像。
- en: In Material Design, we show significant items inside cards. A *card* is a rectangular
    panel that appears to float slightly above the background. If you’ve ever used
    the Google Play Store, you will have seen cards used to display applications,
    music tracks, or other things you might want to download. We will place a card
    inside each `Grid` item and use it to display a preview, a text description, and
    a button that can show a more detailed version of the image. You can see the cards
    in the example application in [Figure 6-1](#ch06_image_1).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在Material Design中，我们将重要的项目显示在卡片内。*卡片*是一个矩形面板，看起来略高于背景浮动。如果你曾经使用过Google Play
    Store，你会看到卡片用于显示应用程序、音乐曲目或其他你想要下载的内容。我们将在每个`Grid`项目中放置一个卡片，并用它来显示预览、文本描述和一个按钮，该按钮可以显示图像的更详细版本。你可以在示例应用程序中查看这些卡片，如[图 6-1](#ch06_image_1)所示。
- en: '![](Images/recb_0601.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_0601.png)'
- en: Figure 6-1\. Cards are inside grid items, which are inside a container
  id: totrans-34
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-1。卡片位于网格项目内，而这些网格项目则位于容器内
- en: 'Material-UI also has extensive support for dialog windows. Here is an example
    of a custom dialog:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Material-UI还对对话窗口有着广泛的支持。这里是一个自定义对话框的例子：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that we are importing an SVG icon from the Material-UI icons library
    that we installed earlier. The `DialogTitle` appears at the top of the dialog.
    The `DialogActions` are the buttons that appear at the base of the dialog. You
    define the main body of the dialog in the `DialogContent`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们从之前安装的Material-UI图标库中导入了一个SVG图标。`DialogTitle`出现在对话框顶部。`DialogActions`是出现在对话框底部的按钮。你可以在`DialogContent`中定义对话框的主体内容。
- en: 'Here is the complete code for *App.js*:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是*App.js*的完整代码：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Discussion
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Material-UI is a great library to use and is one of the most popular libraries
    currently used with React. Users coming to your application will almost certainly
    have used it elsewhere, which will increase your application’s usability. Before
    launching into using Material-UI in your application, it is worth spending some
    time understanding the [Material Design principles](https://oreil.ly/Jlk7w). That
    way, you will create an application that is not only attractive but also easy
    to use and [accessible](https://oreil.ly/RJiW1) to users.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Material-UI是一个非常好用的库，也是当前与React一起使用最广泛的库之一。使用你的应用程序的用户几乎肯定在其他地方也用过它，这将增加你的应用程序的可用性。在开始在你的应用程序中使用Material-UI之前，值得花一些时间了解[Material
    Design原则](https://oreil.ly/Jlk7w)。这样，你将创建一个不仅外观吸引人，而且易于使用和[可访问](https://oreil.ly/RJiW1)的应用程序。
- en: You can download the source for this recipe from the [GitHub site](https://oreil.ly/TqVFz).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从[GitHub网站](https://oreil.ly/TqVFz)下载此示例的源代码。
- en: Create a Simple UI with React Bootstrap
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React Bootstrap创建一个简单的UI
- en: Problem
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: The most popular CSS library of the last 10 years is probably Twitter’s Bootstrap
    library. It’s also a good choice if you are creating a new application and have
    very little time to worry about creating a custom UI and simply want something
    easy-to-use and familiar to the vast number of users.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 过去10年中最流行的CSS库可能是Twitter的Bootstrap库。如果你正在创建一个新应用程序，且没有太多时间去定制UI，只是想要一个易于使用且对大多数用户来说很熟悉的东西，那Bootstrap也是一个不错的选择。
- en: But Bootstrap comes from a time before frameworks like React existed. Bootstrap
    includes CSS resources and a set of JavaScript libraries designed for web pages
    containing a small amount of handcrafted client code. The base Bootstrap library
    doesn’t play well with a framework like React.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 但是Bootstrap出现在像React这样的框架之前。Bootstrap包含了用于包含少量手工客户端代码的网页的CSS资源和一组JavaScript库。基础的Bootstrap库与像React这样的框架不兼容。
- en: How do you use Bootstrap when you’re creating a React application?
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个React应用程序时，你如何使用Bootstrap？
- en: Solution
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: There are several ports of the Bootstrap library for use with React. In this
    recipe, we will look at React Bootstrap. React Bootstrap works alongside the standard
    Bootstrap CSS libraries, but it extends the Bootstrap JavaScript to make it more
    React-friendly.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个Bootstrap库的端口可以与React一起使用。在这个示例中，我们将看看React Bootstrap。React Bootstrap与标准的Bootstrap
    CSS库一起工作，但它扩展了Bootstrap JavaScript，使其更加适合React使用。
- en: 'Let’s begin by first installing the React Bootstrap components and the Bootstrap
    JavaScript libraries:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先安装 React Bootstrap 组件和 Bootstrap JavaScript 库：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The React Bootstrap library does not include any CSS styling of its own. You
    will need to include a copy of that yourself. The most common way of doing this
    is by downloading it from a content distribution network (CDN) in your HTML. For
    example, if you are using `create-react-app`, you should include something like
    this in your *public/index.html* file:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: React Bootstrap 库本身不包含任何 CSS 样式。你需要自己包含一份副本。最常见的方法是在你的 HTML 文件中从内容分发网络（CDN）下载它。例如，如果你使用
    `create-react-app`，你应该在你的 *public/index.html* 文件中包含类似以下的内容：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It would be best if you replaced this with the latest stable version of Bootstrap
    that’s available. You will need to manage the version of Bootstrap manually; it
    will not update when you upgrade your JavaScript libraries.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该使用可用的最新稳定版本的 Bootstrap 替换它。你需要手动管理 Bootstrap 的版本；当你升级 JavaScript 库时，它不会自动更新。
- en: 'Bootstrap is a good, general-purpose library, but its support for forms is
    particularly strong. Good form layout can take time and can be tedious. Bootstrap
    handles all of the hard work for you and allows you to focus on the functionality
    of your form. For example, the React Bootstrap `Form` component contains almost
    everything you need to create a form. The `Form.Control` component will generate
    an `input` by default. The `Form.Label` will generate a `label`, and a `Form.Group`
    will associate the two together and lay them out appropriately:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap 是一个很好的通用库，但它对表单的支持特别强大。良好的表单布局可能需要时间并且可能很繁琐。Bootstrap 为你处理了所有艰难的工作，允许你专注于表单的功能。例如，React
    Bootstrap 的 `Form` 组件包含几乎你创建表单所需的一切。`Form.Control` 组件默认会生成一个 `input`。`Form.Label`
    会生成一个 `label`，`Form.Group` 会将它们关联起来并适当地布局：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Form fields are normally displayed on a single line and take up the available
    width. If you want more than one field to appear on a line, then you can use a
    `Form.Row`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 表单字段通常显示在一行上并占用可用宽度。如果你想要一行上显示多个字段，那么你可以使用 `Form.Row`：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `Col` component ensures that the labels and fields are sized appropriately.
    If you want a form field that’s something other than an `input`, you can use the
    `as` attribute:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`Col` 组件确保标签和字段的大小适当。如果你想要一个不是 `input` 的表单字段，你可以使用 `as` 属性：'
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This will generate a Bootstrap-styled `select` element.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个 Bootstrap 样式的 `select` 元素。
- en: 'Putting the whole thing together leads to the form you can see in [Figure 6-2](#ch06_image_2):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有内容放在一起，就得到了你可以在[图 6-2](#ch06_image_2)中看到的表单：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![](Images/recb_0602.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_0602.png)'
- en: Figure 6-2\. A React bootstrap form and alert box
  id: totrans-65
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-2\. 一个 React 引导表单和警告框
- en: Discussion
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Bootstrap is a much older UI toolkit than Material Design, but there are still
    markets where it feels more appropriate. If you’re building an application that
    has to feel more like a traditional website, then Bootstrap will give it that
    more traditional feel. If you want to build something that feels more like a cross-platform
    application, you should consider Material-UI.^([3](ch06.xhtml#idm46634406416456))
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap 是一个比 Material Design 更早的 UI 工具包，但仍然有市场认为它更合适。如果你正在构建一个需要更像传统网站的应用程序，那么
    Bootstrap 将赋予它更传统的感觉。如果你想构建更像跨平台应用程序的东西，你应该考虑 Material-UI。^([3](ch06.xhtml#idm46634406416456))
- en: You can download the source for this recipe from the [GitHub site](https://oreil.ly/ZpzF3).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从[GitHub 网站](https://oreil.ly/ZpzF3)下载这个示例的源代码。
- en: View Data Sets with React Window
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 React Window 查看数据集
- en: Problem
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Some applications need to display a seemingly endless quantity of data. If you
    are writing an application like Twitter, you don’t want to download all of the
    tweets in the user’s timeline because it would probably take several hours, days,
    or months. The solution is to *window* the data. When you window a list of items,
    you keep only the items in memory that are currently on display. As you scroll
    up or down, the application downloads the data needed for the current view.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一些应用程序需要显示看似无穷的数据量。如果你正在开发像 Twitter 这样的应用程序，你不希望下载用户时间轴上的所有推文，因为这可能需要几个小时、几天或几个月的时间。解决方案是*窗口化*数据。当你窗口化一个项目列表时，你只保留当前显示的项目在内存中。当你向上或向下滚动时，应用程序会下载当前视图所需的数据。
- en: But creating this windowing logic is quite complex. Not only does it involve
    meticulous tracking of what’s currently visible,^([4](ch06.xhtml#idm46634406401880))
    but if you’re not careful, you can quickly run into memory issues if you fail
    to cache the windowing data efficiently.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 但是创建这种窗口逻辑是相当复杂的。它不仅涉及对当前可见内容的精确跟踪，^([4](ch06.xhtml#idm46634406401880)) 而且如果未能有效缓存窗口数据，可能会很快遇到内存问题。
- en: How do you implement windowing code inside a React application?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 应用程序中如何实现窗口代码？
- en: Solution
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: The React Window library is a set of components for applications that need to
    scroll a large amount of data. We’ll look at how to create a large, fixed-size
    list.^([5](ch06.xhtml#idm46634406397224))
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: React Window 库是一组用于需要滚动大量数据的应用程序的组件。我们将看看如何创建一个大型、固定大小的列表。^([5](ch06.xhtml#idm46634406397224))
- en: To start, we need to create a component that will show the details for a single
    item. In our example application, we’re going to create a set of 10,000 date strings.
    We will render each date with a component called `DateRow`, which will be our
    item-renderer. React Window works by rendering only the items that are visible
    in the current viewport. As the user scrolls up or down the list, it will create
    new items as they come into view and remove them as they disappear.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个组件，用于显示单个项目的详细信息。在我们的示例应用程序中，我们将创建一组 10,000 个日期字符串。我们将使用一个名为 `DateRow`
    的组件来渲染每个日期，这将是我们的项目渲染器。React Window 通过仅渲染当前视口中可见的项目来工作。当用户向上或向下滚动列表时，它会在项目进入视图时创建新项目，并在项目消失时将其移除。
- en: 'When React Window calls an item renderer, it passes it two properties: an item
    number, which begins at 0, and a style object.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当 React Window 调用一个项目渲染器时，它会传递两个属性：一个项目编号（从 0 开始），以及一个样式对象。
- en: 'This is our `DateRow` item-renderer:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的 `DateRow` 项渲染器：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This component calculates a date `index` days in the future. In a more realistic
    application, this component would probably download an item of data from a backend
    server.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件会计算未来 `index` 天的日期。在一个更实际的应用程序中，此组件可能会从后端服务器下载一个数据项。
- en: To generate the list itself, we will use a `FixedSizeList`. We need to give
    the list a fixed width and height. React Window calculates how many items are
    visible using the height of the list and the height of each item, using the value
    from the `itemSize` attribute. If the `height` is 400 and the `itemHeight` is
    40, then the list will only need to display 10 or 11 `DateRow` components (see
    [Figure 6-3](#ch06_image_3)).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成列表本身，我们将使用 `FixedSizeList`。我们需要给列表一个固定的宽度和高度。React Window 通过列表的高度和每个项目的高度来计算可见项目的数量，使用
    `itemSize` 属性的值。如果 `height` 是 400，`itemHeight` 是 40，那么列表只需要显示 10 或 11 个 `DateRow`
    组件（见 [Figure 6-3](#ch06_image_3)）。
- en: 'Here is the final version of the code. Notice that the `FixedSizeList` does
    not include an instance of the `DateRow` component. That’s because it wants to
    use the `DateRow` function to create multiple items dynamically as we scroll the
    list. So instead of using `<DateRow/>`, the list uses the `{DateRow}` function
    itself:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码的最终版本。请注意，`FixedSizeList` 不包括 `DateRow` 组件的实例。这是因为它想要使用 `DateRow` 函数动态创建多个项目，当我们滚动列表时。因此，它使用
    `{DateRow}` 函数本身，而不是使用 `<DateRow/>`。
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![](Images/recb_0603.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_0603.png)'
- en: Figure 6-3\. The list contains only visible items
  id: totrans-85
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-3\. 列表仅包含可见项目
- en: 'One final point to note is that because the items are dynamically added to
    and removed from the list, you have to be careful using the `nth-child` selector
    in CSS:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个需要注意的细节是，由于项目会动态添加到列表中并从列表中移除，因此在 CSS 中使用 `nth-child` 选择器时需要小心：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Instead, you need to dynamically check the current index for an item and check
    if it’s odd using a little modulo-2 math, as we do in the example:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，您需要动态检查项目的当前索引，并使用一些模数-2数学来检查它是否为奇数，就像我们在示例中所做的那样：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Discussion
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: React Window is a narrowly focused component library but valuable if you need
    to present a vast data set. You are still responsible for downloading and caching
    the data that appears in the list, but this is a relatively simple task compared
    to the windowing magic that React Window performs.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: React Window 是一个专注于组件库，但如果您需要展示大量数据集，则非常有价值。在列表中显示的数据的下载和缓存仍由您负责，但与 React Window
    执行的窗口处理相比，这是一个相对简单的任务。
- en: You can download the source for this recipe from the [GitHub site](https://oreil.ly/lXxv3).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 [GitHub 网站](https://oreil.ly/lXxv3) 下载此示例的源代码。
- en: Create Responsive Dialogs with Material-UI
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Material-UI 创建响应式对话框
- en: Problem
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: If you’re using a component library, there’s a good chance that at some point
    you will display a dialog window. Dialogs allow you to add UI detail without making
    the user feel they are traveling to another page. They work well for content creation
    or as a quick way of displaying more detail about an item.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用一个组件库，很有可能会在某个时候显示对话框窗口。对话框允许您添加 UI 细节，而不让用户感觉他们正在切换到另一页。它们非常适合内容创建或快速显示有关项目的详细信息。
- en: However, dialogs don’t play well with mobile devices. Mobiles have a small display
    screen, and dialogs frequently waste a lot of space around the edges to display
    the background page.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对话框在移动设备上的表现不佳。移动设备有一个小的显示屏，并且对话框通常会浪费大量空间来显示背景页面的边缘。
- en: How can you create responsive dialogs, which act like floating windows when
    you are using a desktop machine but look like separate full-screen pages on a
    mobile device?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如何创建响应式对话框，在桌面机器上像浮动窗口一样运行，但在移动设备上看起来像单独的全屏页面？
- en: Solution
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'The Material-UI library includes a higher-order function that can tell when
    you are on a mobile device and display dialogs as full-screen windows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Material-UI 库包含一个高阶函数，可以判断您是否在移动设备上，并将对话框显示为全屏窗口：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `withMobileDialog` gives any component it wraps an extra property called
    `fullScreen`, which is set to `true` or `false`. A `Dialog` component can use
    this property to change its behavior. If you pass `fullScreen` to a `Dialog` like
    this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`withMobileDialog` 使其包装的任何组件都有一个额外的属性称为 `fullScreen`，它设置为 `true` 或 `false`。`Dialog`
    组件可以使用此属性来更改其行为。如果像这样传递 `fullScreen` 给 `Dialog`：'
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: the dialog will change its behavior when running on a mobile or desktop device.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当在移动设备或桌面设备上运行时，对话框将更改其行为。
- en: Let’s say we modify the application we created in [“Convert Network Calls to
    Hooks”](ch05.xhtml#ch05-01). In our original application, a dialog appears when
    the user clicked an image in a gallery. The dialog is shown on a mobile device
    in [Figure 6-4](#ch06_image_4).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们修改了在 [“将网络调用转换为钩子”](ch05.xhtml#ch05-01) 中创建的应用程序。在我们原始的应用程序中，当用户点击画廊中的图像时会出现对话框。在移动设备上，对话框如
    [图 6-4](#ch06_image_4) 所示。
- en: '![](Images/recb_0604.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_0604.png)'
- en: Figure 6-4\. By default, a dialog on a mobile device has space around the edge
  id: totrans-106
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-4\. 在移动设备上，默认情况下，对话框周围有空间
- en: If you replace this dialog with a `ResponsiveDialog`, it will look the same
    on a large screen. But on a small screen, the dialog will fill the display, as
    you can see in [Figure 6-5](#ch06_image_5). This not only gives you more space
    for the contents of the dialog, but it will simplify the experience of mobile
    users. Instead of it working like a pop-up window, it will feel more like a separate
    page.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您用 `ResponsiveDialog` 替换此对话框，在大屏幕上看起来是一样的。但在小屏幕上，对话框将填满显示屏，就像您在 [图 6-5](#ch06_image_5)
    中看到的那样。这不仅为对话框内容提供了更多空间，还简化了移动用户的体验。它不再像弹出窗口一样工作，而更像是一个独立的页面。
- en: '![](Images/recb_0605.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_0605.png)'
- en: Figure 6-5\. On a mobile device, the responsive dialog fills the screen
  id: totrans-109
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-5\. 在移动设备上，响应式对话框填满了屏幕
- en: Discussion
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: For more ideas on how to deal with responsive interfaces, see [“Create Interfaces
    with Responsive Routes”](ch02.xhtml#ch02-01).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何处理响应式界面的更多想法，请参见 [“创建具有响应路由的界面”](ch02.xhtml#ch02-01)。
- en: You can download the source for this recipe from the [GitHub site](https://oreil.ly/836i2).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 [GitHub 站点](https://oreil.ly/836i2) 下载此示例的源代码。
- en: Build an Admin Console with React Admin
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 React Admin 构建管理控制台
- en: Problem
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: 'Developers can spend so long creating and maintaining end-user applications
    that one important task is often left neglected: admin consoles. Customers don’t
    use admin consoles; they are used by back-office staff and administrators to look
    at the current data set and to investigate and resolve data issues in an application.
    Some data storage systems like [Firebase](https://oreil.ly/ugvEI) have quite advanced
    admin consoles built-in. But that’s not the case for most backend services. Instead,
    developers often have to dig into data problems by directly accessing the databases,
    which live behind several layers of cloud infrastructure.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员通常会花费很长时间来创建和维护终端用户应用程序，以至于一个重要的任务经常被忽视：管理控制台。客户不使用管理控制台；它们被后台工作人员和管理员用来查看当前数据集，并调查和解决应用程序中的数据问题。一些数据存储系统如
    [Firebase](https://oreil.ly/ugvEI) 内置了相当先进的管理控制台。但对于大多数后端服务来说并非如此。相反，开发人员通常不得不直接访问位于多层云基础设施后面的数据库来解决数据问题。
- en: How can we create an admin console for almost any React application?
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如何为几乎任何 React 应用程序创建管理控制台？
- en: Solution
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: We’re going to look at the React Admin, and although this chapter is about component
    libraries, React Admin contains far more than components. It’s an application
    framework that makes it easy to build interfaces to allow administrators to examine
    and maintain the data in your application.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将研究React Admin，尽管本章是关于组件库，但React Admin包含的内容远不止组件。它是一个应用程序框架，可以轻松构建界面，允许管理员查看和维护应用程序中的数据。
- en: Different applications will use different network service layers. They might
    use REST, GraphQL, or one of many other systems. But in most cases, data is accessed
    as a set of *resources* held on the server. React Admin has most of the pieces
    in place for creating an admin application that will allow you to browse through
    each resource. It lets you create, maintain, and search data. It can also export
    the data to an external application.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的应用程序将使用不同的网络服务层。它们可能使用REST、GraphQL或其他许多系统之一。但在大多数情况下，数据是作为在服务器上保存的一组资源进行访问的。React
    Admin已经准备好大部分组件，用于创建一个管理员应用程序，使您能够浏览每个资源。它允许您创建、维护和搜索数据。它还可以将数据导出到外部应用程序。
- en: To show how `react-admin` works, we’re going to create an admin console for
    the message board application we created in [Chapter 5](ch05.xhtml#chapter05)
    (see [Figure 6-6](#ch06_image_6)).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示`react-admin`的工作原理，我们将为我们在[第5章](ch05.xhtml#chapter05)中创建的消息板应用程序创建一个管理控制台（参见[图6-6](#ch06_image_6)）。
- en: '![](Images/recb_0512.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_0512.png)'
- en: Figure 6-6\. The original message board application
  id: totrans-122
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-6。原始留言板应用程序
- en: 'The backend for the application is a simple GraphQL server. The GraphQL server
    has a relatively simple schema, which defines messages in the schema language
    like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的后端是一个简单的GraphQL服务器。GraphQL服务器具有相对简单的模式，类似于这样定义消息的模式语言：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Each message had a unique `id`. Strings record the text of the message and the
    name of the author.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 每条消息都有一个唯一的`id`。字符串记录消息的文本和作者的姓名。
- en: 'There was only one type of change that a user could make to the data: they
    could add a message. There was one type of query they could run: they could read
    all of the messages.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 用户只能对数据做一种类型的更改：他们可以添加一条消息。他们可以运行一种类型的查询：他们可以读取所有消息。
- en: 'To create a `react-admin` application, you first need to create a new React
    application and then install the `react-admin` library:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个`react-admin`应用程序，首先需要创建一个新的React应用程序，然后安装`react-admin`库：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The main component of the library is called `Admin`. This will form the shell
    of our entire application:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库的主要组件称为`Admin`。这将构成我们整个应用程序的框架：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'An `Admin` component needs a *data provider*. A data provider is an adapter
    that will connect the application to the backend service. Our backend service
    uses GraphQL, so we need a GraphQL data provider:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`Admin`组件需要一个数据提供程序。数据提供程序是一个适配器，将应用程序连接到后端服务。我们的后端服务使用GraphQL，因此我们需要一个GraphQL数据提供程序：'
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'There are data providers available for most backend services. See the [React
    Admin website](https://oreil.ly/2qtVY) for more details. We’ll need to initialize
    our data provider before we can use it. GraphQL is configured with a `buildGraphQLProvider`
    function that is asynchronous, so we need to be careful that it’s ready before
    we use it:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数后端服务都有可用的数据提供程序。有关详细信息，请参阅[React Admin网站](https://oreil.ly/2qtVY)。我们需要在使用数据提供程序之前初始化我们的数据提供程序。GraphQL配置了一个异步的`buildGraphQLProvider`函数，因此在使用它之前我们需要确保它已经准备就绪：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The data provider connects to our GraphQL server running on port 5000.^([6](ch06.xhtml#idm46634405685304))
    The data provider will first download the schema for the application, which will
    tell it what resources (just a single resource, `Messages`, in our case) are available
    and what operations it can perform on them.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 数据提供程序连接到运行在5000端口上的GraphQL服务器。^([6](ch06.xhtml#idm46634405685304)) 数据提供程序将首先下载应用程序的模式，这将告诉它有哪些资源（在我们的情况下只有一个资源`Messages`）可用以及可以在这些资源上执行哪些操作。
- en: If we try to run the application now, it won’t do anything. That’s because even
    though it knows that there’s a `Messages` resource on the server, it doesn’t know
    that we want to do anything with it. So, let’s add the `Messages` resource to
    the application.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在尝试运行应用程序，它将不会执行任何操作。这是因为即使它知道服务器上有一个`Messages`资源，它也不知道我们想对其执行任何操作。所以，让我们将`Messages`资源添加到应用程序中。
- en: 'If we want the application to list all the messages on the server, we will
    need to create a simple component called `ListMessages`. This will use some of
    the ready-made components in `react-admin` to build its interface:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望应用程序列出服务器上的所有消息，我们需要创建一个名为`ListMessages`的简单组件。这将使用`react-admin`中的一些现成组件来构建其界面：
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This will create a table with columns for message `id`, `author`, and `text`.
    We can now tell the admin system about the new component by passing a `Resource`
    to the `Admin` component:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个包含消息`id`、`author`和`text`列的表。现在，我们可以通过将`Resource`传递给`Admin`组件来告知管理员系统有关新组件的信息：
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `Admin` component will see the new `Resource`, contact the server to read
    the messages, and then render them with a `ListMessages` component (see [Figure 6-7](#ch06_image_7)).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`Admin`组件将查看新的`Resource`，联系服务器以读取消息，然后使用`ListMessages`组件呈现它们（见[图 6-7](#ch06_image_7)）。'
- en: '![](Images/recb_0607.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_0607.png)'
- en: Figure 6-7\. Displaying the messages from the server
  id: totrans-143
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-7\. 显示来自服务器的消息
- en: 'The screen update appears to work by magic, but it’s because the server has
    to follow certain conventions so that the GraphQL adapter knows which service
    to call. In this case, it will find a query called `allMessages`, which returns
    messages:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕更新似乎像魔术一样工作，但这是因为服务器必须遵循某些约定，以便GraphQL适配器知道调用哪个服务。在这种情况下，它将找到一个名为`allMessages`的查询，该查询返回消息：
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As a result, you might need to change your backend API to meet the requirements
    of your data provider. However, the services that you add will probably be useful
    in your main application.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可能需要更改后端API以满足数据提供者的要求。然而，您添加的服务可能会在主应用程序中非常有用。
- en: The `allMessages` query allows the admin interface to page through the data
    from your server. It can accept a property called `filter`, which it uses to search
    for the data. The `MessageFilter` in the example schema will allow the admin console
    to find messages containing strings for `author` and `text`. It will also allow
    the admin console to send a general search string (`q`), which it will use to
    find messages that contain a string in any field.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`allMessages`查询允许管理员界面从服务器分页获取数据。它可以接受一个名为`filter`的属性，用于搜索数据。示例模式中的`MessageFilter`将允许管理员控制台查找包含`author`和`text`字符串的消息。它还允许管理员控制台发送通用搜索字符串（`q`），用于查找包含任何字段中字符串的消息。'
- en: 'Here is the GraphQL schema definition of the `MessageFilter` object. You will
    need to create something similar for each resource in your application:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`MessageFilter`对象的GraphQL模式定义。您需要为应用程序中的每个资源创建类似的内容：
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To enable filtering and searching in the frontend, we will first need to create
    some filtering fields in a React component we’ll call `MessageFilter`. This is
    quite distinct from the `MessageFilter` in the schema, although you will notice
    it contains matching fields:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在前端实现过滤和搜索功能，我们首先需要在一个名为`MessageFilter`的React组件中创建一些过滤字段。这与架构中的`MessageFilter`有很大区别，尽管您会注意到它包含匹配字段：
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can now add the `MessageFilter` to the `ListMessages` component, and we
    will suddenly find that we can page, search, and filter messages in the admin
    console (see [Figure 6-8](#ch06_image_8)):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将`MessageFilter`添加到`ListMessages`组件中，突然间，我们发现可以在管理员控制台中进行分页、搜索和过滤消息（见[图 6-8](#ch06_image_8)）：
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '![](Images/recb_0608.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_0608.png)'
- en: Figure 6-8\. Filtering the messages table by author or text
  id: totrans-155
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-8\. 按作者或文本过滤消息表
- en: 'We can also add the ability to create new messages by adding a `CreateMessage`
    component:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过添加`CreateMessage`组件来实现创建新消息的能力：
- en: '[PRE33]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'and then adding the `CreateMessage` component to the `Resource` (see [Figure 6-9](#ch06_image_9)):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将`CreateMessage`组件添加到`Resource`中（见[图 6-9](#ch06_image_9)）：
- en: '[PRE34]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '![](Images/recb_0609.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_0609.png)'
- en: Figure 6-9\. Creating messages on the console
  id: totrans-161
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-9\. 在控制台上创建消息
- en: 'The GraphQL data provider will create messages by passing the contents of the
    `CreateMessage` form to a mutation called `CreateMessage`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL数据提供程序将通过将`CreateMessage`表单的内容传递给名为`CreateMessage`的变化来创建消息：
- en: '[PRE35]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Similarly, you can add the ability to update or delete messages. If you have
    a complex schema with subresources, `react-admin` can display subitems within
    a table. It can also handle different display types. It can show images and links.
    There are components available that can display resources on calendars or in charts
    (see [Figure 6-10](#ch06_image_10) for examples from the [online demo application](https://oreil.ly/fmFwR)).^([7](ch06.xhtml#idm46634404914248))
    Admin consoles can also work with your existing security system.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，您可以添加更新或删除消息的功能。如果您的模式复杂并且包含子资源，`react-admin`可以在表格内显示子项。它还可以处理不同的显示类型。它可以显示图像和链接。有可用的组件可以在日历或图表上显示资源（参见[图 6-10](#ch06_image_10)来自[在线演示应用程序](https://oreil.ly/fmFwR)的示例）。^([7](ch06.xhtml#idm46634404914248))
    管理控制台还可以与现有的安全系统配合使用。
- en: '![](Images/recb_0610.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_0610.png)'
- en: Figure 6-10\. Different view types in the online demo
  id: totrans-166
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-10\. 在线演示中的不同视图类型
- en: Discussion
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Although you will have to make some additional changes to your backend services
    to make `react-admin` work for you, there is an excellent chance that these additional
    services will also be helpful for your main application. Even if they aren’t,
    the building blocks that `react-admin` provides will likely slash the development
    time needed to create a back-office system.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您必须对后端服务进行一些额外的更改，以使`react-admin`适合您的应用，但这些额外的服务极有可能对您的主要应用程序也有帮助。即使它们没有，`react-admin`提供的构建模块也很可能大大减少创建后台系统所需的开发时间。
- en: You can download the source for this recipe from the [GitHub site](https://oreil.ly/2sUhp).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从[GitHub站点](https://oreil.ly/2sUhp)下载此配方的源代码。
- en: No Designer? Use Semantic UI
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有设计师？使用Semantic UI
- en: Problem
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Well-designed styling can add a lot of visual appeal to an application. But
    poor styling can make even a good application appear cheap and amateurish. Many
    developers have a limited sense of design.^([8](ch06.xhtml#idm46634404900392))
    In cases where you have little or no access to professional design help, a simple,
    clear UI component library can allow you to focus on the application’s functionality
    without spending endless hours tweaking the location of buttons and borders.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 设计良好的样式可以为应用程序增添很多视觉吸引力。但糟糕的样式可能会使一个好的应用程序看起来廉价和业余。许多开发者在设计方面的感知有限。^([8](ch06.xhtml#idm46634404900392))
    在您几乎没有或没有专业设计帮助的情况下，一个简单、清晰的UI组件库可以让您专注于应用程序的功能，而不必花费无数小时调整按钮和边框的位置。
- en: Tried-and-tested frameworks like Bootstrap can provide a good, no-gloss foundation
    for most applications.^([9](ch06.xhtml#idm46634404898968)) But even they often
    require a lot of focus on visual appearance. If you want to focus on the functionality
    of an application and want to get a clear functional visual appearance, then the
    Semantic UI library is a good choice.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 经过试验的框架如Bootstrap可以为大多数应用程序提供一个良好的、无光泽的基础。^([9](ch06.xhtml#idm46634404898968))
    但即使是它们通常也需要大量关注视觉外观。如果您希望专注于应用程序的功能并希望获得清晰的功能视觉外观，那么Semantic UI库是一个不错的选择。
- en: But the Semantic UI library is old, coming from the days when jQuery ruled the
    roost. At the time of writing, it has not been updated in more than two years.
    What do you do if you want to use a reliable and well-established library like
    Semantic UI with React?
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 但Semantic UI库很老，来自jQuery统治的时代。在撰写本文时，它已经超过两年没有更新了。如果您想在React中使用像Semantic UI这样可靠和成熟的库，该怎么办？
- en: Solution
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: The Semantic UI React library is a wrapper that makes the Semantic UI library
    available for React users.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Semantic UI React库是一个包装器，使Semantic UI库可用于React用户。
- en: As the name suggests, Semantic UI focuses on the meaning of the interface. You
    manage its visual appearance with CSS rather than components. Instead, Semantic
    UI components focus on functionality. When you create a form, for example, you
    say which fields to include, rather than saying anything about their layout. That
    leads to a clean, consistent appearance, which needs little or no visual adjustment.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，Semantic UI侧重于界面的含义。您可以通过CSS管理其视觉外观，而不是组件。相反，Semantic UI组件侧重于功能性。例如，当您创建一个表单时，您说要包括哪些字段，而不是关于它们布局的任何内容。这导致了干净、一致的外观，几乎不需要任何视觉调整。
- en: 'To get started, let’s install the Semantic library and its styling support:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用，让我们安装Semantic库及其样式支持：
- en: '[PRE36]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In addition, we also need to include a reference to the stylesheet in the *index.js*
    file of the application:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要在应用程序的*index.js*文件中包含对样式表的引用：
- en: '[PRE37]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We’re going to re-create our message posting application. We’ll need a form
    with a text field for the author’s name and a text area for posting a message.
    Semantic components are designed to be as similar to simple HTML elements as possible.
    So if we’re building a form, we’ll import a `Form`, `Input`, `TextArea`, and `Button`
    to post the message:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重新创建我们的消息发布应用程序。我们需要一个包含作者姓名文本字段和发布消息文本区域的表单。语义化组件旨在尽可能与简单的HTML元素相似。因此，如果我们构建一个表单，我们将导入`Form`、`Input`、`TextArea`和`Button`来发布消息：
- en: '[PRE38]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This code should feel familiar. The `Form` component does have a `Field` helper,
    which makes it a little easier to group labels and fields, but beyond that, the
    code looks similar to an elementary HTML form.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码应该感觉很熟悉。`Form`组件确实有一个`Field`助手，可以更轻松地组合标签和字段，但除此之外，代码看起来与基本的HTML表单类似。
- en: 'In the example application, we’re “posting” messages by adding them to an array
    called `messages`. You may have noticed that we’re adding messages to the array
    in a particular object structure:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例应用程序中，我们通过将消息添加到名为`messages`的数组中来“发布”消息。您可能已经注意到，我们是按照特定的对象结构将消息添加到数组中的：
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We did not choose these attributes by accident. Although most of the components
    in Semantic are simple, there are some more complex components, which are there
    to support some common use cases. One such example is the `Feed` component. The
    `Feed` component is there to render a social message stream, such as you might
    see on Twitter or Instagram. It will render a clean series of messages, with date
    stamps, headlines, icons, and so on. Here’s what our final code looks like with
    the `Feed` included:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并非出于偶然选择了这些属性。尽管语义化中的大多数组件都很简单，但也有一些更复杂的组件，这些组件旨在支持一些常见的用例。一个例子是`Feed`组件。`Feed`组件用于呈现社交消息流，例如您可能在Twitter或Instagram上看到的消息流。它将呈现一系列干净的消息，带有日期戳、标题、图标等等。包括`Feed`组件的最终代码如下所示：
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: When you run the application, the interface is clean and unfussy (see [Figure 6-11](#ch06_image_11)).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行应用程序时，界面干净简洁（请参阅[图 6-11](#ch06_image_11)）。
- en: '![](Images/recb_0611.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_0611.png)'
- en: Figure 6-11\. The Semantic UI interface in action
  id: totrans-191
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-11\. Semantic UI界面实例
- en: Discussion
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Semantic UI is an old library. But that’s not a bad thing. Its battle-tested
    interface is clean and functional and is one of the best ways of getting your
    application up and running without the support of a visual designer. It’s particularly
    useful if you’re creating a Lean Startup and want to throw something together
    quickly to test if there is a market for your product.^([10](ch06.xhtml#idm46634404445576))
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Semantic UI是一个老旧的库。但这并不是坏事。它经过了实战考验的界面既清晰又功能强大，是在没有视觉设计师支持的情况下快速启动和测试产品市场的最佳方式之一。如果您正在创建精益创业公司，并希望快速组合一些内容来测试产品是否有市场，它特别有用。^([10](ch06.xhtml#idm46634404445576-marker))
- en: You can download the source for this recipe from the [GitHub site](https://oreil.ly/qeNqy).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[GitHub 站点](https://oreil.ly/qeNqy)下载此示例的源代码。
- en: ^([1](ch06.xhtml#idm46634408664616-marker)) For full details of the entire component
    set, see [the Material-UI site](https://material-ui.com).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch06.xhtml#idm46634408664616-marker)) 有关整个组件集的详细信息，请参阅[Material-UI 网站](https://material-ui.com)。
- en: ^([2](ch06.xhtml#idm46634408268808-marker)) For more information on these components,
    see the [Material-UI site](https://material-ui.com).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch06.xhtml#idm46634408268808-marker)) 有关这些组件的更多信息，请参阅[Material-UI 网站](https://material-ui.com)。
- en: ^([3](ch06.xhtml#idm46634406416456-marker)) See [“Convert Network Calls to Hooks”](ch05.xhtml#ch05-01)
    for more information.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch06.xhtml#idm46634406416456-marker)) 查看更多信息，请参阅[“将网络调用转换为Hooks”](ch05.xhtml#ch05-01)。
- en: ^([4](ch06.xhtml#idm46634406401880-marker)) Including dealing with all the nasty
    edge cases that occur if the viewport changes size.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch06.xhtml#idm46634406401880-marker)) 包括处理视口大小变化时发生的所有棘手边缘情况。
- en: ^([5](ch06.xhtml#idm46634406397224-marker)) You can use the library for variable
    and fixed-sized lists and grids. See the [documentation](https://oreil.ly/pCYaq)
    for more details.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch06.xhtml#idm46634406397224-marker)) 您可以使用该库来处理可变大小和固定大小的列表和网格。详细信息请参阅[文档](https://oreil.ly/pCYaq)。
- en: ^([6](ch06.xhtml#idm46634405685304-marker)) You will find the server in the
    source code for this chapter. You can run the server by typing **`node ./server.js`**.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch06.xhtml#idm46634405685304-marker)) 您可以在本章的源代码中找到服务器。您可以通过输入**`node
    ./server.js`**来运行服务器。
- en: ^([7](ch06.xhtml#idm46634404914248-marker)) Some of them are available only
    if you subscribe to the Enterprise edition.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch06.xhtml#idm46634404914248-marker)) 其中一些仅在您订阅企业版时才可用。
- en: ^([8](ch06.xhtml#idm46634404900392-marker)) Including at least one of the authors…
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch06.xhtml#idm46634404900392-marker)) 包括至少一位作者...
- en: ^([9](ch06.xhtml#idm46634404898968-marker)) See [“Create a Simple UI with React
    Bootstrap”](#ch06-02) for guidance on how to use Bootstrap with your application.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ^([9](ch06.xhtml#idm46634404898968-marker)) 参见[《使用React Bootstrap创建简单UI》](#ch06-02)，了解如何在应用程序中使用Bootstrap的指导。
- en: ^([10](ch06.xhtml#idm46634404445576-marker)) For more details, see *The Lean
    Startup* by Eric Ries (Crown Business).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ^([10](ch06.xhtml#idm46634404445576-marker)) 更多详细信息，请参阅*《精益创业》*（Eric Ries著，Crown
    Business出版）。
