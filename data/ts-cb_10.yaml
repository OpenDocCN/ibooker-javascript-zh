- en: Chapter 9\. The Standard Library and External Type Definitions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。标准库和外部类型定义
- en: TypeScript’s lead architect, Anders Hejlsberg, once said that he envisions “TypeScript
    to be the Switzerland of JavaScript,” meaning that it doesn’t prefer or work toward
    compatibility with a single framework but rather tries to cater to all JavaScript
    frameworks and flavors. In the past, TypeScript worked on a decorator implementation
    to convince Google not to pursue the JavaScript dialect [AtScript](https://oreil.ly/ZrcKR)
    for Angular, which was TypeScript plus decorators. The TypeScript decorator implementation
    also serves as a template for a respective [ECMAScript proposal on decorators](https://oreil.ly/76JuE).
    TypeScript also understands the JSX syntax extension, allowing frameworks like
    React or Preact to use TypeScript without limitations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript的首席架构师Anders Hejlsberg曾说过，他设想“TypeScript是JavaScript的瑞士”，这意味着它不偏爱或努力与单一框架兼容，而是试图迎合所有JavaScript框架和变体。过去，TypeScript曾致力于实现装饰器，说服Google不再推广带有装饰器的JavaScript方言[AtScript](https://oreil.ly/ZrcKR)，后者是TypeScript加上装饰器。TypeScript的装饰器实现也作为相应的[ECMAScript装饰器提案](https://oreil.ly/76JuE)的模板。TypeScript还理解JSX语法扩展，允许像React或Preact这样的框架无限制地使用TypeScript。
- en: But even if TypeScript tries to cater to all JavaScript developers and makes
    a huge effort to integrate new and useful features for a plethora of frameworks,
    there are still things it can’t or won’t do. Maybe because a certain feature is
    too niche, or maybe because a decision would have huge implications for too many
    developers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 但即使TypeScript试图迎合所有JavaScript开发者，并为众多框架整合新的有用特性做出巨大努力，仍有一些它无法或不会做到的事情。也许因为某个特性太小众，或者因为一个决策会对太多开发者产生巨大影响。
- en: This is why TypeScript has been designed to be extensible by default. A lot
    of TypeScript’s features like namespaces, modules, and interfaces allow for declaration
    merging, which gives you the possibility to add type definitions to your liking.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么TypeScript被设计为默认可扩展的原因。像命名空间、模块和接口这样的许多TypeScript特性允许声明合并，这使你可以根据自己的喜好添加类型定义。
- en: In this chapter, we look at how TypeScript deals with standard JavaScript functionality
    like modules, arrays, and objects. We will see some of their limitations, analyze
    the reasoning behind their limitations, and provide reasonable workarounds. You
    will see that TypeScript has been designed to be very flexible for various flavors
    of JavaScript, starting with sensible defaults, and giving you the opportunity
    to extend when you see fit.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到TypeScript如何处理标准JavaScript功能，如模块、数组和对象。我们将看到它们的一些限制，分析其背后的原因，并提供合理的解决方法。你将看到TypeScript被设计为对各种JavaScript变体非常灵活，从合理的默认值开始，并在需要时提供扩展的机会。
- en: 9.1 Iterating over Objects with Object.keys
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.1 使用Object.keys迭代对象
- en: Problem
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: When you try to access object properties via iterating over its keys, TypeScript
    throws red squiggly lines at you, telling you that "`‘string’` can’t be used to
    index type.”
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试通过迭代其键来访问对象属性时，TypeScript会向你抛出红色波浪线，告诉你"`‘string’`不能用于索引类型。”
- en: Solution
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use a `for-in` loop instead of `Object.keys` and lock your type using generic
    type parameters.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`for-in`循环而不是`Object.keys`，并使用泛型类型参数锁定你的类型。
- en: Discussion
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'A prominent head-scratcher in TypeScript is trying to access an object property
    via iterating through its keys. This pattern is so common in JavaScript, yet TypeScript
    seems to keep you from using it at all costs. We use this simple line to iterate
    over an object’s properties:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript中一个引人注目的令人头疼的问题是尝试通过迭代其键来访问对象属性。这种模式在JavaScript中非常常见，然而TypeScript似乎竭尽全力阻止你使用它。我们使用这样一行简单的代码来迭代对象的属性：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It leads to TypeScript throwing red squigglies at you and developers flipping
    tables: “Element implicitly has an `''any''` type because expression of type `''string''`
    can’t be used to index type `''Person''`.” In this situation, experienced JavaScript
    developers feel like TypeScript is working against them. But as with all decisions
    in TypeScript, there is a good reason why TypeScript behaves like this.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致TypeScript向你抛出红色波浪线，开发者翻桌：“元素隐式具有`'any'`类型，因为类型为`'string'`的表达式不能用于索引类型`'Person'`。”在这种情况下，经验丰富的JavaScript开发者感觉TypeScript在与他们作对。但就像TypeScript的所有决策一样，TypeScript这样做有很好的理由。
- en: 'Let’s find out why. Take a look at this function:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找出原因。看看这个函数：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: All we want is to print a `Person`’s fields by accessing them through its keys.
    TypeScript won’t allow this. `Object.keys(p)` returns a `string[]`, which is too
    wide to allow accessing a very defined object shape `Person`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只想通过访问其键来打印`Person`的字段。TypeScript 不允许这样做。`Object.keys(p)` 返回一个`string[]`，这对于访问非常明确定义的对象结构`Person`来说太宽泛了。
- en: 'But why is that? Isn’t it obvious that we only access keys that are available?
    That’s the whole point of using `Object.keys`! It is, but we are also able to
    pass objects that are subtypes of `Person`, which can have more properties than
    defined in `Person`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么会这样？难道我们只能访问可用的键不是显而易见的吗？这正是使用`Object.keys`的整个目的！是的，但我们也可以传递`Person`的子类型的对象，这些对象可能具有比在`Person`中定义的更多的属性：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`printPerson` still should work correctly. It prints more properties, but it
    doesn’t break. It’s still the keys of `p`, so every property should be accessible.
    But what if you don’t access only `p`?'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`printPerson` 仍然应该正确工作。它打印更多的属性，但不会中断。它仍然是`p`的键，因此应该可以访问每个属性。但是如果你不仅仅访问`p`呢？'
- en: 'Let’s assume `Object.keys` gives you `(keyof Person)[]`. You can easily write
    something like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`Object.keys` 给你`(keyof Person)[]`。你可以轻松地写出像这样的东西：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If `Object.keys(p)` returns an array of type `keyof Person[]`, you will be able
    to access other objects of `Person`, too. This might not add up. In our example,
    we just print undefined. But what if you try to do something with those values?
    This will break at runtime.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `Object.keys(p)` 返回一个`keyof Person[]` 类型的数组，你将能够访问其他`Person`对象。这可能不会累积。在我们的例子中，我们只是打印未定义的内容。但是如果你尝试对这些值做些什么，这将在运行时出错。
- en: TypeScript prevents you from scenarios like this. While we might think `Object.keys`
    is `keyof Person`, in reality, it can be so much more.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 阻止你像这样的场景。虽然我们可能认为`Object.keys`是`keyof Person`，但实际上它可能会更多。
- en: 'One way to mitigate this problem is to use type guards:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 缓解这个问题的一种方法是使用类型保护：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: But this adds an extra step that frankly shouldn’t be there.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 但这增加了一个本不应该存在的额外步骤。
- en: 'There’s another way to iterate over objects, using `for-in` loops:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种迭代对象的方法，使用`for-in`循环：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'TypeScript will throw the same error for the same reason because you still
    can do things like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 将因为同样的原因抛出同样的错误，因为你仍然可以做像这样的事情：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And it will break at runtime. However, writing it like this gives you a little
    edge over the `Object.keys` version. TypeScript can be much more exact in this
    scenario if you add a generic:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 但它将在运行时中断。但是，像这样写会给你比`Object.keys`版本更多的优势。如果你添加一个泛型，TypeScript 在这种情况下可以更加精确：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Instead of requiring `p` to be `Person` (and thus be compatible with all subtypes
    of `Person`), we add a new generic type parameter `T` that is a subtype of `Person`.
    This means all types that have been compatible with this function signature are
    still compatible, but the moment we use `p`, we are dealing with an explicit subtype,
    not the broader supertype `Person`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是要求`p`是`Person`（因此与所有`Person`的子类型兼容），我们添加一个新的泛型类型参数`T`，它是`Person`的子类型。这意味着所有兼容该函数签名的类型仍然兼容，但一旦我们使用`p`，我们处理的是一个显式的子类型，而不是更广泛的超类型`Person`。
- en: We substitute `T` for something that is compatible with `Person` but where TypeScript
    knows that it’s concrete enough to prevent errors.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用`T`替换了与`Person`兼容的东西，但 TypeScript 知道它足够具体，以防止错误。
- en: 'The preceding code works. `k` is of type `keyof T`. That’s why we can access
    `p`, which is of type `T`. And this technique still prevents us from accessing
    types that lack specific properties:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码有效。`k`的类型是`keyof T`。这就是为什么我们可以访问`p`，它的类型是`T`。而这种技术仍然防止我们访问缺少特定属性的类型：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can’t access a `Person` with `keyof T`. They might be different. But since
    `T` is a subtype of `Person`, we still can assign properties, if we know the exact
    property names:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法使用`keyof T`访问`Person`。它们可能不同。但由于`T`是`Person`的子类型，如果我们知道确切的属性名称，我们仍然可以分配属性。
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: And that’s exactly what we want.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们想要的。
- en: TypeScript being very conservative about its types here is something that might
    seem odd at first, but it helps you in scenarios you wouldn’t think of. I guess
    this is the part where JavaScript developers usually scream at the compiler and
    think they’re “fighting” it, but maybe TypeScript saved you without you knowing
    it. For situations where this gets annoying, TypeScript at least gives you ways
    to work around it.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 在这里对其类型非常保守，这可能起初看起来有些奇怪，但它帮助你在你不会考虑到的情况下解决问题。我猜这是 JavaScript 开发人员通常会对编译器尖叫并认为他们在“与之战斗”的部分，但也许
    TypeScript 在你不知情的情况下拯救了你。对于这种让人烦恼的情况，TypeScript 至少给了你解决方法。
- en: 9.2 Explicitly Highlighting Unsafe Operations with Type Assertions and unknown
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.2 明确通过类型断言和 `unknown` 强调不安全操作
- en: Problem
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Parsing arbitrary data via JSON operations can go wrong if the data is not correct.
    TypeScript’s defaults don’t provide any safeguards for these unsafe operations.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 JSON 操作解析任意数据可能会出错，如果数据不正确的话。TypeScript 的默认设置不提供这些不安全操作的任何保障。
- en: Solution
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Explicitly highlight unsafe operations by using type assertions instead of type
    annotations, and make sure they are enforced by patching the original types with
    `unknown`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用类型断言而不是类型注释明确突出不安全操作，并确保它们通过对 `unknown` 的原始类型进行修补来实施。
- en: Discussion
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: In [Recipe 3.9](ch03.html#ch03_item_assertions) we spoke about how to effectively
    use type assertions. Type assertions are an explicit call to the type system to
    say that some type should be a different one, and based on some set of guardrails—for
    example, not saying `number` is actually `string`—TypeScript will treat this particular
    value as the new type.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [Recipe 3.9](ch03.html#ch03_item_assertions) 中，我们讨论了如何有效地使用类型断言。类型断言是对类型系统的显式调用，以表明某些类型应该是不同的，并基于一些保护措施（例如，不将
    `number` 实际上视为 `string`）使 TypeScript 将这个特定值视为新类型。
- en: 'With TypeScript’s rich and extensive type system, sometimes type assertions
    are inevitable. Sometimes you even want them, as shown in [Recipe 3.9](ch03.html#ch03_item_assertions)
    where we use the `fetch` API to get JSON data from a backend. One way is to call
    `fetch` and assign the results to an annotated type:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 TypeScript 强大且广泛的类型系统，有时不可避免地需要类型断言。有时甚至是我们想要的，就像在 [Recipe 3.9](ch03.html#ch03_item_assertions)
    中展示的那样，我们使用 `fetch` API 从后端获取 JSON 数据。一种方法是调用 `fetch` 并将结果分配给注释类型：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`res.json()` results in `any`,^([1](ch09.html#id816)) and everything that is
    `any` can be changed to any other type through a type annotation. There is no
    guarantee that the result is actually `Person[]`.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`res.json()` 的结果是 `any`，^([1](ch09.html#id816)) 且一切都可以通过类型注释更改为任何其他类型。不能保证结果实际上是
    `Person[]`。'
- en: 'The other way is to use a type assertion instead of a type annotation:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用类型断言而不是类型注释：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For the type system, this is the same thing, but we can easily scan situations
    where there might be problems. If we don’t validate our incoming values against
    types (with, for example, Zod; see [Recipe 12.5](ch12.html#ch12_zod)), then having
    a type assertion here is an effective way of highlighting unsafe operations.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类型系统而言，这是相同的事情，但我们可以轻松地扫描可能存在问题的情况。如果我们不对传入的值进行类型验证（例如使用 Zod 可参考 [Recipe 12.5](ch12.html#ch12_zod)），那么在此处使用类型断言是突出不安全操作的有效方法。
- en: '*Unsafe* operations in a type system are situations where we tell the type
    system that we expect values to be of a certain type, but we don’t have any guarantee
    from the type system itself that this will actually be true. This happens mostly
    at the borders of our application, where we load data from someplace, deal with
    user input, or parse data with built-in methods.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型系统中，*不安全* 操作是指我们告诉类型系统我们期望值是某种类型，但是我们没有任何来自类型系统本身的保证，它实际上会成为真实情况。这在我们应用程序的边界处经常发生，我们从某个地方加载数据、处理用户输入或使用内置方法解析数据时。
- en: Unsafe operations can be highlighted by using certain keywords that indicate
    an explicit change in the type system. Type assertions (`as`), type predicates
    (`is`), or assertion signatures (`asserts`) help us find those situations. In
    some cases, TypeScript even forces us either to comply with its view of types
    or to explicitly change the rules based on our situations. But not always.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用特定的关键字来突出显示不安全操作，这些关键字表明类型系统中的显式类型更改。类型断言 (`as`)、类型预测 (`is`) 或断言签名 (`asserts`)
    帮助我们找到这些情况。在某些情况下，TypeScript 甚至要求我们遵守其类型视图或根据我们的情况显式更改规则。但并非总是如此。
- en: When we fetch data from some backend, it is just as easy to annotate as it is
    to write a type assertion. Things like that can be overlooked if we don’t force
    ourselves to use the correct technique.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从某个后端获取数据时，标注类型和写入类型断言一样容易。如果我们不强迫自己使用正确的技术，这些事情可能被忽视。
- en: 'But we can help TypeScript help us do the right thing. The problem is the call
    to `res.json()`, which comes from the `Body` interface in *lib.dom.d.ts*:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们可以借助 TypeScript 帮助我们做正确的事情。问题出在对 `res.json()` 的调用，它来自 *lib.dom.d.ts* 中的 `Body`
    接口：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `json()` call returns a `Promise<any>`, and `any` is the loosey-goosey
    type where TypeScript just ignores any type-check at all. We would need `any`’s
    cautious brother, `unknown`. Thanks to declaration merging, we can override the
    `Body` type definition and define `json()` to be a bit more restrictive:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`json()` 调用返回一个 `Promise<any>`，而 `any` 是 TypeScript 中一种松散的类型，TypeScript 在这种情况下完全忽略类型检查。我们需要
    `any` 的谨慎兄弟 `unknown`。由于声明合并，我们可以重写 `Body` 类型定义，并将 `json()` 定义得更为严格：'
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The moment we do a type annotation, TypeScript yells at us that we can’t assign
    `unknown` to `Person[]`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进行类型注释时，TypeScript 会警告我们不能将 `unknown` 分配给 `Person[]`：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'But TypeScript is still happy if we do a type assertion:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果我们进行类型断言，TypeScript 仍然会欣然接受：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: And with that, we can force TypeScript to highlight unsafe operations.^([2](ch09.html#id822))
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以强制 TypeScript 突出显示不安全的操作。^([2](ch09.html#id822))
- en: 9.3 Working with defineProperty
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.3 使用 defineProperty 进行操作
- en: Problem
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You define properties on the fly using `Object.defineProperty`, but TypeScript
    doesn’t pick up changes.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `Object.defineProperty` 动态定义属性，但 TypeScript 不会检测到更改。
- en: Solution
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Create a wrapper function and use assertion signatures to change the object’s
    type.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包装函数，并使用断言签名来更改对象的类型。
- en: Discussion
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'In JavaScript, you can define object properties on the fly with `Ob⁠je⁠ct.de⁠fi⁠ne​Pr⁠op⁠er⁠ty`.
    This is useful if you want your properties to be read-only. Think of a storage
    object that has a maximum value that shouldn’t be overwritten:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，您可以使用 `Ob⁠je⁠ct.de⁠fi⁠ne​Pr⁠op⁠er⁠ty` 动态定义对象属性。如果要求属性为只读，则此方法非常有用。想象一个存储对象，它具有不应被覆盖的最大值：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`defineProperty` and property descriptors are very complex. They allow you
    to do everything with properties that usually is reserved for built-in objects.
    So they’re common in larger codebases. TypeScript has a problem with `defineProperty`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`defineProperty` 和属性描述符非常复杂。它们允许您以通常保留给内置对象的方式处理属性，因此在较大的代码库中非常常见。TypeScript
    在处理 `defineProperty` 时存在问题：'
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If we don’t explicitly assert to a new type, we don’t get `maxValue` attached
    to the type of `storage`. However, for simple use cases, we can help ourselves
    using assertion signatures.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不明确断言为新类型，那么 `maxValue` 将不会附加到 `storage` 的类型中。然而，对于简单的用例，我们可以使用断言签名来帮助自己。
- en: Note
  id: totrans-77
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: While TypeScript might not feature object changes when using `Object.defineProperty`,
    there is a chance that the team will add typings or special behavior for cases
    like this in the future. For example, checking if an object has a certain property
    using the `in` keyword didn’t affect types for years. This changed in 2022 with
    [TypeScript 4.9](https://oreil.ly/YpyGG).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 TypeScript 在使用 `Object.defineProperty` 时可能不支持对象更改，但团队未来可能会为这类情况添加类型或特殊行为。例如，使用
    `in` 关键字检查对象是否具有某个特定属性多年来未影响类型。这在 2022 年随着 [TypeScript 4.9](https://oreil.ly/YpyGG)
    发生了改变。
- en: 'Think of an `assertIsNumber` function where you can make sure some value is
    of type `number`. Otherwise, it throws an error. This is similar to the `assert`
    function in Node.js:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个 `assertIsNumber` 函数，您可以确保某个值是 `number` 类型。否则，它会抛出一个错误。这类似于 Node.js 中的 `assert`
    函数：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To comply with behavior like this, we can add an assertion signature that tells
    TypeScript that we know more about the type after this function:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了符合这种行为，我们可以添加一个断言签名，告诉 TypeScript 我们在此函数后对类型有更多了解：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This works a lot like type predicates (see [Recipe 3.5](ch03.html#ch03_item_type_predicates))
    but without the control flow of a condition-based structure like `if` or `switch`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这与类型预测器（参见 [Recipe 3.5](ch03.html#ch03_item_type_predicates)）非常类似，但没有像 `if`
    或 `switch` 这样基于条件的控制流：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you look at it closely, you can see those assertion signatures can *change
    the type of a parameter or variable on the fly*. This is what `Object.defineProperty`
    does as well.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仔细观察它，您会发现这些断言签名可以 *即时更改参数或变量的类型*。这正是 `Object.defineProperty` 所做的。
- en: 'The following helper does not aim to be 100% accurate or complete. It might
    have errors, and it might not tackle every edge case of the `defineProperty` specification.
    But it will give us the basic functionality. First, we define a new function called
    `de⁠fin⁠e​Pr⁠ope⁠rty` that we use as a wrapper function for `Object.defineProperty`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的帮助函数并不力求完全准确或完整。它可能存在错误，可能无法处理 `defineProperty` 规范的每个边缘情况。但它将为我们提供基本功能。首先，我们定义一个名为
    `de⁠fin⁠e​Pr⁠ope⁠rty` 的新函数，用作 `Object.defineProperty` 的包装函数：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We work with three generics:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用三种泛型：
- en: The object we want to modify, of type `Obj`, which is a subtype of `object`.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们想要修改的对象，类型为 `Obj`，是 `object` 的子类型。
- en: 'Type `Key`, which is a subtype of `PropertyKey` (built-in): `string | number
    | ​sy⁠mb⁠ol`.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Key`类型，是`PropertyKey`的子类型（内置）：`string | number | ​symbol`。'
- en: '`PDesc`, a subtype of `PropertyDescriptor` (built-in). This allows us to define
    the property with all its features (writability, enumerability, reconfigurability).'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PDesc`，`PropertyDescriptor`的子类型（内置）。这允许我们定义带有所有特性的属性（可写性、可枚举性、可重配置性）。'
- en: We use generics because TypeScript can narrow them to a very specific unit type.
    `PropertyKey`, for example, is all numbers, strings, and symbols. But if we use
    `Key extends PropertyKey`, we can pinpoint `prop` to be, for example, type `"maxValue"`.
    This is helpful if we want to change the original type by adding more properties.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用泛型，因为 TypeScript 可以将它们缩小到非常具体的单元类型。例如，`PropertyKey` 就是所有数字、字符串和符号。但如果我们使用`Key
    extends PropertyKey`，我们可以精确定位`prop`为例如类型`"maxValue"`。如果我们想通过添加更多属性来改变原始类型，这是很有帮助的。
- en: The `Object.defineProperty` function either changes the object or throws an
    error should something go wrong. That’s exactly what an assertion function does.
    Our custom helper `defineProperty` thus does the same.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.defineProperty`函数要么改变对象，要么在出现问题时抛出错误。这正是断言函数所做的事情。因此，我们的自定义辅助函数`defineProperty`也是如此。'
- en: 'Let’s add an assertion signature. Once `defineProperty` successfully executes,
    our object has another property. We are creating some helper types for that. The
    signature first:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个断言签名。一旦`defineProperty`成功执行，我们的对象就有了另一个属性。我们正在创建一些辅助类型来做这件事。首先是签名：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`obj` then is of type `Obj` (narrowed through a generic) and our newly defined
    property.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`obj`的类型是`Obj`（通过泛型缩小）和我们新定义的属性。
- en: 'This is the `DefineProperty` helper type:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`DefineProperty`辅助类型：
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'First, we deal with the `writable` property of a `PropertyDescriptor`. It’s
    a set of conditions to define some edge cases and conditions of how the original
    property descriptors work:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们处理`PropertyDescriptor`的`writable`属性。这是一组定义原始属性描述符如何工作的边界情况和条件：
- en: If we set `writable` and any property accessor (`get`, `set`), we fail. `never`
    tells us that an error was thrown.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们设置了`writable`和任何属性访问器（`get`、`set`），我们失败了。`never`告诉我们发生了错误。
- en: If we set `writable` to `false`, the property is read-only. We defer to the
    `InferValue` helper type.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们将`writable`设置为`false`，该属性是只读的。我们推迟到`InferValue`辅助类型。
- en: If we set `writable` to `true`, the property is not read-only. We defer as well.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们将`writable`设置为`true`，该属性就不是只读的。我们同样推迟处理。
- en: 'The last default case is the same as `writable: false`, so `Readonly<InferValue<Prop,
    Desc>>`. (`Readonly<T>` is built-in.)'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '最后的默认情况与`writable: false`相同，因此是`Readonly<InferValue<Prop, Desc>>`。（`Readonly<T>`是内置的。）'
- en: 'This is the `InferValue` helper type, dealing with the set `value` property:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这是处理设置`value`属性的`InferValue`辅助类型：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Again a set of conditions:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 再次一组条件：
- en: Do we have a getter and a value set? `Object.defineProperty` throws an error,
    so `never`.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个 getter 和一个已设置的值吗？`Object.defineProperty`会抛出错误，所以`never`。
- en: If we have set a value, let’s infer the type of this value and create an object
    with our defined property key and the value type.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们设置了一个值，让我们推断出这个值的类型，并创建一个带有我们定义的属性键和值类型的对象。
- en: Or we infer the type from the return type of a getter.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者我们推断一个 getter 的返回类型。
- en: Anything else we forget. TypeScript won’t let us work with the object as it’s
    becoming `never`.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还有其他遗漏的吗？TypeScript 不会让我们像它变成`never`那样处理对象。
- en: 'Lots of helper types, but roughly 20 lines of code to get it right:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多辅助类型，但大约20行代码可以完美解决：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let’s see what TypeScript does with our changes:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 TypeScript 如何处理我们的更改：
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: While this might not cover everything, there is already a lot done for simple
    property definitions.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能不涵盖所有内容，但已经完成了简单属性定义的大部分工作。
- en: 9.4 Expanding Types for Array.prototype.includes
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.4 扩展类型 Array.prototype.includes
- en: Problem
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: TypeScript won’t be able to look for an element of a broad type like `string`
    or `number` within a very narrow tuple or array.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 将无法在非常窄的元组或数组中查找广泛类型（如`string`或`number`）的元素。
- en: Solution
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Create generic helper functions with type predicates, where you change the relationship
    between type parameters.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型谓词创建泛型辅助函数，从而改变类型参数之间的关系。
- en: Discussion
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: We create an array called `actions`, which contains a set of actions in string
    format that we want to execute. The resulting type of this `actions` array is
    `string[]`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`actions`的数组，其中包含我们要执行的一组操作的字符串格式。这个`actions`数组的结果类型是`string[]`。
- en: 'The `execute` function takes any string as an argument. We check if this is
    a valid action, and if so, do something:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`execute` 函数以任何字符串作为参数。我们检查这是否是有效的操作，如果是，则执行某些操作：'
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: It gets a little trickier if we want to narrow the `string[]` to something more
    concrete, a subset of all possible strings. By adding *const context* via `as
    const`, we can narrow `actions` to be of type `readonly ["CREATE", "READ", "UPDATE",
    "DELETE"]`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想将 `string[]` 缩小为更具体的子集，这就变得有些棘手了。通过 `as const` 添加 *const 上下文*，我们可以将 `actions`
    缩小为 `readonly ["CREATE", "READ", "UPDATE", "DELETE"]` 类型。
- en: 'This is handy if we want to do exhaustiveness checking to make sure we have
    cases for all available actions. However, `actions.includes` does not agree with
    us:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要做详尽检查以确保我们为所有可用的操作都有案例，这非常方便。然而，`actions.includes` 却不认同我们：
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Why is that? Let’s look at the typings of `Array<T>` and `ReadonlyArray<T>`
    (we work with the latter due to *const context*):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会这样呢？让我们看一下 `Array<T>` 和 `ReadonlyArray<T>` 的类型定义（由于 *const 上下文*，我们使用后者）：
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The element we want to search for (`searchElement`) needs to be of the same
    type as the array itself! So if we have `Array<string>` (or `string[]` or `Re⁠ad⁠on⁠ly​Ar⁠ra⁠y<s⁠tr⁠in⁠g>`),
    we can search only for strings. In our case, this would mean that `action` needs
    to be of type `"CREATE" | "READ" | "UPDATE" | "DELETE"`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要搜索的元素 (`searchElement`) 需要与数组本身的类型相同！因此，如果我们有 `Array<string>`（或 `string[]`
    或 `Re⁠ad⁠on⁠ly​Ar⁠ra⁠y<s⁠tr⁠in⁠g>`），我们只能搜索字符串。在我们的情况下，这意味着 `action` 需要是 `"CREATE"
    | "READ" | "UPDATE" | "DELETE"` 类型。
- en: Suddenly, our program doesn’t make a lot of sense anymore. Why do we search
    for something if the type already tells us that it can be just one of four strings?
    If we change the type for `action` to `"CREATE" | "READ" | "UPDATE" | "DELETE"`,
    `actions.includes` becomes obsolete. If we don’t change it, TypeScript throws
    an error at us, and rightfully so!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 突然间，我们的程序变得毫无意义。如果类型已经告诉我们它只能是四个字符串之一，为什么还要搜索某些内容呢？如果我们将 `action` 类型更改为 `"CREATE"
    | "READ" | "UPDATE" | "DELETE"`，`actions.includes` 就变得无用了。如果我们不改变它，TypeScript
    将向我们抛出一个错误，这是理所当然的！
- en: One of the problems is that TypeScript lacks the possibility to check for contravariant
    types with, for example, upper-bound generics. We can tell if a type should be
    a *subset* of type `T` with constructs like `extends`; we can’t check if a type
    is a *superset* of `T`. At least not yet!
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 问题之一是，TypeScript 缺乏检查逆变类型的可能性，例如上界泛型。我们可以使用像 `extends` 这样的构造告诉一个类型应该是 `T` 类型的
    *子集*，但我们无法检查一个类型是否是 `T` 类型的 *超集*。至少目前还不能！
- en: So what can we do?
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们可以做些什么呢？
- en: 'Option 1: Redeclare ReadonlyArray'
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选项 1：重新声明 ReadonlyArray
- en: 'One option that comes to mind is changing how `includes` in `ReadonlyArray`
    should behave. Thanks to declaration merging, we can add our own definitions for
    `Re⁠ad⁠on⁠ly​Ar⁠ray` that are a bit looser in the arguments and more specific
    in the result, like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以改变 `ReadonlyArray` 中 `includes` 的行为方式。由于声明合并，我们可以添加对于 `Re⁠ad⁠on⁠ly​Ar⁠ray`
    的自定义定义，这些定义在参数上更宽松，在结果上更具体，就像这样：
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This allows for a broader set of `searchElement` values to be passed (literally
    any!), and if the condition is true, we tell TypeScript through a *type predicate*
    that `se⁠ar⁠ch​Ele⁠men⁠t is⁠ T` (the subset we are looking for).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 允许传递更广泛的 `searchElement` 值集合（字面上的任何值！），如果条件成立，我们通过 *类型预测* 告诉 TypeScript `se⁠ar⁠ch​Ele⁠men⁠t
    is⁠ T`（我们正在寻找的子集）。
- en: 'Turns out, this works pretty well:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，这非常有效：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'There’s a problem, though. The solution works but takes the assumption of what’s
    correct and what needs to be checked. If you change `action` to `number`, TypeScript
    usually throws an error that you can’t search for that kind of type. `actions`
    only consists of `string`, so why even look at `number`? This is an error you
    want to catch:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，这里有一个问题。虽然解决方案可以运行，但它假设了正确的内容和需要检查的内容。如果将 `action` 更改为 `number`，TypeScript
    通常会抛出一个错误，指出不能搜索这种类型。`actions` 只包含 `string`，为什么还要查找 `number`？这是一个你想要捕捉的错误：
- en: '[PRE32]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With our change to `ReadonlyArray`, we lose this check as `searchElement` is
    `any`. While the functionality of `action.includes` still works as intended, we
    might not see the right *problem* once we change function signatures along the
    way.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对 `ReadonlyArray` 的修改，我们失去了这个检查，因为 `searchElement` 是 `any`。虽然 `action.includes`
    的功能仍然按预期工作，但一旦我们在路途中更改函数签名，我们可能就看不到正确的 *问题* 了。
- en: Also, and more important, we change the behavior of built-in types. This might
    change your type-checks somewhere else and might cause problems in the long run!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 而且更重要的是，我们改变了内置类型的行为。这可能会影响到其他地方的类型检查，并可能在长期运行中造成问题！
- en: Tip
  id: totrans-144
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If you do a *type patch* by changing behavior from the standard library, be
    sure to do this module scoped, and not globally.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过改变标准库的行为来进行 *类型补丁*，确保这是在模块范围内进行，而不是全局的。
- en: There is another way.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种方法。
- en: 'Option 2: A helper with type assertions'
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选项 2：带有类型断言的辅助函数
- en: 'As originally stated, one of the problems is that TypeScript lacks the possibility
    to check if a value belongs to a *superset* of a generic parameter. With a helper
    function, we can turn this relationship around:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 正如最初所述， TypeScript 缺乏检查一个值是否属于泛型参数的 *超集* 的可能性之一。通过一个辅助函数，我们可以改变这种关系：
- en: '[PRE33]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `includes` function takes the `ReadonlyArray<T>` as an argument and searches
    for an element that is of type `U`. We check through our generic bounds that `T
    extends U`, which means that `U` is a *superset* of `T` (or `T` is a *subset*
    of `U`). If the method returns `true`, we can say for sure that `el` is of the
    *narrower* type `U`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`includes` 函数以 `ReadonlyArray<T>` 作为参数，并搜索类型为 `U` 的元素。通过我们的泛型边界检查 `T extends
    U`，这意味着 `U` 是 *T* 的超集（或者 *T* 是 *U* 的子集）。如果方法返回 `true`，我们可以肯定 `el` 是更窄类型 `U`。'
- en: The only thing that we need to make the implementation work is to do a little
    type assertion the moment we pass `el` to `Array.prototype.includes`. The original
    problem is still there! The type assertion `el as T` is OK, though, as we check
    possible problems already in the function signature.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一需要让实现起作用的事情是在将 `el` 传递给 `Array.prototype.includes` 时进行一点类型断言。原始问题仍然存在！虽然类型断言
    `el as T` 是可以的，因为我们已经在函数签名中检查可能的问题。
- en: 'This means the moment we change, for example, `action` to `number`, we get
    the right errors throughout our code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着一旦我们将例如 `action` 更改为 `number`，我们就能在整个代码中获得正确的错误：
- en: '[PRE34]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: And this is the behavior we want. A nice touch is that TypeScript wants us to
    change the array, not the element we are looking for. This is due to the relationship
    between the generic type parameters.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们想要的行为。一个很好的点是 TypeScript 希望我们改变数组，而不是我们正在查找的元素。这是由泛型类型参数之间的关系所决定的。
- en: Tip
  id: totrans-155
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The same solutions also work if you run into similar troubles with `Array.prototype.indexOf`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到与 `Array.prototype.indexOf` 类似的问题，同样的解决方案也适用。
- en: 'TypeScript aims to get all standard JavaScript functionality correct, but sometimes
    you have to make trade-offs. This case calls for trade-offs: do you allow for
    an argument list that’s looser than you would expect, or do you throw errors for
    types where you already should know more?'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 的目标是正确处理所有标准 JavaScript 功能，但有时你必须做出权衡。这种情况需要权衡：你是允许比预期更宽松的参数列表，还是对你已经应该了解更多的类型抛出错误？
- en: Type assertions, declaration merging, and other tools help us get around that
    in situations where the type system can’t help us. Not until it becomes better
    than before, by allowing us to move even further in the type space.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 类型断言、声明合并和其他工具帮助我们在类型系统不能帮助我们的情况下解决问题。直到它变得比以前更好，通过允许我们在类型空间中进一步移动。
- en: 9.5 Filtering Nullish Values
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.5 过滤 Nullish 值
- en: Problem
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to use the Boolean constructor to filter nullish values from an array,
    but TypeScript still yields the same types, including `null` and `undefined`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望使用 Boolean 构造函数从数组中过滤掉 nullish 值，但 TypeScript 仍然生成相同的类型，包括 `null` 和 `undefined`。
- en: Solution
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Overload the `filter` method from `Array` using declaration merging.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用声明合并重载 `Array` 的 `filter` 方法。
- en: Discussion
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Sometimes you have collections that could include *nullish* values (`undefined`
    or `null`):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你有可能包含 *nullish* 值（`undefined` 或 `null`）的集合：
- en: '[PRE35]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To continue working, you want to remove those nullish values from your collection.
    This is typically done using the `filter` method of `Array`, maybe by checking
    the *truthiness* of a value. `null` and `undefined` are *falsy*, so they get filtered
    out:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 继续工作时，你希望从集合中删除这些 nullish 值。通常可以使用 `Array` 的 `filter` 方法来完成，也许通过检查值的 *真实性*。`null`
    和 `undefined` 是 *假值*，因此它们被过滤掉：
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'A convenient way of checking the truthiness of a value is by passing it to
    the Boolean constructor. This is short, on point, and very elegant to read:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 检查值的真实性的一种便捷方法是将其传递给 Boolean 构造函数。这是简短、直接和非常优雅的阅读方式：
- en: '[PRE37]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: But sadly, it doesn’t change our type. We still have `null` and `undefined`
    as possible types for the filtered array.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 但遗憾的是，它并没有改变我们的类型。我们仍然有 `null` 和 `undefined` 作为过滤后数组的可能类型。
- en: 'By opening up the `Array` interface and adding another declaration for `filter`,
    we can add this special case as an overload:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通过打开 `Array` 接口并为 `filter` 添加另一个声明，我们可以将这种特殊情况作为一种重载添加进去：
- en: '[PRE38]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And with that, we get rid of nullish types and have more clarity on the type
    of our array’s contents:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们摆脱了nullish类型，并更清楚地了解了数组内容的类型：
- en: '[PRE39]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Neat! What’s the caveat? Literal tuples and arrays. `BooleanConstructor` filters
    not only nullish values but also falsy values. To get the right elements, we not
    only have to return `NonNullable<T>` but also introduce a type that checks for
    truthy values:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 不错！有什么警告？字面元组和数组。`BooleanConstructor`不仅过滤nullish值，还过滤假值。为了获取正确的元素，我们不仅需要返回`NonNullable<T>`，还要引入一种检查真值的类型：
- en: '[PRE40]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note
  id: totrans-178
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The example includes `0n` which is 0 in the `BigInt` type. This type is available
    only from ECMAScript 2020 on.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 示例包括`0n`，这在`BigInt`类型中是0。这种类型仅从ECMAScript 2020开始提供。
- en: This gives us the right idea of which types to expect, but since `ReadonlyArray<T>`
    takes the tuple’s elements types and not the tuple type itself, we lose information
    on the order of types within the tuple.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我们关于预期类型的正确想法，但由于`ReadonlyArray<T>`使用元组的元素类型而不是元组类型本身，我们失去了元组内部类型顺序的信息。
- en: As with all extensions to existing TypeScript types, be aware that this might
    cause side effects. Scope them locally and use them carefully.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有现有TypeScript类型扩展一样，请注意这可能会引起副作用。在本地范围内使用它们，并小心使用它们。
- en: 9.6 Extending Modules
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.6 扩展模块
- en: Problem
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You work with libraries that provide their own view of HTML elements, like Preact
    or React. But sometimes their type definitions don’t include the latest features.
    You want to patch them.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 您使用提供自己视图的库与HTML元素，如Preact或React一起工作。但有时它们的类型定义不包括最新功能。您希望对它们进行修补。
- en: Solution
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use declaration merging on the module and interface level.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块和接口级别使用声明合并。
- en: Discussion
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: '*JSX* is a syntax extension to JavaScript, introducing an XML-like way of describing
    and nesting components. Basically, everything that can be described as a tree
    of elements can be expressed in JSX. JSX was introduced by the creators of the
    popular React framework to make it possible to write and nest components in an
    HTML-like way within JavaScript, where it is actually transpiled to a series of
    function calls:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*JSX*是JavaScript的语法扩展，引入了一种类似XML的方式来描述和嵌套组件。基本上，可以将任何可以描述为元素树的东西表达为JSX。JSX由流行的React框架的创建者引入，使得可以在JavaScript中以HTML样式编写和嵌套组件，实际上它被转译为一系列函数调用：'
- en: '[PRE41]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: JSX has since been adopted by many frameworks, even if there is little or no
    connection to React. There’s a lot more on JSX in [Chapter 10](ch10.html#ch10).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: JSX已经被许多框架采纳，即使与React没有或几乎没有联系。在[第10章](ch10.html#ch10)中有更多关于JSX的内容。
- en: React typings for TypeScript come with lots of interfaces for all possible HTML
    elements. But sometimes your browsers, your frameworks, or your code are a little
    bit ahead of what’s possible.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript中的React类型附带了所有可能的HTML元素的大量接口。但有时您的浏览器、框架或代码可能比可能性更大。
- en: 'Let’s say you want to use the latest image features in Chrome and load your
    images lazily. This is a progressive enhancement, so only browsers that understand
    what’s going on know how to interpret this. Other browsers are robust enough not
    to care:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您希望在Chrome中使用最新的图像功能并懒加载图像。这是渐进增强，因此只有理解正在发生的事情的浏览器才知道如何解释这一点。其他浏览器足够强大，不需要关心：
- en: '[PRE42]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'But your TypeScript JSX code? Errors:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 但是你的TypeScript JSX代码呢？错误：
- en: '[PRE43]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: To prevent this, we can extend the available interfaces with our own properties.
    This TypeScript feature is called *declaration merging*.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种情况，我们可以用我们自己的属性扩展可用的接口。这个TypeScript特性被称为*声明合并*。
- en: 'Create an *@types* folder and put a *jsx.d.ts* file in it. Change your TypeScript
    config so your compiler options allow for extra types:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个*@types*文件夹，并在其中放置一个*jsx.d.ts*文件。更改您的TypeScript配置，以便您的编译器选项允许额外类型：
- en: '[PRE44]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We re-create the exact module and interface structure:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重新创建了确切的模块和接口结构：
- en: The module is called `'react'`.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块称为`'react'`。
- en: The interface is `ImgHTMLAttributes<T> extends HTMLAttributes<T>`.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口是`ImgHTMLAttributes<T>`扩展自HTMLAttributes<T>。
- en: 'We know that from the original typings. Here, we add the properties we want:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从原始类型定义中知道这一点。在这里，我们添加我们想要的属性：
- en: '[PRE45]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'And while we are at it, let’s make sure we don’t forget alt texts:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，让我们确保不要忘记alt文本：
- en: '[PRE46]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: That’s much better! TypeScript will take the original definition and merge your
    declarations. Your autocomplete can give you all available options *and* will
    error when you forget an alt text.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 非常好！TypeScript将采用原始定义并合并您的声明。您的自动完成可以提供所有可用选项，并在忘记alt文本时显示错误。
- en: 'When working with [Preact](https://preactjs.com), things are a bit more complicated.
    The original HTML typings are very generous and not as specific as React’s typings.
    That’s why we have to be a bit more explicit when defining images:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用[Preact](https://preactjs.com)时，情况变得有些复杂。原始的HTML类型定义非常宽泛，不像React的类型定义那样具体。这就是为什么在定义图像时我们必须更加明确的原因：
- en: '[PRE47]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This makes sure that both `alt` and `src` are available and adds a new attribute
    called `loading`. The technique is the same, though: declaration merging, which
    works on the level of namespaces, interfaces, and modules.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了`alt`和`src`都可用，并添加了一个名为`loading`的新属性。尽管技术是相同的：声明合并，它在命名空间、接口和模块级别上都有效。
- en: 9.7 Augmenting Globals
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.7 扩展全局
- en: Problem
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You use a browser feature like `ResizeObserver` and see that it isn’t available
    in your current TypeScript configuration.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像`ResizeObserver`这样的浏览器特性，你会发现它在你当前的TypeScript配置中不可用。
- en: Solution
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Augment the global namespace with custom type definitions.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自定义类型定义扩展全局命名空间。
- en: Discussion
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: TypeScript stores types to all DOM APIs in *lib.dom.d.ts*. This file is autogenerated
    from Web IDL files. *Web IDL* stands for *Web Interface Definition Language* and
    is a format the W3C and WHATWG use to define interfaces to web APIs. It came out
    around 2012 and has been a standard since 2016.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript将所有DOM API的类型存储在*lib.dom.d.ts*中。这个文件是从Web IDL文件自动生成的。*Web IDL*代表*Web接口定义语言*，是W3C和WHATWG用来定义Web
    API接口的格式。它大约在2012年发布，并且自2016年以来一直是一个标准。
- en: 'When you read standards at [W3C](https://www.w3.org)—like on [Resize Observer](https://oreil.ly/XeSUG)—you
    can see parts of a definition or the full definition somewhere within the specification.
    Like this one:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当你阅读[W3C](https://www.w3.org)的标准时，比如在[Resize Observer](https://oreil.ly/XeSUG)上，你可以在规范的某个地方看到定义的部分或完整的定义。就像这样：
- en: '[PRE48]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Browsers use this as a guideline to implement respective APIs. TypeScript uses
    these IDL files to generate *lib.dom.d.ts*. The [TypeScript and JavaScript lib
    generator](https://oreil.ly/WLcLB) project scrapes web standards and extracts
    IDL information. Then an *IDL to TypeScript* generator parses the IDL file and
    generates the correct typings.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器使用这个作为实现相应API的指南。TypeScript使用这些IDL文件来生成*lib.dom.d.ts*。[TypeScript和JavaScript库生成器](https://oreil.ly/WLcLB)项目抓取Web标准并提取IDL信息。然后，IDL到TypeScript生成器解析IDL文件并生成正确的类型定义。
- en: Pages to scrape are maintained manually. The moment a specification is far enough
    and supported by all major browsers, people add a new resource and see their change
    released with an upcoming TypeScript version. So it’s just a matter of time until
    we get `ResizeObserver` in *lib.dom.d.ts*.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 手动维护要抓取的页面。一旦规范足够成熟并且被所有主要浏览器支持，人们会添加一个新资源，并且看到他们的更改将在即将发布的TypeScript版本中发布。所以只是时间问题，直到我们在*lib.dom.d.ts*中得到`ResizeObserver`。
- en: If we can’t wait, we can add the typings ourselves but only for the project
    we currently are working with.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们等不及，我们可以自己为当前正在工作的项目添加类型定义。
- en: 'Let’s assume we generated the types for `ResizeObserver`. We would store the
    output in a file called *resize-observer.d.ts*. Here are the contents:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们生成了`ResizeObserver`的类型。我们将把输出存储在一个名为*resize-observer.d.ts*的文件中。以下是内容：
- en: '[PRE49]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We declare a ton of interfaces and some variables that implement our interfaces,
    like `declare var ResizeObserver`, which is the object that defines the prototype
    and constructor function:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了大量接口和一些实现我们接口的变量，比如`declare var ResizeObserver`，它是定义原型和构造函数的对象：
- en: '[PRE50]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This already helps a lot. We can use the (arguably) long type declarations and
    put them directly in the file where we need them. `ResizeObserver` is found! We
    want to have it available everywhere, though.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经帮了很多忙。我们可以使用（可以说是）冗长的类型声明，并将它们直接放入我们需要它们的文件中。找到了`ResizeObserver`！虽然我们希望在任何地方都能使用它。
- en: Thanks to TypeScript’s declaration-merging feature, we can extend *namespaces*
    and *interfaces* as needed. This time, we’re extending the *global namespace*.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 由于TypeScript的声明合并功能，我们可以根据需要扩展*命名空间*和*接口*。这一次，我们正在扩展*全局命名空间*。
- en: 'The global namespace contains all objects and interfaces that are, well, globally
    available. Like the `window` object (and `Window` interface), as well as everything
    else that should be part of our JavaScript execution context. We augment the global
    namespace and add the `ResizeObserver` object to it:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 全局命名空间包含所有全局可用的对象和接口。就像`window`对象（和`Window`接口）以及应该作为我们JavaScript执行上下文一部分的其他所有内容。我们扩展全局命名空间并将`ResizeObserver`对象添加到其中：
- en: '[PRE51]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Let’s put *resize-observer.d.ts* in a folder called *@types*. Don’t forget
    to add the folder to the sources that TypeScript will parse as well as the list
    of type declaration folders in *tsconfig.json*:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将*resize-observer.d.ts*放在名为*@types*的文件夹中。不要忘记将该文件夹添加到TypeScript将解析的源列表以及*tsconfig.json*中的类型声明文件夹列表中：
- en: '[PRE52]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Since there’s a significant possibility that `ResizeObserver` is not yet available
    in your target browser, make sure that you make the `ResizeObserver` object `undefined`.
    This urges you to check if the object is available:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在目标浏览器中可能尚未提供`ResizeObserver`，请确保将`ResizeObserver`对象设置为`undefined`。这促使您检查对象是否可用：
- en: '[PRE53]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In your application:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的应用程序中：
- en: '[PRE54]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This makes working with `ResizeObserver` as safe as possible!
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得与`ResizeObserver`一起工作尽可能安全！
- en: 'It might be that TypeScript doesn’t pick up your ambient declaration files
    and the global augmentation. If this happens, make sure that:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 可能是TypeScript未捕捉到您的环境声明文件和全局扩展。如果发生这种情况，请确保：
- en: You parse the *@types* folder via the `include` property in *tsconfig.json*.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`tsconfig.json`中的`include`属性解析*@types*文件夹。
- en: Your ambient type declaration files are recognized as such by adding them to
    `types` or `typeRoots` in the *tsconfig.json* compiler options.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将它们添加到*tsconfig.json*编译器选项中的`types`或`typeRoots`，您的环境类型声明文件将被识别为此类文件。
- en: You add `export {}` at the end of your ambient declaration file so TypeScript
    recognizes this file as a module.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在环境声明文件的末尾添加`export {}`，以便TypeScript将此文件识别为模块。
- en: 9.8 Adding Non-JS Modules to the Module Graph
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.8 将非JS模块添加到模块图中
- en: Problem
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You use a bundler like Webpack to load files like *.css* or images from JavaScript,
    but TypeScript does not recognize those files.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用类似Webpack的打包工具从JavaScript中加载*.css*或图像文件，但TypeScript不会识别这些文件。
- en: Solution
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Globally declare modules based on filename extensions.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 基于文件扩展名全局声明模块。
- en: Discussion
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'There is a movement in web development to make JavaScript the default entry
    point of everything and let it handle all relevant assets via `import` statements.
    What you need for this is a build tool, a bundler, that analyzes your code and
    creates the right artifacts. A popular tool for this is [Webpack](https://webpack.js.org),
    a JavaScript bundler that allows you to bundle *everything*—CSS, Markdown, SVGs,
    JPEGs, you name it:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web开发中有一种趋势，即将JavaScript作为一切的默认入口点，并通过`import`语句处理所有相关资产。为此，您需要一个构建工具，即一个捆绑工具，分析您的代码并创建正确的构件。这方面的一个流行工具是[Webpack](https://webpack.js.org)，一个JavaScript捆绑工具，允许您捆绑*所有内容*——CSS、Markdown、SVG、JPEG等等：
- en: '[PRE55]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Webpack uses a concept called *loaders*, which looks at file endings and activates
    certain bundling concepts. Importing *.css* files in JavaScript is not native.
    It’s part of Webpack (or whatever bundler you are using). However, we can teach
    TypeScript to understand files like this.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack使用称为*loaders*的概念，它查看文件结尾并激活某些捆绑概念。在JavaScript中导入*.css*文件不是本地操作，这是Webpack（或您使用的任何捆绑工具）的一部分。但是，我们可以教会TypeScript理解这类文件。
- en: Note
  id: totrans-250
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: There is a proposal in the ECMAScript standards committee to allow imports of
    files other than JavaScript and assert certain built-in formats for this. This
    will have an effect on TypeScript eventually. You can read all about it [here](https://oreil.ly/stAm5).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript标准委员会中有一个提案，允许导入除JavaScript以外的文件，并断言对此类特定内置格式的支持。这将最终影响到TypeScript。您可以在[此处](https://oreil.ly/stAm5)阅读详细信息。
- en: 'TypeScript supports *ambient module declarations*, even for a module that is
    not “physically” there but in the environment or reachable via tooling. One example
    is Node’s main built-in modules, like `url`, `http` or `path`, as described in
    TypeScript’s documentation:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript支持*环境模块声明*，即使是对于在环境中或通过工具可达但“物理上”不存在的模块。一个例子是Node的主要内置模块，如`url`、`http`或`path`，如TypeScript的文档中所述：
- en: '[PRE56]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This is great for modules where we know the exact name. We can also use the
    same technique for wildcard patterns. Let’s declare a generic ambient module for
    all our *.css* files:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于我们知道确切名称的模块非常有用。我们也可以对通配符模式使用相同的技术。让我们为所有*.css*文件声明一个通用环境模块：
- en: '[PRE57]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The pattern is ready. This listens to all *.css* files we want to import. What
    we expect is a list of class names that we can add to our components. Since we
    don’t know which classes are defined in the *.css* files, let’s go with an object
    that accepts every string key and returns a string:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式已经准备好了。这会监听我们想要导入的所有*.css*文件。我们期望的是一组可以添加到我们组件中的类名。由于我们不知道*.css*文件中定义了哪些类，让我们使用一个接受每个字符串键并返回字符串的对象：
- en: '[PRE58]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: That’s all we need to make our files compile again. The only downside is that
    we can’t use the exact class names to get autocompletion and similar benefits.
    A way to solve this is to generate type files automatically. There are packages
    on [NPM](https://oreil.ly/sDBv0) that deal with that problem. Feel free to choose
    one of your liking.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要做的一切来使我们的文件重新编译。唯一的缺点是我们无法使用确切的类名来获得自动完成和类似的好处。解决这个问题的一种方法是自动生成类型文件。有一些在
    [NPM](https://oreil.ly/sDBv0) 上处理这个问题的包。请随意选择您喜欢的包。
- en: It’s a bit easier if we want to import something like MDX into our modules.
    MDX lets us write Markdown, which parses to regular React (or JSX) components
    (more on React in [Chapter 10](ch10.html#ch10)).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要将 MDX 类似的东西导入到我们的模块中，那会稍微容易些。MDX 允许我们编写 Markdown，它会解析为常规的 React（或 JSX）组件（更多关于
    React 的信息请参见 [第 10 章](ch10.html#ch10)）。
- en: 'We expect a functional component (that we can pass props to) that returns a
    JSX element:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望一个函数组件（我们可以传递属性给它），返回一个 JSX 元素：
- en: '[PRE59]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'And voilà! We can load *.mdx* files in JavaScript and use them as components:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Voilà！我们可以在 JavaScript 中加载 *.mdx* 文件并将它们用作组件：
- en: '[PRE60]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'If you don’t know what to expect, make your life easy. All you need to do is
    declare the module. Don’t provide any types. TypeScript will allow loading but
    won’t give you any type safety:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不知道会发生什么，请简化自己的生活。您所需做的只是声明该模块。不提供任何类型。TypeScript 允许加载但不会提供任何类型安全性：
- en: '[PRE61]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'To make ambient modules available to your app, it is recommended to create
    an *@types* folder somewhere in your project (probably root level). There you
    can put any amount of *.d.ts* files with your module definitions. Add a referral
    to your *tsconfig.json*, and TypeScript knows what to do:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 要让环境模块在您的应用程序中可用，建议在项目的某个地方（可能是根目录）创建一个 *@types* 文件夹。您可以在这里放置任意数量的 *.d.ts* 文件，其中包含您的模块定义。向您的
    *tsconfig.json* 添加引用，TypeScript 就知道该如何处理了：
- en: '[PRE62]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: One of TypeScript’s main features is to be adaptable to all JavaScript flavors.
    Some things are built-in, and others need some extra patching from you.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 的主要功能之一是适应所有 JavaScript 的变体。有些是内置的，而其他的则需要您进行额外的补丁。
- en: ^([1](ch09.html#id816-marker)) Back when the API defintiion was created, `unknown`
    didn’t exist. Also, TypeScript has a strong focus on developer productivity, and
    with `res.json()` being a widely used method, this would’ve broken countless applications.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch09.html#id816-marker)) 在创建 API 定义时，`unknown` 不存在。此外，TypeScript 强调开发人员的生产力，`res.json()`
    是一个广泛使用的方法，如果这样做将会破坏无数应用程序。
- en: ^([2](ch09.html#id822-marker)) Credit to Dan Vanderkam’s [*Effective TypeScript*
    blog](https://effectivetypescript.com) for inspiration on this subject.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch09.html#id822-marker)) 感谢丹·范德坎姆的 [*Effective TypeScript* 博客](https://effectivetypescript.com)
    在这个主题上的灵感。
