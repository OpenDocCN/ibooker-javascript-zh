- en: Chapter 9\. Suspense
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。Suspense
- en: This is the least important chapter in this book. At least, that’s what we’ve
    been told by the React team. They didn’t specifically say, “this is the least
    important chapter, don’t write it.” They’ve only issued a series of tweets warning
    educators and evangelists that much of their work in this area will very soon
    be outdated. All of this will change.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书中最不重要的章节。至少，这是React团队告诉我们的。他们并没有明确地说，“这是最不重要的章节，不要写它。”他们只是发布了一系列警告教育者和传道者，说他们在这个领域的大部分工作很快就会过时。所有这些都会改变。
- en: It could be said that the work the React team has done with Fiber, Suspense,
    and concurrent mode represents the future of web development. This work may change
    the way browsers interpret JavaScript. That sounds pretty important. We’re saying
    that this is the least important chapter in this book because the community hype
    for Suspense is high; we need to say it to balance out your expectations. The
    APIs and patterns that make up Suspense are not the single overarching theory
    that defines how all things large and small should operate.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说，React团队在Fiber、Suspense和并发模式方面的工作代表了Web开发的未来。这项工作可能会改变浏览器解释JavaScript的方式。听起来相当重要。我们说这是本书中最不重要的章节，因为Suspense在社区中的热度很高；我们需要这样说来平衡您的期望。构成Suspense的API和模式并非定义所有大大小小事务如何运作的单一支配理论。
- en: Suspense is a just a feature. You may not ever need to use it. It’s being designed
    to solve specific problems that Facebook experiences working at scale. We don’t
    all have the same problems as Facebook, so we may want to think twice before reaching
    for those tools as the solution to all our problems. They may unnecessarily introduce
    complexity where complexity is not needed. Plus, this is all going to change.
    Concurrent mode is an experimental feature, and the React team has issued stern
    warnings about trying to use it in production. In fact, most of these concepts
    involve using hooks. If you don’t see yourself developing custom hooks on a daily
    basis, you’ll probably never need to know about these features. Much of the mechanics
    involving Suspense can be abstracted away in hooks.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Suspense只是一个特性。您可能永远不需要使用它。它被设计来解决Facebook在规模上的具体问题。我们并不都面临与Facebook相同的问题，因此在将其作为解决方案之前，我们可能需要三思。它们可能会在不必要的地方引入复杂性。而且，所有这些都将会改变。并发模式是一个实验性特性，React团队已经发出了严厉的警告，不要试图在生产环境中使用它。事实上，大多数涉及Suspense的概念都涉及使用钩子。如果您不经常开发自定义钩子，您可能永远不需要了解这些特性。Suspense的许多机制可以在钩子中进行抽象化。
- en: In light of these three paragraphs of downplay, the concepts covered in this
    chapter are exciting. If used correctly, they could someday help us create better
    user experiences. If you own or maintain a React library of hooks and/or components,
    you may find these concepts valuable. They’ll help you fine-tune your custom hooks
    to allow for better feedback and prioritization.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于这三段话的贬低，本章涵盖的概念是令人兴奋的。如果正确使用，它们可能有助于我们在未来创建更好的用户体验。如果您拥有或维护一个React钩子和/或组件库，您可能会发现这些概念很有价值。它们将帮助您调优自定义钩子，以实现更好的反馈和优先级设置。
- en: 'In this chapter, we’ll build another small app to demonstrate some of these
    features. We’ll essentially rebuild the app from [Chapter 8](ch08.html#incorporating-data),
    but this time with a little more structure. For example, we’ll be using a `SiteLayout`
    component:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建另一个小应用程序来演示其中一些特性。本质上，我们将重新构建来自[第8章](ch08.html#incorporating-data)的应用程序，但这次会更有结构。例如，我们将使用一个`SiteLayout`组件：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`SiteLayout` will rendered within the `App` component to help us compose our
    UI:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`SiteLayout`将在`App`组件中被渲染，以帮助我们组合我们的UI：'
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This component will be used to give our layout some style, as shown in [Figure 9-1](#fig0901).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件将用于为我们的布局增添一些样式，如[图9-1](#fig0901)所示。
- en: Specifically, it will allow us to clearly see where and when specific components
    are rendered.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 具体而言，它将使我们能够清楚地看到特定组件何时何地被渲染。
- en: '![Sample layout](assets/lrc2_0901.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![示例布局](assets/lrc2_0901.png)'
- en: Figure 9-1\. Sample layout
  id: totrans-12
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9-1。示例布局
- en: Error Boundaries
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误边界
- en: Thus far, we haven’t done the best job with handling errors. An error thrown
    anywhere in our component tree will take down the entire application. Larger component
    trees only further complicate our project and complicate debugging it. Sometimes,
    it can be hard to pinpoint where an error has occurred, especially when they occur
    within components that we didn’t write.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在处理错误方面做得还不够好。在组件树中的任何地方抛出错误都会导致整个应用程序崩溃。较大的组件树进一步复杂化了我们的项目，并增加了调试的复杂性。有时候，很难准确定位错误发生的位置，特别是当它们发生在我们没有编写的组件中时。
- en: Error boundaries are components that can be used to prevent errors from crashing
    the entire app. They also allow us to render sensible error messages in production.
    Because errors can be handled by a single component, they could potentially track
    errors within the application and report them to an issue management system.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 错误边界是可以用来防止错误崩溃整个应用程序的组件。它们还允许我们在生产环境中渲染合理的错误消息。由于错误可以由单个组件处理，因此它们有可能跟踪应用程序中的错误并将其报告给问题管理系统。
- en: 'Currently, the only way to make an error boundary component is to use a class
    component. Like most topics in this chapter, this too will eventually change.
    In the future, creating error boundaries could be possible with a hook or some
    other solution that doesn’t require creating a class. For now, here’s an example
    of an `ErrorBoundary` component:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，创建错误边界组件的唯一方法是使用类组件。就像本章的大多数主题一样，这种情况也将会改变。将来，可能会通过钩子或其他不需要创建类的解决方案来创建错误边界。现在，这里有一个`ErrorBoundary`组件的示例：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is a class component. It stores state differently, and it doesn’t use hooks.
    Instead, it has access to specific methods that are invoked during different times
    throughout the component life cycle. `getDerivedStateFromError` is one of those
    methods. It is invoked when an error occurs anywhere within the `children` during
    the render process. When an error occurs, the value for `state.error` is set.
    Where there’s an error, the `fallback` component is rendered, and that error is
    passed to the component as a property.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个类组件。它以不同的方式存储状态，并且不使用钩子。相反，它可以访问在组件生命周期中不同时间调用的特定方法。`getDerivedStateFromError`就是其中之一。在渲染过程中的任何`children`中发生错误时，将调用此方法。当发生错误时，将设置`state.error`的值。如果有错误，将渲染`fallback`组件，并将该错误作为属性传递给组件。
- en: 'Now we can use this component in our tree to capture errors and render a `fallback`
    component if they occur. For example, we could wrap our entire application with
    an error boundary:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在我们的组件树中使用这个组件来捕获错误，并在发生错误时渲染一个`fallback`组件。例如，我们可以用错误边界包装整个应用程序：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `ErrorScreen` provides a gentle message for our users that an error has
    occurred. It renders some details about the error. It also gives us a place to
    potentially track errors that occur anywhere within our app. If an error does
    occur within the app, this component will be rendered instead of a black screen.
    We can make this component look nice with a little CSS:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`ErrorScreen`为我们的用户提供了一个友好的消息，说明发生了错误。它渲染了关于错误的一些细节。它还为我们提供了一个可能跟踪整个应用程序中任何地方发生的错误的地方。如果应用程序发生错误，将渲染此组件，而不是黑屏。我们可以通过一些CSS使这个组件看起来更漂亮：'
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To test this out we’re going to create a component we can use to intentionally
    cause errors. `BreakThings` always throws an error:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个功能，我们将创建一个可以故意引发错误的组件。`BreakThings`总是会抛出一个错误：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Error boundaries can be composed. Sure, we wrapped the `App` component in an
    `ErrorBoundary`, but we can also wrap individual components within the `App` with
    Error:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 错误边界可以进行组合。当然，我们将`App`组件包装在`ErrorBoundary`中，但我们也可以将`App`中的各个组件单独包装在`Error`中：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Each `ErrorBoundary` will render a `fallback` if an error occurs anywhere within
    their children. In this case, we used the `BreakThings` component in the menu
    and within the `Callout`. This would result in rendering the `ErrorScreen` twice,
    as we can see in [Figure 9-2](#fig0902).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`ErrorBoundary`在其子组件中的任何地方发生错误时都会渲染一个`fallback`。在这种情况下，我们在菜单和`Callout`中使用了`BreakThings`组件。这将导致渲染`ErrorScreen`两次，正如我们在[图 9-2](#fig0902)中所看到的。
- en: We can see that the `ErrorBoundaries` are rendered in place. Notice that the
    two errors that have occurred have been contained to their regions. The boundaries
    are like walls that prevent these errors from attacking the rest of the application.
    Despite intentionally throwing two errors, the contents are still rendered without
    issue.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 `ErrorBoundaries` 被渲染在原位。请注意，已发生的两个错误已被限制在它们的区域内。这些边界就像墙壁一样，阻止这些错误攻击其余的应用程序。尽管故意抛出了两个错误，但内容仍然正常渲染。
- en: '![Error Boundaries](assets/lrc2_0902.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![错误边界](assets/lrc2_0902.png)'
- en: Figure 9-2\. ErrorBoundaries
  id: totrans-30
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-2\. 错误边界
- en: In [Figure 9-3](#fig0903), we can observe what happens when we move the `BreakThings`
    component to only the contents.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 9-3](#fig0903) 中，我们可以观察当我们将 `BreakThings` 组件移动到仅包含内容时发生了什么。
- en: '![error](assets/lrc2_0903.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![error](assets/lrc2_0903.png)'
- en: Figure 9-3\. Error
  id: totrans-33
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-3\. 错误
- en: Now we see the menu and the callout being rendered without issue, but the contents
    has rendered an error to notify the user that an error has occurred.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看到菜单和呼叫被渲染出来，但内容渲染了一个错误以通知用户发生了错误。
- en: 'Inside of the `render` method in the `ErrorBoundary` class component, we can
    make the `fallback` property optional. When it’s not included, we’ll simply use
    our `ErrorScreen` component:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ErrorBoundary` 类组件的 `render` 方法中，我们可以将 `fallback` 属性设为可选。当未包含时，我们将简单地使用我们的
    `ErrorScreen` 组件：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is a good solution for handling errors consistently across an application.
    Now, we just have to wrap specific parts of our component tree with an `ErrorBoundary`
    and let the component handle the rest:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是处理应用程序中错误的一个好方法。现在，我们只需用 `ErrorBoundary` 包装组件树的特定部分，让组件处理其余部分：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Error boundaries are not only a good idea—they’re essential for retaining users
    in production, and they’ll prevent some small bug in a relatively unimportant
    component from bringing down the entire application.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 错误边界不仅是一个好主意 —— 它们在生产环境中是必不可少的，它们会防止一些相对不重要的组件中的小错误导致整个应用崩溃。
- en: Code Splitting
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码拆分
- en: If the applications you’re working on are small now, chances are they won’t
    stay that way. A lot of the applications you work on will eventually contain massive
    codebases with hundreds, maybe even thousands, of components. Most of your users
    could be accessing your applications via their phones on potentially slow networks.
    They can’t wait for the entire codebase of your application to successfully download
    before React completes its first render.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在处理的应用程序很小，那么它们很可能不会保持现状。您处理的大多数应用程序最终会包含大量的代码库，可能甚至包含数百，甚至数千个组件。您的大多数用户可能通过手机访问您的应用程序，可能在潜在的慢网络上。他们不能等待应用程序的整个代码库成功下载，然后
    React 完成第一次渲染。
- en: '*Code splitting* provides us with a way to split our codebase into manageable
    chunks and then load those chunks as they’re needed. To exemplify the power of
    code splitting, we’ll add a user agreement screen to our application:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码拆分* 为我们提供了一种将代码库拆分为可管理的块，然后根据需要加载这些块的方法。为了展示代码拆分的强大功能，我们将在我们的应用程序中添加一个用户协议屏幕：'
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we’ll move the rest of our codebase from a component called `App` to
    a component called `Main`, and we’ll place that component in its own file:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将将我们代码库的其余部分从名为 `App` 的组件移动到名为 `Main` 的组件，并将该组件放在自己的文件中：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'So `Main` is where the current site layout is rendered. Now we’ll modify the
    `App` component to render the `Agreement` until the user agrees to it. When they
    agree, we’ll unmount the `Agreement` component and render the `Main` website component:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`Main` 是当前网站布局被渲染的地方。现在我们将修改 `App` 组件，以便在用户同意之前渲染 `Agreement`，一旦他们同意，我们将卸载
    `Agreement` 组件并渲染 `Main` 网站组件：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Initially, the only component that’s rendered is the `Agreement` component.
    Once the user agrees, the value for `agree` changes to `true`, and the `Main`
    component is rendered. The issue is that all code for the `Main` component and
    all of its children is packaged into a single JavaScript file: the bundle. That
    means that users have to wait for this codebase to download completely before
    the `Agreement` component is initially rendered.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，只有 `Agreement` 组件被渲染出来。一旦用户同意，`agree` 的值就会变为 `true`，然后 `Main` 组件被渲染出来。问题在于，`Main`
    组件及其所有子组件的所有代码都打包到一个 JavaScript 文件中：捆绑包。这意味着用户必须等待这些代码完全下载后，才能最初渲染 `Agreement`
    组件。
- en: 'We can put off loading the main component until it has rendered by declaring
    it using `React.lazy` instead of initially importing it:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `React.lazy` 声明而不是最初导入来推迟加载主组件直到它已经渲染出来：
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We’re telling React to wait to load the codebase for the `Main` component until
    it’s initially rendered. When it is rendered, it will be imported at that time
    using the `import` function.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们告诉React在初始渲染时等待加载`Main`组件的代码库。当它被渲染时，将使用`import`函数在那时导入它。
- en: Importing code during runtime is just like loading anything else from the internet.
    First, the request for the JavaScript code is pending. Then it’s either successful,
    and a JavaScript file is returned, or it fails, causing an error to occur. Just
    like we need to notify a user that we’re in the process of loading data, we’ll
    need to let the user know that we’re in the process of loading code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时导入代码就像从互联网加载任何其他内容一样。首先，JavaScript 代码的请求是挂起状态。然后要么成功，返回一个JavaScript文件，要么失败，导致错误发生。正如我们需要通知用户我们正在加载数据的过程一样，我们需要让用户知道我们正在加载代码的过程。
- en: 'Introducing: The Suspense Component'
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍：`Suspense`组件
- en: Once again, we find ourselves in a situation where we’re managing an asynchronous
    request. This time, we have the `Suspense` component to help us out. The `Suspense`
    component works much like the `ErrorBoundary` component. We wrap it around specific
    components in our tree. Instead of falling back to an error message when an error
    occurs, the `Suspense` component renders a loading message when lazy loading occurs.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 再次发现自己在处理异步请求的情况下。这次，我们有`Suspense`组件来帮助我们。`Suspense`组件的工作方式与`ErrorBoundary`组件类似。我们将它包裹在树中特定的组件周围。当发生错误时，`Suspense`组件不会回退到错误消息，而是在延迟加载发生时渲染加载消息。
- en: 'We can modify the app to lazy load the `Main` component with the following
    code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以修改应用程序，使用以下代码来延迟加载`Main`组件：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now the app initially only loads the codebase for `React`, the `Agreement` component,
    and the `ClimbingBoxLoader`. React will hold off on loading the `Main` component
    until the user agrees to the agreement.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用程序初始时只加载`React`的代码库、`Agreement`组件和`ClimbingBoxLoader`。React 将推迟加载`Main`组件的代码库，直到用户同意协议。
- en: The `Main` component has been wrapped in a `Suspense` component. As soon as
    the user agrees to the agreement, we start loading the codebase for the `Main`
    component. Because the request for this codebase is pending, the `Suspense` component
    will render the `ClimbingBoxLoader` in its place until the codebase has successfully
    loaded. Once that happens, the `Suspense` component will unmount the `ClimbingBoxLoader`
    and render the `Main` component.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main`组件已经被包裹在`Suspense`组件中。一旦用户同意协议，我们就开始加载`Main`组件的代码库。因为对该代码库的请求是挂起状态，`Suspense`组件会在加载成功之前渲染`ClimbingBoxLoader`。加载成功后，`Suspense`组件将卸载`ClimbingBoxLoader`并渲染`Main`组件。'
- en: Note
  id: totrans-59
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'React Spinners is a library of animated loading spinners that indicate that
    something is loading or that the app is working. For the remainder of this chapter,
    we’ll be sampling different loader components from this library. Make sure you
    install this library: `npm i react-spinners`.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: React Spinners 是一个动画加载旋转器库，用于指示加载或应用程序运行中的状态。在本章的其余部分，我们将从这个库中尝试不同的加载器组件。确保你安装了这个库：`npm
    i react-spinners`。
- en: 'What happens when the internet connection goes down before trying to load the
    `Main` component? Well, we’ll have an error on our hands. We can handle that by
    wrapping our `Suspense` component within an `ErrorBoundary`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在尝试加载`Main`组件之前网络连接断开会发生什么？好吧，我们将面临一个错误。我们可以通过在`Suspense`组件周围包裹`ErrorBoundary`来处理这个问题：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The composition of these three components gives us a way to handle most asynchronous
    requests. We have a solution for pending: the `Suspense` component will render
    a loader animation while the request for the source code is pending. We have a
    solution for the failed state: if an error occurs while loading the `Main` component,
    it will be caught and handled by the `ErrorBoundary`. We even have a solution
    for success: if the request is successful, we’ll render the `Main` component.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个组件的组合为我们处理大多数异步请求提供了一种方法。对于挂起状态，`Suspense`组件将在源代码请求挂起时渲染加载动画。对于失败状态，如果在加载`Main`组件时发生错误，它将被`ErrorBoundary`捕获和处理。甚至对于成功状态，如果请求成功，我们将渲染`Main`组件。
- en: Using Suspense with Data
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Suspense 处理数据
- en: 'In the last chapter, we built a `useFetch` hook and a `Fetch` component to
    help us handle the three states involved with making a GitHub request: pending,
    success, and fail. That was our solution. We think it was pretty cool. However,
    in the last section, we handled these three states by elegantly composing the
    `ErrorBoundary` and `Suspense` components. That was for lazy loading JavaScript
    source code, but we can use the same pattern to help us load data.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们构建了一个`useFetch`钩子和一个`Fetch`组件来帮助我们处理在进行GitHub请求时涉及的三种状态：挂起、成功和失败。那是我们的解决方案。我们觉得它相当酷。然而，在最后一节中，我们通过优雅地组合`ErrorBoundary`和`Suspense`组件来处理这三种状态。那是为了延迟加载JavaScript源代码，但我们可以使用相同的模式来帮助我们加载数据。
- en: 'Let’s say we have a `Status` component that’s capable of rendering some sort
    of status message:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个能够渲染某种状态消息的`Status`组件：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This component invokes the `loadStatus` function to retrieve the current status
    message. We can render the `Status` component in our `App` component:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件调用`loadStatus`函数来获取当前的状态消息。我们可以在`App`组件中渲染`Status`组件：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If we were to run this code as-is, we would see our successful status message,
    as shown in [Figure 9-4](#fig0904).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们按原样运行这段代码，我们将看到我们的成功状态消息，如[Figure 9-4](#fig0904)所示。
- en: '![Success: everything works](assets/lrc2_0904.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![成功：一切正常](assets/lrc2_0904.png)'
- en: 'Figure 9-4\. Success: everything works'
  id: totrans-72
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 9-4\. 成功：一切正常
- en: 'When we rendered the `Status` component within the `App` component, we were
    good React developers because we wrapped the `Status` component inside of an error
    boundary. Now if something goes wrong while loading the status, the `ErrorBoundary`
    will fall back to the default error screen. To demonstrate this, let’s cause an
    error inside of the `loadStatus` function:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`App`组件中渲染`Status`组件时，我们是优秀的React开发者，因为我们将`Status`组件包装在错误边界内部。现在如果在加载状态时出现问题，`ErrorBoundary`将退回到默认的错误界面。为了演示这一点，让我们在`loadStatus`函数内部引发一个错误：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now when we run our application, we see the expected output. The `ErrorBoundary`
    caught our error and rendered a message to the user instead ([Figure 9-5](#fig0905)).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们运行我们的应用程序时，我们看到了预期的输出。`ErrorBoundary`捕获了我们的错误，并向用户呈现了一条消息（[Figure 9-5](#fig0905)）。
- en: '![Fail: error boundary triggered](assets/lrc2_0905.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![失败：错误边界触发](assets/lrc2_0905.png)'
- en: 'Figure 9-5\. Fail: error boundary triggered'
  id: totrans-77
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 9-5\. 失败：错误边界触发
- en: 'So far, everything is working as suspected. We’ve composed the `Status` component
    inside of an `ErrorBoundary`, and the combination of these two components is handling
    two of the three promise states: success or rejected. “Rejected” is the official
    promise term for a failed or error state.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都按预期工作。我们将`Status`组件组合在`ErrorBoundary`内部，这两个组件的结合处理了三种Promise状态中的两种：成功或被拒绝。“被拒绝”是一个表示失败或错误状态的官方Promise术语。
- en: 'We have two of the three states covered. What about the third state? Pending?
    That state can be triggered by throwing a promise:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了三种状态中的两种。第三种状态呢？挂起？这种状态可以通过抛出Promise来触发：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If we throw a promise from the `loadStatus` function, we’ll see a special type
    of error in the browser ([Figure 9-6](#fig0906)).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从`loadStatus`函数中抛出一个Promise，我们将在浏览器中看到一种特殊类型的错误（[Figure 9-6](#fig0906)）。
- en: 'This error is telling us that a pending state was triggered, but there is no
    `Suspense` component configured somewhere higher in the tree. Whenever we throw
    a promise from a React app, we need a `Suspense` component to handle rendering
    a fallback:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误告诉我们触发了一个挂起状态，但是树中某个地方没有配置`Suspense`组件。当我们从React应用程序中抛出Promise时，我们需要一个`Suspense`组件来处理渲染一个回退界面：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![Throw promise](assets/lrc2_0906.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![抛出Promise](assets/lrc2_0906.png)'
- en: Figure 9-6\. Throw promise
  id: totrans-85
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 9-6\. 抛出Promise
- en: Now we have the right component composition to handle all three states. The
    `loadStatus` function is still throwing a promise, but there’s now a `Suspense`
    component configured somewhere higher in the tree to handle it. When we throw
    the promise, we’re telling React that we’re waiting on a pending promise. React
    responds by rendering the fallback `GridLoader` component ([Figure 9-7](#fig0907)).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了正确的组件组合来处理所有三种状态。`loadStatus`函数仍然在抛出一个Promise，但是现在树的更高级别配置了一个`Suspense`组件来处理它。当我们抛出Promise时，我们告诉React我们正在等待一个挂起的Promise。React通过渲染回退的`GridLoader`组件来响应（[Figure 9-7](#fig0907)）。
- en: '![Grid Loader](assets/lrc2_0907.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![网格加载器](assets/lrc2_0907.png)'
- en: Figure 9-7\. GridLoader
  id: totrans-88
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 9-7\. 网格加载器
- en: When `loadStatus` successfully returns a result, we’ll render the `Status` component
    as planned. If something goes wrong (if `loadStatus` throws an error), we have
    it covered with an `ErrorBoundary`. When `loadStatus` throws a promise, we trigger
    the pending state, which is handled by the `Suspense` component.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `loadStatus` 成功返回结果时，我们将按计划渲染 `Status` 组件。如果出现问题（如果 `loadStatus` 抛出错误），我们将通过
    `ErrorBoundary` 进行处理。当 `loadStatus` 抛出一个 promise 时，我们会触发挂起状态，由 `Suspense` 组件处理。
- en: This is a pretty cool pattern, but wait…what do you mean, “throw a promise”?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常酷的模式，但等等……你说的“抛出一个 promise”是什么意思？
- en: Throwing Promises
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抛出 Promises
- en: 'In JavaScript, the `throw` keyword is technically for errors. You’ve probably
    used it many times in your own code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，`throw` 关键字在技术上是用于错误的。你可能在自己的代码中多次使用过它：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This line of code causes an error. When this error goes unhandled, it crashes
    the whole app, as demonstrated in [Figure 9-8](#fig0908).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码会导致一个错误。当这个错误未被处理时，它会导致整个应用崩溃，正如 [图 9-8](#fig0908) 中所演示的。
- en: '![Throwing an error](assets/lrc2_0908.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![抛出一个错误](assets/lrc2_0908.png)'
- en: Figure 9-8\. Throwing an error
  id: totrans-96
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-8\. 抛出一个错误
- en: 'The error screen you see rendered in the browser is a development-mode feature
    of Create React App. Whenever you’re in development mode, unhandled errors are
    caught and displayed directly on the screen. If you close this screen by clicking
    on the “X” in the upper right-hand corner, you’ll see what your production users
    see when there’s an error: nothing, a blank, white screen.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中看到的错误屏幕是 Create React App 的开发模式特性。当你处于开发模式时，未处理的错误会被捕获并直接显示在屏幕上。如果你通过点击右上角的“X”关闭此屏幕，你将看到当出现错误时你的生产用户看到的：什么都没有，一个空白的白屏。
- en: Unhandled errors are always visible in the console. All the red text we see
    in the console is information about the error we’ve thrown.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 未处理的错误始终会在控制台可见。我们在控制台看到的所有红色文本都是关于我们抛出的错误的信息。
- en: 'JavaScript is a pretty free-loving language. It lets us get away with a lot
    of stuff that we can’t get away with when using traditional typed languages. For
    example, in JavaScript, we can throw any type:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 是一门非常自由的语言。它允许我们做很多传统类型语言无法做到的事情。例如，在 JavaScript 中，我们可以抛出任何类型：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we’ve thrown a string. The browser will tell us that something has gone
    uncaught, but it’s not an error ([Figure 9-9](#fig0909)).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们抛出了一个字符串。浏览器会告诉我们发生了未捕获的情况，但这不是一个错误（见 [图 9-9](#fig0909)）。
- en: '![Grid Loader](assets/lrc2_0909.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![网格加载器](assets/lrc2_0909.png)'
- en: Figure 9-9\. GridLoader
  id: totrans-103
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-9\. GridLoader
- en: This time, when we threw a string, the Create React App error screen wasn’t
    rendered inside the browser. React knows the difference between an error and a
    string.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，当我们抛出一个字符串时，Create React App 错误屏幕没有在浏览器内渲染。React 知道错误和字符串之间的区别。
- en: 'JavaScript lets us throw any type, which means we can throw a promise:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 允许我们抛出任何类型，这意味着我们可以抛出一个 promise：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now the browser is telling us that something has gone uncaught. It’s not an
    error, it’s a promise, as shown in [Figure 9-10](#fig0910).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在浏览器告诉我们发生了未捕获的情况。这不是一个错误，而是一个 promise，如 [图 9-10](#fig0910) 所示。
- en: '![Throwing a promise](assets/lrc2_0910.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![抛出一个 promise](assets/lrc2_0910.png)'
- en: Figure 9-10\. Throwing a promise
  id: totrans-109
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-10\. 抛出一个 promise
- en: 'To throw a promise within the React component tree, we’ll do so first in a
    `loadStatus` function:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 React 组件树中抛出一个 promise，我们首先要在 `loadStatus` 函数中这样做：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If we use this `loadStatus` function inside a React component, a promise is
    thrown, then somewhere farther up the tree is caught by the `Suspense` component.
    That’s right: JavaScript allows us to throw any type, which also means that we
    can catch any type.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 React 组件内使用这个 `loadStatus` 函数，会抛出一个 promise，然后在树的更高层被 `Suspense` 组件捕获。没错，JavaScript
    允许我们抛出任何类型，这也意味着我们可以捕获任何类型。
- en: 'Consider the following example:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下例子：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We’re sending the `loadStatus` function a `safe` function, which makes `safe`
    a higher-order function. `loadStatus` becomes `fn` within the scope of the `safe`
    function. The `safe` function tries to invoke the `fn` that’s passed as the argument.
    In this case, `safe` tries to invoke `loadStatus`. When it does, `loadStatus`
    throws a promise, an intentional delay of three seconds. That promise is immediately
    caught and becomes `error` within the scope of the catch block. We can check to
    see if the `error` is a promise, and in this case, it is. Now we can wait for
    that promise to resolve and then attempt to call `safe` again with the same `loadStatus`
    function.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `loadStatus` 函数发送给一个 `safe` 函数，这使得 `safe` 成为一个高阶函数。`loadStatus` 在 `safe`
    函数的作用域内成为 `fn`。`safe` 函数尝试调用作为参数传递的 `fn`。在这种情况下，`safe` 尝试调用 `loadStatus`。当它这样做时，`loadStatus`
    抛出一个 promise，即三秒钟的延迟。该 promise 立即被捕获，并在 catch 块的作用域内成为 `error`。我们可以检查 `error`
    是否是一个 promise，在这种情况下它是。现在我们可以等待该 promise 解决，然后尝试再次用相同的 `loadStatus` 函数调用 `safe`。
- en: What do we expect to happen when we invoke the `safe` function recursively with
    a function that creates a promise that causes a three-second delay? We get a delayed
    loop, as shown in [Figure 9-11](#fig0911).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用一个创建导致三秒延迟的 promise 的函数递归调用 `safe` 函数时，我们期望会发生什么？我们得到了一个延迟循环，如 [图 9-11](#fig0911)
    所示。
- en: '![An unfortunate loop](assets/lrc2_0911.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![一个不幸的循环](assets/lrc2_0911.png)'
- en: Figure 9-11\. An unfortunate loop
  id: totrans-118
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-11\. 一个不幸的循环
- en: The `safe` function is invoked, the promise is caught, we wait three seconds
    for the promise to resolve, then we call `safe` again with the same function,
    and the cycle starts all over again. Every three seconds, the string “load status”
    is printed to the console. How many times you watch that happen depends upon how
    patient you are.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`safe` 函数被调用，promise 被捕获，我们等待三秒钟直到 promise 解决，然后再次用相同的函数调用 `safe`，循环重新开始。每三秒钟，字符串“load
    status”被打印到控制台。你能观察到这种情况发生的次数，这取决于你的耐心。'
- en: 'We didn’t make this endless recursive loop to test your patience; we made it
    to demonstrate a point. Watch what happens when we use this new `loadStatus` function
    in conjunction with our `Status` component from earlier:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们制作这个无限递归循环并不是为了测试你的耐心；我们是为了证明一个观点。看看当我们将这个新的 `loadStatus` 函数与之前的 `Status`
    组件一起使用时会发生什么：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Because `loadStatus` is throwing a promise, the `GridLoader` animation renders
    on the screen. When you take a look at the console, the results are once again
    testing your patience ([Figure 9-12](#fig0912)).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `loadStatus` 抛出了一个 promise，所以 `GridLoader` 动画会在屏幕上渲染。当你查看控制台时，结果再次测试你的耐心（[图 9-12](#fig0912)）。
- en: '![Suspense Recursion](assets/lrc2_0912.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![悬念递归](assets/lrc2_0912.png)'
- en: Figure 9-12\. Suspense recursion
  id: totrans-124
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-12\. 悬念递归
- en: We see the same pattern as we did with the `safe` function. The `Suspense` component
    knows that a promise was thrown. It will render the `fallback` component. Then
    the `Suspense` component waits for the thrown promise to be resolved, just like
    the `safe` function did. Once resolved, the `Suspense` component rerenders the
    `Status` component. When `Status` renders again, it calls `loadStatus` and the
    whole process repeats itself. We see “load status” printed to the console, every
    three seconds, endlessly, forever.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到与 `safe` 函数相同的模式。`Suspense` 组件知道 promise 被抛出了。它将渲染 `fallback` 组件。然后 `Suspense`
    组件等待抛出的 promise 被解决，就像 `safe` 函数所做的那样。一旦解决，`Suspense` 组件重新渲染 `Status` 组件。当 `Status`
    再次渲染时，它调用 `loadStatus`，整个过程重复。我们看到“load status”每三秒钟无休止地被打印到控制台。
- en: An endless loop is typically not the desired output. It isn’t for React, either.
    It’s important to know that, when we throw a promise, it’s caught by the `Suspense`
    component, and we enter into a `pending` state until the promise has been resolved.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通常不期望出现无限循环。对于 React 也是如此。重要的是要知道，当我们抛出一个 promise 时，它会被 `Suspense` 组件捕获，并且我们进入
    `pending` 状态，直到 promise 被解决。
- en: Building Suspenseful Data Sources
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建悬念数据源
- en: 'A Suspenseful data source needs to provide a function that handles all the
    states associated with loading data: pending, success, and error. The `loadStatus`
    function can only return or throw one type at a time. We need the `loadStatus`
    function to throw a promise when the data is loading, return a `response` when
    the data is successful, or throw an error if something goes wrong:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 悬念数据源需要提供一个处理与加载数据相关的所有状态的函数：pending（进行中）、success（成功）和 error（错误）。`loadStatus`
    函数每次只能返回或抛出一种类型。当数据正在加载时，我们需要 `loadStatus` 函数抛出一个 promise，当数据成功时返回一个 `response`，或者在出现问题时抛出错误：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We’ll need a place to declare `error`, `response`, and `promise`. We also need
    to make sure that these variables are scoped appropriately and do not collide
    with other requests. The solution is to define `loadStatus` using a closure:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个地方声明 `error`、`response` 和 `promise`。我们还需要确保这些变量的作用域适当，并且不会与其他请求发生冲突。解决方案是使用闭包定义
    `loadStatus`：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This is a closure. The scope of the `error`, `promise`, and `response` are
    closed off from any code outside of the function where they’re defined. When we
    declare `loadStatus`, an anonymous function is declared and immediately invoked:
    `fn()` is the same as `(fn)()`. The value of `loadStatus` becomes the inner function
    that’s returned. The `loadStatus` function now has access to `error`, `promise`,
    and `response`, but the rest of our JavaScript world does not.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个闭包。`error`、`promise` 和 `response` 的作用域从定义它们的函数外部封闭。当我们声明 `loadStatus` 时，一个匿名函数被声明并立即调用：`fn()`
    等同于 `(fn)()`。`loadStatus` 的值成为返回的内部函数。现在，`loadStatus` 函数可以访问 `error`、`promise`
    和 `response`，但是我们 JavaScript 世界的其余部分无法访问它们。
- en: 'Now all we need to do is handle the values for `error`, `response`, and `promise`.
    The `promise` will be pending for three seconds before it’s successfully resolved.
    When the `promise` resolves, the value for `response` will be set to “success.”
    We’ll catch any errors or promise rejections and use them to set the `error` value:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要处理 `error`、`response` 和 `promise` 的值。承诺将在三秒钟内挂起，然后成功解决。承诺解决时，`response`
    的值将设置为“success”。我们将捕获任何错误或承诺拒绝，并使用它们来设置 `error` 值：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We created a promise that’s pending for three seconds. If the `loadStatus`
    function is invoked at any point during that time, the promise itself will be
    thrown. After the three seconds, the promise is successfully resolved and `response`
    is assigned a value. If you invoke `loadStatus` now, it will return the response:
    “success.” If something went wrong, then the `loadStatus` function would return
    the `error`.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个三秒钟等待的承诺。如果在此期间的任何时候调用 `loadStatus` 函数，承诺本身将被抛出。三秒后，承诺成功解决，`response`
    被分配一个值。如果现在调用 `loadStatus`，它将返回响应：“success”。如果出现问题，`loadStatus` 函数将返回 `error`。
- en: The `loadStatus` function is our Suspenseful data source. It is capable of communicating
    its state with the Suspense architecture. The inner workings of `loadStatus` are
    hardcoded. It always resolves the same three-second delay promise. However, the
    mechanics of handling `error`, `response`, and `promise` are repeatable. We can
    wrap any promise with this technique to produce suspenseful data sources.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadStatus` 函数是我们悬念数据源。它能够与悬念架构通信。`loadStatus` 的内部工作是硬编码的。它始终解析相同的三秒延迟承诺。然而，处理
    `error`、`response` 和 `promise` 的机制是可重复的。我们可以用这种技术包装任何承诺来生成悬念数据源。'
- en: 'All we need to create a Suspenseful data source is a promise, so we can create
    a function that takes a promise as an argument and returns a Suspenseful data
    source. In this example, we call that function `createResource`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 创建悬念数据源所需的全部是一个承诺，因此我们可以创建一个函数，将一个承诺作为参数，并返回一个悬念数据源。在这个例子中，我们称之为 `createResource`
    函数：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This code assumes that `createResource(promise)` will successfully create a
    `resource` object. This object has a `read` function, and we can invoke `read`
    as many times as we like. When the promise is resolved, `read` will return the
    resulting data. When the promise is pending, `read` will throw the `promise`.
    And if anything goes wrong, `read` will throw an error. This data source is ready
    to work with Suspense.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码假设 `createResource(promise)` 将成功创建一个 `resource` 对象。该对象有一个 `read` 函数，我们可以随意调用
    `read` 函数。当承诺解决时，`read` 将返回结果数据。当承诺挂起时，`read` 将抛出 `promise`。如果出现任何问题，`read` 将抛出错误。这个数据源准备好与悬念一起工作。
- en: 'The `createResource` function looks a lot like our anonymous function from
    before:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`createResource` 函数看起来很像我们之前的匿名函数：'
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This function still closes off the values for `error` and `response`, but it
    allows consumers to pass in a promise as an argument called `pending`. When the
    pending promise is resolved, we capture the results with a `.then` function. If
    the promise is rejected, we’ll catch the error and use it to assign a value to
    the `error` variable.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数仍然封闭了 `error` 和 `response` 的值，但允许消费者传入一个名为 `pending` 的承诺作为参数。当挂起的承诺解决时，我们使用
    `.then` 函数捕获结果。如果承诺被拒绝，我们将捕获错误并用它来为 `error` 变量分配一个值。
- en: The `createResource` function returns a resource object. This object contains
    a function called `read`. If the promise is still pending, then `error` and `response`
    will be undefined. So `read` throws the promise. Invoking `read` when there’s
    a value for `error` will cause that `error` to be thrown. Finally, invoking `read`
    when there’s a response will yield whatever data was resolved by the promise.
    It doesn’t matter how many times we call `read`—it will always accurately report
    on the state of our promise.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`createResource` 函数返回一个资源对象。该对象包含一个名为 `read` 的函数。如果 promise 仍在等待中，则 `error`
    和 `response` 将为未定义状态。因此 `read` 会抛出 promise。在 `error` 有值时调用 `read` 会导致该 `error`
    被抛出。最后，在有响应时调用 `read` 将会返回 promise 解析的任何数据。无论我们调用 `read` 多少次，它都能准确报告我们 promise
    的状态。'
- en: 'In order to test it out in a component, we’ll need a promise, ideally one that
    sounds like the name of an ’80s ski movie:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在组件中进行测试，我们需要一个 promise，最好是听起来像80年代滑雪电影名称的一个 promise：
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `threeSecondsToGnar` promise waits three seconds before resolving to an
    object that has a field and value for `gnar`. Let’s use this promise to create
    a Suspenseful data resource and use that data resource in a small React application:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`threeSecondsToGnar` promise 在解析前会等待三秒钟，然后返回一个具有 `gnar` 字段和值的对象。让我们使用这个 promise
    创建一个 Suspenseful 数据资源，并在一个小的 React 应用程序中使用该数据资源：'
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: React components can render a lot. The `Gnar` component will be rendered several
    times before it actually returns a response. Each time `Gnar` is rendered, `resource.read()`
    is invoked. The first time `Gnar` is rendered, a promise is thrown. That promise
    is handled by the `Suspense` component and a `fallback` component will be rendered.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: React 组件可以渲染很多内容。在 `Gnar` 组件实际返回响应之前，会多次进行渲染。每次渲染 `Gnar` 时，都会调用 `resource.read()`。第一次渲染
    `Gnar` 时，会抛出一个 promise。该 promise 由 `Suspense` 组件处理，会渲染一个 `fallback` 组件。
- en: When the promise has resolved, the `Suspense` component will attempt to render
    `Gnar` again. `Gnar` will invoke `resource.read()` again, but this time, assuming
    everything went OK, `resource.read()` will successfully return `Gnar`, which is
    used to render the state of `Gnar` in an `h1` element. If something went wrong,
    `resource.read()` would have thrown an error, which would be handed by the `ErrorBoundary`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当 promise 解析后，`Suspense` 组件将尝试再次渲染 `Gnar`。`Gnar` 将再次调用 `resource.read()`，但这次假设一切顺利，`resource.read()`
    将成功返回 `Gnar`，用于在 `h1` 元素中呈现 `Gnar` 的状态。如果出现问题，`resource.read()` 将会抛出一个错误，该错误将由
    `ErrorBoundary` 处理。
- en: As you can imagine, the `createResource` function can become quite robust. Our
    resource can attempt to handle errors. Maybe when there’s a network error, the
    resource can wait a few seconds and automatically attempt to load the data again.
    Our resource could communicate with other resources. Maybe we can log the performance
    statistics behind all of our resources. The sky’s the limit. As long as we have
    a function that we can use to read the current state of that resource, we can
    do whatever we like with the resource itself.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可以想象的那样，`createResource` 函数可以变得非常强大。我们的资源可以尝试处理错误。也许在网络错误时，资源可以等待几秒钟，然后自动尝试重新加载数据。我们的资源可以与其他资源进行通信。也许我们可以记录所有资源背后的性能统计数据。天空是极限。只要我们有一个函数可以用来读取资源当前状态，我们可以随心所欲地处理资源本身。
- en: 'At present, this is how Suspense works. This is how we can use the `Suspense`
    component with any type of asynchronous resource. This could all change, and we
    expect it to change. However, whatever the finalized API for Suspense ends up
    being, it will be sure to handle three states: pending, success, and fail.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这就是 Suspense 的工作方式。这是我们可以使用 `Suspense` 组件处理任何类型的异步资源的方法。这一切可能会发生变化，而且我们期望它会改变。然而，无论最终的
    Suspense API 是什么样子，它肯定会处理三种状态：pending（等待）、success（成功）和fail（失败）。
- en: The look at these Suspense APIs has been kind of high-level, and this was intentional
    because this stuff is experimental. It’s going to change. What’s important to
    take away from this chapter is that React is always tinkering with ways to make
    React apps faster.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对这些 Suspense API 的讨论比较高级，这是有意为之的，因为这些东西还在试验阶段。它会变化。从本章中要记住的重点是，React 总是在尝试各种方法来使
    React 应用更快。
- en: Behind the scenes of a lot of this work is the way that React itself works—specifically,
    its reconciliation algorithm called Fiber.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 本身工作的背后，有很多这样的工作——特别是其称为 Fiber 的调和算法。
- en: Fiber
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Fiber
- en: Throughout this book, we’ve talked about React components as being functions
    that return data as a UI. Every time this data changes (props, state, remote data,
    etc), we rely on React to rerender the component. If we click a star to rate a
    color, we assume that our UI will change, and we assume that it’ll happen fast.
    We assume this because we trust React to make it happen. How exactly does this
    work though? To understand how React efficiently updates the DOM, let’s take a
    closer look at how React works.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们把 React 组件称为返回 UI 数据的函数。每当这些数据改变（props、state、远程数据等），我们依赖 React 重新渲染组件。如果我们点击星星来评价一个颜色，我们假设我们的
    UI 会改变，而且会发生得很快。我们之所以这样假设，是因为我们信任 React 能够实现这一点。不过，这究竟是如何工作的呢？为了了解 React 如何高效地更新
    DOM，让我们仔细看看 React 的工作原理。
- en: Consider that you’re writing an article for your company blog. You want feedback,
    so you send the article to your coworker before you publish. They recommend a
    few quick changes, and now you need to incorporate those changes. You create a
    brand-new document, type out the entire article from scratch, and then add in
    the edits.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你正在为公司的博客写一篇文章。你希望得到反馈，所以你在发布之前将文章发送给同事。他们建议做一些快速的更改，现在你需要将这些更改整合进来。你创建了一个全新的文档，从头开始键入整篇文章，然后加入这些编辑内容。
- en: You’re probably groaning at this unnecessary extra effort, but this is how a
    lot of libraries previously worked. To make an update, we’d get rid of everything,
    then start from scratch and rebuild the DOM during the update.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会因为这种不必要的额外工作而叹气，但这是许多库以前的工作方式。为了进行更新，我们会摆脱一切，然后从头开始重建 DOM。
- en: Now, you’re writing another blog post and you send it to your coworker again.
    This time, you’ve modernized your article-writing process to use GitHub. Your
    coworker checks out a GitHub branch, makes the changes, and merges in the branch
    when they’re finished. Faster and more efficient.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你又在写一篇博客文章，并再次把它发送给你的同事。这一次，你现代化了你的文章撰写过程，采用了 GitHub。你的同事检出了一个 GitHub 分支，进行了更改，并在完成后合并了该分支。更快更高效。
- en: 'This process is similar to how React works. When a change occurs, React makes
    a copy of the component tree as a JavaScript object. It looks for the parts of
    the tree that need to change and changes only those parts. Once complete, the
    copy of the tree (known as the work-in-progress tree) replaces the existing tree.
    It’s important to reiterate that it uses the parts of the tree that are already
    there. For example, if we had to update an item in the list from `red` to `green`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程类似于 React 的工作原理。当发生变化时，React 会将组件树复制为 JavaScript 对象。它寻找需要更改的树的部分，并仅更改这些部分。完成后，复制的树（称为工作中的树）取代现有的树。重申一下，它使用的是树中已经存在的部分。例如，如果我们需要将列表中的项目从
    `red` 更新为 `green`：
- en: '[PRE33]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: React would not get rid of the third `li`. Instead it would replace its children
    (`red` text) with `green` text. This is an efficient approach to updating and
    is the way that React has updated the DOM since its inception. There is a potential
    problem here, though. Updating the DOM is an expensive task because it’s synchronous.
    We have to wait for all of the updates to be reconciled and then rendered before
    we can do other tasks on the main thread. In other words, we’d have to wait for
    React to recursively move through all of the updates, which could make the user
    experience seem unresponsive.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: React 不会摆脱第三个 `li`，而是将其子节点（`red` 文本）替换为 `green` 文本。这是一种高效的更新方式，也是 React 自从诞生以来更新
    DOM 的方式。然而，这里存在一个潜在的问题。更新 DOM 是一项昂贵的任务，因为它是同步的。我们必须等待所有更新完成并渲染后，才能在主线程上执行其他任务。换句话说，我们必须等待
    React 递归地遍历所有更新，这可能会导致用户体验显得不够响应。
- en: The React team’s solution to this was a full rewrite of React’s reconciliation
    algorithm, called Fiber. Fiber, released in version 16.0, rewrote the way that
    DOM updates worked by taking a more asynchronous approach. The first change with
    16.0 was the separation of the renderer and the reconciler. A renderer is the
    part of the library that handles rendering, and the reconciler is the part of
    the library that manages updates when they occur.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: React 团队的解决方案是对 React 协调算法的全面重写，称为 Fiber。Fiber 在 16.0 版本中发布，通过采用更加异步的方式改写了 DOM
    更新的工作方式。16.0 的第一个变化是将渲染器和协调器分离开来。渲染器是处理渲染的库的一部分，而协调器则是管理更新的一部分。
- en: Separating the renderer from the reconciler was a big deal. The reconciliation
    algorithm was kept in React Core (the package you install to use React), and each
    rendering target was made responsible for rendering. In other words, ReactDOM,
    React Native, React 360, and more would be responsible for the logic of rendering
    and could be plugged into React’s core reconciliation algorithm.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 将渲染器与协调器分离是一件大事。协调算法保留在 React 核心中（安装以使用 React 的软件包），每个渲染目标负责自己的渲染。换句话说，ReactDOM、React
    Native、React 360 等都将负责渲染逻辑，并可以插入到 React 核心的协调算法中。
- en: Another huge shift with React Fiber was its changes to the reconciliation algorithm.
    Remember our expensive DOM updates that blocked the main thread? This lengthy
    block of updates is called *work*—with Fiber, React split the work into smaller
    units of work called *fibers*. A fiber is a JavaScript object that keeps track
    of what it’s reconciling and where it is in the updating cycle.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: React Fiber 的另一个重大变化是其对协调算法的改变。还记得我们那些阻塞主线程的昂贵 DOM 更新吗？这些长时间的更新称为*work* —— 使用
    Fiber 后，React 将工作分解为称为*fibers*的更小工作单元。一个 fiber 是一个 JavaScript 对象，用于跟踪其正在协调的内容及其更新周期中的位置。
- en: Once a fiber (unit of work) is complete, React checks in with the main thread
    to make sure there’s not anything important to do. If there is important work
    to do, React will give control to the main thread. When it’s done with that important
    work, React will continue its update. If there’s nothing critical to jump to on
    the main thread, React moves on to the next unit of work and renders those changes
    to the DOM.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦一个 fiber（工作单元）完成，React 就会与主线程通信，以确保没有重要的事情要处理。如果有重要的工作要处理，React 将控制权交给主线程。完成重要工作后，React
    将继续其更新。如果主线程没有需要跳转的重要工作，React 将继续处理下一个工作单元，并将这些更改渲染到 DOM 中。
- en: To use the GitHub example from earlier, each fiber represents a commit on a
    branch, and when we check the branch back into the main branch, that represents
    the updated DOM tree. By breaking up the work of an update into chunks, Fiber
    allows priority tasks to jump the line for immediate handling by the main thread.
    The result is a user experience that feels more responsive.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以先前的 GitHub 示例为例，每个 fiber 代表分支上的一个提交，当我们将分支检入主分支时，这表示更新的 DOM 树。通过将更新工作分解为块，Fiber
    允许优先任务立即由主线程处理。其结果是用户体验更为响应。
- en: If this was all Fiber did, it would be a success, but there’s even more to it
    than that! In addition to the performance benefits of breaking work into smaller
    units, the rewrite also sets up exciting possibilities for the future. Fiber provides
    the infrastructure for prioritizing updates. In the longer term, the developer
    may even be able to tweak the defaults and decide which types of tasks should
    be given the highest priority. The process of prioritizing units of work is called
    *scheduling*; this concept underlies the experimental concurrent mode, which will
    eventually allow these units of work to be performed in parallel.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只有这些，Fiber 已经是一项成功的工作了，但事实并非如此！除了将工作分解为更小单元的性能优势外，重写还为未来设定了令人兴奋的可能性。Fiber
    提供了优先处理更新的基础设施。从长远来看，开发者甚至可以调整默认设置，并决定哪些类型的任务应该优先处理。对工作单元进行优先处理的过程称为*scheduling*；这一概念为实验性的并发模式打下了基础，最终将允许这些工作单元并行执行。
- en: An understanding of Fiber is not vital to working with React in production,
    but the rewrite of its reconciliation algorithm provides interesting insight into
    how React works and how its contributors are thinking about the future.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在生产环境中使用 React，了解 Fiber 并非至关重要，但重写其协调算法提供了有趣的洞察力，深入了解 React 的工作原理以及其贡献者对未来的思考。
