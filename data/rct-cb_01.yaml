- en: Chapter 1\. Creating Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章\. 创建应用程序
- en: React is a surprisingly adaptable development framework. Developers use it to
    create large JavaScript-heavy Single-Page Applications (SPAs) or to build surprisingly
    small plug-ins. You can use it to embed code inside a Rails application or generate
    a content-rich website.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: React 是一个非常灵活的开发框架。开发者使用它来创建大型 JavaScript 重度单页应用（SPA），或者创建非常小的插件。你可以在 Rails
    应用中嵌入代码，也可以生成内容丰富的网站。
- en: In this chapter, we look at the various ways of creating a React application.
    We also look at some of the more valuable tools you might want to add to your
    development cycle. Few people now create their JavaScript projects from scratch.
    Doing so is a tedious process, involving an uncomfortable amount of tinkering
    and configuration. The good news is that you can use a tool to generate the code
    you need in almost every case.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨创建 React 应用程序的各种方式。我们还将介绍一些可能想要添加到开发周期中的更有价值的工具。现在很少有人从头开始创建他们的 JavaScript
    项目。这样做是一个繁琐的过程，涉及大量琢磨和配置。好消息是，你可以使用一个工具来几乎在每种情况下生成你需要的代码。
- en: 'Let’s take a whistle-stop tour of the many ways of starting your React journey,
    beginning with the one most frequently used: `create-react-app`.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速浏览一下开始 React 之旅的多种方式，从最常用的一种开始：`create-react-app`。
- en: Generate a Simple Application
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成一个简单的应用程序
- en: Problem
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: React projects are challenging to create and configure from scratch. Not only
    are there numerous design choices to make—which libraries to include, which tools
    to use, which language features to enable—but manually created applications will,
    by their nature, differ from one another. Project idiosyncrasies increase the
    time it takes a new developer to become productive.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 从头开始创建和配置 React 项目是具有挑战性的。不仅需要做出众多设计选择（包括要包含哪些库、使用哪些工具、启用哪些语言功能），而且手动创建的应用程序由于其特性而彼此不同。项目的特殊性增加了新开发者达到生产力所需时间。
- en: Solution
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: '`create-react-app` is a tool for building SPAs with a standard structure and
    a good set of default options. Generated projects use the React Scripts library
    to build, test, and run the code. Projects have a standard Webpack configuration
    and a standard set of language features enabled.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`create-react-app` 是一个用于构建符合标准结构且具有良好默认选项的 SPA 的工具。生成的项目使用 React Scripts 库来构建、测试和运行代码。项目有一个标准的
    Webpack 配置和一组启用的标准语言功能。'
- en: 'Any developer who has worked on one `create-react-app` application instantly
    feels at home with any other. They understand the project structure and know which
    language features they can use. It is simple to use and contains all the features
    that a typical application requires: from Babel configuration and file loaders
    to testing libraries and a development server.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 任何曾在一个 `create-react-app` 应用程序上工作过的开发者都能立刻适应其他任何一个。他们理解项目结构并知道可以使用哪些语言功能。这是一个简单易用的工具，包含了典型应用程序所需的所有功能：从
    Babel 配置和文件加载器到测试库和开发服务器。
- en: If you’re new to React, or need to create a generic SPA with the minimum of
    fuss, then you should consider creating your app with `create-react-app`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是 React 的新手，或者需要用最少的麻烦创建一个通用的 SPA，那么你应该考虑使用 `create-react-app` 来创建你的应用程序。
- en: 'You can choose to install the `create-react-app` command globally on your machine,
    but this is now discouraged. Instead, you should create a new project by calling
    `create-react-app` via `npx`. Using `npx` ensures you’re building your application
    with the latest version of `create-react-app`:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择在计算机上全局安装 `create-react-app` 命令，但这现在已经不被推荐。相反，你应该通过 `npx` 调用 `create-react-app`
    来创建新项目。使用 `npx` 确保你使用的是 `create-react-app` 的最新版本：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This command creates a new project directory called *my-app*. By default, the
    application uses JavaScript. If you want to use TypeScript as your development
    language, `create-react-app` provides that as an option:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令创建一个名为 *my-app* 的新项目目录。默认情况下，该应用程序使用 JavaScript。如果你想要使用 TypeScript 作为开发语言，`create-react-app`
    也提供了这个选项：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Facebook developed `create-react-app`, so it should come as no surprise that
    if you have the `yarn` package manager installed, then your new project will use
    `yarn` by default. To use `npm`, you can either specify the `--use-npm` flag or
    change into the directory and remove the *yarn.lock* file and then rerun the install
    with `npm`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`create-react-app` 是由 Facebook 开发的，因此如果你已安装 `yarn` 包管理器，那么你的新项目将默认使用 `yarn`
    并不足为奇。要使用 `npm`，你可以指定 `--use-npm` 标志，或者进入目录并删除 *yarn.lock* 文件，然后使用 `npm` 重新运行安装。'
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To start your application, run the `start` script:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动你的应用程序，请运行 `start` 脚本：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This command launches a server on port 3000 and opens a browser at the home
    page, as shown in [Figure 1-1](ch01_split_000.xhtml#ch01_image_1).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令在端口3000上启动服务器，并在主页打开浏览器，如[图1-1](ch01_split_000.xhtml#ch01_image_1)所示。
- en: Figure 1-1\. The generated front page
  id: totrans-20
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-1\. 生成的首页
- en: 'The server delivers your application as a single, large bundle of JavaScript.
    The code mounts all of its components inside this `<div/>` in *public/index.html*:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将你的应用程序作为一个单独的大 JavaScript 包交付。代码将其所有组件挂载在*public/index.html*中的这个`<div/>`内：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The code to generate the components begins in the *src/index.js* file (*src/index.tsx*
    if you’re using TypeScript):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 生成组件的代码始于*src/index.js*文件（如果你使用 TypeScript，则为*src/index.tsx*）：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This file does little more than render a single component called `<App/>`,
    which it imports from *App.js* (or *App.tsx*) in the same directory:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件几乎只是渲染一个名为`<App/>`的单个组件，它从同一目录中的*App.js*（或*App.tsx*）导入：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you edit this file while the application is `start`-ed, the page in the browser
    automatically updates.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在`start`状态下编辑此文件，浏览器中的页面将自动更新。
- en: 'When you’re ready to ship the code to production, you need to generate a set
    of static files that you can deploy on a standard web server. To do this, run
    the `build` script:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备将代码部署到生产环境时，你需要生成一组静态文件，这些文件可以部署到标准的 Web 服务器上。要做到这一点，请运行`build`脚本：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `build` script creates a *build* directory and then publishes a set of static
    files (see [Figure 1-2](ch01_split_000.xhtml#ch01_image_2)).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`build`脚本创建一个*build*目录，然后发布一组静态文件（参见[图1-2](ch01_split_000.xhtml#ch01_image_2)）。'
- en: '![](Images/recb_0102.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_0102.png)'
- en: Figure 1-2\. The generated contents in the build directory
  id: totrans-32
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-2\. 构建目录中生成的内容
- en: The build copies many of these files from the *public/* directory. The code
    for the app is transpiled into browser-compatible JavaScript and stored in one
    or more files in the *static/js* directory. Stylesheets used by the application
    are stitched together and stored in *static/css*. Several of the files have hashed
    IDs added to them so that when you deploy your application, browsers download
    the latest code rather than some old cached version.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 构建从*public/*目录复制了许多这些文件。应用程序的代码被转译为浏览器兼容的 JavaScript，并存储在*static/js*目录中的一个或多个文件中。应用程序使用的样式表被拼接在一起，并存储在*static/css*中。其中的几个文件添加了哈希
    ID，以便在部署应用程序时，浏览器下载最新代码，而不是某个旧版本的缓存。
- en: Discussion
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: '`create-react-app` is not just a tool for generating a new application but
    also a platform to keep your React application up-to-date with the latest tools
    and libraries. You can upgrade the `react-scripts` library as you would any other:
    by changing the version number and rerunning `npm install`. You don’t need to
    manage a list of Babel plugins or postcss libraries, or maintain a complex *webpack.config.js*
    file. The `react-scripts` library manages them all for you.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`create-react-app`不仅是一个生成新应用程序的工具，还是一个平台，可用于保持你的 React 应用程序与最新工具和库保持更新。你可以像更新其他库一样更新`react-scripts`库：通过更改版本号并重新运行`npm
    install`。你无需管理一长串的 Babel 插件或 postcss 库，也无需维护复杂的*webpack.config.js*文件。`react-scripts`库为你管理它们。'
- en: The configuration is all still there, of course, but buried deep within the
    *react-scripts* directory. In there, you will find the *webpack.config.js* file,
    containing all the Babel configuration and file loaders that your application
    will use. Because it’s a library, you can update React Scripts just as you would
    any other dependency.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，配置仍然在那里，但是埋藏在*react-scripts*目录的深处。在那里，你会找到*webpack.config.js*文件，其中包含你的应用程序将使用的所有
    Babel 配置和文件加载器。因为它是一个库，你可以像更新任何其他依赖项一样更新 React Scripts。
- en: 'If, however, you later decide to manage all of this yourself, you’re free to
    do so. If you eject the application, then everything comes back under your control:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你后来决定自行管理所有内容，完全可以这样做。如果你将应用程序弹出，那么所有内容将重新回到你的控制下：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: However, this is a one-time-only change. Once you have ejected your application,
    there is no going back. You should think carefully before ever ejecting an application.
    You may find that the configuration you need is already available. For example,
    developers would often eject an application to switch to using TypeScript. The
    `--template typescript` option now removes the need for that.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这是一次性的变更。一旦你弹出了应用程序，就无法再回去了。在弹出应用程序之前，请仔细考虑。你可能会发现你需要的配置已经可用。例如，开发者经常会弹出应用程序以切换到使用
    TypeScript。现在，`--template typescript`选项消除了这种需要。
- en: 'Another common reason for ejecting was to proxy web services. React apps often
    need to connect to some separate API backend. Developers used to do this by configuring
    Webpack to proxy a remote server through the local development server. You can
    now avoid doing this by setting a proxy in the *package.json* file:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的弹出的原因是代理 Web 服务。React 应用程序经常需要连接到某个独立的 API 后端。开发人员过去通过配置 Webpack 在本地开发服务器上代理远程服务器来完成此操作。现在您可以通过在
    *package.json* 文件中设置代理来避免这样做：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If your code now contacts a URL that the server cannot find locally (*/api/thing*),
    the `react-scripts` automatically proxies these requests to *http://myapiserver/api/thing*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的代码现在访问了服务器在本地找不到的 URL（*/api/thing*），`react-scripts` 会自动将这些请求代理到 *http://myapiserver/api/thing*。
- en: If you can, avoid ejecting your application. Look through the [`create-react-app`
    documentation](https://oreil.ly/99Ied) to see if you can make the change some
    other way.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能的话，避免弹出您的应用程序。查看 [`create-react-app` 文档](https://oreil.ly/99Ied) 看看是否可以通过其他方式进行更改。
- en: You can download the source for this recipe in [JavaScript](https://oreil.ly/UK0dZ)
    or [TypeScript](https://oreil.ly/oOSo9) from the GitHub site.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 GitHub 站点下载此示例的源代码，支持 [JavaScript](https://oreil.ly/UK0dZ) 或 [TypeScript](https://oreil.ly/oOSo9)。
- en: Build Content-Rich Apps with Gatsby
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用 Gatsby 构建内容丰富的应用程序
- en: Problem
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: '*Content-rich* sites like blogs and online stores need to serve large amounts
    of complex content efficiently. A tool like `create-react-app` is not suitable
    for this kind of website because it delivers everything as a single large bundle
    of JavaScript that a browser must download before anything displays.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*内容丰富* 的网站，如博客和在线商店，需要有效地提供大量复杂的内容。像 `create-react-app` 这样的工具并不适合这种类型的网站，因为它会将所有内容打包为一个大的
    JavaScript 捆绑包，浏览器必须在显示任何内容之前下载。'
- en: Solution
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: If you are building a content-rich site, consider using Gatsby.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在构建内容丰富的网站，请考虑使用 Gatsby。
- en: Gatsby focuses on loading, transforming, and delivering content in the most
    efficient way possible. It can generate static versions of web pages, which means
    that the response times of Gatsby sites are often significantly slower than, say,
    those built with `create-react-app`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Gatsby 专注于以最高效的方式加载、转换和提供内容。它可以生成网页的静态版本，这意味着 Gatsby 网站的响应时间通常明显慢于使用 `create-react-app`
    构建的网站。
- en: Gatsby has many plugins that can load and transform data efficiently from static
    local data, GraphQL sources, and third-party content management systems such as
    WordPress.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Gatsby 拥有许多插件，可以高效地从静态本地数据、GraphQL 数据源和第三方内容管理系统（如 WordPress）加载和转换数据。
- en: 'You can install `gatsby` globally, but you can also run it via the `npx` command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以全局安装 `gatsby`，但也可以通过 `npx` 命令运行它：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `gatsby new` command creates a new project in a subdirectory called *my-app*.
    The first time you run this command, it asks which package manager to use: either
    `yarn` or `npm`.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`gatsby new` 命令在名为 *my-app* 的子目录中创建一个新项目。第一次运行此命令时，它会询问要使用哪个包管理器：`yarn` 还是
    `npm`。'
- en: 'To start your application, change into the new directory and run it in development
    mode:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动您的应用程序，请进入新目录并以开发模式运行它：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can then open your application at *http://localhost:8000*, as shown in [Figure 1-3](ch01_split_000.xhtml#ch01_image_3).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，您可以打开您的应用程序，网址为 *http://localhost:8000*，如 [图 1-3](ch01_split_000.xhtml#ch01_image_3)
    所示。
- en: '![](Images/recb_0103.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_0103.png)'
- en: Figure 1-3\. Gatsby page at http://localhost:8000
  id: totrans-59
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-3\. Gatsby 页面位于 http://localhost:8000
- en: Gatsby projects have a straightforward structure, as shown in [Figure 1-4](ch01_split_000.xhtml#ch01_image_4).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Gatsby 项目具有简单的结构，如 [图 1-4](ch01_split_000.xhtml#ch01_image_4) 所示。
- en: '![](Images/recb_0104.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_0104.png)'
- en: Figure 1-4\. The Gatsby directory structure
  id: totrans-62
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-4\. Gatsby 目录结构
- en: 'The core of the application lives under the *src* directory. Each page within
    a Gatsby app has its own React component. This is the front page of the default
    application in *index.js*:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的核心位于 *src* 目录下。Gatsby 应用程序中的每个页面都有其自己的 React 组件。这是默认应用程序的首页，位于 *index.js*
    中：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There is no need to create a route for the page. Each page component is automatically
    assigned a route. For example, the page at *src/pages/using-typescript.tsx* is
    automatically available at *using-typescript*.^([1](ch01_split_001.xhtml#idm46634434661000))
    This approach has multiple advantages. First, if you have many pages, you don’t
    need to manage the routes for them manually. Second, it means that Gatsby can
    deliver much more rapidly. To see why, let’s look at how to generate a production
    build for a Gatsby application.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要为页面创建路由。每个页面组件都会自动分配一个路由。例如，位于 *src/pages/using-typescript.tsx* 的页面会自动在 *using-typescript*
    处可用^([1](ch01_split_001.xhtml#idm46634434661000))。这种方法有多个优点。首先，如果有多个页面，您无需手动管理它们的路由。其次，这意味着
    Gatsby 可以更快地交付。要了解原因，请看如何为 Gatsby 应用程序生成生产构建。
- en: 'If you stop the Gatsby development server,^([2](ch01_split_001.xhtml#idm46634434658632))
    you can generate a production build with the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果停止 Gatsby 开发服务器^([2](ch01_split_001.xhtml#idm46634434658632))，您可以使用以下命令生成生产构建：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This command runs a `gatsby build` command, which creates a *public* directory.
    And it is the *public* directory that contains the real magic of Gatsby. For each
    page, you find two files. First, a generated JavaScript file:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令运行 `gatsby build` 命令，创建一个 *public* 目录。而 *public* 目录则包含了 Gatsby 的真正魔力。对于每个页面，您会找到两个文件。首先是生成的
    JavaScript 文件：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here you can see that the code for *using-typescript.tsx* is just 1,389 bytes
    long, which, with the core framework, is just enough JavaScript to build the page.
    It is not the kind of include-everything script that you find in a `create-react-app`
    project.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到 *using-typescript.tsx* 的代码仅有 1,389 字节长，与核心框架一起，这些 JavaScript 刚好足够构建页面。这不是在
    `create-react-app` 项目中找到的包含所有内容的脚本。
- en: Second, there is a subdirectory for each page containing a generated HTML file.
    For *using-typescript.tsx*, the file is called *public/using-typescript/index.html*,
    containing a statically generated version of the web page. It contains the HTML
    that the *using-typescript.tsx* component would otherwise render dynamically.
    At the end of the web page, it loads the JavaScript version of the page to generate
    any dynamic content.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，每个页面都有一个子目录，其中包含一个生成的 HTML 文件。例如，对于 *using-typescript.tsx*，文件名为 *public/using-typescript/index.html*，包含了网页的静态生成版本。它包含了
    *using-typescript.tsx* 组件本应动态渲染的 HTML。在网页末尾，它加载页面的 JavaScript 版本来生成任何动态内容。
- en: This file structure means that Gatsby pages load as quickly as static pages.
    Using the bundled `react-helmet` library, you can also generate `<meta/>` header
    tags with additional features about your site. Both features are great for search
    engine optimization (SEO).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这种文件结构意味着 Gatsby 页面的加载速度与静态页面一样快。使用捆绑的 `react-helmet` 库，您还可以生成关于您站点的 `<meta/>`
    标签，具有关于您站点的额外功能。这两个功能对搜索引擎优化（SEO）非常有利。
- en: Discussion
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: How will the content get into your Gatsby application? You might use a headless
    content management system, a GraphQL service, a static data source, or something
    else. Fortunately, Gatsby has many plugins that allow you to connect data sources
    to your application and then transform the content from other formats, such as
    Markdown, into HTML.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如何将内容导入到您的 Gatsby 应用程序中？您可以使用无头内容管理系统、GraphQL 服务、静态数据源或其他方式。幸运的是，Gatsby 有许多插件可以让您连接数据源到您的应用程序，然后将内容从其他格式（如
    Markdown）转换为 HTML。
- en: You can find a complete set of plugins on the [Gatsby website](https://oreil.ly/9GwLv).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [Gatsby 网站](https://oreil.ly/9GwLv) 上找到完整的插件集。
- en: Most of the time, you choose the plugins you need when you first create the
    project. To give you a head start, Gatsby also supports *start templates*. The
    template provides the initial application structure and configuration. The app
    we built earlier uses the default starter template, which is quite simple. The
    *gatsby-config.js* file in the root of the application configures which plugins
    your application uses.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，您在创建项目时选择需要的插件。为了让您更快上手，Gatsby 还支持 *启动模板*。模板提供了初始的应用程序结构和配置。我们之前构建的应用程序使用了默认的起始模板，非常简单。应用程序根目录下的
    *gatsby-config.js* 文件配置了应用程序使用的插件。
- en: But there are masses of Gatsby starters available, preconfigured to build applications
    that connect to various data sources, with preconfigured options for SEO, styling,
    offline caching, progressive web applications (PWAs), and more. Whatever kind
    of content-rich application you are building, there is a starter close to what
    you need.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 但是有大量预配置的 Gatsby starters 可用于构建连接到各种数据源的应用程序，具有用于SEO、样式、离线缓存、渐进式Web应用程序（PWA）等的预配置选项。无论您构建什么类型的内容丰富应用程序，都会有一个接近您需求的
    starter。
- en: There is more information on the Gatsby website about [Gatsby starters](https://oreil.ly/vwUd8),
    as well as a [cheat sheet](https://oreil.ly/f7xbF) for the most useful tools and
    commands.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 关于[Gatsby starters](https://oreil.ly/vwUd8)，以及关于最有用的工具和命令的[cheat sheet](https://oreil.ly/f7xbF)，Gatsby
    网站上有更多信息。
- en: You can download the source for this recipe from the [GitHub site](https://oreil.ly/DzLSy).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[GitHub 网站](https://oreil.ly/DzLSy)下载此配方的源代码。
- en: Build Universal Apps with Razzle
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Razzle 构建 Universal Apps
- en: Problem
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Sometimes when you start to build an application, it is not always clear what
    the significant architectural decisions will be. Should you create an SPA? If
    performance is critical, should you use server side r? You will need to decide
    what your deployment platform will be and whether you will write your code in
    JavaScript or TypeScript.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有时当您开始构建应用程序时，很难确定哪些重要的架构决策。您应该创建SPA吗？如果性能至关重要，应该使用服务器端r吗？您需要决定您的部署平台将是什么，以及您是否将在JavaScript或TypeScript中编写代码。
- en: Many tools require that you answer these questions early on. If you later change
    your mind, modifying how you build and deploy your application can be complicated.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 许多工具要求您尽早回答这些问题。如果您后来改变主意，修改构建和部署应用程序的方式可能会很复杂。
- en: Solution
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: If you want to defer decisions about how you build and deploy your application,
    you should consider using [Razzle](https://oreil.ly/3pZic).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望推迟有关如何构建和部署应用程序的决策，您应该考虑使用[Razzle](https://oreil.ly/3pZic)。
- en: 'Razzle is a tool for building [Universal applications](https://oreil.ly/C496O):
    applications that can execute their JavaScript on the server. Or the client. Or
    both.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Razzle 是用于构建[Universal applications](https://oreil.ly/C496O)的工具：可以在服务器上执行其JavaScript。或者在客户端上。或者两者兼而有之。
- en: Razzle uses a plugin architecture that allows you to change your mind about
    how you build your application. It will even let you change your mind about building
    your code in React, Preact, or some other framework entirely, like Elm or Vue.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Razzle 使用插件架构，允许您改变构建应用程序的方式。它甚至可以让您改变构建代码的想法，无论是在React、Preact还是完全不同的框架如Elm或Vue。
- en: You can create a Razzle application with the `create-razzle-app` command:^([3](ch01_split_001.xhtml#idm46634434578328))
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`create-razzle-app`命令可以创建一个 Razzle 应用程序：^([3](ch01_split_001.xhtml#idm46634434578328))
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This command creates a new Razzle project in the *my-app* subdirectory. You
    can start the development server with the `start` script:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令在*my-app*子目录中创建一个新的 Razzle 项目。您可以使用`start`脚本启动开发服务器：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `start` script will dynamically build both client code and server code and
    then run the server on port 3000, as shown in Figure 1-5.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`start`脚本将动态构建客户端代码和服务器代码，然后在端口3000上运行服务器，如图1-5所示。'
- en: '![](Images/recb_0105.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_0105.png)'
- en: Figure 1-5\. The Razzle front page at http://localhost:3000
  id: totrans-94
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-5\. Razzle首页位于 http://localhost:3000
- en: 'When you want to deploy a production version of your application, you can then
    run the `build` script:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当您希望部署应用程序的生产版本时，可以运行`build`脚本：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Unlike `create-react-app`, this will build not just the client code but also
    a Node server. Razzle generates the code in the *build* subdirectory. The server
    code will continue to generate static code for your client at runtime. You can
    start a production server by running the *build/server.js* file using the `start:prod`
    script:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 不像`create-react-app`，这不仅会构建客户端代码，还会构建一个Node服务器。 Razzle 生成的代码位于*build*子目录下。服务器代码将在运行时继续为客户端生成静态代码。您可以通过运行*build/server.js*文件使用`start:prod`脚本启动生产服务器：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can deploy the production server anywhere that Node is available.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将生产服务器部署到任何支持Node的地方。
- en: The server and the client can both run the same code, which makes it *Universal*.
    But how does it do this?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器和客户端都可以运行相同的代码，这使得它变得*Universal*。但它是如何做到的呢？
- en: The client and the server have different entry points. The server runs the code
    in *src/server.js*; the browser runs the code in *src/client.js*. Both *server.js*
    and *client.js* then render the same app using *src/App.js*.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务器有不同的入口点。服务器在*src/server.js*中运行代码；浏览器在*src/client.js*中运行代码。*server.js*和*client.js*都使用*src/App.js*渲染相同的应用程序。
- en: 'If you want to run your app as an SPA, remove the *src/index.js* and *src/server.js*
    files. Then create an *index.html* file in the *public* folder containing a `<div/>`
    with an ID of `root`, and rebuild the application with this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要将您的应用程序作为SPA运行，请删除*src/index.js*和*src/server.js*文件。然后在*public*文件夹中创建一个包含`<div/>`并带有ID
    `root`的*index.html*文件，并使用以下命令重新构建应用程序：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: To build your application as an SPA every time, add `--type=spa` to the `start`
    and `build` scripts in *package.json*.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要每次将您的应用程序构建为SPA，请在*package.json*的`start`和`build`脚本中添加`--type=spa`。
- en: You will generate a full SPA in *build/public/* that you can deploy on any web
    server.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您将生成一个完整的SPA，位于*build/public/*目录下，可以部署到任何Web服务器上。
- en: Discussion
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Razzle is so adaptable because it is built from a set of highly configurable
    plugins. Each plugin is a higher-order function that receives a Webpack configuration
    and returns a modified version. One plugin might transpile TypeScript code; another
    might bundle the React libraries.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Razzle非常适应，因为它是从一组高度可配置的插件构建的。每个插件都是一个高阶函数，接收一个Webpack配置并返回一个修改过的版本。一个插件可能会转译TypeScript代码，另一个插件可能会捆绑React库。
- en: If you want to switch your application to Vue, you only need to replace the
    plugins you use.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要将应用程序切换到Vue，只需替换您使用的插件即可。
- en: You can find a list of available plugins on the [Razzle website](https://oreil.ly/UXwPv).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[Razzle网站](https://oreil.ly/UXwPv)上找到可用插件的列表。
- en: You can download the source for this recipe from the [GitHub site](https://oreil.ly/rBR9r).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[GitHub网站](https://oreil.ly/rBR9r)下载此配方的源代码。
- en: Manage Server and Client Code with Next.js
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Next.js管理服务器和客户端代码
- en: Problem
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: React generates client code—even if it generates the client code on the server.
    Sometimes, however, you might have a relatively small amount of application programming
    interface (API) code that you would prefer to manage as part of the same React
    application.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: React会生成客户端代码，即使在服务器上也是如此。但是，有时您可能希望将相对较少的应用程序编程接口（API）代码作为同一React应用程序的一部分管理。
- en: Solution
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Next.js is a tool for generating React applications and server code. The API
    end-points and the client pages use default routing conventions, making them simpler
    to build and deploy than they would be if you manage them yourself. You can find
    full details about Next.js on the [website](https://nextjs.org).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js是一个用于生成React应用程序和服务器代码的工具。API端点和客户端页面使用默认路由约定，使它们比您自行管理时更容易构建和部署。您可以在[网站](https://nextjs.org)上找到关于Next.js的详细信息。
- en: 'You can create a Next.js application with this command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令创建一个Next.js应用程序：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will use `yarn` as the package manager if you have it installed. You can
    force it to use the `npm` package manager with the `--user-npm` flag:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已安装`yarn`，将使用它作为包管理器。您可以使用`--user-npm`标志强制使用`npm`包管理器：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This will create a Next.js application in the *my-app* subdirectory. To start
    the app, run the `dev` script (see [Figure 1-6](ch01_split_000.xhtml#ch01_image_6)):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在*my-app*子目录中创建一个Next.js应用程序。要启动该应用程序，请运行`dev`脚本（参见[图1-6](ch01_split_000.xhtml#ch01_image_6)）：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![](Images/recb_0106.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_0106.png)'
- en: Figure 1-6\. A Next.js page running at http://localhost:3000
  id: totrans-123
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-6\. 一个运行在 http://localhost:3000 的Next.js页面
- en: Next.js allows you to create pages without the need to manage any routing configuration.
    If you add a component script to the *pages* folder, it will instantly become
    available through the server. For example, the *pages/index.js* component generates
    the home page of the default application.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js允许您创建页面，无需管理任何路由配置。例如，如果您向*pages*文件夹添加一个组件脚本，它将立即通过服务器可用。例如，默认应用程序的*pages/index.js*组件生成主页。
- en: This approach is similar to the one taken by Gatsby,^([4](ch01_split_001.xhtml#idm46634434328376))
    but is taken further in Next.js to include server-side code.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法类似于Gatsby的方法^([4](ch01_split_001.xhtml#idm46634434328376))，但在Next.js中进一步包含了服务器端代码。
- en: 'Next.js applications usually include some API server code, which is unusual
    for React applications, which are often built separately from server code. But
    if you look inside *pages/api*, you will find an example server endpoint called
    *hello.js*:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js 应用通常包含一些 API 服务器代码，这在 React 应用中是不常见的，React 应用通常是与服务器代码分开构建的。但如果你查看 *pages/api*
    目录，你会找到一个名为 *hello.js* 的示例服务器端点：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The routing that mounts this to the endpoint *api/hello* happens automatically.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 将此路由挂载到 *api/hello* 端点是自动完成的。
- en: Next.js transpiles your code into a hidden directory called .next, which it
    can then deploy to a service such as Next.js’s own [Vercel](https://vercel.com)
    platform.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js 将你的代码转译成一个名为 .next 的隐藏目录，然后可以部署到诸如 Next.js 自家平台 [Vercel](https://vercel.com)
    的服务上。
- en: 'If you want, you generate a static build of your application with:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以通过以下命令生成应用的静态构建版本：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `export` command will build your client code in a directory called *out*.
    The command will convert each page into a statically rendered HTML file, which
    will load quickly in the browser. At the end of the page, it will load the JavaScript
    version to generate any dynamic content.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`export` 命令将会在一个名为 *out* 的目录中构建你的客户端代码。该命令会将每个页面转换为静态渲染的 HTML 文件，这样在浏览器中加载速度会很快。页面末尾会加载
    JavaScript 版本以生成任何动态内容。'
- en: If you create an exported version of a Next.js application, it won’t include
    any server-side APIs.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你创建了一个 Next.js 应用的导出版本，它将不会包含任何服务器端 API。
- en: Next.js comes with a bunch of data-fetching options, which allow you to get
    data from static content, or via [headless content management system (CMS) sources](https://oreil.ly/Xmia8).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js 提供了一系列数据获取选项，允许你从静态内容或通过 [无头内容管理系统 (CMS) 源](https://oreil.ly/Xmia8)
    获取数据。
- en: Discussion
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Next.js is in many ways similar to Gatsby. Its focus is on the speed of delivery,
    with a small amount of configuration. It’s probably most beneficial for teams
    that will have very little server code.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js 在很多方面与 Gatsby 类似。它的重点是交付速度，配置量很小。它可能对几乎没有服务器代码的团队最为有益。
- en: You can download the source for this recipe from the [GitHub site](https://oreil.ly/9gbJs).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 [GitHub 站点](https://oreil.ly/9gbJs) 下载本示例的源代码。
- en: Create a Tiny App with Preact
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Preact 创建一个微型应用
- en: Problem
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: React applications can be large. It’s pretty easy to create a simple React application
    that is transpiled into bundles of JavaScript code that are several hundred kilobytes
    in size. You might want to build an app with React-like features but with a much
    smaller footprint.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: React 应用可能会很大。创建一个简单的 React 应用并将其转译成数百千字节大小的 JavaScript 捆绑包是非常容易的。你可能希望构建一个具有类似
    React 功能但体积小得多的应用。
- en: Solution
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: If you want React features but don’t want to pay the price of a React-size JavaScript
    bundle, consider using Preact.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要 React 的功能但不想付出 React 规模的 JavaScript 捆绑包代价，可以考虑使用 Preact。
- en: Preact is *not* React. It is a separate library, designed to be as close to
    React as possible but much smaller.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Preact *不是* React。它是一个独立的库，旨在尽可能接近 React 但体积要小得多。
- en: The reason that the React framework is so big is because of the way it works.
    React components don’t generate elements in the Document Object Model (DOM) of
    the browser directly. Instead, they build elements within a *virtual DOM* and
    then update the actual DOM at frequent intervals. Doing so allows basic DOM rendering
    to be fast because the actual DOM needs to be updated only when there are actual
    changes. However, it does have a downside. React’s virtual DOM requires a lot
    of code to keep it up-to-date. It needs to manage an entire synthetic event model,
    which parallels the one in the browser. For this reason, the React framework is
    large and can take some time to download.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: React 框架如此庞大的原因在于它的工作方式。React 组件不会直接在浏览器的文档对象模型 (DOM) 中生成元素。相反，它们在 *虚拟 DOM*
    中构建元素，然后在频繁的间隔内更新实际 DOM。这样做可以让基本的 DOM 渲染速度很快，因为只有在实际发生变化时才需要更新实际 DOM。但这也有一个缺点。React
    的虚拟 DOM 需要大量代码来保持更新。它需要管理一个完整的合成事件模型，与浏览器中的事件模型相似。因此，React 框架体积庞大，并且下载时间可能较长。
- en: One way around this is to use techniques such as SSR, but SSR can be complex
    to configure.^([5](ch01_split_001.xhtml#idm46634434199464)) Sometimes, you want
    to download a small amount of code. And that’s why Preact exists.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方法之一是使用 SSR 等技术，但配置 SSR 可能会比较复杂。^([5](ch01_split_001.xhtml#idm46634434199464))
    有时候，你只想下载少量代码。这就是为什么 Preact 存在的原因。
- en: The Preact library, although similar to React, is tiny. At the time of writing,
    the main Preact library is around 4KB, which is small enough that it’s possible
    to add React-like features to web pages in barely more code than is required to
    write native JavaScript.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Preact库与React类似，但体积小巧。在撰写本文时，主要的Preact库大小约为4KB，足够小，以至于能够在网页中添加类似React的功能，几乎不需要比编写原生JavaScript多的代码。
- en: 'Preact lets you choose how to use it: as a small JavaScript library included
    in a web page (the *no-tools* approach) or as a full-blown JavaScript application.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Preact允许您选择如何使用它：作为包含在网页中的小型JavaScript库（*无需工具*方法）或作为完整的JavaScript应用程序。
- en: 'The no-tools approach is basic. The core Preact library does not support JSX,
    and you will have no Babel support, so you will not be able to use modern JavaScript.
    Here is an example web page using the raw Preact library:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 无需工具方法非常基础。核心Preact库不支持JSX，您将无法使用现代JavaScript。以下是使用原始Preact库的示例网页：
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This application will mount itself at the `<div/>` with an ID of `root`, where
    it will display a button. When you click the button, it will replace the contents
    of the root `div` with the string `"Hello"`, which is about as basic as a Preact
    app can be.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序将在ID为`root`的`<div/>`中挂载自身，在那里它将显示一个按钮。当您单击按钮时，它将用字符串`"Hello"`替换根`div`的内容，这是Preact应用程序可以达到的基本操作。
- en: You would rarely write an application in this way. In reality, you would create
    a simple build-chain that would, at the least, support modern JavaScript.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你很少会以这种方式编写应用程序。实际上，您将创建一个简单的构建链，至少支持现代JavaScript。
- en: Preact supports the entire spectrum of JavaScript applications. At the other
    extreme, you can create a complete Preact application with `preact-cli`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Preact支持整个JavaScript应用程序的范围。在另一极端，您可以使用`preact-cli`创建完整的Preact应用程序。
- en: '`preact-cli` is a tool for creating Preact projects and is analogous to tools
    like `create-react-app`. You can create a Preact application with:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`preact-cli`是一个用于创建Preact项目的工具，类似于`create-react-app`。您可以使用以下命令创建Preact应用程序：'
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This command uses the default template. Other templates are available for creating
    projects using, for example, Material components or TypeScript. See the [Preact
    GitHub page](https://oreil.ly/IVQua) for more information.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令使用默认模板。其他模板可用于创建项目，例如，使用Material组件或TypeScript。有关更多信息，请参见[Preact GitHub页面](https://oreil.ly/IVQua)。
- en: 'This command will create your new Preact application in the *my-app* subdirectory.
    To start it, run the `dev` script:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将在*my-app*子目录中创建您的新Preact应用程序。要启动它，请运行`dev`脚本：
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The server will run on port 8080, as shown in [Figure 1-7](ch01_split_000.xhtml#ch01_image_7).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将在端口8080上运行，如[图1-7](ch01_split_000.xhtml#ch01_image_7)所示。
- en: '![](Images/recb_0107.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_0107.png)'
- en: Figure 1-7\. A page from Preact
  id: totrans-160
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-7\. 来自Preact的页面
- en: The server generates a web page, which calls back for a JavaScript bundle made
    from the code in *src/index.js*.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器生成一个网页，该网页从*src/index.js*中的代码生成一个JavaScript捆绑包。
- en: 'You now have a full-scale React-like application. The code inside the `Home`
    component (*src/routes/home/index.js*), for example, looks very React-like, with
    full JSX support:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您拥有一个类似于全尺寸的React应用程序。例如，`Home`组件（*src/routes/home/index.js*）中的代码看起来非常像React，并支持完整的JSX：
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The only significant difference from a standard React component is that a function
    called `h` is imported from the `preact` library, instead of importing `React`
    from the `react` library.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 与标准React组件的唯一显著区别是，从`preact`库导入了名为`h`的函数，而不是从`react`库导入`React`。
- en: The JSX within the Preact code will be converted into a series of calls to the
    `h` function, which is why it needs to be imported. For the same reason, applications
    created with `create-react-app` prior to version 17 also required the import of
    the `react` object. From version 17 `create-react-app` switched to use the [JSX
    transform](https://oreil.ly/HOwS9), doing away for the need to import `react`
    every time. It’s always possible that future versions of Preact will make a similar
    change.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Preact代码中的JSX将转换为对`h`函数的一系列调用，这就是为什么需要导入它的原因。出于同样的原因，之前版本的`create-react-app`在版本17之前也需要导入`react`对象。从版本17开始，`create-react-app`切换到使用[JSX转换](https://oreil.ly/HOwS9)，不再需要每次导入`react`。未来版本的Preact可能会做出类似的更改。
- en: 'However, the size of the application has increased: it is now a little over
    300KB. That’s pretty large, but we are still in dev mode. To see the real power
    of Preact, stop the dev server by pressing Ctrl-C, and then run the `build` script:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，应用程序的大小已经增加到略高于 300KB。这相当大，但我们仍处于开发模式。要看到 Preact 的真正强大之处，请按 Ctrl-C 停止开发服务器，然后运行
    `build` 脚本：
- en: '[PRE29]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This command will generate a static version of the application in the *build*
    directory. First, this will have the advantage of creating a static copy of the
    front page, which will render quickly. Second, it will remove all unused code
    from the application and shrink everything down. If you serve this built version
    of the app on a standard web server, the browser will transfer only about 50–60KB
    when it’s opened.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将在 *build* 目录中生成应用程序的静态版本。首先，这样做有助于创建首页的静态副本，渲染速度快。其次，它会删除应用程序中的所有未使用代码并将所有内容缩小。如果您在标准
    Web 服务器上提供此构建版本的应用程序，则在打开时，浏览器只会传输大约 50–60KB 的内容。
- en: Discussion
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Preact is a remarkable project. Despite working in a very different way from
    React, it provides virtually the same power at a fraction of the size. And the
    fact that you can use it for anything from the lowliest inline code to a full-blown
    SPA means it is well worth considering if code size is critical to your project.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Preact 是一个非常出色的项目。尽管它的工作方式与 React 完全不同，但在几乎相同的功能强大的同时，它的体积却只有一小部分。您可以用它来处理从最低级的内联代码到完整的单页面应用程序的任何事情，因此，如果代码大小对您的项目至关重要，那么考虑使用它是非常值得的。
- en: You can find out more about Preact on the [Preact website](https://preactjs.com).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [Preact 网站](https://preactjs.com) 上了解更多关于 Preact 的信息。
- en: You can download the source for the [no-tools example](https://oreil.ly/N9PKf)
    and the [larger Preact example](https://oreil.ly/F0tW9) from the GitHub site.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 GitHub 站点下载 [无工具示例](https://oreil.ly/N9PKf) 和 [更大的 Preact 示例](https://oreil.ly/F0tW9)
    的源代码。
- en: If you would like to make Preact look even more like React, see the [preact-compat](https://oreil.ly/3YXOv)
    library.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果想让 Preact 看起来更像 React，请查看 [preact-compat](https://oreil.ly/3YXOv) 库。
- en: Finally, for a project that takes a similar approach to Preact, look at [InfernoJS](https://infernojs.org).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果想要一个与 Preact 类似的项目，请查看 [InfernoJS](https://infernojs.org)。
- en: Build Libraries with nwb
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 nwb 构建库
- en: Problem
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Large organizations often develop several React applications at the same time.
    If you’re a consultancy, you might create applications for multiple organizations.
    If you’re a software house, you might create various applications that require
    the same look and feel, so you will probably want to build shared components to
    use across several applications.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 大型组织通常同时开发多个 React 应用程序。如果您是咨询公司，可能会为多个组织创建应用程序。如果您是软件公司，可能会创建需要相同外观和感觉的各种应用程序，因此可能希望构建共享组件以在多个应用程序中使用。
- en: When you create a component project, you need to create a directory structure,
    select a set of tools, choose a set of language features, and create a build chain
    that can bundle your component in a deployable format. This process can be just
    as tedious as manually creating a project for an entire React application.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 创建组件项目时，需要创建目录结构，选择一组工具，选择一组语言特性，并创建能够将您的组件捆绑成可部署格式的构建链。这个过程可能与手动创建整个 React
    应用程序的项目一样繁琐。
- en: Solution
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: You can use the `nwb` toolkit to create complete React applications or single
    React components. It can also create components for use within Preact and InfernoJS
    projects, but we concentrate on React components here.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `nwb` 工具包创建完整的 React 应用程序或单个 React 组件。它还可以为在 Preact 和 InfernoJS 项目中使用的组件创建组件，但我们在这里专注于
    React 组件。
- en: 'To create a new React component project, you will first need to install the
    `nwb` tool globally:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的 React 组件项目，首先需要全局安装 `nwb` 工具：
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You can then create a new project with the `nwb` command:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `nwb` 命令可以创建一个新项目：
- en: '[PRE31]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If instead of creating a single component, you want to create an entire `nwb`
    application, you can replace `react-component` in this command with `react-app`,
    `preact-app`, or `inferno-app` to create an application in the given framework.
    You can also use `vanilla-app` if you want to create a basic JavaScript project
    without a framework.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不只是创建单个组件，而是要创建一个完整的 `nwb` 应用程序，可以在该命令中用 `react-app`、`preact-app` 或 `inferno-app`
    替换 `react-component`，以在给定的框架中创建一个应用程序。如果想创建一个没有框架的基本 JavaScript 项目，则可以使用 `vanilla-app`。
- en: 'When you run this command, it will ask you several questions about the type
    of library you want to build. For example, it will ask you if you’re going to
    build ECMAScript modules:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此命令时，它会询问您关于要构建的库类型的几个问题。例如，它会问您是否要构建 ECMAScript 模块：
- en: '[PRE32]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This option allows you to build a version including an `export` statement,
    which Webpack can use to decide if it needs to include the component in a client
    application. You will also be asked if you want to create a Universal Module Definition
    (UMD):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项允许您构建包含 `export` 语句的版本，Webpack 可以使用它来决定是否需要将组件包含在客户端应用程序中。还会询问您是否要创建通用模块定义（UMD）：
- en: '[PRE33]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: That’s useful if you want to include your component in a `<script/>` within
    a web page. For our example, we won’t create a UMD build.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望在网页中的 `<script/>` 中包含组件，则这非常有用。对于我们的示例，我们不会创建 UMD 构建。
- en: 'After the questions, the tool will create an `nwb` component project inside
    the *my-component* subdirectory. The project comes with a simple wrapper application
    that you can start with the `start` script:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在问题回答完毕后，该工具将在 *my-component* 子目录中创建一个 `nwb` 组件项目。该项目附带一个简单的包装器应用程序，您可以使用 `start`
    脚本启动它：
- en: '[PRE34]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The demo application runs on port 3000, as shown in [Figure 1-8](ch01_split_000.xhtml#ch01_image_8).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 演示应用程序在端口 3000 上运行，如 [图 1-8](ch01_split_000.xhtml#ch01_image_8) 所示。
- en: '![](Images/recb_0108.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_0108.png)'
- en: Figure 1-8\. An `nwb` component
  id: totrans-195
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-8\. 一个 `nwb` 组件
- en: 'The application will contain a single component defined in *src/index.js*:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将包含一个在 *src/index.js* 中定义的单个组件：
- en: '[PRE35]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You can now build the component as you would any React project. When you are
    ready to create a publishable version, type:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以像构建任何 React 项目一样构建组件。当您准备好创建可发布版本时，请输入：
- en: '[PRE36]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The built component will be in *lib/index.js*, which you can deploy to a repository
    for use within other projects.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 构建的组件将位于 *lib/index.js*，您可以将其部署到存储库中供其他项目使用。
- en: Discussion
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: For further details on creating `nwb` components, see the [`nwb` guide to developing
    components and libraries](https://oreil.ly/XHrQa).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关创建 `nwb` 组件的更多详细信息，请参阅 [`nwb` 开发组件和库指南](https://oreil.ly/XHrQa)。
- en: You can download the source for this recipe from the [GitHub site](https://oreil.ly/P4Xzj).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 [GitHub 网站](https://oreil.ly/P4Xzj) 下载此示例的源代码。
- en: Add React to Rails with Webpacker
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Webpacker 将 React 添加到 Rails 中
- en: Problem
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: The Rails framework was created before interactive JavaScript applications became
    popular. Rails applications follow a more traditional model for web application
    development, in which it generates HTML pages on the server in response to browser
    requests. But sometimes, you may want to include more interactive elements inside
    a Rails application.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Rails 框架是在交互式 JavaScript 应用程序变得流行之前创建的。Rails 应用程序遵循更传统的 Web 应用程序开发模型，即在服务器上生成
    HTML 页面，以响应浏览器请求。但有时，您可能希望在 Rails 应用程序中包含更多交互式元素。
- en: Solution
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'You can use the Webpacker library to insert React applications into Rails-generated
    web pages. To see how it works, let’s first generate a Rails application that
    includes Webpacker:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Webpacker 库可以将 React 应用程序插入由 Rails 生成的网页中。要查看其工作原理，首先让我们生成一个包含 Webpacker
    的 Rails 应用程序：
- en: '[PRE37]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This command will create a Rails application in a directory called *my-app*
    that is preconfigured to run a Webpacker server. Before we start the application,
    let’s go into it and generate an example page/controller:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将在名为 *my-app* 的目录中创建一个预配置为运行 Webpacker 服务器的 Rails 应用程序。在我们启动应用程序之前，让我们进入其中并生成一个示例页面/控制器：
- en: '[PRE38]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'That code will generate this template page at *app/views/example/index.html.erb*:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将在 *app/views/example/index.html.erb* 中生成此模板页面：
- en: '[PRE39]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, we need to create a small React application that we can insert into this
    page. Rails inserts Webpacker applications as *packs*: small JavaScript bundles
    within Rails. We’ll create a new pack in *app/javascript/packs/counter.js* containing
    a simple counter component:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个小的 React 应用程序，可以将其插入到此页面中。Rails 将 Webpacker 应用程序作为 *packs* 插入：即
    Rails 内的小 JavaScript 捆绑包。我们将在 *app/javascript/packs/counter.js* 中创建一个新的 pack，其中包含一个简单的计数器组件：
- en: '[PRE40]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This application updates a counter every time a user clicks the button.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 每当用户点击按钮时，此应用程序会更新计数器。
- en: 'We can now insert the pack into the web page by adding a single line of code
    to the template page:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过向模板页面添加一行代码来将 pack 插入到网页中：
- en: '[PRE41]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, we can run the Rails server on port 3000:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在端口 3000 上运行 Rails 服务器：
- en: '[PRE42]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: At the time of writing, you will need the `yarn` package manager installed when
    starting the server. You can install `yarn` globally with `npm install -g yarn`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，启动服务器时需要安装 `yarn` 包管理器。你可以使用 `npm install -g yarn` 全局安装 `yarn`。
- en: You will see the *http://localhost:3000/example/index.html* page in [Figure 1-9](ch01_split_000.xhtml#ch01_image_9).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在 [Figure 1-9](ch01_split_000.xhtml#ch01_image_9) 中看到 *http://localhost:3000/example/index.html*
    页面。
- en: '![](Images/recb_0109.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_0109.png)'
- en: Figure 1-9\. A React app embedded in http://localhost:3000/example/index.html
  id: totrans-224
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-9\. 一个嵌入在 http://localhost:3000/example/index.html 中的 React 应用程序
- en: Discussion
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Behind the scenes, as you have probably guessed, Webpacker transforms the application
    using a copy of Webpack, which you can configure with the *app/config/webpacker.yml*
    config file.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 幕后，正如你可能已经猜到的那样，Webpacker 使用 Webpack 的副本转换应用程序，你可以使用 *app/config/webpacker.yml*
    配置文件对其进行配置。
- en: Webpacker is used alongside Rails code rather than as a replacement for it.
    You should consider using it if your Rails application requires a small amount
    of additional interactivity.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Webpacker 与 Rails 代码一起使用，而不是替代它。如果你的 Rails 应用程序需要少量的额外交互性，你应该考虑使用它。
- en: You can find out more about Webpacker on the [Webpacker GitHub site](https://oreil.ly/aYZ0h).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [Webpacker GitHub 站点](https://oreil.ly/aYZ0h) 上找到关于 Webpacker 的更多信息。
- en: You can download the source for this recipe from the [GitHub site](https://oreil.ly/H3q1F).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 [GitHub 站点](https://oreil.ly/H3q1F) 下载本示例的源代码。
- en: Create Custom Elements with Preact
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Preact 创建自定义元素
- en: Problem
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: There are sometimes circumstances where it is challenging to add React code
    into existing content. For example, in some CMS configurations, users are not
    allowed to insert additional JavaScript into the body of a page. In these cases,
    it would be helpful to have some standardized way to insert JavaScript applications
    safely into a page.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在现有内容中添加 React 代码是有挑战性的情况。例如，在某些 CMS 配置中，用户不允许将额外的 JavaScript 插入到页面的主体中。在这些情况下，有一个标准化的方式可以安全地将
    JavaScript 应用程序插入到页面中将会很有帮助。
- en: Solution
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Custom elements are a standard way of creating new HTML elements you can use
    on a web page. In effect, they extend the HTML language by making more tags available
    to a user.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义元素是创建新 HTML 元素的标准方法，您可以在网页上使用它们。实际上，它们通过使更多的标签可用来扩展 HTML 语言。
- en: This recipe looks at how we can use a lightweight framework like Preact to create
    custom elements, which we can publish on a third-party server.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例介绍了如何使用像 Preact 这样的轻量级框架创建自定义元素，并将其发布到第三方服务器上。
- en: Let’s begin by creating a new Preact application. This application will serve
    the custom element that we will be able to use elsewhere:^([6](ch01_split_001.xhtml#idm46634433377096))
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个新的 Preact 应用程序开始。该应用程序将提供我们将能够在其他地方使用的自定义元素：^([6](ch01_split_001.xhtml#idm46634433377096))
- en: '[PRE43]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now we will change into the app’s directory and add the `preact-custom-element`
    library to the project:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将进入应用程序目录，并向项目添加 `preact-custom-element` 库：
- en: '[PRE44]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `preact-custom-element` library will allow us to register a new custom HTML
    element in a browser.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`preact-custom-element` 库将允许我们在浏览器中注册一个新的自定义 HTML 元素。'
- en: 'Next, we need to modify the *src/index.js* file of the Preact project so that
    it registers a new custom element, which we will call *components/Converter/index.js*:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要修改 Preact 项目的 *src/index.js* 文件，以便注册一个新的自定义元素，我们将其命名为 *components/Converter/index.js*：
- en: '[PRE45]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `register` method tells the browser that we want to create a new custom
    HTML element called `<x-converter/>` that has a single property called `currency`,
    which we will define in *src/components/Converter/index.js*:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`register` 方法告诉浏览器，我们要创建一个名为 `<x-converter/>` 的新自定义 HTML 元素，该元素具有一个名为 `currency`
    的属性，我们将在 *src/components/Converter/index.js* 中定义它：'
- en: '[PRE46]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: To be compliant with the custom elements specification, we must choose a name
    for our element that begins with a lowercase letter, does not include any uppercase
    letters, and contains a hyphen.^([7](ch01_split_001.xhtml#idm46634433284040))
    This convention ensures the name does not clash with any standard element name.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 要符合自定义元素规范，我们必须为我们的元素选择一个以小写字母开头、不包含任何大写字母并包含连字符的名称。^([7](ch01_split_001.xhtml#idm46634433284040))
    这种约定确保该名称不会与任何标准元素名称冲突。
- en: 'Our `Converter` component is a currency converter, which in our example uses
    a fixed set of exchange rates. If we now start our Preact server:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Converter` 组件是一个货币转换器，在我们的示例中使用了一组固定的汇率。如果现在启动我们的 Preact 服务器：
- en: '[PRE47]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: the JavaScript for the custom element will be available at *http://localhost:8080/bundle.js*.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义元素的 JavaScript 将在 *http://localhost:8080/bundle.js* 上可用。
- en: 'To use this new custom element, let’s create a static web page somewhere with
    this HTML:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个新的自定义元素，让我们在某个地方创建一个静态网页，并使用以下 HTML：
- en: '[PRE48]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This web page includes the definition of the custom element in the final `<script/>`
    of the `<head/>` element. To ensure that the custom element is available across
    both new and old browsers, we also include a couple of shims from *unpkg.com*.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 此网页包含在 `<head/>` 元素的最终 `<script/>` 中嵌入的自定义元素的定义。为了确保自定义元素在新旧浏览器中都可用，我们还从 *unpkg.com*
    包含了一些 shims。
- en: Now that we’ve included the custom element code in the web page, we can insert
    `<x-converter/>` tags into the code, as if they are part of standard HTML. In
    our example, we are also passing a `currency` property to the underlying Preact
    component.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在网页中包含了自定义元素代码，我们可以像将其作为标准 HTML 的一部分一样插入 `<x-converter/>` 标签。在我们的示例中，我们还向底层
    Preact 组件传递了一个 `currency` 属性。
- en: Custom element properties are passed to the underlying component with lowercase
    names, regardless of how we define them in the HTML.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们在 HTML 中如何定义它们，自定义元素属性都以小写名称传递给底层组件。
- en: We can run this page through a web server, separate from the Preact server.
    [Figure 1-10](ch01_split_000.xhtml#ch01_image_10) shows the new custom element.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过一个独立于 Preact 服务器的 Web 服务器运行此页面。[图 1-10](ch01_split_000.xhtml#ch01_image_10)
    显示了新的自定义元素。
- en: '![](Images/recb_0110.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_0110.png)'
- en: Figure 1-10\. The custom element embedded in a static page
  id: totrans-256
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-10\. 嵌入静态页面中的自定义元素
- en: Discussion
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The custom element does not need to be on the same server as the web page that
    uses it, which means that we can use custom elements to publish widgets for any
    web page. Because of this, you might want to check the `Referer` header on any
    incoming request to the component to prevent any unauthorized usage.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义元素不需要与使用它的网页位于同一服务器上，这意味着我们可以使用自定义元素为任何网页发布小部件。因此，您可能希望检查任何传入请求的 `Referer`
    标头，以防止未经授权的使用。
- en: Our example is serving the custom element from Preact’s development server.
    For a production release, you would probably want to create a static build of
    the component, which will likely be significantly smaller.^([8](ch01_split_001.xhtml#idm46634432733768))
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例是从 Preact 的开发服务器提供自定义元素。对于生产发布，您可能希望创建组件的静态构建，这可能会显著减小体积。^([8](ch01_split_001.xhtml#idm46634432733768))
- en: You can download the source for this recipe from the [GitHub site](https://oreil.ly/aB7BP).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 [GitHub 网站](https://oreil.ly/aB7BP) 下载此示例的源代码。
- en: Use Storybook for Component Development
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Storybook 进行组件开发
- en: Problem
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: React components are the stable building material of React applications. If
    we write them carefully, we can reuse the components in other React applications.
    But when you build a component, it takes work to check how it works in all circumstances.
    For example, in an asynchronous application, React might render the component
    with undefined properties. Will the component still render correctly? Will it
    show errors?
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: React 组件是 React 应用程序的稳定构建材料。如果我们仔细编写它们，就可以在其他 React 应用程序中重用这些组件。但是当你构建一个组件时，需要检查它在所有情况下的工作情况。例如，在异步应用程序中，React
    可能会使用未定义的属性渲染组件。组件仍然会正确渲染吗？会显示错误吗？
- en: But if you are building components as part of a complex application, it can
    be tough to create all of the situations with which your component will need to
    cope.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您正在构建复杂应用程序的组件，可能很难创建组件需要处理的所有情况。
- en: Also, if you have specialized user experience (UX) developers working on your
    team, it can waste a lot of time if they have to navigate through an application
    to view the single component they have in development.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，如果您的团队中有专门的用户体验（UX）开发人员，如果他们必须浏览整个应用程序才能查看正在开发的单个组件，那将浪费很多时间。
- en: It would be helpful if there were some way of displaying a component in isolation
    and passing it example sets of properties.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一种方法可以独立显示组件并传递示例属性集，那将会很有帮助。
- en: Solution
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Storybook is a tool for displaying libraries of components in various states.
    You could describe it as a gallery for components, but that’s probably selling
    it short. In reality, Storybook is a tool for component development.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Storybook 是一种用于显示各种状态下组件库的工具。您可以将其描述为组件的画廊，但这可能有点贬低它。实际上，Storybook 是一个用于组件开发的工具。
- en: 'How do we add Storybook to a project? Let’s begin by creating a React application
    with `create-react-app`:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如何将 Storybook 添加到项目中？让我们从使用 `create-react-app` 创建一个 React 应用程序开始：
- en: '[PRE49]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now we can add Storybook to the project:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将 Storybook 添加到项目中：
- en: '[PRE50]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We then start the Storybook server with `yarn` or `npm`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `yarn` 或 `npm` 启动 Storybook 服务器：
- en: '[PRE51]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Storybook runs a separate server on port 9000, as you can see in [Figure 1-11](ch01_split_001.xhtml#ch01_image_11).
    When you use Storybook, there is no need to run the actual React application.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Storybook 在 9000 端口上运行一个单独的服务器，如您在 [Figure 1-11](ch01_split_001.xhtml#ch01_image_11)
    中所见。使用 Storybook 时，无需运行实际的 React 应用程序。
- en: '![](Images/recb_0111.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_0111.png)'
- en: Figure 1-11\. The welcome page in Storybook
  id: totrans-277
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 1-11\. Storybook 的欢迎页面
- en: 'Storybook calls a single component rendered with example properties a *story*.
    The default installation of Storybook generates sample stories in the *src/stories*
    directory of the application. For example, this is *src/stories/Button.stories.js*:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Storybook 将用示例属性呈现的单个组件称为 *story*。Storybook 的默认安装在应用程序的 *src/stories* 目录中生成示例故事。例如，*src/stories/Button.stories.js*：
- en: '[PRE52]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Storybook watches for files named **.stories.js* in your source folder, and
    it doesn’t care where they are, so you are free to create them where you like.
    One typical pattern places the stories in a folder alongside the component they
    are showcasing. So if you copy the folder to a different application, you can
    include stories as living documentation.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Storybook 监视源文件夹中命名为 **.stories.js* 的文件，并不关心它们的位置，因此您可以自由地在喜欢的位置创建它们。一个典型的模式是将故事放在与其展示的组件相邻的文件夹中。因此，如果您将文件夹复制到不同的应用程序中，可以将故事作为活动文档包含在内。
- en: '[Figure 1-12](ch01_split_001.xhtml#ch01_image_12) shows what *Button.stories.js*
    looks like in Storybook.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '[Figure 1-12](ch01_split_001.xhtml#ch01_image_12) 显示了在 Storybook 中 *Button.stories.js*
    的外观。'
- en: '![](Images/recb_0112.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_0112.png)'
- en: Figure 1-12\. An example story
  id: totrans-283
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 1-12\. 一个示例故事
- en: Discussion
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Despite its simple appearance, Storybook is a productive development tool. It
    allows you to focus on one component at a time. Like a kind of visual unit test,
    it enables you to try a component in a series of possible scenarios to check that
    it behaves appropriately.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管其看起来简单，但 Storybook 是一个高效的开发工具。它允许您一次专注于一个组件。就像一种视觉单元测试，它使您能够在一系列可能的场景中尝试组件，以检查其行为是否适当。
- en: Storybook also has a large selection of additional [add-ons](https://oreil.ly/3kSVa).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: Storybook 还拥有大量额外的 [插件](https://oreil.ly/3kSVa)。
- en: 'The add-ons allow you to:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 插件允许您：
- en: Check for accessibility problems (*addon-a11y*)
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查无障碍问题（*addon-a11y*）
- en: Add interactive controls for setting properties (*Knobs*)
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加用于设置属性的交互式控件（*Knobs*）
- en: Include inline documentation for each story (*Docs*)
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个故事包含内联文档（*Docs*）
- en: Record snapshots of the HTML to test the impact of changes (*Storyshots*)
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录 HTML 的快照以测试更改的影响（*Storyshots*）
- en: And do much more.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以做更多事情。
- en: For further information about Storybook, see [the website](https://storybook.js.org).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多关于 Storybook 的信息，请访问 [该网站](https://storybook.js.org)。
- en: You can download the source for this recipe from the [GitHub site](https://oreil.ly/GyxTX).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 [GitHub 站点](https://oreil.ly/GyxTX) 下载此示例的源代码。
- en: Test Your Code in a Browser with Cypress
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Cypress 在浏览器中测试您的代码
- en: Problem
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Most React projects include a testing library. The most common is probably `@testing-library/react`,
    which comes bundled with `create-react-app`, or Enzyme, which is used by Preact.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 React 项目都包含一个测试库。最常见的可能是 `@testing-library/react`，它与 `create-react-app`
    捆绑在一起，或者是 Preact 使用的 Enzyme。
- en: But nothing quite beats testing code in a real browser, with all the additional
    complications that entails. Traditionally, browser testing can be unstable and
    requires frequent maintenance as you need to upgrade browser drivers (such as
    ChromeDriver) every time you upgrade the browser.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 但是没有什么比在真实浏览器中测试代码更好，因为那会带来额外的复杂性。传统上，浏览器测试可能会不稳定，并且需要频繁维护，因为您需要每次升级浏览器时升级浏览器驱动程序（如
    ChromeDriver）。
- en: Add to that the issue of generating test data on a backend server, and browser-based
    testing can be complex to set up and manage.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 加上在后端服务器上生成测试数据的问题，基于浏览器的测试可能会复杂设置和管理。
- en: Solution
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: The [Cypress testing framework](https://www.cypress.io) avoids many of the downsides
    of traditional browser testing. It runs in a browser but avoids the need for an
    external web-driver tool. Instead, it communicates directly with a browser, like
    Chrome or Electron, over a network port and then injects JavaScript to run much
    of the test code.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '[Cypress 测试框架](https://www.cypress.io) 避免了传统浏览器测试的许多缺点。它在浏览器中运行，但避免了使用外部的 Web
    驱动程序工具。相反，它通过网络端口直接与浏览器（如 Chrome 或 Electron）通信，然后注入 JavaScript 来运行大部分测试代码。'
- en: 'Let’s create an application `create-react-app` to see how it works:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个 `create-react-app` 应用程序，看看它是如何工作的：
- en: '[PRE53]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now let’s go into the app directory and install Cypress:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们进入应用程序目录并安装Cypress：
- en: '[PRE54]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Before we run Cypress, we need to configure it so that it knows how to find
    our application. We can do this by creating a *cypress.json* file in the application
    directory and telling it the uniform resource locator (URL) of our app:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行Cypress之前，我们需要配置它，以便它知道如何找到我们的应用程序。我们可以通过在应用程序目录中创建一个*cypress.json*文件，并告诉它我们应用程序的统一资源定位器（URL）来实现这一点：
- en: '[PRE55]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Once we have started the main application:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们启动了主应用程序：
- en: '[PRE56]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'we can then open Cypress:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以打开Cypress：
- en: '[PRE57]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The first time you run Cypress, it will install all the dependencies it needs.
    We’ll now create a test in the *cypress/integration* directory called *screenshot.js*,
    which opens the home page and takes a screenshot:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行Cypress时，它会安装所有需要的依赖项。现在我们将在*cypress/integration*目录下创建一个名为*screenshot.js*的测试，它将打开首页并截图：
- en: '[PRE58]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: You’ll notice that we wrote the tests in Jest format. Once you save the test,
    it will appear in the main Cypress window, shown in [Figure 1-13](ch01_split_001.xhtml#ch01_image_13).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们以Jest格式编写了测试。保存测试后，它将显示在主Cypress窗口中，如[图1-13](ch01_split_001.xhtml#ch01_image_13)所示。
- en: '![](Images/recb_0113.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_0113.png)'
- en: Figure 1-13\. The Cypress window
  id: totrans-316
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-13. Cypress窗口
- en: If you double-click the test, Cypress will run it in a browser. The front page
    of the application will open, and the test will save a screenshot to *cypress/screenshots/screenshot.js/frontpage.png*.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果双击测试，Cypress将在浏览器中运行它。应用程序的首页将打开，并且测试将保存一个截图到*cypress/screenshots/screenshot.js/frontpage.png*。
- en: Discussion
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Here are some example commands you can perform with Cypress:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是您可以在Cypress中执行的一些示例命令：
- en: '| Command | Description |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 描述 |'
- en: '| --- | --- |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `cy.contains(''Fred'')` | Finds the element containing *`Fred`* |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| `cy.contains(''Fred'')` | 查找包含*`Fred`*的元素 |'
- en: '| `cy.get(''.Norman'').click()` | Clicks the element with class *`Norman`*
    |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| `cy.get(''.Norman'').click()` | 单击具有类*`Norman`*的元素 |'
- en: '| `cy.get(''input'').type(''Hi!'')` | Types `"Hi!"` into the input field |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| `cy.get(''input'').type(''Hi!'')` | 在输入框中键入`"Hi!"` |'
- en: '| `cy.get(''h1'').scrollIntoView()` | Scrolls the `<h1/>` into view |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| `cy.get(''h1'').scrollIntoView()` | 滚动`<h1/>`到视图中 |'
- en: These are just some of the commands that interact with the web page. But Cypress
    has another trick up its sleeve. Cypress can also modify the code inside the browser
    to change the time (`cy.clock()`), the cookies (`cy.setCookie()`), the local storage
    (`cy.clearLocalStorage()`) and—most impressively—fake requests and responses to
    an API server.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是与网页交互的一些命令。但是Cypress还有另一个绝招。Cypress还可以修改浏览器内部的代码以更改时间（`cy.clock()`）、cookies（`cy.setCookie()`）、本地存储（`cy.clearLocalStorage()`）和最令人印象深刻的是伪造请求和响应到API服务器。
- en: 'It does this by modifying the networking functions that are built into the
    browser so that this code:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过修改内置在浏览器中的网络功能来实现这一点，使得这段代码：
- en: '[PRE59]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'will intercept any requests to a server endpoint beginning */api/server?* and
    return the JSON array `[{some: ''Data''}]`.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '将拦截任何以/api/server?开头的服务器端点的请求，并返回JSON数组`[{some: ''Data''}]`。'
- en: Simulating network responses can completely change the way teams develop applications
    because it decouples the frontend development from the backend. The browser tests
    can specify what data they need without having to create a real server and database.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟网络响应可以彻底改变团队开发应用程序的方式，因为它将前端开发与后端解耦。浏览器测试可以指定它们所需的数据，而无需创建真实的服务器和数据库。
- en: To learn more about Cypress, visit the [documentation site](https://oreil.ly/eX09t).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于Cypress的信息，请访问[文档站点](https://oreil.ly/eX09t)。
- en: You can download the source for this recipe from the [GitHub site](https://oreil.ly/3j8vI).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[GitHub网站](https://oreil.ly/3j8vI)下载此配方的源代码。
- en: ^([1](ch01_split_000.xhtml#idm46634434661000-marker)) And yes, this means that
    Gatsby has TypeScript support built-in.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch01_split_000.xhtml#idm46634434661000-marker)) 是的，这意味着Gatsby内置了对TypeScript的支持。
- en: ^([2](ch01_split_000.xhtml#idm46634434658632-marker)) You can do this in most
    operating systems by pressing Ctrl-C.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch01_split_000.xhtml#idm46634434658632-marker)) 大多数操作系统按Ctrl-C即可完成此操作。
- en: ^([3](ch01_split_000.xhtml#idm46634434578328-marker)) The name is intentionally
    similar to `create-react-app`. The maintainer of Razzle, Jared Palmer, lists `create-react-app`
    as one of the inspirations for Razzle.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch01_split_000.xhtml#idm46634434578328-marker)) 名称有意与`create-react-app`相似。Razzle的维护者Jared
    Palmer将`create-react-app`列为Razzle的灵感之一。
- en: ^([4](ch01_split_000.xhtml#idm46634434328376-marker)) See [“Build Content-Rich
    Apps with Gatsby”](ch01_split_000.xhtml#ch01-02).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch01_split_000.xhtml#idm46634434328376-marker)) 参见[“使用Gatsby构建内容丰富的应用程序”](ch01_split_000.xhtml#ch01-02)。
- en: ^([5](ch01_split_000.xhtml#idm46634434199464-marker)) See Recipes [1.2](ch01_split_000.xhtml#ch01-02)
    and [1.3](ch01_split_000.xhtml#ch01-03).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch01_split_000.xhtml#idm46634434199464-marker)) 查看配方 [1.2](ch01_split_000.xhtml#ch01-02)
    和 [1.3](ch01_split_000.xhtml#ch01-03)。
- en: ^([6](ch01_split_000.xhtml#idm46634433377096-marker)) For more information on
    creating Preact applications, see [“Create a Tiny App with Preact”](ch01_split_000.xhtml#ch01-05).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch01_split_000.xhtml#idm46634433377096-marker)) 欲了解如何创建 Preact 应用程序的更多信息，请参阅
    [“使用 Preact 创建微型应用”](ch01_split_000.xhtml#ch01-05)。
- en: ^([7](ch01_split_000.xhtml#idm46634433284040-marker)) See the [WHATWG specification](https://oreil.ly/KOjmP)
    for further details on custom elements and naming conventions.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch01_split_000.xhtml#idm46634433284040-marker)) 参阅 [WHATWG 规范](https://oreil.ly/KOjmP)
    了解自定义元素和命名约定的详细信息。
- en: ^([8](ch01_split_000.xhtml#idm46634432733768-marker)) For further details on
    shrinking Preact downloads, see [“Create a Tiny App with Preact”](ch01_split_000.xhtml#ch01-05).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch01_split_000.xhtml#idm46634432733768-marker)) 进一步了解如何缩小 Preact 的下载量，请参阅
    [“使用 Preact 创建微型应用”](ch01_split_000.xhtml#ch01-05)。
