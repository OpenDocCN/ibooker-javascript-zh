- en: 'Chapter 2\. TypeScript: A 10_000 Foot View'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 TypeScript：一个 10_000 英尺视角
- en: Over the next few chapters, I’ll introduce the TypeScript language, give you
    an overview of how the TypeScript Compiler (TSC) works, and take you on a tour
    of TypeScript’s features and the patterns you can develop with them. We’ll start
    with the compiler.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几章中，我将介绍 TypeScript 语言，向你概述 TypeScript 编译器（TSC）的工作原理，并带你游览 TypeScript 的特性及你可以开发的模式。我们将从编译器开始。
- en: The Compiler
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译器
- en: Depending on what programming languages you worked with in the past (that is,
    before you decided to buy this book and commit to a life of type safety), you’ll
    have a different understanding of how programs work. The way TypeScript works
    is unusual compared to other mainstream languages like JavaScript or Java, so
    it’s important that we’re on the same page before we go any further.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你过去使用的编程语言（也就是，在你决定购买这本书并致力于类型安全生活之前），你对程序如何工作有不同的理解。TypeScript 的工作方式与其他主流语言（如
    JavaScript 或 Java）相比是不同寻常的，因此在我们继续深入之前，我们达成共识是很重要的。
- en: 'Let’s start broad: programs are files that contain a bunch of text written
    by you, the programmer. That text is parsed by a special program called a *compiler*,
    which transforms it into an *abstract syntax tree (AST)*, a data structure that
    ignores things like whitespace, comments, and where you stand on the tabs versus
    spaces debate. The compiler then converts that AST to a lower-level representation
    called *bytecode*. You can feed that bytecode into another program called a *runtime*
    to evaluate it and get a result. So when you run a program, what you’re really
    doing is telling the runtime to evaluate the bytecode generated by the compiler
    from the AST parsed from your source code. The details vary, but for most languages
    this is an accurate high-level view.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从广义上开始：程序是由你，程序员，编写的一堆文本组成的文件。这些文本被一个称为*编译器*的特殊程序解析，将其转换为*抽象语法树（AST）*，这是一种数据结构，忽略像空格、注释以及你在制表符与空格之争中站在哪一边这样的事物。编译器然后将该
    AST 转换为称为*字节码*的低级表示。你可以将该字节码提供给另一个称为*运行时*的程序来评估它并获得结果。因此，当你运行一个程序时，你实际上是告诉运行时评估由编译器从你的源代码解析的
    AST 生成的字节码。细节有所不同，但对于大多数语言来说，这是一个准确的高层视图。
- en: 'Once again, the steps are:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这些步骤是：
- en: Program is parsed into an AST.
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序被解析成一个 AST。
- en: AST is compiled to bytecode.
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: AST 被编译成字节码。
- en: Bytecode is evaluated by the runtime.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字节码由运行时评估。
- en: Where TypeScript is special is that instead of compiling straight to bytecode,
    TypeScript compiles to… JavaScript code! You then run that JavaScript code like
    you normally would—in your browser, or with NodeJS, or by hand with a paper and
    pen (for anyone reading this after the machine uprising has begun).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 的特殊之处在于，它不是直接编译成字节码，而是编译成…… JavaScript 代码！然后你像平常一样运行那些 JavaScript
    代码——在你的浏览器里，或者用 NodeJS，或者用纸和笔手动输入（针对那些在机器起义后阅读本文的人）。
- en: 'At this point you may be thinking: “Wait! In the last chapter you said TypeScript
    makes my code safer! When does that happen?”'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能会想：“等等！在上一章中你说 TypeScript 让我的代码更安全！那是什么时候发生的？”
- en: 'Great question. I actually skipped over a crucial step: after the TypeScript
    Compiler generates an AST for your program—but before it emits code—it *typechecks*
    your code.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 很好的问题。我实际上跳过了一个关键步骤：在 TypeScript 编译器为你的程序生成 AST 之后——但在它发出代码之前——它会*类型检查*你的代码。
- en: This typechecking is the magic behind TypeScript. It’s how TypeScript makes
    sure that your program works as you expect, that there aren’t obvious mistakes,
    and that the cute barista across the street really will call you back when they
    said they would. (Don’t worry, they’re probably just busy.)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型检查是 TypeScript 背后的魔力。这是 TypeScript 确保你的程序按照你的期望工作的方式，没有明显错误，并且当街对面可爱的咖啡师确实会在约定时间打电话给你的方式。（别担心，他们可能只是忙着。）
- en: 'So if we include typechecking and JavaScript emission, the process of compiling
    TypeScript now looks roughly like [Figure 2-1](#ch02-compilation-pipeline):'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们包括类型检查和 JavaScript 生成，现在编译 TypeScript 的过程大致如[Figure 2-1](#ch02-compilation-pipeline)所示：
- en: '![prts 0201](assets/prts_0201.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![prts 0201](assets/prts_0201.png)'
- en: Figure 2-1\. Compiling and running TypeScript
  id: totrans-15
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-1\. 编译和运行 TypeScript
- en: Steps 1–3 are done by TSC, and steps 4–6 are done by the JavaScript runtime
    that lives in your browser, NodeJS, or whatever JavaScript engine you’re using.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤 1–3 由 TSC 完成，步骤 4–6 由你的浏览器、NodeJS，或者你使用的任何 JavaScript 引擎中的 JavaScript 运行时完成。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: JavaScript compilers and runtimes tend to be smushed into a single program called
    an *engine*; as a programmer, this is what you’ll normally interact with. It’s
    how V8 (the engine powering NodeJS, Chrome, and Opera), SpiderMonkey (Firefox),
    JSCore (Safari), and Chakra (Edge) work, and it’s what gives JavaScript the appearance
    of being an *interpreted* language.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的编译器和运行时通常被整合成一个称为*引擎*的单一程序；作为程序员，这是你通常会交互的东西。这是 V8（驱动 NodeJS、Chrome
    和 Opera 的引擎）、SpiderMonkey（Firefox）、JSCore（Safari）和 Chakra（Edge）的工作方式，它也是 JavaScript
    看起来像是*解释*语言的原因。
- en: 'In this process, steps 1–2 use your program’s types; step 3 does not. That’s
    worth reiterating: *when TSC compiles your code from TypeScript to JavaScript,
    it won’t look at your types*. That means your program’s types will never affect
    your program’s generated output, and are only used for typechecking. This feature
    makes it foolproof to play around with, update, and improve your program’s types,
    without risking breaking your application.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，步骤 1–2 使用了你程序的类型；步骤 3 则没有。这值得重申：*当 TSC 将你的 TypeScript 代码编译成 JavaScript
    时，它不会查看你的类型*。这意味着你程序的类型永远不会影响到生成的输出，并且只用于类型检查。这个特性使得可以轻松地玩耍、更新和改进你的程序类型，而不会危及到你的应用程序。
- en: The Type System
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型系统
- en: Modern languages have all sorts of different *type systems*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现代语言有各种不同的*类型系统*。
- en: 'There are generally two kinds of type systems: type systems in which you have
    to tell the compiler what type everything is with explicit syntax, and type systems
    that infer the types of things for you automatically. Both approaches have trade-offs.^([1](ch02.html#idm46304995709880))'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通常有两种类型系统：一种需要使用显式语法告诉编译器每个东西的类型，另一种则会自动为你推断东西的类型。这两种方法都有权衡之处。^([1](ch02.html#idm46304995709880))
- en: 'TypeScript is inspired by both kinds of type systems: you can explicitly annotate
    your types, or you can let TypeScript infer most of them for you.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 同时受到这两种类型系统的启发：你可以显式注释你的类型，也可以让 TypeScript 大部分时间为你推断类型。
- en: 'To explicitly signal to TypeScript what your types are, use annotations. Annotations
    take the form *value: type* and tell the typechecker, “Hey! You see this *value*
    here? Its type is *type*.” Let’s look at a few examples (the comments following
    each line are the actual types inferred by TypeScript):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '要明确告诉 TypeScript 你的类型是什么，请使用注释。注释的形式是*值: 类型*，并告诉类型检查器，“嘿！你看见这里的*值*吗？它的类型是*类型*。”让我们看几个例子（每行后面的注释是
    TypeScript 推断的实际类型）：'
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And if you want TypeScript to infer your types for you, just leave them off
    and let TypeScript get to work:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望 TypeScript 为你推断类型，只需省略它们，让 TypeScript 自动处理即可：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Right away, you’ll notice how good TypeScript is at inferring types for you.
    If you leave off the annotations, the types are the same! Throughout this book,
    we will use annotations only when necessary, and let TypeScript work its inference
    magic for us whenever possible.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 立即你就会注意到 TypeScript 在为你推断类型方面的出色表现。如果你省略了注释，类型是相同的！在本书中，我们将仅在必要时使用注释，并尽可能让 TypeScript
    发挥其推断的魔力。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In general, it is good style to let TypeScript infer as many types as it can
    for you, keeping explicitly typed code to a minimum.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，让 TypeScript 尽可能多地为你推断类型是一种良好的风格，将显式类型代码保持到最小。
- en: TypeScript Versus JavaScript
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TypeScript 与 JavaScript 比较
- en: Let’s take a deeper look at TypeScript’s type system, and how it compares to
    JavaScript’s type system. [Table 2-1](#comparing-type-systems) presents an overview.
    A good understanding of the differences is key to building a mental model of how
    TypeScript works.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解 TypeScript 的类型系统，以及它与 JavaScript 的类型系统的比较。[表 2-1](#comparing-type-systems)
    提供了一个概述。了解这些差异对于建立 TypeScript 工作方式的心理模型至关重要。
- en: Table 2-1\. Comparing JavaScript’s and TypeScript’s type systems
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-1\. 比较 JavaScript 和 TypeScript 的类型系统
- en: '| Type system feature | JavaScript | TypeScript |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 类型系统特性 | JavaScript | TypeScript |'
- en: '| --- | --- | --- |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **How are types bound?** | Dynamically | Statically |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| **类型如何绑定？** | 动态地 | 静态地 |'
- en: '| **Are types automatically converted?** | Yes | No (mostly) |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| **类型是否自动转换？** | 是 | 否（大多数情况下） |'
- en: '| **When are types checked?** | At runtime | At compile time |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| **类型何时检查？** | 在运行时 | 在编译时 |'
- en: '| **When are errors surfaced?** | At runtime (mostly) | At compile time (mostly)
    |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| **错误何时暴露？** | 在运行时（大多数情况下） | 在编译时（大多数情况下） |'
- en: How are types bound?
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型如何绑定？
- en: Dynamic type binding means that JavaScript needs to actually run your program
    to know the types of things in it. JavaScript doesn’t know your types before running
    your program.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 动态类型绑定意味着JavaScript需要实际运行你的程序才能知道其中的各种类型。JavaScript在运行你的程序之前并不知道你的类型。
- en: TypeScript is a *gradually typed* language. That means that TypeScript works
    best when it knows the types of everything in your program at compile time, but
    it doesn’t have to know every type in order to compile your program. Even in an
    untyped program TypeScript can infer some types for you and catch some mistakes,
    but without knowing the types for everything, it will let a lot of mistakes slip
    through to your users.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 是一种*逐渐类型化*的语言。这意味着在编译时，TypeScript 最擅长于了解程序中所有内容的类型，但并不需要了解所有类型就能编译你的程序。即使在未类型化的程序中，TypeScript
    也可以为你推断一些类型并捕捉一些错误，但如果不了解程序中所有内容的类型，它将让许多错误传递给用户。
- en: This gradual typing is really useful for migrating legacy codebases from untyped
    JavaScript to typed TypeScript (more on that in [“Gradually Migrating from JavaScript
    to TypeScript”](ch11.html#migrating-to-typescript)), but unless you’re in the
    middle of migrating your codebase, you should aim for 100% type coverage. That
    is the approach this book takes, except where explicitly noted.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这种逐渐类型化对于将未类型化的JavaScript遗留代码库迁移到类型化的TypeScript中非常有用（详见[“逐步从JavaScript迁移到TypeScript”](ch11.html#migrating-to-typescript)），但除非你正在迁移代码库，否则应该力求100%的类型覆盖率。这本书的方法是如此，除非特别注明。
- en: Are types automatically converted?
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型是否会自动转换？
- en: 'JavaScript is weakly typed, meaning if you do something invalid like add a
    number and an array (like we did in [Chapter 1](ch01.html#intro)), it will apply
    a bunch of rules to figure out what you really meant so it can do the best it
    can with what you gave it. Let’s walk through the specific example of how JavaScript
    evaluates `3 + [1]`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是弱类型语言，这意味着如果你做了一些无效的事情，比如将一个数字和一个数组相加（就像我们在[第1章](ch01.html#intro)中做的那样），它会应用一系列规则来弄清楚你的真实意图，以便尽可能有效地处理你给它的内容。让我们通过具体的例子来解释JavaScript如何评估`3
    + [1]`：
- en: JavaScript notices that `3` is a number and `[1]` is an array.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JavaScript注意到`3`是一个数字，`[1]`是一个数组。
- en: Because we’re using `+`, it assumes we want to concatenate the two.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为我们使用了`+`，它假设我们想要连接这两个值。
- en: It implicitly converts `3` to a string, yielding `"3"`.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将`3`隐式转换为字符串，得到`"3"`。
- en: It implicitly converts `[1]` to a string, yielding `"1"`.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将`[1]`隐式转换为字符串，得到`"1"`。
- en: It concatenates the results, yielding `"31"`.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它连接这些结果，得到`"31"`。
- en: 'We could do this more explicitly too (so JavaScript avoids doing steps 1, 3,
    and 4):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以更加显式地做这件事情（这样JavaScript就避免了步骤1、3和4）：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'While JavaScript tries to be helpful by doing clever type conversions for you,
    TypeScript complains as soon as you do something invalid. When you run that same
    JavaScript code through TSC, you’ll get an error:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管JavaScript试图通过为你进行巧妙的类型转换来帮助你，但TypeScript会在你做出无效操作时立即抱怨。当你通过TSC运行同样的JavaScript代码时，你会得到一个错误：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you do something that doesn’t seem right, TypeScript complains, and if you’re
    explicit about your intentions, TypeScript gets out of your way. This behavior
    makes sense: who in their right mind would try to add a number and an array, expecting
    the result to be a string (of course, besides Bavmorda the JavaScript witch who
    spends her time coding by candlelight in your startup’s basement)?'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你做了什么看起来不对的事情，TypeScript会抱怨；如果你对自己的意图表达明确，TypeScript会离开你的道路。这种行为是有道理的：在正常情况下，除了JavaScript女巫Bavmorda之外（她在你创业公司的地下室里点蜡烛编程），谁会试图将一个数字和一个数组相加，期望结果是一个字符串呢？
- en: The kind of implicit conversion that JavaScript does can be a really hard-to-track-down
    source of errors, and is the bane of many JavaScript programmers. It makes it
    hard for individual engineers to get their jobs done, and it makes it even harder
    to scale code across a large team, since every engineer needs to understand the
    implicit assumptions your code makes.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript进行的这种隐式转换可能是错误的一个难以追踪的来源，也是许多JavaScript程序员的噩梦。它让单个工程师难以完成工作，也让整个团队更难以扩展代码，因为每个工程师都需要理解你的代码所做的隐含假设。
- en: In short, if you must convert types, do it explicitly.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，如果必须进行类型转换，请显式地进行。
- en: When are types checked?
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么时候检查类型？
- en: In most places JavaScript doesn’t care what types you give it, and it instead
    tries to do its best to convert what you gave it to what it expects.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，JavaScript并不关心你给它什么类型，而是尽量将你给它的内容转换为它期望的内容。
- en: TypeScript, on the other hand, typechecks your code at compile time (remember
    step 2 in the list at the beginning of this chapter?), so you don’t need to actually
    run your code to see the `Error` from the previous example. TypeScript *statically
    analyzes* your code for errors like these, and shows them to you before you run
    it. If your code doesn’t compile, that’s a really good sign that you made a mistake
    and you should fix it before you try to run the code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，TypeScript 在编译时检查你的代码（记住本章开头的步骤2），因此你无需实际运行代码就能看到前面示例中的`Error`。TypeScript
    *静态分析* 你的代码以检测此类错误，并在运行之前展示给你。如果你的代码无法编译，那很可能是你犯了错误，应该在运行代码之前修复它。
- en: '[Figure 2-2](#ch02-ide-error) shows what happens when I type the last code
    example into VSCode (my code editor of choice).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-2](#ch02-ide-error) 展示了当我将最后一个代码示例输入到 VSCode（我首选的代码编辑器）时会发生什么。'
- en: '![prts 0202](assets/prts_0202.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![prts 0202](assets/prts_0202.png)'
- en: Figure 2-2\. TypeError reported by VSCode
  id: totrans-63
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-2\. VSCode 报告的 TypeError
- en: With a good TypeScript extension for your preferred code editor, the error will
    show up as a red squiggly line under your code *as you type it*. This dramatically
    speeds up the feedback loop between writing code, realizing that you made a mistake,
    and updating the code to fix that mistake.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你喜欢的代码编辑器安装好 TypeScript 扩展后，当你**输入代码**时，错误将以红色的波浪线显示出来。这显著加快了编写代码、意识到错误并更新代码以修复错误之间的反馈循环。
- en: When are errors surfaced?
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误会在何时显示？
- en: When JavaScript throws exceptions or performs implicit type conversions, it
    does so at runtime.^([2](ch02.html#idm46304990806104)) This means you have to
    actually run your program to get a useful signal back that you did something invalid.
    In the best case, that means as part of a unit test; in the worst case, it means
    an angry email from a user.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当 JavaScript 抛出异常或执行隐式类型转换时，这是在运行时进行的。^([2](ch02.html#idm46304990806104)) 这意味着你必须实际运行程序才能得到一个有用的信号，表明你做了一些无效操作。在最好的情况下，这意味着作为单元测试的一部分；在最坏的情况下，这意味着用户的一封愤怒的电子邮件。
- en: TypeScript throws both syntax-related errors and type-related errors at compile
    time. In practice, that means those kinds of errors will show up in your code
    editor, right as you type—it’s an amazing experience if you’ve never worked with
    an incrementally compiled statically typed language before.^([3](ch02.html#idm46304990802632))
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 在编译时抛出与语法相关的错误和类型相关的错误。在实际操作中，这意味着这些类型的错误将在你输入代码时立即在代码编辑器中显示出来——如果你以前从未使用过增量编译的静态类型语言，这将是一种令人惊叹的体验。^([3](ch02.html#idm46304990802632))
- en: That said, there are lots of errors that TypeScript can’t catch for you at compile
    time—things like stack overflows, broken network connections, and malformed user
    inputs—that will still result in runtime exceptions. What TypeScript does is make
    compile-time errors out of most errors that would have otherwise been runtime
    errors in a pure JavaScript world.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，TypeScript 仍无法在编译时捕获许多错误，比如堆栈溢出、网络连接中断和用户输入格式错误等，在这些情况下仍会导致运行时异常。TypeScript
    的作用是将在纯 JavaScript 环境中本来会是运行时错误的大多数错误变成编译时错误。
- en: Code Editor Setup
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码编辑器设置
- en: Now that you have some intuition for how the TypeScript Compiler and type system
    work, let’s get your code editor set up so we can start diving into some real
    code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对 TypeScript 编译器和类型系统的工作有了一些直觉，让我们设置你的代码编辑器，开始深入到一些真实的代码中去。
- en: Start by downloading a code editor to write your code in. I like VSCode because
    it provides a particularly nice TypeScript editing experience, but you can also
    use Sublime Text, Atom, Vim, WebStorm, or whatever editor you like. Engineers
    tend to be really picky about IDEs, so I’ll leave it to you to decide. If you
    do want to use VSCode, follow the instructions on the [website](https://code.visualstudio.com/)
    to get it set up.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先下载一个代码编辑器来编写你的代码。我喜欢使用 VSCode，因为它提供了非常好的 TypeScript 编辑体验，但你也可以选择 Sublime Text、Atom、Vim、WebStorm
    或者其他你喜欢的编辑器。工程师们对于集成开发环境非常挑剔，所以选择权留给你来决定。如果你选择使用 VSCode，请按照 [网站](https://code.visualstudio.com/)
    上的说明进行设置。
- en: TSC is itself a command-line application written in TypeScript,^([4](ch02.html#idm46304990765000))
    which means you need NodeJS to run it. Follow the instructions on the official
    NodeJS [website](https://nodejs.org) to get NodeJS up and running on your machine.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: TSC 本身是一个用 TypeScript 编写的命令行应用程序，^([4](ch02.html#idm46304990765000)) 这意味着你需要
    NodeJS 来运行它。请访问官方 NodeJS [网站](https://nodejs.org) 按照指南安装 NodeJS 到你的计算机上。
- en: 'NodeJS comes with NPM, a package manager that you will use to manage your project’s
    dependencies and orchestrate your build. We’ll start by using it to install TSC
    and TSLint (a linter for TypeScript). Start by opening your terminal and creating
    a new folder, then initializing a new NPM project in it:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: NodeJS附带了NPM，一个包管理器，您将使用它来管理项目的依赖项并编排构建过程。我们将从使用它来安装TSC和TSLint（TypeScript的代码检查工具）开始。首先打开您的终端，创建一个新文件夹，然后在其中初始化一个新的NPM项目：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: tsconfig.json
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: tsconfig.json
- en: Every TypeScript project should include a file called *tsconfig.json* in its
    root directory. This *tsconfig.json* is where TypeScript projects define things
    like which files should be compiled, which directory to compile them to, and which
    version of JavaScript to emit.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 每个TypeScript项目都应该在其根目录中包含一个名为*tsconfig.json*的文件。*tsconfig.json*文件用于定义诸如应编译哪些文件、将它们编译到哪个目录以及应生成哪个版本的JavaScript等内容。
- en: 'Create a new file called *tsconfig.json* in your root folder (`touch tsconfig.json`),^([5](ch02.html#idm46304990750392))
    then pop it open in your code editor and give it the following contents:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在根目录中创建一个名为*tsconfig.json*的新文件（`touch tsconfig.json`），然后在代码编辑器中打开它，并给它以下内容：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let’s briefly go over some of those options and what they mean ([Table 2-2](#tsconfig-json-table)):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要介绍一下其中一些选项及其含义（参见[表 2-2](#tsconfig-json-table)）：
- en: Table 2-2\. *tsconfig.json* options
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-2\. *tsconfig.json*选项
- en: '| Option | Description |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| Option | Description |'
- en: '| --- | --- |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `include` | Which folders should TSC look in to find your TypeScript files?
    |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `include` | TypeScript编译器（TSC）应查找哪些文件夹以找到您的TypeScript文件？ |'
- en: '| `lib` | Which APIs should TSC assume exist in the environment you’ll be running
    your code in? This includes things like ES5’s `Function.prototype.bind`, ES2015’s
    `Object.assign`, and the DOM’s `document.querySelector`. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `lib` | TSC应假定在您运行代码的环境中存在哪些API？这包括ES5的`Function.prototype.bind`、ES2015的`Object.assign`以及DOM的`document.querySelector`等内容。
    |'
- en: '| `module` | Which module system should TSC compile your code to (CommonJS,
    SystemJS, ES2015, etc.)? |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `module` | TSC应将您的代码编译到哪种模块系统（CommonJS、SystemJS、ES2015等）？ |'
- en: '| `outDir` | Which folder should TSC put your generated JavaScript code in?
    |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `outDir` | TSC应将生成的JavaScript代码放在哪个文件夹中？ |'
- en: '| `strict` | Be as strict as possible when checking for invalid code. This
    option enforces that all of your code is properly typed. We’ll be using it for
    all of the examples in the book, and you should use it for your TypeScript project
    too. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `strict` | 在检查无效代码时尽可能严格。此选项强制要求所有代码都经过正确类型化。我们将在本书的所有示例中使用它，您在自己的TypeScript项目中也应该使用它。
    |'
- en: '| `target` | Which JavaScript version should TSC compile your code to (ES3,
    ES5, ES2015, ES2016, etc.)? |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `target` | TSC应将您的代码编译到哪个JavaScript版本（ES3、ES5、ES2015、ES2016等）？ |'
- en: These are just a few of the available options—*tsconfig.json* supports dozens
    of options, and new ones are added all the time. You won’t find yourself changing
    these much in practice, besides dialing in the `module` and `target` settings
    when switching to a new module bundler, adding `"dom"` to `lib` when writing TypeScript
    for the browser (you’ll learn more about this in [Chapter 12](ch12.html#typescript-in-production)),
    or adjusting your level of `strict`ness when migrating your existing JavaScript
    code to TypeScript (see [“Gradually Migrating from JavaScript to TypeScript”](ch11.html#migrating-to-typescript)).
    For a complete and up-to-date list of supported options, head over to the official
    documentation on the [TypeScript website](http://bit.ly/2JWfsgY).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是可用选项中的一小部分—*tsconfig.json*支持数十个选项，并且新选项会不断添加。在实际应用中，您通常不会经常更改这些选项，除非在切换到新的模块打包工具时调整`module`和`target`设置，或者在编写面向浏览器的TypeScript时（您将在[第12章](ch12.html#typescript-in-production)中学到更多相关知识），将`"dom"`添加到`lib`时，或者在将现有JavaScript代码逐步迁移到TypeScript时调整`strict`性级别（参见[“逐步从JavaScript迁移到TypeScript”](ch11.html#migrating-to-typescript)）。有关完整和最新支持的选项列表，请访问[TypeScript官方文档](http://bit.ly/2JWfsgY)。
- en: Note that while using a *tsconfig.json* file to configure TSC is handy because
    it lets us check that configuration into source control, you can set most of TSC’s
    options from the command line too. Run `./node_modules/.bin/tsc --help` for a
    list of available command-line options.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然使用*tsconfig.json*文件配置TSC很方便，因为它允许我们将配置纳入源代码控制，但您也可以通过命令行设置大多数TSC选项。运行`./node_modules/.bin/tsc
    --help`以获取可用命令行选项列表。
- en: tslint.json
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: tslint.json
- en: Your project should also have a *tslint.json* file containing your TSLint configuration,
    codifying whatever stylistic conventions you want for your code (tabs versus spaces,
    etc.).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您的项目还应包含一个 *tslint.json* 文件，其中包含您的 TSLint 配置，用于定义您代码的风格约定（制表符与空格等）。
- en: Note
  id: totrans-93
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Using TSLint is optional, but it’s strongly recommend for all TypeScript projects
    to enforce a consistent coding style. Most importantly, it will save you from
    arguing over code style with coworkers during code reviews.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 TSLint 是可选的，但强烈建议所有 TypeScript 项目都使用它来强制执行一致的编码风格。最重要的是，它将在代码审查期间为您节省与同事争论代码风格的时间。
- en: 'The following command will generate a *tslint.json* file with a default TSLint
    configuration:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将生成一个包含默认 TSLint 配置的 *tslint.json* 文件：
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can then add overrides to this to conform with your own coding style. For
    example, my *tslint.json* looks like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以添加覆盖以符合自己的编码风格。例如，我的 *tslint.json* 如下所示：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For the full list of available rules, head over to the [TSLint documentation](https://palantir.github.io/tslint/rules/).
    You can also add custom rules, or install extra presets (like for [ReactJS](https://www.npmjs.com/package/tslint-react)).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取可用规则的完整列表，请转到[TSLint 文档](https://palantir.github.io/tslint/rules/)。您还可以添加自定义规则，或安装额外的预设（比如[ReactJS](https://www.npmjs.com/package/tslint-react)）。
- en: index.ts
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`index.ts`'
- en: 'Now that you’ve set up your *tsconfig.json* and *tslint.json*, create a *src*
    folder containing your first TypeScript file:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经设置好了 *tsconfig.json* 和 *tslint.json*，创建一个包含您的第一个 TypeScript 文件的 *src* 文件夹：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Your project’s folder structure should now look this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您项目的文件夹结构现在应该看起来像这样：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Pop open *src/index.ts* in your code editor, and enter the following TypeScript
    code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码编辑器中打开 *src/index.ts*，并输入以下 TypeScript 代码：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, compile and run your TypeScript code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，编译并运行您的 TypeScript 代码：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you’ve followed all the steps here, your code should run and you should
    see a single log in your console:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您按照这里的所有步骤操作，您的代码应该能够运行，并且您应该在控制台中看到一个单独的日志：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: That’s it—you just set up and ran your first TypeScript project from scratch.
    Nice work!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样——您刚刚从头开始设置并运行了您的第一个 TypeScript 项目。干得好！
- en: Tip
  id: totrans-112
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'Since this might have been your first time setting up a TypeScript project
    from scratch, I wanted to walk through each step so you have a sense for all the
    moving pieces. There are a couple of shortcuts you can take to do this faster
    next time:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这可能是您第一次从头开始设置 TypeScript 项目，我想逐步介绍每个步骤，以便您对所有组成部分有所了解。有几个快捷方式可以帮助您更快地完成这些步骤：
- en: Install [`ts-node`](https://npmjs.org/package/ts-node), and use it to compile
    and run your TypeScript with a single command.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 [`ts-node`](https://npmjs.org/package/ts-node)，并使用它来编译并运行您的 TypeScript，只需一个命令即可。
- en: Use a scaffolding tool like [`typescript-node-starter`](https://github.com/Microsoft/TypeScript-Node-Starter)
    to quickly generate your folder structure for you.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用像 [`typescript-node-starter`](https://github.com/Microsoft/TypeScript-Node-Starter)
    这样的脚手架工具，快速为您生成文件夹结构。
- en: Exercises
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Now that your environment is set up, open up *src/index.ts* in your code editor.
    Enter the following code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的环境已设置好，请在代码编辑器中打开 *src/index.ts*。输入以下代码：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now hover over `a`, `b`, `c`, and `d`, and notice how TypeScript infers the
    types of all your variables for you: `a` is a `number`, `b` is a `number`, `c`
    is an object with a specific shape, and `d` is also a `number` ([Figure 2-3](#ch02-ide-example)).'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将鼠标悬停在 `a`、`b`、`c` 和 `d` 上，并注意 TypeScript 如何为您推断所有变量的类型：`a` 是一个 `number`，`b`
    是一个 `number`，`c` 是具有特定形状的对象，`d` 也是一个 `number`（参见 [图 2-3](#ch02-ide-example)）。
- en: '![prts 0203](assets/prts_0203.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![prts 0203](assets/prts_0203.png)'
- en: Figure 2-3\. TypeScript inferring types for you
  id: totrans-121
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-3\. TypeScript 为您推断类型
- en: 'Play around with your code a bit. See if you can:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 玩弄一下您的代码。看看您是否可以：
- en: Get TypeScript to show a red squiggly when you do something invalid (we call
    this “throwing a `TypeError`“).
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您执行无效操作时，让 TypeScript 显示红色波浪线（我们称之为“抛出 `TypeError`”）。
- en: Read the `TypeError`, and try to understand what it means.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读 `TypeError`，并尝试理解其含义。
- en: Fix the `TypeError` and see the red squiggly disappear.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修复 `TypeError`，并看到红色波浪线消失。
- en: If you’re ambitious, try to write a piece of code that TypeScript is unable
    to infer the type for.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您雄心勃勃，尝试编写一段 TypeScript 无法推断类型的代码片段。
- en: '^([1](ch02.html#idm46304995709880-marker)) There are languages all over this
    spectrum: JavaScript, Python, and Ruby infer types at runtime; Haskell and OCaml
    infer and check missing types at compile time; Scala and TypeScript require some
    explicit types and infer and check the rest at compile time; and Java and C need
    explicit annotations for almost everything, which they check at compile time.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch02.html#idm46304995709880-marker)) 这个谱系上有各种语言：JavaScript、Python 和 Ruby
    在运行时推断类型；Haskell 和 OCaml 在编译时推断并检查缺失的类型；Scala 和 TypeScript 需要一些显式类型，并在编译时推断和检查其余部分；而
    Java 和 C 几乎需要为所有事情都做显式注解，它们在编译时进行检查。
- en: ^([2](ch02.html#idm46304990806104-marker)) To be sure, JavaScript surfaces syntax
    errors and a few select bugs (like multiple `const` declarations with the same
    name in the same scope) after it parses your program, but before it runs it. If
    you parse your JavaScript as part of your build process (e.g., with Babel), you
    can surface these errors at build time.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch02.html#idm46304990806104-marker)) 要确定，JavaScript 在解析你的程序后但在运行前能检测到语法错误和一些特定的错误（例如在相同作用域内多次声明相同名称的
    `const`）。如果在构建过程中解析 JavaScript（例如使用 Babel），你可以在构建时检测到这些错误。
- en: ^([3](ch02.html#idm46304990802632-marker)) Incrementally compiled languages
    can be quickly recompiled when you make a small change, rather than having to
    recompile your whole program (including the parts you didn’t touch).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch02.html#idm46304990802632-marker)) 增量编译的语言可以在你进行小改动时快速重新编译，而不需要重新编译整个程序（包括你没有触及的部分）。
- en: ^([4](ch02.html#idm46304990765000-marker)) This puts TSC in the mystical class
    of compilers known as *self-hosting compilers*, or compilers that compile themselves.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch02.html#idm46304990765000-marker)) 这使得 TSC 属于神秘的编译器类别，称为 *自托管编译器*，或者能够自我编译的编译器。
- en: '^([5](ch02.html#idm46304990750392-marker)) For this exercise, we’re creating
    a *tsconfig.json* manually. When you set up TypeScript projects in the future,
    you can use TSC’s built-in initialize command to generate one for you: `./node_modules/.bin/tsc
    --init`.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch02.html#idm46304990750392-marker)) 对于这个练习，我们手动创建了一个 *tsconfig.json*。在未来设置
    TypeScript 项目时，你可以使用 TSC 内置的初始化命令为你生成一个：`./node_modules/.bin/tsc --init`。
