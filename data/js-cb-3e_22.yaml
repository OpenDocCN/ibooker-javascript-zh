- en: Chapter 18\. Node Modules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第18章 Node 模块
- en: 'One of the great aspects of writing Node.js applications is the built-in modularity
    the environment provides. It’s simple to download and install any number of Node
    modules, and using them is equally simple: just include a single `require()` statement
    naming the module, and you’re off and running.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 编写 Node.js 应用程序的一个重要方面是其内建的模块化环境。下载和安装任意数量的 Node 模块都非常简单，同样简单的是使用它们：只需包含一个 `require()`
    语句来命名模块，然后就可以运行了。
- en: The ease with which the modules can be incorporated is one of the benefits of
    JavaScript *modularization*. Modularizing ensures that external functionality
    is created in such a way that it isn’t dependent on other external functionality,
    a concept known as *loose coupling*. This means I can use a `Foo` module, without
    having to include a `Bar` module, because `Foo` is tightly dependent on having
    `Bar` included.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript *模块化* 的一个好处是模块的轻松集成。模块化确保外部功能被创建的方式不依赖于其他外部功能，这是一种称为 *松耦合* 的概念。这意味着我可以使用
    `Foo` 模块，而不必包含 `Bar` 模块，因为 `Foo` 严重依赖于已经包含的 `Bar`。
- en: 'JavaScript modularization is both a discipline and a contract. The discipline
    comes in having to follow certain mandated criteria in order for external code
    to participate in the module system. The contract is between you, me, and other
    JavaScript developers: we’re following an agreed-on path when we produce (or consume)
    external functionality in a module system, and we all have expectations based
    on the module system.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的模块化既是一种纪律，也是一种契约。纪律在于必须遵循特定的标准，以便外部代码能够参与模块系统。契约是在你、我和其他 JavaScript
    开发人员之间的一种约定：我们在模块系统中生产（或消费）外部功能时，都遵循了一个商定的路径，并且我们都对模块系统有期望。
- en: Note
  id: totrans-4
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: One major dependency on virtually all aspects of application and library management
    and publication is the use of Git, a source control system, and GitHub, an extremely
    popular Git *endpoint*. How Git works and using Git with GitHub are beyond the
    scope of this book. I recommend the *[Git Pocket Guide](http://shop.oreilly.com/product/0636920024972.do)*
    by Richard Silverman (O’Reilly) to get more familiar with Git, and GitHub’s [own
    documentation](https://github.com) for more on using this service.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有应用程序和库管理及发布的一个主要依赖是 Git，一个源代码控制系统，以及 GitHub，一个非常流行的 Git *终点*。Git 的工作原理以及如何在
    GitHub 上使用 Git 超出了本书的范围。我建议阅读 Richard Silverman 的 *[Git Pocket Guide](http://shop.oreilly.com/product/0636920024972.do)*（O’Reilly）来更深入了解
    Git，以及访问 GitHub 的 [官方文档](https://github.com) 以获取更多关于该服务的信息。
- en: Searching for a Specific Node Module via npm
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 npm 搜索特定的 Node 模块
- en: Problem
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You’re creating a Node application and want to use existing modules, but you
    don’t know how to discover them.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您正在创建一个 Node 应用程序，并希望使用现有模块，但不知道如何找到它们。
- en: Solution
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[“Downloading a Package with npm”](ch01.html#installing_npm_package) explains
    how to install packages with npm, Node’s popular package manager (and the glue
    that holds the Node universe together). But you haven’t yet considered how to
    *find* the useful packages that you need in npm’s sprawling registry.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[“使用 npm 下载包”](ch01.html#installing_npm_package) 解释了如何使用 npm 安装包，这是 Node 的流行包管理器（也是维系
    Node 世界的粘合剂）。但是您尚未考虑如何 *查找* 您在 npm 广阔的注册表中需要的有用包。'
- en: 'In most cases, you’ll discover modules via recommendations from your friends
    and codevelopers, but sometimes you need something new. You can search for new
    modules directly at the [npm website](https://www.npmjs.org). You can also use
    the npm command-line interface directly to search for a module. For instance,
    if you’re interested in modules that do something with PDFs, run the following
    search at the command line:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，您会通过朋友和共同开发者的推荐来发现模块，但有时您需要一些新的东西。您可以直接在 [npm 网站](https://www.npmjs.org)
    上搜索新模块。您还可以直接使用 npm 命令行界面来搜索模块。例如，如果您对处理 PDF 的模块感兴趣，可以在命令行中运行以下搜索：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Discussion
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The npm website provides more than just documentation for using npm; it also
    provides an interface for searching for modules. If you access each module’s page
    at npm, you can see how popular the module is, what other modules are dependent
    on it, the license, and other relevant information.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: npm 网站不仅提供了使用 npm 的文档，还提供了一个界面用于搜索模块。如果您访问每个模块在 npm 上的页面，您可以看到模块的流行程度、其它依赖它的模块、许可证以及其他相关信息。
- en: However, you can also search for modules, directly, using npm. The process can
    take a fair amount of time and when it finishes, you’re likely to get a huge number
    of modules in return, especially with a broader topic such as modules that work
    with PDFs.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您也可以直接使用 npm 搜索模块。这个过程可能需要相当长的时间，完成后，您可能会得到大量的模块返回，特别是对于诸如处理 PDF 的模块这样广泛的主题。
- en: 'You can refine the results by listing multiple terms:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过列出多个术语来细化结果：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This query returns a much smaller list of modules, specific to PDF generation.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询返回一个更小的模块列表，专门用于 PDF 生成。
- en: 'Once you do find a module that sounds interesting, you can get detailed information
    about it with:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您找到一个听起来有趣的模块，您可以通过以下方式获取详细信息：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You’ll get useful information from the *package.json* of the module, which can
    tell you what it’s dependent on, who wrote it, and when it was created. We still
    recommend checking out the module’s npm website page and GitHub repository page
    directly. There you’ll be able to determine if the module is being actively maintained,
    get a sense of how popular the module is, review open issues, and look at the
    source code.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您将从模块的 *package.json* 中获得有用的信息，它可以告诉您它依赖于什么，由谁编写的，以及创建时间。我们仍建议直接查看模块的 npm 网站页面和
    GitHub 存储库页面。在那里，您可以确定模块是否正在积极维护，了解模块的受欢迎程度，查看开放的问题，并查看源代码。
- en: Converting Your Library into a Node Module
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将您的库转换为 Node 模块
- en: Problem
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to use one of your libraries in Node.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您想在 Node 中使用您的一个库。
- en: Solution
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Convert the library into a Node module. In Node, each file is treated as a
    module. For example, if the library is a file containing a function stored at
    `/lib/hello.js`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 将库转换为 Node 模块。在 Node 中，每个文件都被视为一个模块。例如，如果库是包含在 `/lib/hello.js` 的函数文件：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can convert it to work as a Node module with the `exports` keyword:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `exports` 关键字将其转换为 Node 模块：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Alternately, can also `export` the function directly:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，也可以直接 `export` 函数：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can then use the module in your application:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以在应用程序中使用该模块：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Discussion
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Node’s default module system is based on CommonJS, which uses three constructs:
    `exports` to define what’s exported from the library, `require()` to include the
    module in the application, and `module`, which includes information about the
    module but also can be used to export a function directly.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Node 的默认模块系统基于 CommonJS，使用三种结构：`exports` 用于定义从库中导出的内容，`require()` 用于在应用程序中包含模块，以及
    `module`，它包含关于模块的信息，但也可用于直接导出函数。
- en: 'If your library returns an object with several functions and data objects,
    you can assign each to the comparably named property on `module.exports`, or you
    could return an object:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的库返回一个带有多个函数和数据对象的对象，则可以将每个分配给`module.exports`上同名属性，或者您可以返回一个对象：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'or:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And then access the object properties directly:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然后直接访问对象属性：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Because the module isn’t installed using npm, and just resides in the directory
    where the application resides, it’s accessed by the file location and name, not
    just the name.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因为该模块未使用 npm 安装，而是仅驻留在应用程序所在的目录中，所以它通过文件位置和名称访问，而不仅仅是名称。
- en: See Also
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: In [“Taking Your Code Across Module Environments”](#creating_compatible_modules),
    we cover how to make sure your library code works in both CommonJS and ECMAScript
    module environments.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [“跨模块环境进行代码转换”](#creating_compatible_modules) 中，我们介绍了如何确保您的库代码在 CommonJS 和
    ECMAScript 模块环境中都能正常工作。
- en: In [“Creating an Installable Node Module”](#creating_installable_node_module),
    we cover how to create an standalone module.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [“创建可安装的 Node 模块”](#creating_installable_node_module) 中，我们介绍了如何创建一个独立的模块。
- en: Taking Your Code Across Module Environments
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨模块环境进行代码转换
- en: Problem
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You’ve written a library that you’d like to share with others, but folks are
    using a variety of Node versions with both CommonJS and ECMAScript modules. How
    can you ensure your library works in all of the various environments?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您编写了一个库，希望与他人分享，但使用各种 Node 版本和 CommonJS 及 ECMAScript 模块。如何确保您的库在所有不同的环境中都能正常工作？
- en: Solution
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use CommonJS modules with an ECMAScript module wrapper.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带有 ECMAScript 模块包装器的 CommonJS 模块。
- en: 'First, write the library as a CommonJS module, saved with the *.cjs* file extension:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将库写成一个 CommonJS 模块，并保存为 *.cjs* 文件扩展名：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Followed by an ECMAScript wrapper module, which uses the *.mjs* file extension:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 紧随其后的是 ECMAScript 包装模块，使用 *.mjs* 文件扩展名：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And a *package.json* file, which includes the `type`, `main`, and `exports`
    fields:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以及包含 `type`、`main` 和 `exports` 字段的 *package.json* 文件：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Users of our module, using CommonJS syntax, can use the `require` syntax to
    import the module:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们模块的用户可以使用`require`语法导入模块，使用CommonJS语法：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'or:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 'or:'
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'While those using ECMAScript modules can specify the `module` version of the
    library to use the ES `import` syntax:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 而那些使用ECMAScript模块的用户可以指定使用ES `import`语法的`module`版本库：
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'or:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 'or:'
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-65
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of writing, it is possible to avoid the */module* naming convention
    for ECMAScript modules using the `--experimental-conditional-exports` flag. However,
    due to the current experimental nature and the potential of future changes in
    the syntax, we currently recommend against it. In future versions of Node, this
    will likely become the standard. You can read more about this approach in the
    [Node documentation](https://oreil.ly/Xzkid).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当前编写时，可以通过使用`--experimental-conditional-exports`标志避免ECMAScript模块中的*/module*命名约定。然而，由于当前是实验性质并且语法可能会发生变化，我们目前建议不要这样做。在Node的未来版本中，这可能会成为标准。您可以在[Node文档](https://oreil.ly/Xzkid)中了解更多关于这种方法的信息。
- en: Discussion
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: CommonJS modules have been the standard in Node since the beginning, and tools
    such as Browserify brought this syntax out of the Node ecosystem, allowing developers
    to use Node style modules in the browser. The ECMAScript 2015 (also known as ES6)
    standard introduced a native JavaScript module syntax, which was introduced in
    Node 8.5.0 and could be used behind an `--experimental-module` flag. Beginning
    with Node 13.2.0, Node ships with native support for ECMAScript modules.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 自Node起，CommonJS模块一直是标准，诸如Browserify之类的工具将这种语法带出Node生态系统，允许开发者在浏览器中使用Node风格模块。ECMAScript
    2015（也称为ES6）标准引入了一种原生JavaScript模块语法，这在Node 8.5.0中引入，并可以在`--experimental-module`标志后使用。从Node
    13.2.0开始，Node支持原生ECMAScript模块。
- en: A common pattern is to write a module using either the CommonJS or ECMAScript
    module syntax and use a compile tool to ship both as either separate module entry
    points or exported paths. However, this runs the risk of a module being loaded
    twice if it is loaded directly via one syntax by the application and either loaded
    directly or by a dependency using the other syntax.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的模式是使用CommonJS或ECMAScript模块语法编写模块，并使用编译工具将它们作为单独的模块入口点或导出路径发布。然而，如果应用程序通过一种语法直接加载模块，并且该模块通过另一种语法或依赖项直接或间接加载，这可能导致模块加载两次。
- en: 'In *package.json* there are three key fields:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在*package.json*中有三个关键字段：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`"type"`'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`"type"`'
- en: Specifies that this is a `module`, meaning that this library is using the ECMAScript
    module syntax. For libraries that exclusively use CommonJS, the `"type"` would
    be `"commonjs"`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 指定这是一个`module`，意味着这个库正在使用ECMAScript模块语法。对于完全使用CommonJS的库，`"type"`将是`"commonjs"`。
- en: '`"main"`'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`"main"`'
- en: Specifies the main entry point of the application, for which we will point to
    the CommonJS file.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 指定应用程序的主入口点，我们将指向CommonJS文件。
- en: '`"exports"`'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`"exports"`'
- en: Defines the exported paths of our modules. Through this consumers of the default
    `package` will receive the CommonJS module directly, while those using `package/module`
    will import the file from the ECMAScript module wrapper.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 定义我们模块的导出路径。通过这种方式，使用默认`package`的消费者将直接接收CommonJS模块，而使用`package/module`的消费者将从ECMAScript模块包装器中导入文件。
- en: 'If we wish to avoid using the *.cjs* and *.mjs* file extensions, we may do
    so:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望避免使用*.cjs*和*.mjs*文件扩展名，我们可以这样做：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: See Also
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: In [“Writing Multiplatform Libraries”](#multiplatform), we cover how to make
    sure your library code works across multiple module environments in both Node
    and the browser by using Webpack as a code bundler.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“编写多平台库”](#multiplatform)中，我们介绍了如何通过使用Webpack作为代码捆绑器，确保您的库代码在Node和浏览器中的多个模块环境中正常工作。
- en: Creating an Installable Node Module
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个可安装的Node模块
- en: Problem
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You’ve either created a Node module from scratch, or converted an existing library
    to one that will work in the browser or in Node. Now, you want to know how to
    modify it into a module that can be installed using npm.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从头开始创建一个Node模块，或者将现有库转换为可以在浏览器或Node中工作的模块。现在，您想知道如何将其修改为可以使用npm安装的模块。
- en: Solution
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Once you’ve created your Node module and any supporting functionality (including
    module tests), you can package the entire directory. The key to packaging and
    publishing the Node module is creating a *package.json* file that describes the
    module, any dependencies, the directory structure, what to ignore, and so on.
    You can generate a *package.json* file by running the `npm init` command in the
    root of the project’s directory and following the prompts.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了你的 Node 模块和任何支持的功能（包括模块测试），你可以打包整个目录。打包和发布 Node 模块的关键是创建一个描述模块、任何依赖项、目录结构、忽略内容等的
    *package.json* 文件。你可以在项目根目录运行 `npm init` 命令并按提示操作来生成 *package.json* 文件。
- en: 'The following is a relatively basic *package.json* file:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个相对基本的 *package.json* 文件：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Once you’ve created *package.json*, package all the source directories and the
    *package.json* file as a gzipped tarball. Then install the package locally, or
    install it in npm for public access.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了 *package.json*，将所有源目录和 *package.json* 文件打包为一个 gzip 压缩的 tarball。然后在本地安装该包，或者在
    npm 上进行公共访问。
- en: Discussion
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'The *package.json* file is key to packaging up a Node module for local installation
    or uploading to npm for management. At a minimum, it requires a `name` and a `version`.
    The other fields given in the solution are:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*package.json* 文件是将 Node 模块打包为本地安装或上传到 npm 进行管理的关键。至少需要 `name` 和 `version`。解决方案中给出的其他字段包括：'
- en: '`description`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`description`'
- en: A description of what the module is and does
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的描述和功能
- en: '`main`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`'
- en: Entry file for the module
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的入口文件
- en: '`author`'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`author`'
- en: Author(s) of the module
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的作者
- en: '`keywords`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`keywords`'
- en: List of keywords that can help others find the module
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字列表，可以帮助其他人找到这个模块
- en: '`repository`'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`repository`'
- en: Place where the code lives, typically GitHub
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 代码所在的地方，通常是 GitHub
- en: '`engines`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`engines`'
- en: Node versions you know your module works with
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道你的模块可以运行的 Node 版本
- en: '`bugs`'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`bugs`'
- en: Where to file bugs
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 提交 bug 的地方
- en: '`licenses`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`licenses`'
- en: License for your module
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你的模块许可证
- en: '`dependencies`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`dependencies`'
- en: A list of dependencies required by the module
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 模块所需的依赖项列表
- en: '`directories`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`directories`'
- en: A hash describing the directory structure for your module
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 描述你的模块目录结构的哈希
- en: '`scripts`'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`scripts`'
- en: A hash of object commands that are run during the module life cycle
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 描述在模块生命周期内运行的对象命令的哈希
- en: 'There are a host of other options that are described at the [npm website](https://oreil.ly/iXynV).
    You can also use a tool to help you fill in many of these fields. Typing the following
    at the command line runs the tool that asks questions and then generates a basic
    *package.json* file:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [npm 网站](https://oreil.ly/iXynV) 上有一系列其他选项描述。你也可以使用工具来帮助填写许多这些字段。在命令行输入以下内容运行该工具，它会询问问题，然后生成一个基本的
    *package.json* 文件：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once you have your source set up and your *package.json* file, you can test
    whether everything works by running the following command in the top-level directory
    of your module:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了源代码并创建了 *package.json* 文件，你可以在模块的顶级目录运行以下命令测试一切是否正常：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you have no errors, then you can package the file as a gzipped tarball.
    At this point, if you want to publish the module, you’ll first need to add yourself
    as a user in the npm registry:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有错误，那么可以将文件打包为 gzip 压缩的 tarball。此时，如果要发布模块，你首先需要在 npm 注册表中添加自己为用户：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To publish the Node module to the npm registry, use the following in the root
    directory of the module, specifying a URL to the tarball, a filename for the tarball,
    or a path:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 Node 模块发布到 npm 注册表，请在模块的根目录中使用以下命令，指定一个 tarball 的 URL、文件名或路径：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you have development dependencies for your module, such as using a testing
    framework like Jest, one excellent shortcut to ensure these are added to your
    *package.json* file is to use the following, in the same directory as the *package.json*
    file, when you’re installing the dependent module:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的模块有开发依赖项，比如使用 Jest 这样的测试框架，确保这些依赖项添加到 *package.json* 文件的一个优秀捷径是在与 *package.json*
    文件相同的目录中使用以下内容时，安装依赖模块：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Not only does this install Jest (discussed later, in [“Unit Testing Your Modules”](#unit_testing_node_modules)),
    this command also updates your *package.json* file with the following command:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅会安装 Jest（稍后讨论，在 [“单元测试你的模块”](#unit_testing_node_modules) 中），这条命令还会更新你的 *package.json*
    文件，内容如下：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can also use this same type of option to add a module to `dependencies`
    in *package.json*. The following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用相同类型的选项将模块添加到 *package.json* 中的 `dependencies`。以下内容：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'adds the following to the *package.json* file:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到 *package.json* 文件中：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If the module is no longer needed and shouldn’t be listed in *package.json*,
    remove it from the `devDependencies` with:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不再需要模块并且不应出现在 *package.json* 中，请使用以下方法从 `devDependencies` 中删除它：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And remove a module to `dependencies` with:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 并且从 `dependencies` 中移除模块的方法是：
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If the module is the last in either `dependencies` or `devDependencies`, the
    property isn’t removed. It’s just set to an empty value:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模块是 `dependencies` 或 `devDependencies` 中的最后一个，则不会移除该属性。它只是被设置为空值：
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-136
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: npm provides [a decent developer guide for creating and installing a Node module](https://oreil.ly/ifa4e).
    You should consider the use of an *.npmignore* or *.gitignore* file for keeping
    stuff *out* of your module. And though this is beyond the scope of the book, you
    should also become familiar with Git and GitHub, and make use of it for your applications/modules.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: npm 还为[创建和安装 Node 模块提供了一个不错的开发人员指南](https://oreil.ly/ifa4e)。您应该考虑使用 *.npmignore*
    或 *.gitignore* 文件来排除您模块中的内容。虽然这超出了本书的范围，但您还应该熟悉 Git 和 GitHub，并在应用程序/模块中使用它。
- en: 'Extra: The README File and Markdown Syntax'
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 额外信息：README 文件和 Markdown 语法
- en: When you package your module or library for reuse and upload it to a source
    repository such as GitHub, you’ll need to provide how-to information about installing
    the module/library and basic information about how to use it. For this, you need
    a README file.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将模块或库打包以便重用，并将其上传到 GitHub 等源代码存储库时，您需要提供有关安装模块/库的详细信息以及如何使用它的基本信息。为此，您需要一个
    README 文件。
- en: You’ve likely seen files named *README.md* with applications and Node modules.
    They’re text-based with some odd, unobtrusive markup that you’re not sure is useful,
    until you see it in a site like GitHub, where the README file provides all of
    the project page installation and usage information. The markup translates into
    HTML, making for readable web-based help.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经看到过名为 *README.md* 的文件，它们与应用程序和 Node 模块一起。它们基于文本，并带有一些奇怪而不显眼的标记，您可能不确定其有用性，直到在像
    GitHub 这样的网站上看到它，其中 README 文件提供了项目页面安装和使用信息的全部内容。这些标记被转换为 HTML，使得网页帮助内容更易读。
- en: The content for the README is marked up with annotation known as Markdown. The
    popular website Daring Fireball calls Markdown easy to read and write, but “Readability,
    however, is emphasized above all else.” Unlike with HTML, the Markdown markup
    doesn’t get in the way of reading the text.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: README 的内容使用称为 Markdown 的注释标记进行标记。流行的网站 Daring Fireball 称 Markdown 易于阅读和写作，但“可读性始终是最重要的”。与
    HTML 不同，Markdown 标记不会妨碍文本阅读。
- en: Note
  id: totrans-142
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Daring Fireball also provides an [overview of generic Markdown](https://oreil.ly/qkKRT),
    but if you’re working with GitHub files, you might also want to check out [GitHub’s
    Flavored Markdown](https://help.github.com/en/github/writing-on-github).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Daring Fireball 还提供了一个[通用 Markdown 概述](https://oreil.ly/qkKRT)，但如果您在处理 GitHub
    文件，可能还想查看[GitHub 的 Flavored Markdown](https://help.github.com/en/github/writing-on-github)。
- en: 'Here is a sample *REAMDE.md* file:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例 *REAMDE.md* 文件：
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Most popular text editors include Markdown syntax highlighting and previewing
    capabilities. There are also desktop Markdown editors available for all platforms.
    I can also use a CLI tool, like [Pandoc](https://oreil.ly/Cc4GX), to covert the
    *README.md* file into readable HTML:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数流行的文本编辑器包括 Markdown 语法高亮和预览功能。所有平台还提供桌面 Markdown 编辑器。我还可以使用 CLI 工具，例如 [Pandoc](https://oreil.ly/Cc4GX)，将
    *README.md* 文件转换为可读的 HTML：
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[Figure 18-1](#generated_html_from_markdown) displays the generated content.
    It’s not fancy, but it is eminently readable.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 18-1](#generated_html_from_markdown) 显示了生成的内容。它并不花哨，但却非常易读。'
- en: '![jsc3 1801](assets/jsc3_1801.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![jsc3 1801](assets/jsc3_1801.png)'
- en: Figure 18-1\. Generated HTML from README.md text and Markdown annotation
  id: totrans-150
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 18-1\. README.md 文本和 Markdown 注释生成的 HTML
- en: When you host your source code at a site such as GitHub, GitHub uses the *README.md*
    file to generate the cover page for the repository.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将源代码托管在 GitHub 等网站时，GitHub 使用 *README.md* 文件生成存储库的封面页面。
- en: Writing Multiplatform Libraries
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写多平台库
- en: Problem
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You’ve created a library that is useful both in the browser and in Node.js,
    and would like to make it available in both environments.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经创建了一个在浏览器和 Node.js 中都有用的库，并希望在两个环境中都可以使用它。
- en: Solution
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use a bundling tool, such as Webpack, to bundle your library so that it works
    as an ES2015 module, CommonJS module, and AMD module, and can be loaded as a script
    tag in the browser.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用打包工具（如 Webpack）来打包您的库，以使其作为 ES2015 模块、CommonJS 模块和 AMD 模块运行，并且可以作为脚本标签在浏览器中加载。
- en: 'In Webpack’s *webpack.config.js* file, include the `library` and `libraryTarget`
    fields, which signify that the module should be bundled as a library and target
    multiple environments:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在Webpack的 *webpack.config.js* 文件中，包括 `library` 和 `libraryTarget` 字段，表示该模块应作为库捆绑，并针对多个环境进行目标化：
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `library` field specifies a name for the library that will be used in ECMAScript,
    CommonJS, and AMD module environments. The `libraryTarget` field allows you to
    specify how the module will be exposed. The default is `var`, which will expose
    a variable. Specifying `umd` will utilize the JavaScript [Universal Module Definition
    (UMD)](https://oreil.ly/VSpd0), enabling the ability for multiple module styles
    to consume the library. To make the UMD build available in both browser and Node.js
    environments, you will need to set the `output.globalObject` option to `this`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`library` 字段指定一个库的名称，将在 ECMAScript、CommonJS 和 AMD 模块环境中使用。`libraryTarget` 字段允许您指定模块将如何公开。默认值为
    `var`，将公开一个变量。指定 `umd` 将利用 JavaScript [Universal Module Definition (UMD)](https://oreil.ly/VSpd0)，使多个模块样式能够使用该库。要使
    UMD 构建在浏览器和 Node.js 环境中都可用，需要设置 `output.globalObject` 选项为 `this`。'
- en: Note
  id: totrans-160
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: For more details on using Webpack to bundle code, see [Chapter 17](ch17.html#ch17).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用Webpack进行代码捆绑的更多详情，请参见[第17章](ch17.html#ch17)。
- en: Discussion
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'In the example, I’ve created a simple math library. Currently, the only function
    is one called `squareIt`, which accepts a number as a parameter and returns the
    value of that number multiplied by itself. This is at *src/index.js*:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我创建了一个简单的数学库。当前，唯一的函数是一个名为 `squareIt` 的函数，接受一个数字作为参数，并返回该数字乘以自身的值。这在 *src/index.js*
    中：
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The *package.json* file contains Webpack and the Webpack command-line interface
    (CLI) as development dependencies. It also points the `main` distribution at the
    bundled version of the library, which Webpack will output to the *dist* folder.
    I’ve also added a build script that will run the Webpack bundler, aptly named
    `build`. This will allow me to generate the bundle by typing `npm run build` (or
    `yarn run build` if using Yarn).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*package.json* 文件包含 Webpack 和 Webpack 命令行接口（CLI）作为开发依赖项。它还将 `main` 分发指向库的捆绑版本，Webpack
    将其输出到 *dist* 文件夹。我还添加了一个名为 `build` 的构建脚本，将运行Webpack打包工具。这样可以通过输入 `npm run build`（如果使用Yarn，则为
    `yarn run build`）来生成捆绑包。'
- en: '[PRE35]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, my project contains a *webpack.config.js*, as described in the recipe:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我的项目包含一个 *webpack.config.js*，如食谱所述：
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: With this setup, the command `npm run build` will bundle the library and place
    it within the *dist* directory of the project. This bundled file is what consumers
    of the library will use.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此设置，命令 `npm run build` 将捆绑库并放置在项目的 *dist* 目录中。消费者将使用此捆绑文件。
- en: Tip
  id: totrans-170
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: To test the package locally, before publishing it to npm, run `npm link` from
    the root of the project directory. Then in a separate project, where you’d like
    to use the module, type `npm link <library name>`. Doing so will create a symbolic
    link to the package, as though it is globally installed.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在将包发布到 npm 之前，可以在本地测试包，从项目目录的根目录运行 `npm link`。然后在希望使用该模块的另一个项目中，键入 `npm link
    <library name>`。这样做将创建一个符号链接到包，就像全局安装一样。
- en: Publishing the library
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发布库
- en: 'Once your library is complete, you will most likely want to publish it to npm
    for distribution. Make sure that your project is version controlled with Git and
    has been pushed to a public remote repository (such as GitHub or GitLab). From
    the root of your project’s directory:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 完成库后，您可能会希望将其发布到 npm 进行分发。确保项目已使用 Git 进行版本控制，并已推送到公共远程仓库（如 GitHub 或 GitLab）。从项目根目录：
- en: '[PRE37]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Once published to a remote Git repository and the npm registry, the library
    can be consumed by running `npm install`, downloading or cloning the Git repository,
    or directly referencing the library in a web page using *https://unpkg.com/<library-name>*.
    The library can be consumed across the multiple JavaScript library formats.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 发布到远程 Git 仓库和 npm 注册表后，可以通过运行 `npm install`，下载或克隆Git仓库，或直接在网页中引用库，使用 *https://unpkg.com/<library-name>*。该库可以跨多个JavaScript库格式进行消费。
- en: 'As an ES 2015 module:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 ES 2015 模块：
- en: '[PRE38]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As a CommonJS module:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 CommonJS 模块：
- en: '[PRE39]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'As an AMD module:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 AMD 模块：
- en: '[PRE40]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'And using a script tag on a web page:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 并在网页上使用脚本标签：
- en: '[PRE41]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Handling library dependencies
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理库的依赖关系
- en: 'Oftentimes a library may contain subdependencies. With our current setup, all
    dependencies will be packaged and bundled with the library itself. To limit the
    outputted bundle and to ensure that library consumers are not installing multiple
    instances of a subdependency, it may be best to treat them as a “peer dependency,”
    which must also be installed or referenced on its own. To do so, add an `externals`
    property to your *webpack.config.js*. In the instance below, `moment` is being
    used as a peer dependency:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 往往一个库可能包含子依赖项。使用我们当前的设置，所有依赖项将被打包并与库一起捆绑。为了限制输出的捆绑包并确保库使用者不会安装多个子依赖项的实例，最好将它们视为“对等依赖项”，这也必须被单独安装或引用。要执行此操作，请向您的*webpack.config.js*添加一个`externals`属性。在下面的示例中，`moment`正被用作对等依赖项：
- en: '[PRE42]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: With this configuration, `moment` will be treated as a global variable by our
    library.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此配置，`moment`将作为我们库的全局变量处理。
- en: Unit Testing Your Modules
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试你的模块
- en: Problem
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to make sure your module is functioning correctly and ready to be used
    by others.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望确保您的模块正常运行并准备好供他人使用。
- en: Solution
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Add *unit tests* as part of your production process.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 将*单元测试* 作为生产过程的一部分添加。
- en: 'Given the following module, named `bbarray`, and created in a file named *index.js*:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于以下名为`bbarray`的模块，并在名为*index.js*的文件中创建：
- en: '[PRE43]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Using [Jest](https://jestjs.io), a JavaScript testing framework, the following
    unit test (created as *index.js* and located in the project’s *test* subdirectory)
    should result in the successful pass of six tests:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[Jest](https://jestjs.io)，一个JavaScript测试框架，以下单元测试（作为*index.js*创建，并位于项目的*test*子目录中）应该能够成功通过六个测试：
- en: '[PRE44]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The result of the test is shown in [Figure 18-2](#result_of_jest_test), run
    using `npm test`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 测试结果显示在[图 18-2](#result_of_jest_test)，使用`npm test`运行。
- en: '![jsc3 1802](assets/jsc3_1802.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![jsc3 1802](assets/jsc3_1802.png)'
- en: Figure 18-2\. Running unit tests based on Jest
  id: totrans-199
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 18-2\. 基于Jest运行的单元测试
- en: Discussion
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'A *unit test* is a way that developers test their code to ensure it meets the
    specifications. It involves testing functional behavior, and seeing what happens
    when you send bad arguments—or no arguments at all. It’s called unit testing because
    it’s used with individual units of code, such as testing one module in a Node
    application, as compared to testing the entire Node application. It becomes one
    part of *integration testing*, where all the pieces are plugged together, before
    going to *user acceptance testing*: testing to ensure that the application does
    what users expect it to do (and that they generally don’t hate it when they use
    it).'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '*单元测试* 是开发人员测试其代码以确保其符合规范的一种方式。它涉及测试功能行为，并查看在发送错误参数或根本没有参数时会发生什么。之所以称为单元测试，是因为它用于单独的代码单元，例如在Node应用程序中测试一个模块，而不是测试整个Node应用程序。它成为*集成测试*
    的一部分，其中所有部分在连接在一起之前进行测试，然后进行*用户验收测试*：测试确保应用程序按照用户期望的方式运行（并且他们通常在使用时不讨厌它）。'
- en: Unit testing is one of those development tasks that may seem like a pain when
    you first start, but can soon become second nature. A good goal is to develop
    both tests and code in parallel to one another. Many developers even practice
    *test-driven development*, where unit tests are written prior to the code itself.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是开发中可能一开始看起来很痛苦的任务之一，但很快就会变得轻车熟路。一个良好的目标是并行开发测试和代码。许多开发人员甚至练习*测试驱动开发*，在编写代码本身之前先编写单元测试。
- en: In the solution, we use Jest, a sophisticated testing framework. The module
    is simple, so we’re not using some of the more complex Jest testing mechanisms.
    However, this provides an example of the building blocks of writing unit tests.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案中，我们使用了Jest，一个复杂的测试框架。该模块很简单，所以我们没有使用一些更复杂的Jest测试机制。但是，这提供了编写单元测试的基本示例。
- en: 'To install Jest, use the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装Jest，请使用以下命令：
- en: '[PRE45]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'I’m using the `--save-dev` flag, because I’m installing Jest into the module’s
    development dependencies. In addition, I modify the module’s *package.json* file
    to add the following section:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用`--save-dev`标志，因为我将Jest安装到模块的开发依赖项中。此外，我修改了模块的*package.json*文件以添加以下部分：
- en: '[PRE46]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The test script is saved as *index.js* in the *tests* subdirectory under the
    project. Jest automatically looks for files in a *tests* directory or files following
    the *filename.test.js* naming pattern. The following command runs the test:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 测试脚本保存在项目的*tests*子目录下的*index.js*中。Jest会自动查找*tests*目录中的文件或遵循*filename.test.js*命名模式的文件。以下命令运行测试：
- en: '[PRE47]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The Jest unit tests makes use of [*expect matchers*](https://oreil.ly/E7RnY)
    to test for the returned values.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 单元测试利用 [*expect matchers*](https://oreil.ly/E7RnY) 来测试返回的值。
