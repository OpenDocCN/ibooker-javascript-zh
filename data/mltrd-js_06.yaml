- en: Chapter 5\. Advanced Shared Memory
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章\. 高级共享内存
- en: '[Chapter 4](ch04.xhtml#ch_shared_mem) looked at using the `SharedArrayBuffer`
    object to read and write directly to a collection of shared data from across separate
    threads. But doing so is risky business, allowing one thread to clobber data that
    was written by another thread. However, thanks to the `Atomics` object, you are
    able to perform very basic operations with that data in a way that prevents data
    from being clobbered.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[第4章](ch04.xhtml#ch_shared_mem)介绍了使用`SharedArrayBuffer`对象直接从不同线程读取和写入共享数据的方法。但这样做是有风险的，因为一个线程可能会破坏另一个线程写入的数据。然而，由于`Atomics`对象的存在，您可以以一种方式对数据执行非常基本的操作，以防止数据被破坏。'
- en: Although the basic operations provided by `Atomics` are convenient, you will
    often find yourself needing to perform more complex interactions with that data.
    For example, once you’ve serialized data as described in [“Data Serialization”](ch04.xhtml#ch_shared_mem_sec_serialize),
    like a 1 kilobyte string, you’ll then need to write that data to the `SharedArrayBuffer`
    instance, and none of the existing `Atomics` methods will allow you to set the
    entire value all at once.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`Atomics`提供的基本操作非常方便，但通常您会发现自己需要执行更复杂的数据交互。例如，一旦您按照[“数据序列化”](ch04.xhtml#ch_shared_mem_sec_serialize)中描述的方法对数据进行了序列化，如1千字节字符串，然后需要将该数据写入`SharedArrayBuffer`实例中，而现有的`Atomics`方法均不能一次性设置整个值。
- en: This chapter covers additional functionality for coordinating reads and writes
    to shared data across threads for situations when the previously covered `Atomics`
    methods just aren’t enough.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了用于协调跨线程共享数据的额外功能，适用于先前讨论的`Atomics`方法不足以满足需求的情况。
- en: Atomic Methods for Coordination
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协调的原子方法
- en: These methods are a little different than the ones that were already covered
    in [“Atomic Methods for Data Manipulation”](ch04.xhtml#ch_shared_mem_sec_atomics).
    Specificially, the methods previously covered each work with a `TypedArray` of
    any kind and may operate on both `SharedArrayBuffer` and `ArrayBuffer` instances.
    However, the methods listed here will only work with `Int32Array` and `BigInt64Array`
    instances, and they only make sense when used with `SharedArrayBuffer` instances.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法与之前讨论过的方法有些不同，之前讨论的方法可以使用任何类型的`TypedArray`，并且可以操作`SharedArrayBuffer`和`ArrayBuffer`实例。然而，这里列出的方法只适用于`Int32Array`和`BigInt64Array`实例，并且只在与`SharedArrayBuffer`实例一起使用时才有意义。
- en: 'If you try to use these methods with the wrong type of `TypedArray`, you’ll
    get one of these errors:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试在错误类型的`TypedArray`上使用这些方法，将会收到以下错误之一：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As far as prior art goes, these methods are modeled after a feature available
    in the Linux kernel called the *futex*, which is short for *fast userspace mutex*.
    *Mutex* itself is short for *mutual exclusion*, which is when a single thread
    of execution gets exclusive access to a particular piece of data. A mutex can
    also be referred to as a *lock*, where one thread locks access to the data, does
    its thing, and then unlocks access, allowing another thread to then touch the
    data. A futex is built on two basic operations, one being “wait” and the other
    being “wake.”
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 至于先前的技术，这些方法是基于Linux内核中称为*futex*的功能设计的。*Futex*是*fast userspace mutex*的缩写。*Mutex*本身是*mutual
    exclusion*的缩写，即单个执行线程对特定数据的独占访问。Mutex也可以称为*lock*，其中一个线程锁定数据访问，执行操作，然后解锁访问，允许另一个线程接触数据。Futex建立在两种基本操作上，一种是“等待”，另一种是“唤醒”。
- en: Atomics.wait()
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Atomics.wait()
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This method first checks `typedArray` to see if the value at `index` is equal
    to `value`. If it is not, the function returns the value `not-equal`. If the value
    is equal, it will then freeze the thread for up to `timeout` milliseconds. If
    nothing happens during that time, the function returns the value `timed-out`.
    On the other hand, if another thread calls `Atomics.notify()` for that same `index`
    within the time period, the function then returns with a value of `ok`. [Table 5-1](#list_atomics_wait_return)
    lists these return values.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法首先检查`typedArray`中索引为`index`的值是否等于`value`。如果不等，则函数返回值为`not-equal`。如果相等，则会冻结线程最多`timeout`毫秒。如果在此期间没有发生任何事情，则函数返回值为`timed-out`。另一方面，如果另一个线程在此时间段内为相同的`index`调用`Atomics.notify()`，则函数将返回值为`ok`。[表5-1](#list_atomics_wait_return)列出了这些返回值。
- en: Table 5-1\. Return values from `Atomics.wait()`
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 表5-1\. `Atomics.wait()`的返回值
- en: '| Value | Meaning |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 含义 |'
- en: '| --- | --- |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `not-equal` | The provided `value` didn’t equal the value present in the
    buffer. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `not-equal` | 提供的`value`与缓冲区中的值不相等。 |'
- en: '| `timed-out` | Another thread didn’t call `Atomics.notify()` within the allotted
    `timeout`. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `timed-out` | 另一个线程在指定的`timeout`内没有调用`Atomics.notify()`。 |'
- en: '| `ok` | Another thread did call `Atomics.notify()` in time. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `ok` | 另一个线程在规定时间内调用了`Atomics.notify()`。 |'
- en: You might be wondering why this method doesn’t throw an error for the first
    two conditions and silently succeed instead of returning an `ok`. Because multithreaded
    programming is used for performance reasons, it stands to reason that calling
    these `Atomics` methods will be done in the *hotpaths* of an application, which
    are areas where the application spends the most time. It’s less performant in
    JavaScript to instantiate `Error` objects and generate stack traces than to return
    a simple string, so the performance of this approach is pretty high. Another reason
    is that the `not-equal` case doesn’t really represent an error case but that something
    you’re waiting for has already happened.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想为什么这种方法在前两个条件下不会抛出错误，而是悄悄地成功而不是返回`ok`。因为多线程编程是为了性能而使用的，因此合理推断调用这些`Atomics`方法将在应用程序的*热路径*中完成，这些路径是应用程序花费大部分时间的地方。在JavaScript中，实例化`Error`对象并生成堆栈跟踪比返回简单字符串的性能要差，因此这种方法的性能非常高。另一个原因是`not-equal`情况实际上并不代表错误情况，而是你正在等待的事情已经发生了。
- en: This blocking behavior might be a little shocking at first. Locking an entire
    thread sounds a bit intense, and in many cases it is. Another example of what
    can cause an entire JavaScript thread to lock is the `alert()` function in a browser.
    When that function is called, the browser displays a dialog and nothing at all
    can run—not even any background tasks using the event loop—until the dialog is
    dismissed. The `Atomics.wait()` method similarly freezes the thread.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这种阻塞行为可能一开始会有点震惊。锁定整个线程听起来有点强烈，在许多情况下确实如此。导致整个JavaScript线程锁定的另一个例子是浏览器中的`alert()`函数。调用该函数时，浏览器会显示对话框，直到对话框关闭后，没有任何背景任务（包括使用事件循环的任何后台任务）都不能运行。类似地，`Atomics.wait()`方法会冻结线程。
- en: 'This behavior is so extreme, in fact, that the “main” thread—the default thread
    that is available when running JavaScript, outside of a web worker—is not allowed
    to call this method, at least in a browser. The reason is that locking the main
    thread would be such a poor user experience that the API authors didn’t even want
    to allow it. If you do try to call this method in the main thread of a browser,
    you will get one of the following errors:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这种行为非常极端，即“主”线程——在运行JavaScript时默认可用的线程，在Web Worker之外——至少在浏览器中不允许调用此方法。原因是锁定主线程会导致非常糟糕的用户体验，因此API的作者甚至不想允许这样做。如果你试图在浏览器的主线程中调用此方法，你将会收到以下错误之一：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Node.js, on the other hand, does allow `Atomics.wait()` to be called in the
    main thread. Since Node.js doesn’t have a UI, this isn’t necessarily a bad thing.
    Indeed, it can be useful when writing scripts where calling `fs.readFileSync()`
    is acceptable.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Node.js允许在主线程中调用`Atomics.wait()`。由于Node.js没有UI，这并不一定是一件坏事。实际上，在编写允许调用`fs.readFileSync()`的脚本时，这可能会很有用。
- en: If you’re a JavaScript developer who has ever worked at a company with mobile
    or desktop developers, you may have overheard them talk about “offloading work
    from the main thread” or “locking the main thread.” These concerns, which have
    traditionally belonged to developers of native apps, will be enjoyed by us JavaScript
    engineers more and more as the language advances. With regards to browsers this
    issue is often referred to as *scroll jank*, which is when a CPU is too busy to
    draw the UI while scrolling.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一名JavaScript开发人员，曾在一个有移动或桌面开发人员的公司工作过，你可能听到他们谈论“将工作从主线程转移”或“锁定主线程”。这些关注点传统上属于本机应用程序的开发人员，随着语言的进步，我们JavaScript工程师将会越来越多地享受到这些好处。在浏览器方面，这个问题通常被称为*滚动卡顿*，即在滚动时CPU太忙无法绘制UI。
- en: Atomics.notify()
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Atomics.notify()`'
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `Atomics.notify()`^([1](ch05.xhtml#idm45995918555608)) method attempts to
    awaken other threads that have called `Atomics.wait()` on the same `typedArray`
    and at the same `index`. If any other threads are currently frozen, then they
    will wake up. Multiple threads can be frozen at the same time, each waiting to
    be notified. The `count` value then determines how many of them to awaken. The
    `count` value defaults to `Infinity`, meaning that every thread will be awakened.
    However, if you have four threads waiting and set the value to three, then all
    but one of them will be woken up. [“Timing and Nondeterminism”](#ch_adv_shared_mem_sec_timing)
    examines the order of these waking threads.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`Atomics.notify()`^([1](ch05.xhtml#idm45995918555608)) 方法尝试唤醒那些在相同的 `typedArray`
    和相同 `index` 上调用了 `Atomics.wait()` 的其他线程。如果有其他线程当前处于冻结状态，它们将被唤醒。多个线程可以同时处于冻结状态，每个线程等待被通知。然后
    `count` 值决定唤醒多少个线程。`count` 值默认为 `Infinity`，意味着每个线程都将被唤醒。然而，如果有四个线程在等待并且将值设置为三，则除了一个线程外，其他所有线程都将被唤醒。[“时序和非确定性”](#ch_adv_shared_mem_sec_timing)
    探讨了这些唤醒线程的顺序问题。'
- en: The return value is the number of threads that have been awoken once the method
    is complete. If you were to pass in a `TypedArray` instance that points to a nonshared
    `ArrayBuffer` instance, this will always return a `0`. If no threads happen to
    be listening at the time it will also return a `0`. Because this method doesn’t
    block the thread, it can always be called from a main JavaScript thread.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 方法完成后的返回值是已唤醒的线程数。如果传入指向非共享 `ArrayBuffer` 实例的 `TypedArray` 实例，则始终返回 `0`。如果此时没有任何线程在监听，它也会返回
    `0`。由于此方法不会阻塞线程，因此可以始终从主 JavaScript 线程中调用。
- en: Atomics.waitAsync()
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Atomics.waitAsync()
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is essentially a promise-based version of `Atomics.wait()` and is the latest
    addition to the `Atomics` family. As of this writing it is available in Node.js
    v16 and Chrome v87 but not yet available in Firefox or Safari.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这本质上是 `Atomics` 家族中 `Atomics.wait()` 的基于 promise 的版本。截至撰写本文时，它在 Node.js v16
    和 Chrome v87 中可用，但尚未在 Firefox 或 Safari 中可用。
- en: This method is essentially a less-performant, nonblocking version of `Atomics.wait()`
    that returns a promise which resolves the status of the wait operation. Due to
    the loss of performance (a resolving promise is going to have more overhead than
    pausing a thread and returning a string), it isn’t necessarily as useful for the
    hotpath of a CPU-heavy algorithm. On the other hand, it can be useful in situations
    where a lock change is more convenient to signal another thread than to perform
    message-passing operations via `postMessage()`. Because this method doesn’t block
    the thread, it can be used in the main thread of an application.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法本质上是 `Atomics.wait()` 的性能较差的非阻塞版本，它返回一个解析等待操作状态的 promise。由于性能下降（解析的 promise
    比暂停线程并返回字符串的开销更大），它并不一定适用于 CPU 密集型算法的热路径。另一方面，在锁定更改更便于通过信号另一个线程而不是通过 `postMessage()`
    执行消息传递操作的情况下，它可能会更有用。由于此方法不会阻塞线程，因此可以在应用程序的主线程中使用。
- en: One of the driving factors for adding this method is so that code compiled using
    Emscripten (covered in [“Compiling C Programs to WebAssembly with Emscripten”](ch07.xhtml#ch_webassembly_sec_compile))
    that makes use of threading is allowed to execute in the main thread and not just
    in worker threads.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 添加此方法的主要驱动因素之一是，使用 Emscripten 编译的代码（在 [“使用 Emscripten 将 C 程序编译为 WebAssembly”](ch07.xhtml#ch_webassembly_sec_compile)
    中介绍）可以利用线程而不仅限于工作线程中执行。
- en: Timing and Nondeterminism
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时序和非确定性
- en: In order for an application to be correct it usually needs to behave in a deterministic
    fashion. The `Atomics.notify()` function accepts an argument `count` that contains
    the number of threads to wake up. The glaring question in this situation is which
    threads get woken up and in which order?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保应用程序的正确性，通常需要它以确定性方式运行。`Atomics.notify()` 函数接受一个名为 `count` 的参数，其中包含要唤醒的线程数。在这种情况下显而易见的问题是哪些线程会被唤醒，以及它们的唤醒顺序是什么？
- en: Example of Nondeterminism
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非确定性示例
- en: Threads are woken up in *FIFO* (first in, first out) order, meaning the first
    thread that called `Atomics.wait()` is the first to be woken up, the second to
    call is the second to be woken up, and so on. Measuring this can be difficult,
    however, because log messages printed from different workers aren’t guaranteed
    to be displayed in the terminal in the true order that they were executed in.
    Ideally, you should build your application in such a way that it continues to
    work fine regardless of the order in which threads have been awoken.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 线程按 *FIFO*（先进先出）顺序被唤醒，这意味着调用 `Atomics.wait()` 的第一个线程将第一个被唤醒，第二个调用的线程将第二个被唤醒，依此类推。然而，测量这一点可能很困难，因为来自不同工作者的日志消息不能保证以真实的执行顺序显示在终端中。理想情况下，您应该构建您的应用程序，使其继续正常工作，而不受唤醒线程的顺序影响。
- en: To test this for yourself, you can create a new application. First, create a
    new directory named *ch5-notify-order/*. In it, start off by creating another
    basic *index.html* file using the content from [Example 5-1](#ex_timing_index).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 想要亲自测试这个，你可以创建一个新的应用程序。首先，创建一个名为 *ch5-notify-order/* 的新目录。在其中，通过使用来自 [示例 5-1](#ex_timing_index)
    的内容，创建另一个基本的 *index.html* 文件。
- en: Example 5-1\. *ch5-notify-order/index.html*
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-1\. *ch5-notify-order/index.html*
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Next, create another *main.js* file, containing the content from [Example 5-2](#ex_timing_main).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建另一个 *main.js* 文件，其中包含来自 [示例 5-2](#ex_timing_main) 的内容。
- en: Example 5-2\. *ch5-notify-order/main.js*
  id: totrans-41
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-2\. *ch5-notify-order/main.js*
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[![1](Images/1.png)](#co_advanced_shared_memory_CO1-1)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_advanced_shared_memory_CO1-1)'
- en: Four dedicated workers are instantiated.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 四个专用工作者被实例化。
- en: '[![2](Images/2.png)](#co_advanced_shared_memory_CO1-2)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_advanced_shared_memory_CO1-2)'
- en: The shared buffer is notified at index 0.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 共享缓冲器在索引 0 处被通知。
- en: '[![3](Images/3.png)](#co_advanced_shared_memory_CO1-3)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_advanced_shared_memory_CO1-3)'
- en: The notification is sent at half a second.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通知每半秒发送一次。
- en: This file first creates a 4-byte buffer, which is the smallest buffer that can
    support the needed `Int32Array` view. Next, it creates four different dedicated
    workers using a `for` loop. For each of the workers it immediately calls the appropriate
    `postMessage()` call to pass in both the buffer as well as the identifier for
    the thread. This results in five different threads that we care about; namely
    the main thread and threads that we’ve nicknamed 0, 1, 2, and 3.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件首先创建一个4字节的缓冲区，这是支持所需 `Int32Array` 视图的最小缓冲区。接下来，它使用 `for` 循环创建四个不同的专用工作者。对于每个工作者，它立即调用适当的
    `postMessage()` 调用，传递缓冲区以及线程的标识符。这导致我们关心的五个不同的线程；即主线程和我们命名为 0、1、2 和 3 的线程。
- en: JavaScript creates those threads, and the underlying engine goes to work assembling
    resources, allocating memory, and otherwise doing a lot of magic for us behind
    the scenes. The amount of time that it takes to perform those tasks is nondeterministic,
    which is unfortunate. We can’t know that, for example, it always takes 100 ms
    to complete the preparation work. In fact, this number will change wildy across
    machines depending on things like core count and how busy the machine happens
    to be at the time the code is run. Lucky for us, the `postMessage()` call is essentially
    queued up for us; the JavaScript engine will call the worker’s `onmessage` function
    once it’s ready.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 创建这些线程，底层引擎开始组装资源，分配内存，以及在幕后为我们做很多魔法。执行这些任务所需的时间是不确定的，这很不幸。我们无法知道，例如，完成准备工作是否总是需要100毫秒。事实上，这个数字将根据机器的核心数量以及代码运行时机器的繁忙程度而大幅变化。幸运的是，`postMessage()`
    调用基本上已经为我们排队了；JavaScript 引擎会在准备好后调用工作者的 `onmessage` 函数。
- en: After that, the main thread finishes its work, then waits half a second (500
    ms) using `setTimeout`, and finally calls `Atomics.notify()`. What would happen
    if the `setTimeout` value were too low, say 10 ms? Or even if it were called in
    the same stack outside of `setTimeout`? In that case the threads wouldn’t yet
    be initialized, the worker wouldn’t have had time to call `Atomics.wait()`, and
    the call would immediately return with a `0`. What would happen if the time value
    is too high? Well, the application might be painfully slow, or any `timeout` value
    used by `Atomics.wait()` might have been exceeded.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，主线程完成其工作，然后使用`setTimeout`等待半秒钟（500毫秒），最后调用`Atomics.notify()`。如果`setTimeout`值过低，比如10毫秒，会发生什么？或者甚至在同一堆栈外调用？在这种情况下，线程尚未初始化，工作者没有时间调用`Atomics.wait()`，调用将立即返回`0`。如果时间值太高会发生什么？那么应用程序可能会非常缓慢，或者`Atomics.wait()`使用的任何`timeout`值可能已超过。
- en: On Thomas’s laptop the threshold of readiness seems to be somewhere around 120
    ms. At that point some of the threads are ready and some aren’t. At about 100
    ms usually none of the threads are ready, and at 180 ms usually all of the threads
    are ready. But *usually* is a word that we don’t like to use in programming. It
    is difficult to know an exact amount of time before a thread is ready. Often this
    is an issue when first starting an application, not one that is present throughout
    the life cycle of the application.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在Thomas的笔记本电脑上，就绪阈值似乎在约120毫秒左右。此时一些线程已准备好，一些则没有。通常在大约100毫秒时，没有任何线程准备好，在180毫秒时，通常所有线程都准备好了。但是“通常”是我们在编程中不喜欢使用的词语。确切地知道线程准备好之前的时间很难。通常这只是在首次启动应用程序时出现的问题，而不是应用程序整个生命周期中的问题。
- en: To finish off the application, create a file named *worker.js*, and add the
    content from [Example 5-3](#ex_timing_worker) to it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成应用程序，创建一个名为*worker.js*的文件，并将[示例5-3](#ex_timing_worker)中的内容添加到其中。
- en: Example 5-3\. *ch5-notify-order/worker.js*
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例5-3。*ch5-notify-order/worker.js*
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[![1](Images/1.png)](#co_advanced_shared_memory_CO2-1)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_advanced_shared_memory_CO2-1)'
- en: Wait on 0th entry in buffer, assuming initial value of `0`, for up to 1 second.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在缓冲区的第0条目上等待，假定初始值为`0`，最多等待1秒钟。
- en: The worker accepts the shared buffer and the name of the worker thread and stores
    the values, printing a message that the thread has been initialized. It then calls
    `Atomics.wait()` using the 0th index of the buffer. It assumes an initial value
    of `0` is present in the buffer (which it is, since we haven’t modified the value).
    The method call also uses a `timeout` value of one second (1,000 ms). Finally,
    once the method call is complete, the value is printed in the terminal.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 工作者接受共享缓冲区和工作者线程的名称，并存储这些值，并打印线程已初始化的消息。然后，它调用`Atomics.wait()`，使用缓冲区的第0索引。它假设缓冲区中存在初始值`0`（因为我们尚未修改该值）。该方法调用还使用了`timeout`值为一秒（1,000毫秒）。最后，一旦方法调用完成，值将在终端上打印出来。
- en: 'Once you’ve finished creating these files, switch to a terminal and run another
    web server to view the content. Again, you can do so by running the following
    command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 创建完这些文件后，切换到终端并运行另一个Web服务器以查看内容。同样，您可以通过运行以下命令来执行此操作：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As usual, navigate to the URL printed in the terminal and open the console.
    If you don’t see any output, you may need to refresh the page to run the application
    again. [Table 5-2](#table_coordination_determinism) contains the output from a
    test run.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，导航到终端中打印的URL并打开控制台。如果看不到任何输出，可能需要刷新页面以再次运行应用程序。[表5-2](#table_coordination_determinism)包含测试运行的输出。
- en: Table 5-2\. Example nondeterministic output
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 表5-2。示例非确定性输出
- en: '| Log | Location |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 记录 | 位置 |'
- en: '| --- | --- |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Worker 1 started | worker.js:4:11 |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| Worker 1已启动 | worker.js:4:11 |'
- en: '| Worker 0 started | worker.js:4:11 |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| Worker 0已启动 | worker.js:4:11 |'
- en: '| Worker 3 started | worker.js:4:11 |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| Worker 3已启动 | worker.js:4:11 |'
- en: '| Worker 2 started | worker.js:4:11 |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| Worker 2已启动 | worker.js:4:11 |'
- en: '| Worker 0 awoken with ok | worker.js:7:11 |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| Worker 0因成功唤醒 | worker.js:7:11 |'
- en: '| Worker 3 awoken with ok | worker.js:7:11 |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| Worker 3因成功唤醒 | worker.js:7:11 |'
- en: '| Worker 1 awoken with ok | worker.js:7:11 |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| Worker 1因成功唤醒 | worker.js:7:11 |'
- en: '| Worker 2 awoken with timed-out | worker.js:7:11 |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| Worker 2因超时唤醒 | worker.js:7:11 |'
- en: You will most likely get different output. In fact, if you refresh the page
    again, you may get different output once again. Or you may even get consistent
    output across multiple runs. Ideally, though, the final worker name that is printed
    with the “started” messages will also be the worker that fails with the “timed-out”
    message.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你很可能会得到不同的输出。事实上，如果你再次刷新页面，你可能会再次得到不同的输出。或者，即使在多次运行中，你可能会得到一致的输出。但理想情况下，与“启动”消息一起打印的最后一个工作者名称也将是失败并显示“超时”消息的工作者。
- en: This output might be a little confusing. Earlier we stated that the order seems
    to be FIFO ordered, but the numbers here aren’t from 0 to 3\. The reason is that
    the order doesn’t depend on the order that the threads were created (0, 1, 2,
    3), but the order in which the threads executed the `Atomics.wait()` call (1,
    0, 3, 2 in this case). Even with that in mind the order of the “awoken” messages
    is confusing (0, 3, 1, 2 in this case). This is likely due to a race condition
    in the JavaScript engine where different threads print messages, likely at almost
    the exact same moment.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出可能会有些混乱。早些时候我们说过，顺序似乎是先进先出的，但这里的数字并不是从0到3。原因在于顺序并不取决于线程的创建顺序（0, 1, 2, 3），而是取决于线程执行`Atomics.wait()`调用的顺序（在这种情况下是1,
    0, 3, 2）。即使有了这个认识，被“唤醒”的消息的顺序也很混乱（在这种情况下是0, 3, 1, 2）。这很可能是JavaScript引擎中的竞态条件导致的，不同线程几乎在完全相同的时刻打印消息。
- en: Once printed, the messages don’t get displayed directly to the screen. If that
    could happen, then the messages could overwrite each other, and you’d end up with
    visual tearing of pixels. Instead, the engine queues up the messages to be printed,
    and some other mechanism internal to the browser, but hidden away from us developers,
    determines the order in which they’re taken from the queue and printed to the
    screen. For that reason, the order of the two sets of messages won’t necessarily
    correlate. But the only way to truly tell any order is that the message that times
    out happens to be from the final thread that was started. Indeed, in this case
    the “timed-out” message is always from the last worker that was started.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 打印后，消息不会直接显示在屏幕上。如果可能的话，这些消息可能会互相覆盖，导致像素出现视觉撕裂。相反，引擎会将消息排队等待打印，并且浏览器内部的某种机制（但我们开发者看不到）决定了从队列中取出和打印消息的顺序。因此，两组消息的顺序不一定会相关联。但是唯一确定任何顺序的方法是超时消息恰好来自最后启动的线程。实际上，在这种情况下，“超时”消息总是来自最后启动的工作者。
- en: Detecting Thread Preparedness
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测线程准备就绪
- en: 'This experiment begs the question: how can an application deterministically
    know when a thread has finished going through initial setup and is thus prepared
    to take on work?'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实验引发了一个问题：一个应用程序如何确定一个线程何时完成了初始设置并准备好承担工作？
- en: A simple way to do so is to call `postMessage()` from within the worker threads
    to post back to the parent thread at some point during the `onmessage()` handler.
    This works because once the `onmessage()` handler has been called the worker thread
    has finished its initial setup and is now running JavaScript code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的方法是在工作者线程中从`onmessage()`处理程序的某个时间点开始调用`postMessage()`返回给父线程。这是有效的，因为一旦调用了`onmessage()`处理程序，工作者线程就完成了初始设置，现在正在运行JavaScript代码。
- en: Here’s an example of the quickest way to pull this off. First, copy the *ch5-notify-order/*
    directory you created and paste it as a new *ch5-notify-when-ready/* directory.
    Inside this directory the *index.html* file will remain the same, though the two
    JavaScript files will be updated. First, update *main.js* to contain the content
    from [Example 5-4](#ex_timing_ready_main).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个快速完成这个任务的例子。首先，复制你创建的*ch5-notify-order/*目录，粘贴为一个新的*ch5-notify-when-ready/*目录。在这个目录中，*index.html*文件保持不变，但是两个JavaScript文件将被更新。首先，更新*main.js*以包含[示例
    5-4](#ex_timing_ready_main)中的内容。
- en: Example 5-4\. *ch5-notify-when-ready/main.js*
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-4\. *ch5-notify-when-ready/main.js*
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[![1](Images/1.png)](#co_advanced_shared_memory_CO3-1)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_advanced_shared_memory_CO3-1)'
- en: Instantiate four workers.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化四个工作者。
- en: '[![2](Images/2.png)](#co_advanced_shared_memory_CO3-2)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_advanced_shared_memory_CO3-2)'
- en: Immediately post a message to the workers.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 立即向工作者发送消息。
- en: '[![3](Images/3.png)](#co_advanced_shared_memory_CO3-3)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_advanced_shared_memory_CO3-3)'
- en: Notify on the 0th entry once all four workers reply.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有四个工作者回复，就在第0个条目上发出通知。
- en: The script has been modified so that `Atomics.notify()` will be called after
    each of the four workers has posted a message back to the main thread. Once the
    fourth and final worker has posted a message, the notification is then sent. This
    allows the application to post a message as soon as it’s ready, likely saving
    hundreds of milliseconds in the best case, and preventing a failure in the worst
    case (like when running the code on a very slow single-core computer).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本已经修改，以便在四个工作线程中的每个都向主线程发送消息后调用 `Atomics.notify()`。一旦第四个也是最后一个工作线程发送了消息，就会发送通知。这允许应用程序在准备就绪时立即发送消息，在最好的情况下可能节省数百毫秒，在最坏的情况下（例如在非常慢的单核计算机上运行代码时）则防止失败。
- en: The `Atomics.notify()` call has also been updated to simply wake up all threads
    instead of just three, and the timeout has been set back to the default of `Infinity`.
    This was done to show that every thread will receive the message on time.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`Atomics.notify()` 调用也已更新为仅唤醒所有线程，而不仅仅是三个，并且超时已恢复为默认的 `Infinity`。这样做是为了显示每个线程都将及时接收到消息。'
- en: Next, update *worker.js* to contain the content from [Example 5-5](#ex_timing_ready_worker).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，更新 *worker.js* 以包含来自 [示例 5-5](#ex_timing_ready_worker) 的内容。
- en: Example 5-5\. *ch5-notify-when-ready/worker.js*
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-5\. *ch5-notify-when-ready/worker.js*
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![1](Images/1.png)](#co_advanced_shared_memory_CO4-1)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_advanced_shared_memory_CO4-1)'
- en: Post message back to parent thread to signal readiness.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 向父线程发送消息以表明准备就绪。
- en: '[![2](Images/2.png)](#co_advanced_shared_memory_CO4-2)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_advanced_shared_memory_CO4-2)'
- en: Wait for notification on the 0th entry.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 等待第 0 个条目的通知。
- en: This time the `onmessage` handler immediately calls `postMessage()` to send
    a message back to the parent. Then, the wait call happens shortly afterward. Technically,
    if the parent thread were to somehow receive the message before the `Atomics.wait()`
    call were made, then the application could conceivably break. But the code is
    relying on the fact that message passing is far slower than iterating over lines
    of code within a synchronous JavaScript function.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这次 `onmessage` 处理程序立即调用 `postMessage()` 向父线程发送消息。然后不久之后发生等待调用。从技术上讲，如果父线程在 `Atomics.wait()`
    调用之前某种方式接收到消息，则应用程序可能会崩溃。但代码依赖于消息传递比在同步 JavaScript 函数中迭代代码行要慢得多的事实。
- en: One thing to keep in mind is that calling `Atomics.wait()` will pause the thread.
    This means `postMessage()` can’t be called afterward.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 有一点需要记住，调用 `Atomics.wait()` 将暂停线程。这意味着之后不能再调用 `postMessage()`。
- en: 'When you run this code, the new logs print out three pieces of information:
    the name of the thread, the countdown (always in the order of 3, 2, 1, 0), and
    finally the amount of time it took for the thread to be ready since the start
    of the script. Run the same command that you ran before and open the resulting
    URL in your browser. [Table 5-3](#table_thread_start_timing) contains the log
    output from some sample runs.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码时，新的日志将输出三条信息：线程名称、倒计时（始终为 3、2、1、0 的顺序）以及线程自脚本启动以来的准备时间。运行与之前相同的命令，并在浏览器中打开生成的
    URL。[表 5-3](#table_thread_start_timing) 包含了一些示例运行的日志输出。
- en: Table 5-3\. Thread start timing
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5-3\. 线程启动时间
- en: '| Firefox v88 | Chrome v90 |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| Firefox v88 | Chrome v90 |'
- en: '| --- | --- |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| T1, 86ms | T0, 21ms |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| T1, 86ms | T0, 21ms |'
- en: '| T0, 99ms | T1, 24ms |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| T0, 99ms | T1, 24ms |'
- en: '| T2, 101ms | T2, 26ms |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| T2, 101ms | T2, 26ms |'
- en: '| T3, 108ms | T3, 29ms |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| T3, 108ms | T3, 29ms |'
- en: In this case, with a 16-core laptop, Firefox seems to take around four times
    as long to initialize the worker threads as Chrome does. Also, Firefox gives a
    more random thread order than Chrome. Each time the page is refreshed the order
    of threads for Firefox changes but the order in Chrome does not. This then suggests
    that the V8 engine used by Chrome is more optimized for starting new JavaScript
    environments or instantiating browser APIs than the SpiderMonkey engine used by
    Firefox.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用 16 核笔记本电脑，Firefox 初始化工作线程似乎要比 Chrome 慢四倍左右。此外，Firefox 给出的线程顺序比 Chrome
    更随机。每次刷新页面时，Firefox 的线程顺序都会改变，但 Chrome 的顺序不会。这表明 Chrome 使用的 V8 引擎在启动新的 JavaScript
    环境或实例化浏览器 API 方面比 Firefox 使用的 SpiderMonkey 引擎更加优化。
- en: Be sure to test this code in multiple browsers to compare the results that you
    get. Another thing to keep in mind is that the speed that it takes to initialize
    threads will also likely depend on the number of cores available on your computer.
    In fact, to have some additional fun with this program, change the value of `4`
    that is assigned to the `count` variable and in the `for` loop to a higher number,
    then run the code and see what happens. Upon increasing the value to `128`, the
    amount of time it took both browsers to initialize threads jumped a lot. This
    also consistently breaks the order in which the threads are prepared on Chrome.
    Generally, performance is lost when using too many threads, and this is examined
    in more detail in [“Low Core Count”](ch08.xhtml#ch_benchmarks_sec_avoid_ss_lowcore).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 请务必在多个浏览器中测试此代码，以比较所得到的结果。另一件需要注意的事情是，初始化线程所需的速度很可能取决于计算机上可用的核心数。事实上，要通过此程序增添些乐趣，将分配给`count`变量和`for`循环的值从`4`改为更高的数字，然后运行代码并观察结果。将值增加到`128`后，两个浏览器初始化线程所花费的时间显著增加。这也会在Chrome上一贯地破坏线程准备的顺序。通常情况下，使用过多线程会降低性能，这在[“低核心计数”](ch08.xhtml#ch_benchmarks_sec_avoid_ss_lowcore)中有更详细的分析。
- en: 'Example Application: Conway’s Game of Life'
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例应用：康威生命游戏（Conway's Game of Life）
- en: 'Now that we’ve had a look at `Atomics.wait()` and `Atomics.notify()`, it’s
    time to look at a concrete example. We’ll use Conway’s Game of Life, a well-established
    concept that naturally lends itself to parallel programming. The “game” is actually
    a simulation of population growth and decay. The “world” this simulation exists
    in is a grid of cells that are in one of two states: alive or dead. The simulation
    works iteratively, and on each iteration, the following algorithm is performed
    for each cell.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看过`Atomics.wait()`和`Atomics.notify()`，是时候看一个具体的例子了。我们将使用康威生命游戏，这是一个自然适合并行编程的成熟概念。这个“游戏”实际上是人口增长和衰退的模拟。这个模拟存在于一个网格中，网格中的细胞处于两种状态之一：存活或死亡。模拟是迭代进行的，每次迭代对每个细胞执行以下算法。
- en: 'If the cell is alive:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果细胞死亡：
- en: If there are 2 or 3 neighbors alive, the cell remains alive.
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有2或3个邻居存活，则细胞保持存活。
- en: If there are 0 or 1 neighbors alive, the cell dies (this simulates underpopulation
    as a cause of death).
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有0个或1个邻居存活，则细胞死亡（这模拟了由于生育不足而导致的死亡）。
- en: If there are 4 or more neighbors alive, the cell dies (this simulates overpopulation
    as a cause of death).
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有4个或更多邻居存活，则细胞死亡（这模拟了由于过度生育而导致的死亡）。
- en: 'If the cell is dead:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果细胞死亡：
- en: If there are exactly 3 neighbors alive, the cell becomes alive (this simulates
    reproduction).
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果恰好有3个邻居存活，则细胞变为存活（这模拟了繁殖）。
- en: In any other case, the cell remains dead.
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在任何其他情况下，细胞保持死亡状态。
- en: When talking about “neighbors alive,” we’re referring to any cell that’s at
    most one unit away from the current cell, including diagonals, and we’re referring
    to the state prior to the current iteration. We can simplify these rules to the
    following.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到“邻居存活”时，我们指的是任何距离当前细胞至多一单元的细胞，包括对角线方向，并且我们指的是当前迭代之前的状态。我们可以将这些规则简化为以下形式。
- en: If there are exactly 3 neighbors alive, the new cell state is alive (regardless
    of how it started).
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果恰好有3个邻居存活，新细胞状态为存活（无论其起始状态如何）。
- en: If the cell is alive and exactly 2 neighbors are alive, the cell remains alive.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果细胞存活且恰好有2个邻居存活，则细胞保持存活。
- en: In all other cases, the new cell state is dead.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在所有其他情况下，新细胞状态为死亡。
- en: 'For our implementation, we’ll make the following assumptions:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的实现，我们将做出以下假设：
- en: The grid is a square. This is a slight simplification so that there’s one less
    dimension to worry about.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网格是一个正方形。这是一个轻微的简化，因此少了一个维度的担忧。
- en: The grid wraps around itself like a torus. This means that when we’re at an
    edge, and we need to evaluate a neighboring cell outside the bounds, we’ll look
    at the cell at the other end.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网格像一个环面一样环绕自身。这意味着当我们处于边缘时，需要评估超出边界的邻居细胞时，我们会看到另一端的细胞。
- en: We’ll write our code for web browsers, since they give us a handy canvas element
    with which to plot the state of the Game of Life world. That being said, it’s
    relatively straightforward to adapt the example to other environments that have
    some kind of image rendering. In Node.js you could even write to the terminal
    using ANSI escape codes.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写我们的代码用于Web浏览器，因为它们为我们提供了一个便捷的画布元素来绘制生命游戏世界的状态。话虽如此，在其他具有某种图像渲染的环境中适应这个示例也是相对简单的。在Node.js中，甚至可以使用ANSI转义码向终端写入。
- en: Single-Threaded Game of Life
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单线程生命游戏
- en: To start off, we’ll build up a `Grid` class, which holds our Game of Life world
    as an array and handles each iteration. We’ll build it in a frontend-agnostic
    way, and we’ll even make it usable without any changes in our multithreaded example.
    To properly simulate the Game of Life, we’ll need a multidimensional array to
    represent our grid of cells. We could use arrays of arrays, but to make things
    easier later on, we’ll store it in a one-dimensional array (in fact, a `Uint8Array`),
    and then for any cell with coordinates `x` and `y`, we’ll store it in the array
    at `cells[size * x + y]`. We’ll also need two of these, since one will be for
    the current state, and one for the previous state. In another attempt to simplify
    things for later on, we’ll store both of them sequentially in the same `ArrayBuffer`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将构建一个`Grid`类，它将我们的生命游戏世界作为一个数组，并处理每次迭代。我们将以一种与前端无关的方式构建它，甚至在多线程示例中也可以使用它而无需进行任何更改。为了正确模拟生命游戏，我们需要一个多维数组来表示我们的单元格网格。我们可以使用数组的数组，但为了稍后简化事务，我们将其存储在一个一维数组中（实际上是`Uint8Array`），然后对于任何具有坐标`x`和`y`的单元格，我们将其存储在数组中的位置`cells[size
    * x + y]`。我们还需要两个这样的数组，因为一个将用于当前状态，另一个用于先前状态。为了稍后更轻松地简化事务，我们将它们顺序存储在同一个`ArrayBuffer`中。
- en: Make a directory called *ch5-game-of-life/* and add the contents of [Example 5-6](#ex_ch5_gol_1)
    to *gol.js* in that directory.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为*ch5-game-of-life/*的目录，并将[示例 5-6](#ex_ch5_gol_1)的内容添加到该目录下的*gol.js*中。
- en: Example 5-6\. *ch5-game-of-life/gol.js* (part 1)
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-6\. *ch5-game-of-life/gol.js*（第1部分）
- en: '[PRE11]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here we’ve started off the `Grid` class with a constructor. It takes in a `size`,
    which is the width of our square, an `ArrayBuffer` called `buffer`, and a `paint`
    function which we’ll use later on. We then establish our `cells` and `nextCells`
    as instances of `Uint8Array` stored side-by-side in the `buffer`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们用构造函数开始了`Grid`类。它接受一个`size`，这是我们正方形的宽度，一个名为`buffer`的`ArrayBuffer`，以及一个稍后将要使用的`paint`函数。然后我们将我们的`cells`和`nextCells`作为`Uint8Array`的实例存储在`buffer`中的相邻位置。
- en: Next, we can add the cell retrieval method we’ll need later on when performing
    iterations. Add the code in [Example 5-7](#ex_ch5_gol_2).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，当执行迭代时，我们可以添加后面需要的单元格检索方法。将代码添加到[示例 5-7](#ex_ch5_gol_2)中。
- en: Example 5-7\. *ch5-game-of-life/gol.js* (part 2)
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-7\. *ch5-game-of-life/gol.js*（第2部分）
- en: '[PRE12]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To retrieve a cell with a given set of coordinates, we need to normalize the
    indices. Recall that we’re saying the grid wraps around. The normalization we’ve
    done here makes sure that if we’re one unit above or below the range, we instead
    retrieve the cell at the other end of the range.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要根据给定的坐标集检索单元格，我们需要对索引进行规范化。回想一下，我们说过网格是环绕的。我们在这里进行的规范化确保，如果超出范围的上下单位，我们将检索到范围另一端的单元格。
- en: Now, we’ll add the actual algorithm that runs on every iteration. Add the code
    in [Example 5-8](#ex_ch5_gol_3).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加在每次迭代时运行的实际算法。将代码添加到[示例 5-8](#ex_ch5_gol_3)中。
- en: Example 5-8\. *ch5-game-of-life/gol.js* (part 3)
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-8\. *ch5-game-of-life/gol.js*（第3部分）
- en: '[PRE13]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](Images/1.png)](#co_advanced_shared_memory_CO5-1)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_advanced_shared_memory_CO5-1)'
- en: The set of neighbors coordinates are used in the algorithm to look at neighboring
    cells in eight directions. We’ll keep this array handy because we’ll need to use
    it for every cell.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 算法中使用的邻居坐标集用于查看八个方向上的相邻单元格。我们会将这个数组放在手边，因为每个单元格都需要使用它。
- en: '[![2](Images/2.png)](#co_advanced_shared_memory_CO5-2)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_advanced_shared_memory_CO5-2)'
- en: The `iterate()` method takes in a range to operate on in the form of minimum
    X and Y values (inclusive) and maximum X and Y values (exclusive). For our single-threaded
    example, it will always be `(0, 0, size, size)`, but putting a range here will
    make it easier to split up when we move to a multithreaded implementation, where
    we’ll use these X and Y boundaries to divide the whole grid into sections for
    each thread to work on.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`iterate()`方法接受一个操作范围，以最小X和Y值（包含）和最大X和Y值（不包含）的形式。对于我们的单线程示例，它将始终是`(0, 0, size,
    size)`，但在我们转移到多线程实现时，将在这里放置一个范围将使其更容易分割整个网格，以便每个线程可以处理的部分。'
- en: We loop over every cell in the grid, and for each one get the number of neighbors
    that are alive. We’re using the number `1` to represent living cells and `0` to
    represent dead cells, so we can count the number of neighboring living cells by
    adding them all up. Once we have that, we can apply the simplified Game of Life
    algorithm. We store the new cell state in the `nextCells` array, and then provide
    the new cell state and coordinates to the `paint` callback for visualization.
    Then we swap the `cells` and `nextCells` arrays for the subsequent iteration to
    use. That way, inside each iteration, `cells` always represents the previous iteration’s
    result, and `newCells` always represents the current iteration’s result.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遍历网格中的每个单元格，并计算每个单元格周围存活的邻居数量。我们使用数字 `1` 表示存活的单元格，使用 `0` 表示死亡的单元格，因此可以通过累加来计算周围存活的邻居数量。一旦计算出来，我们就可以应用简化的生命游戏算法。我们将新的单元格状态存储在
    `nextCells` 数组中，并将新的单元格状态和坐标提供给 `paint` 回调函数以进行可视化。然后我们交换 `cells` 和 `nextCells`
    数组，以便在后续迭代中使用。这样，在每次迭代中，`cells` 始终代表前一次迭代的结果，而 `newCells` 始终代表当前迭代的结果。
- en: All the code up until this point will be shared with our multithreaded implementation.
    With the `Grid` class complete, we can now move on to creating and initializing
    a `Grid` instance and tying it to our UI. Add the code from [Example 5-9](#ex_ch5_gol_4).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的所有代码将与我们的多线程实现共享。完成 `Grid` 类后，我们现在可以继续创建和初始化一个 `Grid` 实例，并将其与我们的用户界面绑定。添加来自
    [示例 5-9](#ex_ch5_gol_4) 的代码。
- en: Example 5-9\. *ch5-game-of-life/gol.js* (part 4)
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-9\. *ch5-game-of-life/gol.js*（第 4 部分）
- en: '[PRE14]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[![1](Images/1.png)](#co_advanced_shared_memory_CO6-1)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_advanced_shared_memory_CO6-1)'
- en: We assign some constants for the black-and-white pixels we’ll draw to the screen
    and set the size (actually, the width) of the grid we’re using. Feel free to play
    around with the size to see the Game of Life play out in different magnitudes.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为将绘制到屏幕上的黑白像素分配一些常量，并设置我们使用的网格的大小（实际上是宽度）。可以随意调整大小，以查看不同规模下生命游戏的表现。
- en: '[![2](Images/2.png)](#co_advanced_shared_memory_CO6-2)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_advanced_shared_memory_CO6-2)'
- en: We grab an iteration counter and canvas element from the HTML (which we’ll write
    later on). We’ll set our canvas width and height to `SIZE`, and get a 2D context
    from it to work with.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 HTML 中获取迭代计数器和画布元素（稍后将进行编写）。我们将设置画布的宽度和高度为 `SIZE`，并从中获取一个 2D 上下文来进行操作。
- en: '[![3](Images/3.png)](#co_advanced_shared_memory_CO6-3)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_advanced_shared_memory_CO6-3)'
- en: We’ll use an `ImageData` instance to modify the pixels on the canvas directly,
    via a `Uint32Array`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个 `ImageData` 实例直接修改画布上的像素，通过 `Uint32Array`。
- en: '[![4](Images/4.png)](#co_advanced_shared_memory_CO6-4)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_advanced_shared_memory_CO6-4)'
- en: This `paint()` function will be used both in initialization of the grid and
    on each iteration to modify the buffer backing the `ImageData` instance. If a
    cell is alive, it’ll paint it black. Otherwise, it’ll paint it white.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `paint()` 函数将用于初始化网格和在每次迭代中修改支持 `ImageData` 实例的缓冲区。如果单元格是活着的，它将绘制为黑色；否则，绘制为白色。
- en: '[![5](Images/5.png)](#co_advanced_shared_memory_CO6-5)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](Images/5.png)](#co_advanced_shared_memory_CO6-5)'
- en: Now we create the grid instance, passing in the size, an `ArrayBuffer` big enough
    to hold both `cells` and `nextCells`, and our `paint()` function.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们创建网格实例，传入大小、足够大以容纳 `cells` 和 `nextCells` 的 `ArrayBuffer`，以及我们的 `paint()`
    函数。
- en: '[![6](Images/6.png)](#co_advanced_shared_memory_CO6-6)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](Images/6.png)](#co_advanced_shared_memory_CO6-6)'
- en: To initialize the grid, we’ll loop over all the cells and assign each one a
    random dead or alive state. At the same time, we’ll pass the result to our `paint()`
    function to ensure that the image is updated.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了初始化网格，我们将遍历所有单元格，并为每个分配一个随机的生死状态。同时，我们将结果传递给我们的 `paint()` 函数，以确保图像得到更新。
- en: '[![7](Images/7.png)](#co_advanced_shared_memory_CO6-7)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](Images/7.png)](#co_advanced_shared_memory_CO6-7)'
- en: Whenever an `ImageData` is modified, we need to add it back to the canvas, so
    we’re doing it here now that we’re done initializing.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 每当修改 `ImageData` 后，我们都需要将其添加回画布中，所以我们现在在这里执行初始化完成后的操作。
- en: Finally, we’re ready to start running iterations. Add the code from [Example 5-10](#ex_ch5_gol_5).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们准备开始运行迭代。添加来自 [示例 5-10](#ex_ch5_gol_5) 的代码。
- en: Example 5-10\. *ch5-game-of-life/gol.js* (part 5)
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-10\. *ch5-game-of-life/gol.js*（第 5 部分）
- en: '[PRE15]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For each iteration, we start off by calling our `grid.iterate()` method, which
    modifies the cells as appropriate. Note that it calls the `paint()` function for
    each cell, so once that happens, our image data is already set, so we just need
    to add it to the canvas context with `putImageData()`. Then, we’ll update the
    iteration counter on the page and schedule another iteration to happen in a `requestAnimationFrame()`
    callback. Finally, we kick everything off with an initial call to `iterate()`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 每次迭代，我们都会调用 `grid.iterate()` 方法，根据需要修改单元格。请注意，它为每个单元格调用 `paint()` 函数，一旦发生这种情况，我们的图像数据就已经设置好了，所以我们只需用
    `putImageData()` 将其添加到画布上下文中。然后，我们将在页面上更新迭代计数器，并安排在 `requestAnimationFrame()`
    回调中进行另一次迭代。最后，我们通过初始调用 `iterate()` 来启动一切。
- en: We’re done with the JavaScript, but now we need the supporting HTML. Fortunately,
    this is very short. Add the contents of [Example 5-11](#ex_ch5_gol_6) to a file
    called *gol.html* in the same directory, and then open that file up in your browser.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了 JavaScript 的部分，但现在我们需要支持 HTML。幸运的是，这很简短。将 [Example 5-11](#ex_ch5_gol_6)
    的内容添加到同一目录下名为 *gol.html* 的文件中，然后在浏览器中打开该文件。
- en: Example 5-11\. *ch5-game-of-life/gol.html*
  id: totrans-166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 5-11\. *ch5-game-of-life/gol.html*
- en: '[PRE16]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You should now see a 1,000 by 1,000 image displaying Conway’s Game of Life,
    going through the iterations as fast as it can. It should look something like
    [Figure 5-1](#fig_gol1).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该能够看到一个 1,000 x 1,000 的图像，显示康威生命游戏，尽可能快地进行迭代。它应该看起来类似于 [Figure 5-1](#fig_gol1)。
- en: Depending on your computer, you may find that this lags a little bit, rather
    than being crisp and smooth. Iterating over all of these cells and performing
    calculations on them takes a lot of computing power. To speed things up a bit,
    let’s take advantage of some more CPU cores on your machine using web worker threads.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的计算机性能，您可能会发现它稍微有些延迟，而不是清晰流畅。在所有这些单元格上进行迭代并对其进行计算需要大量的计算能力。为了加快速度，让我们利用您机器上更多的
    CPU 核心，使用 Web Worker 线程。
- en: '![mtjs 0501](Images/mtjs_0501.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![mtjs 0501](Images/mtjs_0501.png)'
- en: Figure 5-1\. Conway’s Game of Life after 290 iterations
  id: totrans-171
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 5-1\. 290 次迭代后的康威生命游戏
- en: Multithreaded Game of Life
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多线程生命游戏
- en: For the multithreaded version of our Game of Life implementation, we can reuse
    a lot of the code. In particular, the HTML doesn’t change and neither does our
    `Grid` class. We’ll set up some worker threads and an additional one to coordinate
    and modify image data. We need that additional thread because we can’t use `Atomics.wait()`
    on the main browser thread. We’ll make use of `SharedArrayBuffer`, rather than
    the regular `ArrayBuffer` used in the single-threaded example. To coordinate the
    threads, we’ll need 8 bytes for coordination, specifically 4 to synchronize in
    each direction, since `Atomics.wait()` requires at least an `Int32Array`. Since
    our coordination thread will also be generating the image data, we’ll also need
    enough shared memory to hold that as well. For a grid of side length `SIZE`, this
    means a `SharedArrayBuffer` with memory laid out as in [Table 5-4](#table_gol_sab_layout).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的多线程生命游戏实现版本，我们可以重用大部分代码。特别是 HTML 不会更改，`Grid` 类也不会更改。我们将设置一些工作线程和一个额外的协调线程来修改图像数据。我们需要额外的线程，因为我们不能在主浏览器线程上使用
    `Atomics.wait()`。我们将使用 `SharedArrayBuffer`，而不是单线程示例中使用的常规 `ArrayBuffer`。为了协调线程，我们需要
    8 字节来进行协调，具体来说是每个方向 4 个字节，因为 `Atomics.wait()` 至少需要一个 `Int32Array`。由于我们的协调线程还将生成图像数据，因此我们还需要足够的共享内存来保存这些数据。对于边长为
    `SIZE` 的网格，这意味着一个 `SharedArrayBuffer`，其内存布局如 [Table 5-4](#table_gol_sab_layout)
    所示。
- en: Table 5-4\. Memory layout for four worker threads
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Table 5-4\. 四个工作线程的内存布局
- en: '| Purpose | # of Bytes |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| Purpose | # of Bytes |'
- en: '| --- | --- |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Cells (or next cells) | `SIZE * SIZE` |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| Cells (or next cells) | `SIZE * SIZE` |'
- en: '| Cells (or next cells) | `SIZE * SIZE` |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| Cells (or next cells) | `SIZE * SIZE` |'
- en: '| Image data | `4 * SIZE * SIZE` |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| Image data | `4 * SIZE * SIZE` |'
- en: '| Worker thread wait | `4` |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| Worker thread wait | `4` |'
- en: '| Coordination thread wait | `4` |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| Coordination thread wait | `4` |'
- en: To get started here, copy the *.html* and *.js* files from the previous example
    to new files named *thread-gol.html* and *thread-gol.js*, respectively. Edit *thread-gol.html*
    to make reference to this new JavaScript file.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请将上一个示例中的 *.html* 和 *.js* 文件复制到名为 *thread-gol.html* 和 *thread-gol.js* 的新文件中。分别编辑
    *thread-gol.html*，引用这个新的 JavaScript 文件。
- en: Delete everything after the `Grid` class definition. The next thing we’ll do
    is set up some constants. Add [Example 5-12](#ex_ch5_gol_thread_1) to *thread-gol.js*.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 删除 `Grid` 类定义之后的所有内容。接下来，我们将设置一些常量。在 *thread-gol.js* 中添加 [Example 5-12](#ex_ch5_gol_thread_1)。
- en: Example 5-12\. *ch5-game-of-life/thread-gol.js* (part 1)
  id: totrans-184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-12。*ch5-game-of-life/thread-gol.js*（第1部分）
- en: '[PRE17]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `BLACK`, `WHITE`, and `SIZE` constants have the same purpose as in the single-threaded
    example. We’ll set this `THREADS` constant to any number that’s a divisor of `SIZE`,
    and it will represent the number of worker threads we’ll spawn for doing the Game
    of Life calculation. We’ll be dividing the grid into chunks that can be handled
    by each thread. Feel free to play around with the `THREADS` and `SIZE` variables,
    so long as `THREADS` divides `SIZE`. We’ll need the offsets for where the image
    data and sync bytes are stored, so those are handled here as well. Finally, we’re
    going to use the same file to run on the main thread and any worker threads, so
    we’ll need a way of knowing whether we’re on the main thread or not.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`BLACK`、`WHITE`和`SIZE`常量与单线程示例中的目的相同。我们将这个`THREADS`常量设置为`SIZE`的任何可以整除的数字，它将代表我们为执行生命游戏计算而生成的工作线程数。我们将网格划分为每个线程可以处理的块。可以随意调整`THREADS`和`SIZE`变量，只要`THREADS`能够整除`SIZE`。我们需要处理图像数据和同步字节存储位置的偏移量，因此在此处处理它们。最后，我们将使用相同的文件在主线程和任何工作线程上运行，因此我们需要一种方法来知道我们当前是否在主线程上。'
- en: Next, we’ll start writing the code for the main thread. Add the contents of
    [Example 5-13](#ex_ch5_gol_thread_2).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将开始编写主线程的代码。添加[示例 5-13](#ex_ch5_gol_thread_2)的内容。
- en: Example 5-13\. *ch5-game-of-life/thread-gol.js* (part 2)
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-13。*ch5-game-of-life/thread-gol.js*（第2部分）
- en: '[PRE18]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[![1](Images/1.png)](#co_advanced_shared_memory_CO7-1)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_advanced_shared_memory_CO7-1)'
- en: The `SharedArrayBuffer` ends 16 bytes later than the `syncOffset`, since we
    need 4 bytes for synchronization for each of our four threads.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`SharedArrayBuffer`的结束比`syncOffset`晚了16个字节，因为我们需要为每个线程的同步分配4个字节。'
- en: The first part of this is roughly the same as in the single-threaded example.
    We’re just grabbing the DOM elements and setting the grid size. Next, we set up
    the `SharedArrayBuffer`, which we’re calling `sharedMemory`, and put views on
    it for the `cells` (which we’ll assign values to soon) and got the image data.
    We’ll use both a `Uint32Array` and a `Uint8ClampedArray` for the image data, for
    modification and assignment to the `ImageData` instance, respectively.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分的第一部分与单线程示例中的大致相同。我们只是获取DOM元素并设置网格大小。接下来，我们设置了`SharedArrayBuffer`，我们称之为`sharedMemory`，并为其`cells`（我们很快将为其分配值）放置了视图，并获取了图像数据。我们将使用`Uint32Array`和`Uint8ClampedArray`两种方式处理图像数据，用于修改和分配到`ImageData`实例。
- en: Then we’ll initialize the grid randomly, and at the same time modify the image
    data accordingly and populate that image data to the canvas context. This sets
    up our initial state for the grid. At this point, we can start spawning worker
    threads. Add the contents of [Example 5-14](#ex_ch5_gol_thread_3).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将随机初始化网格，并同时相应地修改图像数据并将该图像数据填充到画布上下文中。这为网格设置了初始状态。此时，我们可以开始生成工作线程。添加[示例 5-14](#ex_ch5_gol_thread_3)的内容。
- en: Example 5-14\. *ch5-game-of-life/thread-gol.js* (part 3)
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-14。*ch5-game-of-life/thread-gol.js*（第3部分）
- en: '[PRE19]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We set up some worker threads in a loop. For each one, we give it a unique name
    for debugging purposes, post it a message telling it what range (i.e., the boundaries
    `minX`, `minY`, `maxX`, and `maxY`) of the grid we want it to operate in, and
    send it the `s⁠h⁠a⁠r⁠e⁠d⁠M⁠e⁠mo⁠r⁠y`. Then we add a coordination worker, pass
    it the `sharedMemory`, and let it know that it’s the coordination worker via a
    message.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用循环设置了一些工作线程。对于每个线程，我们为调试目的给它分配了一个唯一的名称，向其发送了一条消息，告诉它我们希望它操作网格的哪个范围（即边界`minX`、`minY`、`maxX`和`maxY`），并发送了`sharedMemory`。然后，我们添加了一个协调工作线程，传递了`sharedMemory`，并通过消息告知它是协调工作线程。
- en: From the main browser thread, we’re only going to talk to this coordination
    worker. We’ll set it up so that it loops by posting a message every time it receives
    one, but only after grabbing the image data from `SharedMemory`, making the appropriate
    UI updates, and requesting an animation frame.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 从主浏览器线程开始，我们只与这个协调工作线程交互。我们将设置它，使其在接收到消息后每次都会发出一条消息，但仅在从`SharedMemory`获取图像数据，进行适当的UI更新并请求动画帧之后才这样做。
- en: The rest of the code runs in the other threads. Add the contents of [Example 5-15](#ex_ch5_gol_thread_4).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其余部分在其他线程中运行。添加[示例 5-15](#ex_ch5_gol_thread_4)的内容。
- en: Example 5-15\. *ch5-game-of-life/thread-gol.js* (part 4)
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-15。*ch5-game-of-life/thread-gol.js*（第4部分）
- en: '[PRE20]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We’re on the other side of that `isMainThread` condition now, so we know we’re
    in a worker thread or the coordination thread. Here, we declare some variables,
    and then add an initial listener to the `message` event. Regardless of whether
    this is a coordination thread or a worker thread, we’ll need the `sharedMemory`
    and `sync` variables populated, so we assign those in the listener. Then we remove
    the initialization listener, since we won’t need it anymore. The worker threads
    won’t rely on message passing at all, and the coordination thread will have a
    different listener, as we’ll see in a moment.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在 `isMainThread` 条件的另一侧，因此我们知道我们在工作线程或协调线程中。在这里，我们声明一些变量，然后向 `message` 事件添加一个初始监听器。无论这是协调线程还是工作线程，我们都需要填充
    `sharedMemory` 和 `sync` 变量，因此我们在监听器中进行分配。然后我们移除初始化监听器，因为我们不再需要它。工作线程根本不依赖消息传递，协调线程将有一个不同的监听器，稍后我们将看到。
- en: If we’ve initialized a coordination thread we’ll add a new `message` listener;
    a `runCoord` function that we’ll define later. Then we’ll get references to `cells`
    and `nextCells` since we’ll need to keep track on the coordination thread separate
    from what’s going on in the `Grid` instances in the worker threads. Since we’re
    generating the image on the coordination thread, we’ll need that too. Then we
    run the first iteration of `runCoord`. If we’ve initialized a worker thread, we
    simply go ahead and pass the options (containing the range to operate) to `runWorker()`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们初始化了协调线程，我们将添加一个新的 `message` 监听器；一个稍后我们将定义的 `runCoord` 函数。然后我们将获取 `cells`
    和 `nextCells` 的引用，因为我们需要将协调线程中正在进行的 `Grid` 实例与工作线程中的不同步。由于我们在协调线程上生成图像，所以我们也需要它。然后我们运行
    `runCoord` 的第一次迭代。如果我们初始化了工作线程，我们只需将包含操作范围的选项传递给 `runWorker()`。
- en: Let’s go ahead and define `runWorker()` right now. Add the contents of [Example 5-16](#ex_ch5_gol_thread_5).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们定义 `runWorker()`。现在就添加 [Example 5-16](#ex_ch5_gol_thread_5) 的内容。
- en: Example 5-16\. *ch5-game-of-life/thread-gol.js* (part 5)
  id: totrans-204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-16\. *ch5-game-of-life/thread-gol.js*（第 5 部分）
- en: '[PRE21]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Worker threads are the only ones that need an instance of the `Grid` class,
    so first we instantiate it, passing in the `sharedMemory` as the backing buffer.
    This works because we decided that the first part of the `sharedMemory` would
    be the `cells` and `nextCells`, as it would be in the single-threaded example.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 工作线程是唯一需要 `Grid` 类实例的线程，所以我们首先实例化它，并将 `sharedMemory` 作为后备缓冲传递进去。这样做的原因是因为我们决定
    `sharedMemory` 的第一部分将是 `cells` 和 `nextCells`，就像单线程示例中一样。
- en: 'Then we start an infinite loop. The loop performs the following operations:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们启动一个无限循环。循环执行以下操作：
- en: It performs an `Atomics.wait()` on the `i`th element of the `sync` array. In
    the coordination thread, we’ll do the appropriate `Atomics.notify()` to allow
    this to proceed. We’re waiting for the coordination thread here because otherwise
    we may start changing data and swapping references to `cells` and `nextCells`
    before other threads are ready and data has made its way to the main browser thread.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `sync` 数组的第 `i` 个元素上执行 `Atomics.wait()`。在协调线程中，我们将执行适当的 `Atomics.notify()`
    来允许这一过程继续。我们在这里等待协调线程，因为否则我们可能在其他线程准备好并且数据已经传递到主浏览器线程之前开始改变数据并交换对 `cells` 和 `nextCells`
    的引用。
- en: Then it performs the iteration on the `Grid` instance. Remember, we’re only
    operating on the range that the coordination thread said to operate on via the
    `range` property.
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后在 `Grid` 实例上执行迭代。请记住，我们仅在协调线程通过 `range` 属性指定的范围上操作。
- en: Once that’s done, it notifies the main thread of having completed this task.
    This is done by setting the `i`th element of the `sync` array to `1` with `Atomics.store()`,
    and then waking the waiting thread via `Atomics.notify()`. We’re using the transition
    away from the `0` state as an indicator that we should do some work, and a transition
    back to the `0` state to notify that we’ve finished the work.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，通知主线程已完成此任务。通过使用 `Atomics.store()` 将 `sync` 数组的第 `i` 个元素设置为 `1`，然后通过 `Atomics.notify()`
    唤醒等待的线程。我们使用从 `0` 状态转移作为应该执行一些工作的指示器，并在转移回 `0` 状态时通知我们已完成工作。
- en: We’re using `Atomics.wait()` to stop the coordination thread from executing
    while the worker threads are modifying data, and then stop the worker threads
    with `Atomics.wait()` while the coordination thread does its work. On either side,
    we use `Atomics.notify()` to wake the other thread and immediately go back into
    a waiting state, waiting for the other thread to notify back. Because we use atomic
    operations to both modify data and control when it is modified, we know that all
    the data accesses are *sequentially consistent*. In the interleaving program flow
    across threads, a deadlock cannot occur, since we’re always flipping execution
    back and forth from the coordination thread to the worker threads. The worker
    threads never execute on the same parts of memory as each other, so we don’t have
    to worry about this concept from the perspective of solely the worker threads.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用`Atomics.wait()`来阻止协调线程在工作线程修改数据时执行，然后使用`Atomics.wait()`来阻止工作线程在协调线程执行其工作时执行。在两端，我们使用`Atomics.notify()`唤醒另一个线程，并立即进入等待状态，等待另一个线程再次通知。因为我们使用原子操作来修改数据并控制何时修改它，所以我们知道所有的数据访问都是*顺序一致*的。在跨线程的交错程序流中，死锁不会发生，因为我们总是在协调线程和工作线程之间来回切换执行。工作线程永远不会在内存的相同部分执行，因此我们不必单独从工作线程的角度担心这个概念。
- en: Worker threads can just run infinitely. We don’t have to be worried about that
    infinite loop because it will only proceed if `Atomics.wait()` returns, which
    requires that another thread calls `Atomics.notify()` for that same array element.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 工作线程可以无限地运行。我们不必担心那个无限循环，因为它只会在`Atomics.wait()`返回时继续进行，而这需要另一个线程为相同的数组元素调用`Atomics.notify()`。
- en: Let’s wrap up the code here with the `runCoord()` function, which is triggered
    via a message from the main browser thread after the initialization message. Add
    the contents of [Example 5-17](#ex_ch5_gol_thread_6).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过`runCoord()`函数来结束这里的代码，该函数是在主浏览器线程初始化消息后通过消息触发的。添加[示例 5-17](#ex_ch5_gol_thread_6)的内容。
- en: Example 5-17\. *ch5-game-of-life/thread-gol.js* (part 6)
  id: totrans-214
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-17\. *ch5-game-of-life/thread-gol.js*（第6部分）
- en: '[PRE22]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The first thing that happens here is the coordination thread notifying the worker
    threads via the `i`th element of the `sync` array for each worker thread, waking
    them up to perform an iteration. When they’re done, they’ll notify via the same
    element of the `sync` array, so we’ll wait on those. The fact that each of these
    calls to `Atomics.wait()` blocks the thread execution is exactly why we need this
    coordination thread in the first place, rather than just doing it all on the main
    browser thread.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的第一件事是协调线程通过每个工作线程的`sync`数组的第`i`个元素通知工作线程，唤醒它们执行迭代。当它们完成时，它们将通过`sync`数组的相同元素进行通知，所以我们将在这些元素上等待。每个对`Atomics.wait()`的调用阻塞线程执行的事实正是我们需要这个协调线程的原因，而不只是在主浏览器线程上执行所有操作。
- en: Next, we swap the `cells` and `nextCells` references. The workers have already
    done this for themselves inside the `iterate()` method, so we need to follow suit
    here. Then we’re ready to iterate over all the `cells` and convert their values
    to pixels in the image data. Finally, we post a message back to the main browser
    thread, indicating that the data is ready to be displayed in the UI. The coordination
    thread has nothing to do until the next time it receives a message, at which point
    `runCoord` is run again. This method completes the conceptual loop started in
    [Example 5-14](#ex_ch5_gol_thread_3).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们交换`cells`和`nextCells`的引用。工作线程已经在其`iterate()`方法中为自己完成了这一点，所以我们需要在这里跟随。然后，我们准备遍历所有`cells`并将它们的值转换为图像数据中的像素。最后，我们向主浏览器线程发送一条消息，表明数据已准备好在UI中显示。协调线程在接收到下一条消息之前没有任何操作，此时再次运行`runCoord`。该方法完成了[示例 5-14](#ex_ch5_gol_thread_3)中开始的概念循环。
- en: 'Now we’re done! To view the HTML file, remember that in order to use `SharedArrayBuffer`,
    we need a server running with particular headers set. To do this, run the following
    in your *ch5-game-of-life* directory:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们完成了！要查看HTML文件，请记住，为了使用`SharedArrayBuffer`，我们需要运行一个设置了特定头文件的服务器。要做到这一点，请在您的*ch5-game-of-life*目录中运行以下内容：
- en: '[PRE23]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Then, append */thread-gol.html* to the URL provided to see our multithreaded
    implementation of Conway’s Game of Life running. Because we haven’t changed any
    UI code, it should look exactly the same as the single-threaded example in [Figure 5-1](#fig_gol1).
    The only difference you should see is in performance. The transitions between
    iterations likely appear to be much smoother and quicker. You’re not imagining
    things! We’ve moved the work of calculating cell states and plotting pixels into
    separate threads, so now the main thread is free to animate more smoothly, and
    iterations happen faster because we’re using more CPU cores in parallel to do
    the work.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在提供的URL后面添加*/thread-gol.html*，即可看到我们实现的康威生命游戏的多线程实现运行情况。由于我们没有改变任何UI代码，所以它看起来应该与[图 5-1](#fig_gol1)中的单线程示例完全相同。你唯一能看到的区别应该在性能上。迭代之间的过渡可能会显得更加流畅和快速。你没有幻觉！我们已经将计算细胞状态和绘制像素的工作移动到单独的线程中，因此主线程现在可以更流畅地进行动画化，并且由于我们并行使用更多CPU核心来进行工作，迭代速度更快。
- en: Most importantly, we’re avoiding most of the overhead of passing messages between
    threads for coordination by just using `Atomics.notify()` to let other threads
    know that they can continue after having paused themselves with `Atomics.wait()`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，我们通过仅使用`Atomics.notify()`来避免大部分线程协调的消息传递开销，让其他线程知道它们可以在使用`Atomics.wait()`暂停之后继续执行。
- en: Atomics and Events
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Atomics和事件
- en: At the heart of JavaScript lies the event loop, which allows the language to
    create new call stacks and handle events. It’s always been there and we JavaScript
    engineers have always depended on it. This is true for both JavaScript that runs
    in the browser, where you might have jQuery that listens for a click event in
    the DOM, or JavaScript that runs on the server, where you might have the Fastify
    server that waits for an incoming TCP connection to be established.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的核心在于事件循环，它允许语言创建新的调用栈并处理事件。它一直存在，我们JavaScript工程师一直依赖它。无论是运行在浏览器中的JavaScript，例如在DOM中监听点击事件的jQuery，还是运行在服务器上的JavaScript，例如等待建立传入TCP连接的Fastify服务器，这都是真实存在的。
- en: 'Enter the new kid on the block: `Atomics.wait()` and shared memory. This pattern
    now allows applications to halt the execution of JavaScript, thereby causing the
    event loop to completely stop working. Because of this you can’t simply start
    throwing calls to make use of multithreading into your application and expect
    it to work without problem. Instead, certain restrictions must be followed to
    make the application behave nicely.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 新来的新宠:`Atomics.wait()`和共享内存。这种模式现在允许应用程序停止执行JavaScript，从而完全停止事件循环。因此，你不能简单地开始在你的应用程序中随意调用多线程使用的调用，并期望它能够在没有问题的情况下工作。相反，必须遵循某些限制，以使应用程序表现良好。
- en: 'One such restriction is hinted at when it comes to browsers: the main thread
    of the application should not call `Atomics.wait()`. And, while it can be done
    in a simple Node.js script, you should really avoid doing so in a larger application.
    For example, if your main Node.js thread is handling incoming HTTP requests, or
    has a handler for receiving operating system signals, what’s going to happen when
    the event loop comes to a halt when a wait operation is started? [Example 5-18](#ex_stutter)
    is an example of such a program.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到浏览器时，存在这样一种限制：应用程序的主线程不应调用`Atomics.wait()`。虽然在简单的Node.js脚本中可以这样做，但在更大的应用程序中，你确实应该避免这样做。例如，如果你的主Node.js线程正在处理传入的HTTP请求，或者有一个处理接收操作系统信号的处理程序，当事件循环开始等待操作时会发生什么？[示例 5-18](#ex_stutter)就是这样一个程序的示例。
- en: Example 5-18\. *ch5-node-block/main.js*
  id: totrans-226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-18\. *ch5-node-block/main.js*
- en: '[PRE24]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[![1](Images/1.png)](#co_advanced_shared_memory_CO8-1)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_advanced_shared_memory_CO8-1)'
- en: Every 2 seconds the app pauses for 1.9 seconds
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 每2秒应用程序暂停1.9秒
- en: 'If you feel so inclined, create a directory for this file and execute the server
    by running the following command:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感兴趣，可以为此文件创建一个目录，并通过运行以下命令来执行服务器：
- en: '[PRE25]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Once it’s running, execute the following command in your terminal several times,
    waiting a random amount of time between each invocation:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦程序运行起来，在终端中多次执行以下命令，每次调用之间等待随机时间：
- en: '[PRE26]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: What this application does is first create an HTTP server and listen for requests.
    Then, every two seconds, a call to `Atomics.wait()` is made. It’s configured in
    such a way that the application freezes for 1.9 seconds to exaggerate the effect
    of long pauses. The `curl` command you’re running is prefixed with the `time`
    command, which displays the amount of time the following command takes to run.
    Your output will then randomly vary between 0 and 1.9 seconds, which is a huge
    amount of time for a web request to pause for. Even as you reduce that timeout
    value closer and closer to 0, you’ll still end up with micro stutters that globally
    affect all incoming requests. If web browsers allowed `Atomics.wait()` calls in
    the main thread, you would definitely be encountering micro stutters from this
    in websites you visit today.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序首先创建HTTP服务器并监听请求。然后，每两秒钟调用一次`Atomics.wait()`。它被配置为应用程序冻结1.9秒，以夸大长暂停的效果。你正在运行的`curl`命令前面带有`time`命令，显示以下命令运行所需的时间。你的输出将在0到1.9秒之间随机变化，这对于Web请求来说是巨大的暂停时间。即使将该超时值减小到接近0，你仍会遇到全局影响所有传入请求的微小卡顿。如果Web浏览器允许在主线程中调用`Atomics.wait()`，那么你今天访问的网站肯定会遇到微小卡顿。
- en: 'Another question still remains: what sort of restrictions should come into
    play with each of the additional threads that an application spawns, considering
    that each thread has their own event loop?'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题仍然存在：应用程序生成的每个额外线程都应该施加什么样的限制，考虑到每个线程都有自己的事件循环？
- en: Our recommendation is to designate ahead of time what the main purpose of each
    spawned thread is. Each thread either becomes a CPU-heavy thread that makes heavy
    use of `Atomics` calls or an event-heavy thread that makes minimal `Atomics` calls.
    With such an approach, you might have a thread that is a worker in the truest
    sense, constantly performing complex calculations and writing the results to a
    shared array buffer. You would also have your main thread, which is then mostly
    communicating via message passing and doing event loop based work. It then might
    make sense to have simple intermediary threads that call `Atomics.wait()` as they
    wait for another thread to finish doing work, then call `postMessage()` to send
    the resulting data back to the main thread to handle the result at a much higher
    level.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议事先确定每个生成线程的主要目的。每个线程要么成为一个CPU密集型线程，大量使用`Atomics`调用，要么成为一个事件密集型线程，最小限度使用`Atomics`调用。采用这样的方法，你可能会有一个真正的工作线程，不断执行复杂的计算并将结果写入共享数组缓冲区。你也会有你的主线程，主要通过消息传递进行通信，并进行基于事件循环的工作。因此，拥有简单的中介线程调用`Atomics.wait()`等待另一个线程完成工作，然后调用`postMessage()`发送生成的数据回主线程，以便在更高层次处理结果，这样做可能是有意义的。
- en: 'To summarize the concepts in this section:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 总结本节中的概念：
- en: Don’t use `Atomics.wait()` in the main thread.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在主线程中使用`Atomics.wait()`。
- en: Designate which threads are CPU-heavy and use lots of `Atomics` calls and which
    threads are evented.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定哪些线程是CPU密集型的，并且大量使用`Atomics`调用，哪些线程是事件驱动的。
- en: Consider using simple “bridge” threads to wait and post messages where appropriate.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑在适当的地方使用简单的“桥接”线程来等待和发布消息。
- en: These are some very high-level guidelines that you can follow when designing
    your application. But sometimes some more concrete patterns really help drive
    the point home. [Chapter 6](ch06.xhtml#ch_patterns) contains some such patterns
    you might find beneficial.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是你在设计应用程序时可以遵循的一些非常高级的指南。但有时候一些更具体的模式确实有助于更好地理解。[第6章](ch06.xhtml#ch_patterns)包含一些这样的模式，你可能会发现有益。
- en: ^([1](ch05.xhtml#idm45995918555608-marker)) `Atomics.notify()` was originally
    going to be called `Atomics.wake()` like its Linux futex equivalent but was later
    renamed to prevent visual confusion between “wake” and “wait” methods.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch05.xhtml#idm45995918555608-marker)) `Atomics.notify()`最初被称为`Atomics.wake()`，就像它的Linux
    futex等效物一样，但后来改名以防止“wake”和“wait”方法之间的视觉混淆。
