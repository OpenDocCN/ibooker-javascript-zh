- en: Chapter 5\. Classes and Interfaces
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章\. 类和接口
- en: If you’re like most programmers coming from an object-oriented programming language,
    classes are your bread and butter. Classes are how you organize and think about
    your code, and they serve as your primary unit of encapsulation. You’ll be pleased
    to learn that TypeScript classes borrow heavily from C#, and support things like
    visibility modifiers, property initializers, polymorphism, decorators, and interfaces.
    But because TypeScript classes compile down to regular JavaScript classes, you
    can also express JavaScript idioms like mixins in a typesafe way.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您像大多数来自面向对象编程语言的程序员一样，类是您的基础和要点。类是您组织和思考代码的方式，也是封装的主要单元。您会高兴地发现，TypeScript
    类大量借鉴了 C#，支持可见性修饰符、属性初始化器、多态、装饰器和接口等功能。但由于 TypeScript 类编译成常规 JavaScript 类，您也可以以类型安全的方式表达
    JavaScript 习语，如混合类。
- en: Some of TypeScript’s class features, like property initializers and decorators,
    are supported by JavaScript classes too,^([1](ch05.html#idm46304973683464)) and
    so generate runtime code. Other features, like visibility modifiers, interfaces,
    and generics, are TypeScript-only features that just exist at compile time, and
    don’t generate any code when you compile your application to JavaScript.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 的某些类特性，如属性初始化器和装饰器，也被 JavaScript 类支持，^([1](ch05.html#idm46304973683464))
    因此会生成运行时代码。其他特性，如可见性修饰符、接口和泛型，则是 TypeScript 独有的特性，仅在编译时存在，编译应用程序为 JavaScript 时不会生成任何代码。
- en: In this chapter I’ll guide you through an extended example of how we work with
    classes in TypeScript, so that you can gain some intuition not only for TypeScript’s
    object-oriented language features, but for how and why we use them. Try to follow
    along, entering the code in your code editor as we go.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将通过一个扩展示例向您介绍如何在 TypeScript 中使用类，以便您不仅可以对 TypeScript 的面向对象语言特性有直观的理解，还可以理解我们使用它们的方式和原因。请尝试跟着进行，将代码输入到您的代码编辑器中。
- en: Classes and Inheritance
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类和继承
- en: We’re going to build a chess engine. Our engine will model a game of chess and
    provide an API for two players to take turns making moves.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要构建一个国际象棋引擎。我们的引擎将模拟国际象棋游戏，并为两名玩家提供轮流进行移动的 API。
- en: 'We’ll start by sketching out the types:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从勾勒类型开始：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There are six types of pieces:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 有六种类型的棋子：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Every piece has a color and a current position. In chess, positions are modeled
    as (letter, number) coordinate pairs; letters run from left to right along the
    x-axis, numbers from bottom to top along the y-axis ([Figure 5-1](#standard-alg-fig)).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 每个棋子都有颜色和当前位置。在国际象棋中，位置被建模为（字母，数字）坐标对；字母沿着 x 轴从左到右，数字沿着 y 轴从底部到顶部（[图 5-1](#standard-alg-fig)）。
- en: '![prts 0501](assets/prts_0501.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![prts 0501](assets/prts_0501.png)'
- en: 'Figure 5-1\. Standard algebraic notation in chess: A–H (the x-axis) are called
    “files” and 1–8 (the inverted y-axis) “ranks”'
  id: totrans-12
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-1\. 国际象棋中的标准代数符号：A–H（x 轴）称为“列”，1–8（反向 y 轴）称为“行”
- en: 'Let’s add color and position to our `Piece` class:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向我们的 `Piece` 类添加颜色和位置：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[![1](assets/1.png)](#icon_in_code_classes__amp__oop_CO1-1)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#icon_in_code_classes__amp__oop_CO1-1)'
- en: Since there are relatively few colors, ranks, and files, we can manually enumerate
    their possible values as type literals. This will let us squeeze out some extra
    safety by constraining these types’ domains from all strings and all numbers to
    a handful of very specific strings and numbers.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于颜色、行和列相对较少，我们可以手动枚举它们的可能值作为类型文字。这将通过将这些类型的域约束为一些非常具体的字符串和数字，来帮助我们提供额外的安全性。
- en: '[![2](assets/2.png)](#icon_in_code_classes__amp__oop_CO1-2)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#icon_in_code_classes__amp__oop_CO1-2)'
- en: The `private` *access modifier* in the constructor automatically assigns the
    parameter to `this` (`this.file` and so on), and sets its visibility to private,
    meaning that code within a `Piece` instance can read and write to it, but code
    outside of a `Piece` instance can’t. Different instances of `Piece` can access
    each other’s private members; instances of any other class—even a subclass of
    `Piece`—can’t.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，`private` *访问修饰符* 自动将参数分配给 `this`（`this.file` 等），并将其可见性设置为私有，这意味着 `Piece`
    实例内的代码可以读取和写入它，但 `Piece` 实例外的代码不能。不同 `Piece` 实例可以访问彼此的私有成员；任何其他类的实例，甚至是 `Piece`
    的子类，也不能访问。
- en: '[![3](assets/3.png)](#icon_in_code_classes__amp__oop_CO1-3)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#icon_in_code_classes__amp__oop_CO1-3)'
- en: We declare the instance variable `position` as `protected`. Like `private`,
    `protected` assigns the property to `this`, but unlike `private`, `protected`
    makes the property visible both to instances of `Piece` and to instances of any
    subclass of `Piece`. We didn’t assign `position` a value when declaring it, so
    we have to assign a value to it in `Piece`’s constructor function. If we hadn’t
    assigned it a value in the constructor, TypeScript would have told us that the
    variable is not *definitely assigned*, i.e., we said it’s of type `T`, but it’s
    actually `T | undefined` because it’s not assigned a value in a property initializer
    or in the constructor—so we would need to update its signature to indicate that
    it’s not necessarily a `Position`, but it might also be `undefined`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实例变量 `position` 声明为 `protected`。与 `private` 不同，`protected` 将属性分配给 `this`，但与
    `private` 不同的是，`protected` 使得属性对 `Piece` 的实例和任何 `Piece` 的子类的实例都可见。我们在声明时没有为 `position`
    分配一个值，因此我们必须在 `Piece` 构造函数中为其分配一个值。如果我们没有在构造函数中为其分配一个值，TypeScript 会告诉我们该变量未被 *确定赋值*，即我们说它是类型
    `T`，但实际上是 `T | undefined`，因为它在属性初始化程序或构造函数中未被赋值 —— 因此我们需要更新其签名以表明它不一定是 `Position`，而可能也是
    `undefined`。
- en: '[![4](assets/4.png)](#icon_in_code_classes__amp__oop_CO1-4)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#icon_in_code_classes__amp__oop_CO1-4)'
- en: '`new Piece` takes three parameters: `color`, `file`, and `rank`. We added two
    modifiers to `color`: `private`, meaning assign it to `this` and make sure it’s
    only accessible from an instance of `Piece`, and `readonly`, meaning that after
    this initial assignment it can only be read and can’t be written anymore.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`new Piece` 接受三个参数：`color`、`file` 和 `rank`。我们对 `color` 添加了两个修饰符：`private`，意味着将其分配给
    `this` 并确保它仅从 `Piece` 的实例访问，以及 `readonly`，意味着在此初始分配后，它只能读取，不能再写入。'
- en: 'TSC Flags: strictNullChecks and strictPropertyInitialization'
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TSC 标志：`strictNullChecks` 和 `strictPropertyInitialization`
- en: To opt into definite assignment checks for class instance variables, enable
    `strictNullChecks` and `strictPropertyInitialization` flags in your *tsconfig.json*.
    If you’re already using the `strict` flag, you’re good to go.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要为类实例变量启用确定赋值检查，请在你的 *tsconfig.json* 中启用 `strictNullChecks` 和 `strictPropertyInitialization`
    标志。如果你已经使用了 `strict` 标志，你可以继续使用。
- en: 'TypeScript supports three access modifiers for properties and methods on a
    class:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 支持类的属性和方法的三种访问修饰符：
- en: '`public`'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`public`'
- en: Accessible from anywhere. This is the default access level.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 可从任何地方访问。这是默认的访问级别。
- en: '`protected`'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`protected`'
- en: Accessible from instances of this class and its subclasses.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 可从此类的实例和其子类访问。
- en: '`private`'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`private`'
- en: Accessible from instances of this class only.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 仅从此类的实例访问。
- en: Using access modifiers, you can design classes that don’t expose too much information
    about their implementations, and instead expose well-defined APIs for others to
    use.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用访问修饰符，你可以设计不会过多暴露其实现细节的类，并暴露出为他人使用定义良好的 API。
- en: 'We’ve defined a `Piece` class, but we don’t want users to instantiate a new
    `Piece` directly—we want them to extend it to create a `Queen`, a `Bishop`, and
    so on, and instantiate *that*. We can use the type system to enforce that for
    us, using the `abstract` keyword:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个 `Piece` 类，但不希望用户直接实例化一个新的 `Piece` —— 我们希望他们扩展它以创建 `Queen`、`Bishop` 等，并实例化那些类。我们可以使用类型系统来强制执行这一点，使用
    `abstract` 关键字：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now if you try to instantiate a `Piece` directly, TypeScript complains:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果你尝试直接实例化一个 `Piece`，TypeScript 会报错：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `abstract` keyword means that you can’t instantiate the class directly,
    but it doesn’t mean you can’t define some methods on it:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`abstract` 关键字意味着你不能直接实例化这个类，但并不意味着你不能在其上定义一些方法：'
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Our `Piece` class now:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Piece` 类现在：
- en: 'Tells its subclasses that they have to implement a method called `canMoveTo`
    that is compatible with the given signature. If a class extends `Piece` but forgets
    to implement the abstract `canMoveTo` method, that’s a type error at compile time:
    when you implement an abstract class, you have to implement its abstract methods
    too.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 告知其子类它们必须实现一个名为 `canMoveTo` 的方法，该方法的签名必须兼容。如果一个类扩展了 `Piece` 但忘记实现抽象的 `canMoveTo`
    方法，那在编译时就是类型错误：当你实现一个抽象类时，你必须也要实现其抽象方法。
- en: Comes with a default implementation for `moveTo` (which its subclasses can override
    if they want). We didn’t put an access modifier on `moveTo`, so it’s `public`
    by default, meaning it’s readable and writable from any other code.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供了一个默认的 `moveTo` 实现（其子类可以选择覆盖）。我们没有在 `moveTo` 上放置访问修饰符，所以默认是 `public`，意味着它可从任何其他代码中读写。
- en: 'Let’s update `King` to implement `canMoveTo`, to satisfy this new requirement.
    We’ll also implement a `distanceFrom` function for convenience, so we can easily
    compute the distance between two pieces:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新 `King`，实现 `canMoveTo`，以满足这个新需求。我们还将实现一个 `distanceFrom` 函数，以便轻松计算两个棋子之间的距离：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When we make a new game, we’ll automatically create a board and some pieces:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个新游戏时，我们会自动创建一个棋盘和一些棋子：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Because of how strictly we typed `Rank` and `File`, if we had entered another
    letter (like `'J'`) or an out-of-range number (like `12`), TypeScript would have
    given us a compile-time error ([Figure 5-2](#typescript-valid-fig)).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们严格类型化了 `Rank` 和 `File`，如果我们输入了另一个字母（如 `'J'`）或超出范围的数字（如 `12`），TypeScript
    将在编译时给出错误（见图 5-2 ）。
- en: '![prts 0502](assets/prts_0502.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![prts 0502](assets/prts_0502.png)'
- en: Figure 5-2\. TypeScript helps us stick to valid ranks and files
  id: totrans-48
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-2。TypeScript 帮助我们坚持有效的等级和文件
- en: This is enough to show off how TypeScript classes work—I’ll avoid getting into
    the nitty-gritty details like how to know when a knight can take a piece, how
    bishops move, and so on. If you’re ambitious, see if you can use what we’ve done
    so far as a starting point to implement the rest of the game yourself.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这已足以展示 TypeScript 类的工作原理——我将避免深入讨论如何知道骑士何时可以吃掉一枚棋子，主教如何移动等细节。如果你有雄心壮志，看看是否可以以我们迄今为止所做的作为实现游戏其余部分的起点。
- en: 'To sum up:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下：
- en: Declare classes with the `class` keyword. Extend them with the `extends` keyword.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `class` 关键字声明类。使用 `extends` 关键字扩展类。
- en: Classes can be either concrete or `abstract`. Abstract classes can have `abstract`
    methods and `abstract` properties.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类可以是具体类或 `abstract` 类。抽象类可以有 `abstract` 方法和 `abstract` 属性。
- en: Methods can be `private`, `protected`, or, by default, `public`. They can be
    instance methods or static methods.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法可以是 `private`、`protected` 或默认的 `public`。它们可以是实例方法或静态方法。
- en: Classes can have instance properties, which can also be `private`, `protected`,
    or, by default, `public`. You can declare them in constructor parameters or as
    property initializers.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类可以有实例属性，这些属性也可以是 `private`、`protected` 或默认的 `public`。你可以在构造函数参数中声明它们，也可以在属性初始化器中声明它们。
- en: You can mark instance properties as `readonly` when declaring them.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在声明时，可以将实例属性标记为 `readonly`。
- en: super
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: super
- en: 'Like JavaScript, TypeScript supports `super` calls. If your child class overrides
    a method defined on its parent class (say, if `Queen` and `Piece` both implement
    the `take` method), the child instance can make a `super` call to call its parent’s
    version of the method (e.g., `super.take`). There are two kinds of `super` calls:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 与 JavaScript 一样，TypeScript 支持 `super` 调用。如果你的子类覆盖了父类定义的方法（比如 `Queen` 和 `Piece`
    都实现了 `take` 方法），子类实例可以使用 `super` 调用来调用其父类的方法（例如 `super.take`）。`super` 调用有两种类型：
- en: Method calls, like `super.take`.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法调用，如 `super.take`。
- en: Constructor calls, which have the special form `super()` and can only be called
    from a constructor function. If your child class has a constructor function, you
    must call `super()` from the child’s constructor to correctly wire up the class
    (don’t worry, TypeScript will warn you if you forget; it’s like a cool futuristic
    robot elephant in that way).
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数调用，具有特殊形式 `super()`，只能从构造函数中调用。如果你的子类有构造函数，必须从子类的构造函数中调用 `super()`，以正确连接类（别担心，TypeScript
    会在你忘记时提醒你；这就像一个酷炫的未来机器大象）。
- en: Note that you can only access a parent class’s methods, and not its properties,
    with `super`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你只能使用 `super` 访问父类的方法，而不能访问其属性。
- en: Using this as a Return Type
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `this` 作为返回类型
- en: Just like you can use `this` as a value, you can also use it as a type (like
    we did in [“Typing this”](ch04.html#typing-this)). When working with classes,
    the `this` type can be useful for annotating methods’ return types.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你可以将 `this` 用作值一样，你也可以将其用作类型（就像我们在“Typing this”中所做的那样）。在处理类时，`this` 类型对于注释方法的返回类型非常有用。
- en: 'For example, let’s build a simplified version of ES6’s `Set` data structure
    that supports two operations: adding a number to the set, and checking whether
    or not a given number is in the set. You use it like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们构建一个简化版的 ES6 `Set` 数据结构，支持两种操作：向集合中添加一个数字，以及检查给定的数字是否在集合中。你可以像这样使用它：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let’s define the `Set` class, starting with the `has` method:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义 `Set` 类，从 `has` 方法开始：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'How about `add`? When you call `add`, you get back an instance of `Set`. We
    could type that as:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`add` 方法如何？当你调用 `add` 时，会得到一个 `Set` 的实例。我们可以将其类型定义为：'
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: So far, so good. What happens when we try to subclass `Set`?
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都好。当我们尝试子类化 `Set` 时会发生什么？
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Of course, `Set`’s `add` method still returns a `Set`, which we’ll need to
    override with `MutableSet` for our subclass:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`Set`的`add`方法仍然返回一个`Set`，我们需要为我们的子类`MutableSet`覆盖它：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This can get a bit tedious when working with classes that extend other classes—you
    have to override the signature for each method that returns `this`. And if you
    end up having to override each method to please the typechecker, what’s the point
    of inheriting from your base class at all?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当你与扩展其他类的类一起工作时，这可能会变得有点乏味——你必须为每个返回`this`的方法覆盖签名。如果你最终不得不为了满足类型检查器而覆盖每个方法，那么从基类继承有什么意义呢？
- en: 'Instead, you can use `this` as a return type annotation to let TypeScript do
    the work for you:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你可以使用`this`作为返回类型注释，让 TypeScript 为你完成这项工作：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, you can remove the `add` override from `MutableSet`, since `this` in `Set`
    points to a `Set` instance, and `this` in `MutableSet` points to a `MutableSet`
    instance:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以从`MutableSet`中删除`add`的覆盖，因为`Set`中的`this`指向一个`Set`实例，而`MutableSet`中的`this`指向一个`MutableSet`实例：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is a really convenient feature for working with chained APIs, like we do
    in [“Builder Pattern”](#builder-pattern).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于与链式 API（如我们在[“构建器模式”](#builder-pattern)中所做的）一起工作非常方便。
- en: Interfaces
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口
- en: When you use classes, you will often find yourself using them with *interfaces*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用类时，你经常会发现自己使用*接口*。
- en: 'Like type aliases, interfaces are a way to name a type so you don’t have to
    define it inline. Type aliases and interfaces are mostly two syntaxes for the
    same thing (like function expressions and function declarations), but there are
    a few small differences. Let’s start with what they have in common. Consider the
    following type alias:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 像类型别名一样，接口是一种命名类型的方法，这样你就不必在内联中定义它。类型别名和接口在大多数情况下是同一件事的两种语法（就像函数表达式和函数声明一样），但它们有一些小差异。让我们从它们的共同点开始。考虑以下类型别名：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'It’s easy to rewrite it as an interface:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 将它重写为接口是很容易的：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Everywhere you used your `Sushi` type alias, you can also use your `Sushi` interface.
    Both declarations define shapes, and those shapes are assignable to one another
    (in fact, they’re identical!).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在你使用`Sushi`类型别名的任何地方，你也可以使用`Sushi`接口。这两个声明都定义了形状，并且这些形状可以互相赋值（实际上它们是相同的！）。
- en: 'Things get more interesting when you start combining types. Let’s model another
    food in addition to `Sushi`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始组合类型时，事情变得更加有趣。让我们模拟除了`Sushi`之外的另一种食物：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'A lot of foods have calories and are tasty—not just `Sushi` and `Cake`. Let’s
    pull `Food` out into its own type, and redefine our foods in terms of it:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 很多食物都有卡路里，而且味道不错——不只是`Sushi`和`Cake`。让我们将`Food`提取到它自己的类型中，并根据它重新定义我们的食物：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Nearly equivalently, you can do that with interfaces too:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎等效地，你也可以用接口做到这一点：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-92
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Interfaces don’t have to extend other interfaces. In fact, an interface can
    extend any shape: an object `type`, a `class`, or another `interface`.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接口不必扩展其他接口。事实上，一个接口可以扩展任何形状：一个对象`type`，一个`class`或另一个`interface`。
- en: What are the differences between types and interfaces? There are three, and
    they’re subtle.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 类型和接口之间有哪些区别？有三个，而且它们是微妙的。
- en: 'The first is that type aliases are more general, in that their righthand side
    can be any type, including a type expression (a type, and maybe some type operators
    like `&` or `|`); for an interface, the righthand side must be a shape. For example,
    there is no way to rewrite the following type aliases as interfaces:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，类型别名更通用，因为它们的右侧可以是任何类型，包括类型表达式（一种类型，可能还包括一些类型操作符如`&`或`|`）；对于接口来说，右侧必须是一个形状。例如，无法将以下类型别名重写为接口：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The second difference is that when you extend an interface, TypeScript will
    make sure that the interface you’re extending is assignable to your extension.
    For example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个区别是，当你扩展一个接口时，TypeScript 将确保你扩展的接口可以赋值给你的扩展。例如：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is not the case when you use intersection types: if you turn the interfaces
    from the last example into type aliases and the `extends` into an intersection
    (`&`), TypeScript will do its best to combine your extension with the type it’s
    extending, resulting in an overloaded signature for `bad` instead of a compile-time
    error (try it in your code editor!).'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用交集类型时不是这样的：如果你将上一个示例中的接口转换为类型别名，并将`extends`转换为交集（`&`），TypeScript 将尽力将你的扩展与它扩展的类型结合起来，导致`bad`的重载签名而不是编译时错误（在你的代码编辑器中试试吧！）。
- en: When you’re modeling inheritance for object types, the assignability check that
    TypeScript does for interfaces can be a helpful tool to catch errors.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当您为对象类型建模继承时，TypeScript为接口进行的可分配性检查可以帮助您捕捉错误。
- en: The third difference is that multiple interfaces with the same name in the same
    scope are automatically merged; multiple *type aliases* with the same name in
    the same scope will throw a compile-time error. This is a feature called *declaration
    merging*.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个区别是在相同作用域中多个名称相同的*类型别名*将抛出编译时错误。这是一种称为*声明合并*的功能。
- en: Declaration Merging
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明合并
- en: Declaration merging is TypeScript’s way of automatically combining multiple
    declarations that share the same name. It came up when we introduced enums ([“Enums”](ch03.html#enums)),
    and it also comes up when working with other features like `namespace` declarations
    (see [“Namespaces”](ch10.html#namespaces)). In this section we’ll briefly introduce
    declaration merging in the context of interfaces. For a deeper dive, head over
    to [“Declaration Merging”](ch10.html#namespace-merging).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 声明合并是TypeScript自动组合多个具有相同名称的声明的方式。当我们引入枚举时（[“枚举”](ch03.html#enums)），它出现了；当处理`namespace`声明（参见[“命名空间”](ch10.html#namespaces)）等其他功能时也会出现。在本节中，我们将简要介绍接口上下文中的声明合并。要深入了解，请转到[“声明合并”](ch10.html#namespace-merging)。
- en: 'For example, if you declare two identically named `User` interfaces, then TypeScript
    will automatically combine them for you into a single interface:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您声明两个名称相同的`User`接口，则TypeScript会自动将它们合并为单个接口：
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here’s what happens if you repeat that example with type aliases:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用类型别名重复该示例的情况如下：
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Note that the two interfaces can’t conflict; if one types `property` as a `T`
    and the other types it as a `U`, and `T` and `U` aren’t identical, then you’ll
    get an error:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这两个接口不能冲突；如果一个类型将`property`声明为`T`，而另一个类型将其声明为`U`，并且`T`和`U`不相同，则会出现错误：
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: And if your interface declares generics (skip ahead to [“Polymorphism”](#class-generics)
    to learn more), those generics have to be declared the exact same way for two
    interfaces to be mergeable—down to the generic’s name!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的接口声明泛型（请跳到[“多态性”](#class-generics)以了解更多），那些泛型必须以完全相同的方式声明两个接口才能合并 - 直到泛型的名称为止！
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Interestingly, this is a rare place where TypeScript checks that two types are
    not only assignable, but *identical*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，这是TypeScript检查两种类型不仅可分配，而且*相同*的罕见场所。
- en: Implementations
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: When you declare a class, you can use the `implements` keyword to say that it
    satisfies a particular interface. Like other explicit type annotations, this is
    a convenient way to add a type-level constraint that your class is implemented
    correctly as closely as possible to the implementation itself, so that the error
    from an incorrect implementation doesn’t show up downstream where it’s less clear
    why it was thrown. It’s also a familiar way to implement common design patterns
    like adapters, factories, and strategies (see the end of this chapter for some
    examples).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当您声明类时，可以使用`implements`关键字表示它满足特定接口。与其他显式类型注释一样，这是一种方便的方式，可以在接口实现不正确的情况下将类型级约束添加到实现本身，以便在下游显示不清楚为什么会引发错误。这也是实现常见设计模式（如适配器、工厂和策略）的熟悉方式（有关一些示例，请参阅本章末尾）。
- en: 'Here’s what that looks like:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来是这样的：
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`Cat` has to implement every method that `Animal` declares, and can implement
    more methods and properties on top if it wants.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cat`必须实现`Animal`声明的每个方法，并且可以在其上实现更多方法和属性。'
- en: 'Interfaces can declare instance properties, but they can’t declare visibility
    modifiers (`private`, `protected`, and `public`) and they can’t use the `static`
    keyword. You can also mark instance properties as `readonly`, just like we did
    for object types in Objects (in [Chapter 3](ch03.html#types)):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接口可以声明实例属性，但不能声明可见性修饰符（`private`、`protected`和`public`），也不能使用`static`关键字。您还可以像在对象（在[第3章](ch03.html#types)）中一样为实例属性标记为`readonly`：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You’re not limited to implementing just one interface—you can implement as
    many as you want:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您不限于实现一个接口，您可以实现尽可能多的接口：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: All of these features are completely typesafe. If you forget to implement a
    method or a property, or implement it incorrectly, TypeScript will come to the
    rescue (see [Figure 5-3](#typescript-error-fig)).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些功能完全安全。如果您忘记实现方法或属性，或者实现不正确，TypeScript将来拯救您（参见[图 5-3](#typescript-error-fig)）。
- en: '![prts 0503](assets/prts_0503.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![prts 0503](assets/prts_0503.png)'
- en: Figure 5-3\. TypeScript throws an error when you forget to implement a required
    method
  id: totrans-124
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-3\. TypeScript 在你忘记实现必需方法时会抛出错误。
- en: Implementing Interfaces Versus Extending Abstract Classes
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现接口与扩展抽象类的区别
- en: Implementing an interface is really similar to extending an abstract class.
    The difference is that interfaces are more general and lightweight, and abstract
    classes are more special-purpose and feature-rich.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 实现接口与扩展抽象类非常相似。不同之处在于接口更通用和轻量级，而抽象类则更专用和功能丰富。
- en: An interface is a way to model a shape. At the value level, that means an object,
    array, function, class, or class instance. Interfaces do not emit JavaScript code,
    and only exist at compile time.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是一种建模形状的方式。在值级别上，这意味着对象、数组、函数、类或类实例。接口不生成 JavaScript 代码，只存在于编译时。
- en: An abstract class can only model, well, a class. It emits runtime code that
    is, you guessed it, a JavaScript class. Abstract classes can have constructors,
    provide default implementations, and set access modifiers for properties and methods.
    Interfaces can’t do any of those things.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类只能模拟类。它生成运行时代码，你猜对了，是 JavaScript 类。抽象类可以有构造函数，提供默认实现，并设置属性和方法的访问修饰符。接口则不能做这些事情。
- en: Which one you use depends on your use case. When an implementation is shared
    among multiple classes, use an abstract class. When you need a lightweight way
    to say “this class is a `T`,” use an interface.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用哪个取决于你的用例。当一个实现被多个类共享时，请使用抽象类。当你需要一种轻量级方式来表达“这个类是`T`”时，请使用接口。
- en: Classes Are Structurally Typed
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类是结构化类型化的
- en: 'Like every other type in TypeScript, TypeScript compares classes by their structure,
    not by their name. A class is compatible with any other type that shares its shape,
    including a regular old object that defines the same properties or methods as
    the class. This is important to keep in mind for those of you coming from C#,
    Java, Scala, and most other languages where classes are typed nominally. It means
    that if you have a function that takes a `Zebra` and you give it a `Poodle`, TypeScript
    might not mind:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 像 TypeScript 中的其他类型一样，TypeScript 通过它们的结构而不是它们的名称来比较类。类与任何其他共享相同形状的类型兼容，包括定义与类相同属性或方法的常规对象。对于从
    C#、Java、Scala 和大多数其他按名义类型化类的语言中来的人来说，这一点很重要。这意味着如果你有一个接受`Zebra`的函数，并给它一个`Poodle`，TypeScript
    可能不会介意：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As the phylogeneticists among you know, a zebra is no poodle—but TypeScript
    doesn’t mind! As long as `Poodle` is assignable to `Zebra`, TypeScript is OK with
    it because from our function’s point of view, the two are interchangeable; all
    that matters is that they implement `.trot`. If you were using almost any other
    language that types classes nominally, this code would have raised an error; but
    TypeScript is structurally typed through and through, so this code is perfectly
    acceptable.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你们中的系统发生学家所知，斑马不是贵宾犬，但 TypeScript 并不介意！只要`Poodle`可分配给`Zebra`，TypeScript 就没问题，因为从我们函数的角度来看，这两者是可以互换的；重要的是它们都实现了`.trot`方法。如果你使用的是几乎任何其他按名义类型化类的语言，此代码将引发错误；但
    TypeScript 是完全结构化类型化的，所以此代码是完全可接受的。
- en: 'The exception to this rule is classes with `private` or `protected` fields:
    when checking whether or not a shape is assignable to a class, if the class has
    any `private` or `protected` fields and the shape is not an instance of that class
    or a subclass of that class, then the shape is not assignable to the class:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此规则的例外是带有`private`或`protected`字段的类：在检查形状是否可分配给类时，如果类具有任何`private`或`protected`字段，并且形状不是该类或其子类的实例，则形状不能分配给类：
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Classes Declare Both Values and Types
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类声明值和类型两者：
- en: 'Most things that you can express in TypeScript are either values *or* types:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 中你可以表达的大多数事物要么是值，*要么*是类型：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Types and values are namespaced separately in TypeScript. Depending on how
    you use a term (`a` or `b` in this example), TypeScript knows whether to resolve
    it to a type or to a value:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 中，类型和值是分开命名空间的。根据你如何使用术语（例如本例中的`a`或`b`），TypeScript 知道是否将其解析为类型还是值：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This *contextual term resolution* is really nice, and lets us do cool things
    like implement companion types (see [“Companion Object Pattern”](ch06.html#companion-objects)).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这种*上下文术语解析*真的很好，让我们能够做一些很酷的事情，比如实现伴生类型（见[“伴生对象模式”](ch06.html#companion-objects)）。
- en: 'Classes and enums are special. They are unique because they generate both a
    type in the type namespace and a value in the value namespace:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 类和枚举是特殊的。它们是独特的，因为它们在类型命名空间和值命名空间都生成了一个类型和一个值：
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[![1](assets/1.png)](#co_classes_and_interfaces_CO1-1)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_classes_and_interfaces_CO1-1)'
- en: In this context, `C` refers to the instance type of our `C` class.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，`C` 指的是我们的 `C` 类的实例类型。
- en: '[![2](assets/2.png)](#co_classes_and_interfaces_CO1-2)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_classes_and_interfaces_CO1-2)'
- en: In this context, `C` refers to `C` the value.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，`C` 指的是值 `C`。
- en: '[![3](assets/3.png)](#co_classes_and_interfaces_CO1-3)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_classes_and_interfaces_CO1-3)'
- en: In this context, `E` refers to the type of our `E` enum.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，`E` 指的是我们的 `E` 枚举类型。
- en: '[![4](assets/4.png)](#co_classes_and_interfaces_CO1-4)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_classes_and_interfaces_CO1-4)'
- en: In this context, `E` refers to `E` the value.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，`E` 指的是值 `E`。
- en: When we work with classes, we need a way to say “this variable should be an
    instance of this class” and the same goes for enums (“this variable should be
    a member of this enum”). Because classes and enums generate types at the type
    level we’re able to express this “is-a” relationship easily.^([2](ch05.html#idm46304971345608))
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用类时，我们需要一种方式来表达“这个变量应该是这个类的实例”，枚举类型也是如此（“这个变量应该是这个枚举的成员”）。因为类和枚举在类型级别生成类型，我们能够轻松地表达这种“is-a”关系。^([2](ch05.html#idm46304971345608))
- en: We also need a way to represent a class at runtime, so that we can instantiate
    it with `new`, call static methods on it, do metaprogramming with it, and operate
    on it with `instanceof`—so a class needs to generate a value too.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一种方法在运行时表示类，以便我们可以使用 `new` 实例化它，调用静态方法，使用元编程，并使用 `instanceof` 操作它——因此类还需要生成一个值。
- en: In the previous example `C` refers to an *instance of* the class `C`. How do
    you talk about the `C` class itself? We use the `typeof` keyword (a type operator
    provided by TypeScript, which is like JavaScript’s value-level `typeof` but for
    types).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，`C` 指的是类 `C` 的实例。那么如何讨论 `C` 类本身？我们使用 `typeof` 关键字（TypeScript 提供的类型运算符，类似于
    JavaScript 的值级 `typeof`，但用于类型）。
- en: 'Let’s create a class `StringDatabase`—the world’s simplest database:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个 `StringDatabase` 类——这是世界上最简单的数据库：
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'What types does this class declaration generate? The instance type `StringDatabase`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类声明生成了哪些类型？实例类型 `StringDatabase`：
- en: '[PRE35]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And the constructor type `typeof StringDatabase`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 而构造函数类型 `typeof StringDatabase`：
- en: '[PRE36]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: That is, `StringDatabaseConstructor` has a single method `.from`, and `new`-ing
    the constructor gives a `StringDatabase` instance. Combined, these two interfaces
    model both the constructor and instance sides of a class.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 即，`StringDatabaseConstructor` 有一个单一的方法 `.from`，并且通过 `new` 构造函数创建一个 `StringDatabase`
    实例。结合起来，这两个接口模拟了类的构造函数和实例两个方面。
- en: 'That `new()` bit is called a *constructor signature*, and is TypeScript’s way
    of saying that a given type can be instantiated with the `new` operator. Because
    TypeScript is structurally typed, that’s the best we can do to describe what a
    class is: a class is anything that can be `new`-ed.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`new()` 这一部分称为 *构造函数签名*，是 TypeScript 表示给定类型可以使用 `new` 操作符实例化的方式。由于 TypeScript
    是结构化类型的，这是我们描述类的最佳方式：一个类是任何可以使用 `new` 实例化的东西。'
- en: 'In this case the constructor doesn’t take any arguments, but you can use it
    to declare constructors that take arguments too. For example, say we update `StringDatabase`
    to take an optional initial state:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，构造函数不接受任何参数，但是您也可以使用它来声明接受参数的构造函数。例如，假设我们更新 `StringDatabase` 来接受一个可选的初始状态：
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We could then type `StringDatabase`’s constructor signature as:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以将 `StringDatabase` 的构造函数签名类型化为：
- en: '[PRE38]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'So, not only does a class declaration generate terms at the value and type
    levels, but it generates two terms at the type level: one representing an instance
    of the class; one representing the class constructor itself (reachable with the
    `typeof` type operator).'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，类声明不仅在值和类型层面生成术语，还在类型层面生成了两个术语：一个表示类的实例；一个表示类构造函数本身（可以使用 `typeof` 类型操作符访问）。
- en: Polymorphism
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态性
- en: 'Like functions and types, classes and interfaces have rich support for generic
    type parameters, including defaults and bounds. You can scope a generic to your
    whole class or interface, or to a specific method:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 类和接口像函数和类型一样，对泛型类型参数具有丰富的支持，包括默认值和边界。您可以将泛型范围限制到整个类或接口，或者到特定的方法：
- en: '[PRE39]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[![1](assets/1.png)](#co_classes_and_interfaces_CO2-1)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_classes_and_interfaces_CO2-1)'
- en: Bind class-scoped generic types when you declare your `class`. Here, `K` and
    `V` are available to every instance method and instance property on `MyMap`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在你声明你的 `class` 时绑定类作用域的泛型类型。这里，`K` 和 `V` 可用于 `MyMap` 上的每个实例方法和实例属性。
- en: '[![2](assets/2.png)](#co_classes_and_interfaces_CO2-2)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_classes_and_interfaces_CO2-2)'
- en: Note that you cannot declare generic types in a `constructor`. Instead, move
    the declaration up to your `class` declaration.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你不能在 `constructor` 中声明泛型类型。相反，将声明提升到你的 `class` 声明中。
- en: '[![3](assets/3.png)](#co_classes_and_interfaces_CO2-3)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_classes_and_interfaces_CO2-3)'
- en: Use class-scoped generic types anywhere inside your class.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的类内部任何地方使用类作用域的泛型类型。
- en: '[![4](assets/4.png)](#co_classes_and_interfaces_CO2-4)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_classes_and_interfaces_CO2-4)'
- en: Instance methods have access to class-level generics, and can also declare their
    own generics on top. `.merge` makes use of the `K` and `V` class-level generics,
    and also declares two of its own generics, `K1` and `V1`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 实例方法可以访问类级别的泛型，并且还可以在顶部声明它们自己的泛型。`.merge` 使用了类级别的泛型 `K` 和 `V`，并且还声明了它自己的两个泛型，`K1`
    和 `V1`。
- en: '[![5](assets/5.png)](#co_classes_and_interfaces_CO2-5)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_classes_and_interfaces_CO2-5)'
- en: Static methods do not have access to their class’s generics, just like at the
    value level they don’t have access to their class’s instance variables. `of` does
    not have access to the `K` and `V` declared in [![1](assets/1.png)](#co_classes_and_interfaces_CO2-1);
    instead, it declares its own `K` and `V` generics.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法不可以访问它们类的泛型，就像在值级别上它们不能访问它们类的实例变量一样。`of` 不能访问在 [![1](assets/1.png)](#co_classes_and_interfaces_CO2-1)
    中声明的 `K` 和 `V`；相反，它声明了它自己的 `K` 和 `V` 泛型。
- en: 'You can bind generics to interfaces too:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将泛型绑定到接口上：
- en: '[PRE40]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'And like with functions, you can bind concrete types to generics explicitly,
    or let TypeScript infer the types for you:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 就像函数一样，你可以显式地将具体类型绑定到泛型上，或者让 TypeScript 自动推断类型：
- en: '[PRE41]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Mixins
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mixins
- en: JavaScript and TypeScript don’t have `trait` or `mixin` keywords, but it’s straightforward
    to implement them ourselves. Both are ways to simulate *multiple inheritance*
    (classes that extend more than one other class) and do *role-oriented programming*,
    a style of programming where you don’t say things like “this thing is a `Shape`"
    but instead describe properties of a thing, like “it can be measured” or “it has
    four sides.” Instead of “is-a” relationships, you describe “can” and “has-a” relationships.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 和 TypeScript 没有 `trait` 或 `mixin` 关键字，但是我们可以自己实现它们。两者都是模拟“多继承”（一个类可以继承多个其他类）和“角色导向编程”的方式，一种编程风格，你不会说“这个东西是一个
    `Shape`”，而是描述一个东西的属性，比如“它可以被测量”或“它有四个边”。而不是“是一个”的关系，你描述“能”和“有一个”的关系。
- en: Let’s build a mixin implementation.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来实现一个 mixin。
- en: 'Mixins are a pattern that allows us to *mix* behaviors and properties *into*
    a class. By convention, mixins:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Mixins 是一种模式，允许我们将行为和属性“混入”到一个类中。按照惯例，mixins：
- en: Can have state (i.e., instance properties)
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以有状态（即实例属性）
- en: Can only provide concrete methods (not abstract ones)
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只能提供具体方法（而不是抽象方法）
- en: Can have constructors, which are called in the same order as their classes were
    mixed in
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以有构造函数，它们按照它们被混合进来的类的顺序调用
- en: 'TypeScript doesn’t have a built-in concept of mixins, but it’s easy to implement
    them ourselves. For example, let’s design a debugging library for TypeScript classes.
    We’ll call it `EZDebug`. The library works by letting you log out information
    about whatever classes use the library, so that you can inspect them at runtime.
    We’ll use it like this:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 没有内置的 mixin 概念，但是我们可以自己实现它们。例如，让我们为 TypeScript 类设计一个调试库。我们将其称为 `EZDebug`。该库通过让你在运行时记录使用该库的任何类的信息来工作，以便你可以检查它们。我们可以这样使用它：
- en: '[PRE42]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'With a standard `.debug` interface, our users will be able to debug anything!
    Let’s build it. We’ll model it with a mixin, which we’ll call `withEZDebug`. A
    mixin is just a function that takes a class constructor and returns a class constructor,
    so our mixin might look like this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 有了标准的 `.debug` 接口，我们的用户将能够调试任何东西！让我们来构建它。我们将使用一个 mixin 来建模它，我们称之为 `withEZDebug`。一个
    mixin 只是一个接受一个类构造函数并返回一个类构造函数的函数，因此我们的 mixin 可能看起来像这样：
- en: '[PRE43]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[![1](assets/1.png)](#co_classes_and_interfaces_CO3-1)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_classes_and_interfaces_CO3-1)'
- en: We start by declaring a type `ClassConstructor`, which represents any constructor.
    Since TypeScript is completely structurally typed, we say that a constructor is
    anything that can be `new`-ed. We don’t know what types of parameters the constructor
    might have, so we say it takes any number of arguments of any type.^([3](ch05.html#idm46304970560536))
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先声明一个类型`ClassConstructor`，它代表任何构造函数。由于 TypeScript 是完全结构化类型的，我们说一个构造函数是可以`new`的任何东西。我们不知道构造函数可能具有什么类型的参数，因此我们说它接受任意数量的任何类型的参数。^([3](ch05.html#idm46304970560536))
- en: '[![2](assets/2.png)](#co_classes_and_interfaces_CO3-2)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](assets/2.png)](#co_classes_and_interfaces_CO3-2)'
- en: We declare our `withEZDebug` mixin with a single type parameter, `C`. `C` has
    to be at least a class constructor, which we enforce with an `extends` clause.
    We let TypeScript infer `withEZDebug`’s return type, which is the intersection
    of `C` and our new anonymous class.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明我们的`withEZDebug`混入一个类型参数`C`。`C`至少必须是一个类构造函数，我们通过一个`extends`子句来强制执行这一点。我们让
    TypeScript 推断`withEZDebug`的返回类型，这是`C`和我们的新匿名类的交集。
- en: '[![3](assets/3.png)](#co_classes_and_interfaces_CO3-3)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](assets/3.png)](#co_classes_and_interfaces_CO3-3)'
- en: Since a mixin is a function that takes a constructor and returns a constructor,
    we return an anonymous class constructor.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 由于混入是一个接受构造函数并返回构造函数的函数，我们返回一个匿名类构造函数。
- en: '[![4](assets/4.png)](#co_classes_and_interfaces_CO3-4)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](assets/4.png)](#co_classes_and_interfaces_CO3-4)'
- en: The class constructor has to take *at least* the arguments that the class you
    pass in might take. But remember, since we don’t know what class you might pass
    in beforehand, I have to keep it as general as possible, which means any number
    of parameters of any type—just like `ClassConstructor`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 类构造函数必须至少接受类可能接受的参数。但请记住，由于我们事先不知道可能传入的类是什么，我必须保持尽可能一般化，这意味着任意数量的任何类型的参数——就像`ClassConstructor`一样。
- en: '[![5](assets/5.png)](#co_classes_and_interfaces_CO3-5)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](assets/5.png)](#co_classes_and_interfaces_CO3-5)'
- en: Finally, since this anonymous class extends another class, to wire everything
    up correctly we need to remember to call `Class`’s constructor too.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于这个匿名类扩展了另一个类，为了正确地连接一切，我们需要记住调用`Class`的构造函数。
- en: Like with regular JavaScript classes, if you don’t have any more logic in the
    `constructor`, you can omit lines [![4](assets/4.png)](#co_classes_and_interfaces_CO3-4)
    and [![5](assets/5.png)](#co_classes_and_interfaces_CO3-5). We aren’t going to
    put any logic into the constructor for this `withEZDebug` example, so we can omit
    them.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 就像常规 JavaScript 类一样，如果在`constructor`中没有更多的逻辑，你可以省略[![](assets/4.png)](#co_classes_and_interfaces_CO3-4)和[![](assets/5.png)](#co_classes_and_interfaces_CO3-5)行。对于这个`withEZDebug`示例，我们不会在构造函数中放置任何逻辑，所以可以省略它们。
- en: 'Now that we’ve set up the boilerplate, it’s time to work some debugging magic.
    When we call `.debug`, we want to log out the class’s constructor name and the
    instance’s value:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好样板，是时候进行一些调试魔术了。当我们调用`.debug`时，我们希望记录出类的构造函数名称和实例的值：
- en: '[PRE44]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: But wait! How do we make sure the class implements a `.getDebugValue` method,
    so that we can call it? Think about this for a second before you move on—can you
    figure it out?
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 但是！我们如何确保类实现了`.getDebugValue`方法，以便我们可以调用它？在继续之前，请花点时间考虑一下——你能想出来吗？
- en: 'The answer is that instead of accepting any old class, we use a generic type
    to make sure the class passed into `withEZDebug` defines a `.getDebugValue` method:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，我们不接受任何旧类，而是使用泛型类型确保传递给`withEZDebug`的类定义了`.getDebugValue`方法：
- en: '[PRE45]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[![](assets/1.png)](#callout_5_1)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](assets/1.png)](#callout_5_1)'
- en: We add a generic type parameter to `ClassConstructor`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向`ClassConstructor`添加了一个泛型类型参数。
- en: '[![](assets/2.png)](#callout_5_2)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](assets/2.png)](#callout_5_2)'
- en: We bind a shape type to `ClassConstructor`, `C`, enforcing that the constructor
    we passed to `withEZDebug` at least defines the `.getDebugValue` method.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一个形状类型绑定到`ClassConstructor`，`C`，强制执行我们传递给`withEZDebug`的构造函数至少定义`.getDebugValue`方法。
- en: 'That’s it! So, how do you use this incredible debugging utility? Like so:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！那么，你如何使用这个令人难以置信的调试工具呢？像这样：
- en: '[PRE46]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Cool, right? You can apply as many mixins to a class as you want to yield a
    class with richer and richer behavior, all in a typesafe way. Mixins help encapsulate
    behavior, and are an expressive way to specify reusable behaviors.^([4](ch05.html#idm46304970288936))
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 酷，对吧？你可以将尽可能多的混入应用于一个类，从而产生行为更丰富的类，所有这些都是类型安全的。混入有助于封装行为，是指定可重用行为的一种表达方式。^([4](ch05.html#idm46304970288936))
- en: Decorators
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器
- en: Decorators are an experimental TypeScript feature that gives us a clean syntax
    for metaprogramming with classes, class methods, properties, and method parameters.
    They’re just a syntax for calling a function on the thing you’re decorating.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器是 TypeScript 的一项实验性功能，它为类、类方法、属性和方法参数的元编程提供了清晰的语法。它们只是在你装饰的内容上调用函数的语法而已。
- en: 'TSC Flag: experimentalDecorators'
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'TSC Flag: experimentalDecorators'
- en: 'Because they’re still experimental—meaning they may change in a backward-incompatible
    way, or may even be entirely removed in future TypeScript releases—decorators
    are hidden behind a TSC flag. If you’re OK with that, and want to play around
    with the feature, set `"experimentalDecorators": true` in your *tsconfig.json*
    and read on.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '因为它们仍处于实验阶段——这意味着它们可能会在未来的 TypeScript 版本中以不兼容的方式更改，甚至可能会完全移除——装饰器被隐藏在了一个 TSC
    标志后面。如果你可以接受这一点，并且想要尝试这个功能，请在你的 *tsconfig.json* 中设置 `"experimentalDecorators":
    true`，然后继续阅读。'
- en: 'To get a sense for how decorators work, let’s start with an example:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解装饰器的工作原理，让我们从一个例子开始：
- en: '[PRE47]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `@serializable` class decorator wraps our `APIPayload` class, and optionally
    returns a new class that replaces it. Without decorators, you might implement
    the same thing with:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 类装饰器`@serializable`包装我们的`APIPayload`类，并可选择返回替代它的新类。没有装饰器的话，你可能需要用以下方式来实现同样的功能：
- en: '[PRE48]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: For each type of decorator, TypeScript requires that you have a function in
    scope with the given name and the required signature for that type of decorator
    (see [Table 5-1](#expected-type-table)).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每种类型的装饰器，TypeScript 要求在作用域中具有指定名称和所需签名的函数（见[表 5-1](#expected-type-table)）。
- en: Table 5-1\. Expected type signatures for the different kinds of decorator functions
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5-1\. 不同类型装饰器函数的预期类型签名
- en: '| What you’re decorating | Expected type signature |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| 正在装饰的内容 | 预期的类型签名 |'
- en: '| --- | --- |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Class | `(Constructor: {new(...any[]) => any}) => any` |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| 类 | `(Constructor: {new(...any[]) => any}) => any` |'
- en: '| Method | `(classPrototype: {}, methodName: string, descriptor:` `PropertyDescriptor``)
    => any` |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | `(classPrototype: {}, methodName: string, descriptor: PropertyDescriptor)
    => any` |'
- en: '| Static method | `(Constructor: {new(...any[]) => any}, methodName: string,
    descriptor: PropertyDescriptor) => any` |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| 静态方法 | `(Constructor: {new(...any[]) => any}, methodName: string, descriptor:
    PropertyDescriptor) => any` |'
- en: '| Method parameter | `(classPrototype: {}, paramName: string, index: number)
    => void` |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| 方法参数 | `(classPrototype: {}, paramName: string, index: number) => void` |'
- en: '| Static method parameter | `(Constructor: {new(...any[]) => any}, paramName:
    string, index: number) => void` |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| 静态方法参数 | `(Constructor: {new(...any[]) => any}, paramName: string, index:
    number) => void` |'
- en: '| Property | `(classPrototype: {}, propertyName: string) => any` |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | `(classPrototype: {}, propertyName: string) => any` |'
- en: '| Static property | `(Constructor: {new(...any[]) => any}, propertyName: string)
    => any` |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| 静态属性 | `(Constructor: {new(...any[]) => any}, propertyName: string) => any`
    |'
- en: '| Property getter/setter | `(classPrototype: {}, propertyName: string, descriptor:`
    `PropertyDescriptor``) => any` |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| 属性的getter/setter | `(classPrototype: {}, propertyName: string, descriptor:
    PropertyDescriptor) => any` |'
- en: '| Static property getter/setter | `(Constructor: {new(...any[]) => any}, propertyName:
    string, descriptor: PropertyDescriptor) => any` |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| 静态属性的getter/setter | `(Constructor: {new(...any[]) => any}, propertyName:
    string, descriptor: PropertyDescriptor) => any` |'
- en: 'TypeScript doesn’t come with any built-in decorators: whatever decorators you
    use, you have to implement yourself (or install from NPM). The implementation
    for each kind of decorator—for classes, methods, properties, and function parameters—is
    a regular function that satisfies a specific signature, depending on what it’s
    decorating. For example, our `@serializable` decorator might look like this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 并没有任何内置的装饰器：无论使用什么装饰器，都需要自己实现（或从 NPM 安装）。对于每种装饰器类型（类、方法、属性和函数参数），其实现都是一个满足特定签名的常规函数。例如，我们的
    `@serializable` 装饰器可能看起来像这样：
- en: '[PRE49]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[![1](assets/1.png)](#co_classes_and_interfaces_CO4-1)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_classes_and_interfaces_CO4-1)'
- en: 'Remember, `new()` is how we structurally type a class constructor in TypeScript.
    And for a class constructor that can be extended (with `extends`), TypeScript
    requires that we type its arguments with an `any` spread: `new(...any[])`.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在 TypeScript 中，`new()` 是我们对类构造函数进行结构化类型的方式。对于可以被扩展（使用`extends`）的类构造函数，TypeScript
    要求我们用`any`展开来对其参数进行类型化：`new(...any[])`。
- en: '[![2](assets/2.png)](#co_classes_and_interfaces_CO4-2)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_classes_and_interfaces_CO4-2)'
- en: '`@serializable` can decorate any class whose instances implement the method
    `.getValue`, which returns a `Payload`.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`@serializable` 可以装饰任何其实例实现了 `.getValue` 方法且返回 `Payload` 的类。'
- en: '[![3](assets/3.png)](#co_classes_and_interfaces_CO4-3)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_classes_and_interfaces_CO4-3)'
- en: Class decorators are functions that take a single argument—the class. If the
    decorator function returns a class (as in the example) it will replace the class
    it’s decorating at runtime; otherwise, it will return the original class.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 类装饰器是一个接受单个参数——类的函数。如果装饰器函数返回一个类（如示例中所示），它将在运行时替换它所装饰的类；否则，它将返回原始类。
- en: '[![4](assets/4.png)](#co_classes_and_interfaces_CO4-4)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_classes_and_interfaces_CO4-4)'
- en: To decorate the class, we return a class that extends it and adds a `.serialize`
    method along the way.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 要装饰类，我们返回一个扩展它并添加 `.serialize` 方法的类。
- en: What happens when we try to call `.serialize`?
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试调用 `.serialize` 时会发生什么？
- en: '[PRE50]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: TypeScript assumes that a decorator doesn’t change the shape of the thing it’s
    decorating—meaning that you didn’t add or remove methods and properties. It checks
    at compile time that the class you returned is assignable to the class you passed
    in, but at the time of writing, TypeScript does not keep track of extensions you
    make in your decorators.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 假设装饰器不会改变其装饰对象的形状——这意味着你没有添加或移除方法和属性。它在编译时检查你返回的类是否可以分配给传入的类，但目前
    TypeScript 不会跟踪你在装饰器中所做的扩展。
- en: 'Until decorators in TypeScript become a more mature feature, I recommend you
    avoid using them and stick to regular functions instead:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 的装饰器成为更成熟的功能之前，建议避免使用它们，而是坚持使用普通函数：
- en: '[PRE51]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We won’t delve more deeply into decorators in this book. For more information,
    head over to the [official documentation](http://bit.ly/2IDQd1U).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在本书中深入探讨装饰器。更多信息请访问[官方文档](http://bit.ly/2IDQd1U)。
- en: Simulating final Classes
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟 final 类
- en: Though TypeScript doesn’t support the `final` keyword for classes or methods,
    it’s easy to simulate it for classes. If you haven’t worked much with object-oriented
    languages before, `final` is the keyword some languages use to mark a class as
    nonextensible, or a method as nonoverridable.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 TypeScript 不支持类或方法的 `final` 关键字，但可以轻松地为类模拟它。如果你之前没有接触过面向对象语言，`final` 是一些语言用来标记类为不可扩展或方法为不可覆盖的关键字。
- en: 'To simulate `final` classes in TypeScript, we can take advantage of private
    constructors:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 要模拟 TypeScript 中的 `final` 类，我们可以利用私有构造函数：
- en: '[PRE52]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'When a `constructor` is marked `private`, you can’t `new` the class or extend
    it:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `constructor` 被标记为 `private` 时，你不能 `new` 这个类或者扩展它：
- en: '[PRE53]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'As well as preventing you from extending the class—which is what we want—private
    constructors also prevent you from directly instantiating it. But for `final`
    classes we do want the ability to instantiate a class, just not to extend it.
    How do we keep the first restriction but get rid of the second? Easy:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 除了阻止你扩展类之外，私有构造函数还阻止你直接实例化它。但是对于 `final` 类，我们希望能够实例化类，只是不允许扩展它。我们如何保留第一个限制但消除第二个限制呢？很简单：
- en: '[PRE54]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This changes `MessageQueue`’s API a bit, but it does a great job of preventing
    extensions at compile time:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这改变了 `MessageQueue` 的 API 一点，但在编译时很好地防止扩展：
- en: '[PRE55]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Design Patterns
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式
- en: This wouldn’t be a chapter on object-oriented programming if we didn’t walk
    through implementing a design pattern or two in TypeScript, right?
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 TypeScript 中没有实现一两个设计模式，这将不会是一个面向对象编程的章节，对吧？
- en: Factory Pattern
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工厂模式
- en: The *factory pattern* is a way to create objects of some type, leaving the decision
    of which concrete object to create to the specific factory that creates that object.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '*工厂模式* 是一种创建某种类型对象的方式，将具体对象的创建决策留给创建该对象的特定工厂。'
- en: 'Let’s build a shoe factory. We’ll start by defining a `Shoe` type, and a few
    kinds of shoes:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们建立一个鞋厂。我们首先定义一个`Shoe`类型，和几种鞋子：
- en: '[PRE56]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note that this example uses a `type`, but we could have just as well used an
    `interface` instead.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此示例使用了 `type`，但我们也可以使用 `interface`。
- en: 'Now, let’s make a shoe factory:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来制造一个鞋厂：
- en: '[PRE57]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[![1](assets/1.png)](#co_classes_and_interfaces_CO5-1)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_classes_and_interfaces_CO5-1)'
- en: Using a union type for `type` helps make `.create` as typesafe as possible,
    preventing consumers from passing in an invalid `type` at compile time.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 使用联合类型来定义 `type` 可以尽可能地使 `.create` 类型安全，防止在编译时传入无效的 `type`。
- en: '[![2](assets/2.png)](#co_classes_and_interfaces_CO5-2)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_classes_and_interfaces_CO5-2)'
- en: Switching on `type` makes it easy for TypeScript to enforce that we’ve handled
    every type of `Shoe`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 切换 `type` 让 TypeScript 能够轻松强制我们处理每种 `Shoe` 的类型。
- en: 'In this example we use the companion object pattern (see [“Companion Object
    Pattern”](ch06.html#companion-objects)) to declare a type `Shoe` and a value `Shoe`
    with the same name (remember that TypeScript has separate namespaces for values
    and for types), as a way to signal that the value provides methods for operating
    on the type. To use the factory, we can just call `.create`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用伴生对象模式（参见 [“伴生对象模式”](ch06.html#companion-objects)）来声明类型`Shoe`和具有相同名称的值`Shoe`（请记住
    TypeScript 为值和类型分别提供了独立的命名空间），作为一种信号表明该值提供了操作该类型的方法。要使用工厂，我们只需调用`.create`：
- en: '[PRE58]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Voilà! We have a factory pattern. Note that we could have gone further and indicated
    in `Shoe.create`’s type signature that passing in `'boot'` will give a `Boot`,
    `'sneaker'` will give a `Sneaker`, and so on, but that would break the abstraction
    that the factory pattern gives us (that the consumer shouldn’t know what concrete
    class they’ll get back, just that the class satisfies a particular interface).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 大功告成！我们有了一个工厂模式。请注意，我们还可以进一步指示`Shoe.create`的类型签名，传入`'boot'`将返回一个`Boot`，传入`'sneaker'`将返回一个`Sneaker`等等，但这将打破工厂模式给我们的抽象（消费者不应知道他们将得到什么具体的类，只知道这个类满足特定的接口）。
- en: Builder Pattern
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建造者模式
- en: 'The *builder pattern* is a way to separate the construction of an object from
    the way that object is actually implemented. If you’ve used JQuery, or ES6 data
    structures like `Map` and `Set`, this style of API should look familiar. Here’s
    what it looks like:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 建造者模式（*builder pattern*）是一种将对象的构建过程与其实际实现方式分离的方法。如果你使用过 JQuery 或者 ES6 中的数据结构如`Map`和`Set`，这种
    API 风格应该很熟悉。它看起来像这样：
- en: '[PRE59]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'How do we implement `RequestBuilder`? Easy—we’ll start with a bare class:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如何实现`RequestBuilder`？很简单——我们从一个空的类开始：
- en: '[PRE60]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'First we’ll add the `.setURL` method:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将添加`.setURL`方法：
- en: '[PRE61]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[![](assets/1.png)](#co_5_2_1)'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](assets/1.png)](#co_5_2_1)'
- en: We keep track of the URL the user set in a private instance variable `url`,
    which we initialize to `null`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个私有实例变量`url`来跟踪用户设置的 URL，初始值为`null`。
- en: '[![](assets/2.png)](#co_5_2_2)'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](assets/2.png)](#co_5_2_2)'
- en: '`setURL`’s return type is `this` (see [“Using this as a Return Type”](#this-in-return-type)),
    that is, the specific instance of `RequestBuilder` that the user called `setURL`
    on.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`setURL`方法的返回类型是`this`（参见 [“将this用作返回类型”](#this-in-return-type)），即用户在`setURL`上调用的具体`RequestBuilder`实例。'
- en: 'Now let’s add the other methods from our example:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加示例中的其他方法：
- en: '[PRE62]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: That’s all there is to it.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样了。
- en: Note
  id: totrans-296
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'This traditional builder design is not completely safe: we can call `.send`
    before we set the method, URL, or data, resulting in a runtime exception (remember,
    that’s the bad kind of exception). See Exercise 4 for some ideas about how to
    improve this design.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这种传统的构建者设计并不完全安全：我们可以在设置方法、URL 或数据之前调用`.send`，导致运行时异常（记住，那是糟糕的异常）。参见练习 4，了解如何改进这种设计。
- en: Summary
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'We’ve now explored TypeScript classes from all sides: how to declare classes;
    how to inherit from classes and implement interfaces; how to mark classes as `abstract`
    so they can’t be instantiated; how to put a field or method on a class with `static`
    and on an instance without it; how to control access to a field or method with
    the `private`, `protected`, and `public` visibility modifiers; and how to mark
    a field as nonwritable using the `readonly` modifier. We’ve covered how to safely
    use `this` and `super`, explored what it means for classes to be both values and
    types at the same time, and talked about the differences between type aliases
    and interfaces, the basics of declaration merging, and using generic types in
    classes. Finally, we covered a few more advanced patterns for working with classes:
    mixins, decorators, and simulating `final` classes. And to cap the chapter off,
    we went through and derived a couple of common patterns for working with classes.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们全面探索了 TypeScript 类的各个方面：如何声明类；如何从类继承和实现接口；如何将类标记为`abstract`以防止实例化；如何使用`static`在类上添加字段或方法，以及在实例上不使用它；如何使用`private`、`protected`和`public`可见性修饰符来控制对字段或方法的访问；如何使用`readonly`修饰符将字段标记为只读。我们讨论了如何安全地使用`this`和`super`，探讨了类同时作为值和类型的含义，以及类型别名和接口之间的差异，声明合并的基础知识，以及如何在类中使用泛型类型。最后，我们还涵盖了一些更高级的类模式：混入（mixins）、装饰器（decorators）以及模拟`final`类。为了结束本章，我们总结了几种常见的处理类的模式。
- en: Exercises
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: What are the differences between a class and an interface?
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类和接口之间有哪些区别？
- en: When you mark a class’s constructor as `private`, that means you can’t instantiate
    or extend the class. What happens when you mark it as `protected` instead? Play
    around with this in your code editor, and see if you can figure it out.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你将一个类的构造函数标记为`private`时，这意味着你不能实例化或扩展这个类。如果你将它标记为`protected`会发生什么？在你的代码编辑器中尝试一下，并看看你能否弄清楚。
- en: 'Extend the implementation we developed [“Factory Pattern”](#factory-pattern)
    to make it safer, at the expense of breaking the abstraction a bit. Update the
    implementation so that a consumer knows at compile time that calling `Shoe.create(''boot'')`
    returns a `Boot` and calling `Shoe.create(''balletFlat'')` returns a `BalletFlat`
    (rather than both returning a `Shoe`). Hint: think back to [“Overloaded Function
    Types”](ch04.html#function-overloads).'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展我们开发的 [“工厂模式”](#factory-pattern) 实现，使其更安全，牺牲一些抽象性。更新实现，以便消费者在编译时知道调用 `Shoe.create('boot')`
    返回一个 `Boot`，调用 `Shoe.create('balletFlat')` 返回一个 `BalletFlat`（而不是两者都返回一个 `Shoe`）。提示：回想一下
    [“重载函数类型”](ch04.html#function-overloads)。
- en: '[Hard] As an exercise, think about how you might design a typesafe builder
    pattern. Extend the Builder pattern [“Builder Pattern”](#builder-pattern) to:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[困难] 作为一个练习，想一想你如何设计一个类型安全的建造者模式。扩展 [“建造者模式”](#builder-pattern) 以：'
- en: 'Guarantee at compile time that someone can’t call `.send` before setting at
    least a URL and a method. Would it be easier to make this guarantee if you also
    force the user to call methods in a specific order? (Hint: what can you return
    instead of `this`?)'
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编译时保证在设置至少一个 URL 和一个方法之前，某人不能调用`.send`。如果你还强制用户按特定顺序调用方法，会更容易实现这个保证吗？（提示：你可以返回什么代替
    `this`？）
- en: '[Harder] How would you change your design if you wanted to make this guarantee,
    but still let people call methods in any order? (Hint: what TypeScript feature
    can you use to make each method’s return type “add” to the `this` type after each
    method call?)'
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[困难] 如果你想要做出这个保证，同时又让人们可以按任意顺序调用方法，你会如何修改你的设计？（提示：你可以使用 TypeScript 的哪个特性，使得每个方法的返回类型在每次方法调用后“添加”到
    `this` 类型？）'
- en: ^([1](ch05.html#idm46304973683464-marker)) Or are on track to soon be supported
    by JavaScript classes.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch05.html#idm46304973683464-marker)) 或者很快将由 JavaScript 类支持。
- en: ^([2](ch05.html#idm46304971345608-marker)) Because TypeScript is structurally
    typed, of course, the relationship for classes is more of a “looks-like”—any object
    that implements the same shape as your class will be assignable to the type of
    your class.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch05.html#idm46304971345608-marker)) 因为 TypeScript 是结构化类型的，所以对于类的关系更像是“看起来像”—任何实现与你的类相同形状的对象都可以赋值给你的类的类型。
- en: '^([3](ch05.html#idm46304970560536-marker)) Note that TypeScript is picky here:
    the type of a constructor type’s arguments has to be `any[]` (not `void`, `unknown[]`,
    etc.) in order for us to be able to extend it.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch05.html#idm46304970560536-marker)) 注意 TypeScript 在这里很挑剔：构造函数类型的参数类型必须是
    `any[]`（而不是 `void`、`unknown[]` 等），以便我们能够扩展它。
- en: ^([4](ch05.html#idm46304970288936-marker)) A handful of languages—Scala, PHP,
    Kotlin, and Rust, to name a few—implement a pared-down version of mixins, called
    *traits*. Traits are like mixins, but don’t have constructors and don’t support
    instance properties. This makes it easier to wire them up and prevent collisions
    between multiple traits accessing state that is shared between them and the base
    class.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch05.html#idm46304970288936-marker)) 少数语言—Scala、PHP、Kotlin 和 Rust 等—实现了一个精简版的混入，称为
    *traits*。Traits 类似于混入，但没有构造函数，也不支持实例属性。这样更容易将它们连接起来，防止多个 trait 访问它们与基类之间共享的状态时发生冲突。
