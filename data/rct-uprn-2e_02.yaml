- en: Chapter 2\. The Life of a Component
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章\. 组件的生命周期
- en: Now that you know how to use the ready-made DOM components, it’s time to learn
    how to make some of your own.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何使用现成的 DOM 组件了，现在是时候学习如何制作自己的组件了。
- en: 'There are two ways to define a custom component, both accomplishing the same
    result but using different syntax:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种定义自定义组件的方式，但两种方式都能实现同样的结果，只是使用了不同的语法：
- en: Using a function (components created this way are referred to as *function*
    *components*)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数（这种方式创建的组件称为*函数*组件）
- en: Using a class that extends `React.Component` (commonly referred to as *class*
    *components*)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用扩展 `React.Component` 类的类（通常称为*类*组件）
- en: A Custom Function Component
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义函数组件
- en: 'Here’s an example of a function component:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个函数组件的示例：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'But wait, this is just a function! Yes, the custom component is just a function
    that returns the UI that you want. In this case, the UI is only text but you’ll
    often need a little bit more, most likely a composition of other components. Here’s
    an example of using a `span` to wrap the text:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，等等，这只是一个函数！是的，自定义组件只是一个返回所需 UI 的函数。在这种情况下，UI 只是文本，但通常你会需要更多，很可能是其他组件的组合。这里有一个使用
    `span` 包装文本的示例：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Using your shiny new component in an application is similar to using the DOM
    components from [Chapter 1](ch01.xhtml#ch1), except you *call* the function that
    defines the component:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中使用你的全新组件与使用[第一章](ch01.xhtml#ch1)中的 DOM 组件类似，只是你*调用*定义组件的函数：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The result of rendering your custom component is shown in [Figure 2-1](#FIG0201).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染你的自定义组件的结果显示在[图 2-1](#FIG0201)中。
- en: '![rur2 0201](Images/rur2_0201.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![rur2 0201](Images/rur2_0201.png)'
- en: Figure 2-1\. Your first custom component (*02.01.custom-functional.html* in
    the book’s repository)
  id: totrans-14
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-1\. 你的第一个自定义组件（书中存储库的 *02.01.custom-functional.html*）
- en: A JSX Version
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSX 版本
- en: 'The same example using JSX will look a little easier to read. Defining the
    component looks like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JSX 的相同示例看起来会更容易阅读。定义组件的方式如下：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Using the component the JSX way looks like this, regardless of how the component
    itself was defined (with JSX or not):'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 无论组件本身是如何定义的（使用 JSX 还是不使用 JSX），使用 JSX 方式使用组件如下：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-20
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that in the self-closing tag `<MyComponent />`, the slash is not optional.
    That applies to HTML elements used in JSX too. `<br>` and `<img>` are not going
    to work; you need to close them like `<br/>` and `<img/>`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在自闭合标签 `<MyComponent />` 中，斜杠是不可选的。这也适用于 JSX 中使用的 HTML 元素。`<br>` 和 `<img>`
    是行不通的；你需要像 `<br/>` 和 `<img/>` 这样关闭它们。
- en: A Custom Class Component
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义类组件
- en: 'The second way to create a component is to define a class that extends `React.Component`
    and implements a `render()` function:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 创建组件的第二种方式是定义一个扩展 `React.Component` 并实现 `render()` 函数的类：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Rendering the component on the page:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面上渲染组件：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you use JSX, you don’t need to know how the component was defined (using
    a class or a function). In both cases using the component is the same:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 JSX，你不需要知道组件是如何定义的（使用类或函数）。在使用组件的两种情况下，都是一样的：
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Which Syntax to Use?
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用哪种语法？
- en: 'You may be wondering: with all these options (JSX vs. pure JavaScript, a class
    component vs. a function one), which one to use? JSX is the most common. And,
    unless you dislike the XML syntax in your JavaScript, the path of least resistance
    and of less typing is to go with JSX. This book uses JSX from now on, unless to
    illustrate a concept. Why then even talk about a no-JSX way? Well, you should
    know that there *is* another way and also that JSX is not magic but rather a thin
    syntax layer that transforms XML into plain JavaScript function calls like `React.createElement()`
    before sending the code to the browser.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想：在所有这些选项（JSX vs. 纯JavaScript，类组件 vs. 函数组件）中，应该选择哪一个？JSX 是最常见的。而且，除非你不喜欢在
    JavaScript 中使用 XML 语法，选择 JSX 是最少阻力和打字量最少的路径。从现在开始，本书将使用 JSX，除非是为了说明概念。那么，为什么还要讨论非
    JSX 的方式呢？嗯，你应该知道还*有*另一种方式，而且 JSX 并不是魔法，而是一层薄薄的语法层，在将代码发送到浏览器之前，它会将 XML 转换为普通的
    JavaScript 函数调用，比如`React.createElement()`。
- en: What about *class* versus *function* components? This is a question of preference.
    If you’re comfortable with object-oriented programming (OOP) and you like how
    classes are laid out, then by all means, go for it. Function components are a
    little lighter on the computer’s CPU and involve a little less typing. They also
    feel more native to JavaScript. Actually *classes* didn’t exist in early versions
    of the JavaScript language; they are an afterthought and merely a syntactical
    sugar on top of functions and prototypes.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 类组件与函数组件之争？这是一个偏好问题。如果您熟悉面向对象编程（OOP），并且喜欢类的布局方式，那么尽管去选择类组件。函数组件在计算机CPU上稍轻，输入少一些。它们也更符合JavaScript的本性。实际上，在JavaScript语言的早期版本中并不存在*类*；它们是后来的想法，仅仅是函数和原型的语法糖。
- en: Historically, as far as React is concerned, function components were not able
    to accomplish everything that classes could. Until the invention of *hooks*, that
    is, which you’ll get to in due time. As for the future, one can only speculate,
    but it’s likely that React will move more and more toward function components.
    However it’s highly unlikely that class components are going to be deprecated
    any time soon. This book teaches you both ways and doesn’t decide for you, though
    you may sense a slight preference toward function components. Why do we even bother
    with classes in this book, you may ask (as did most technical editors of the manuscript)?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 从React的历史角度来看，函数组件无法像类组件那样完成所有任务，直到*hooks*的发明。关于未来，只能进行推测，但很可能React会更多地向函数组件靠拢。但是，类组件不太可能很快就会被废弃。本书将教授您两种方式，并不会为您做出决定，尽管您可能会感觉到对函数组件的轻微偏爱。您可能会问，为什么本书还要使用类？（正如手稿的大多数技术编辑所问。）
- en: Well, there is a lot of code out there in the real world written with classes
    and a lot of online tutorials. In fact, at the time of writing, even React’s official
    documentation shows most examples as class components. Therefore it’s the author’s
    opinion that the readers should be familiar with both syntaxes so they can read
    and understand all the code presented to them and not be confused as soon as a
    non-function component shows up.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中有很多使用类编写的代码和许多在线教程。事实上，在撰写本文时，即使React的官方文档也显示大多数示例为类组件。因此，作者认为读者应该熟悉两种语法，以便能够阅读和理解所有呈现给他们的代码，并且在出现非函数组件时不会感到困惑。
- en: Properties
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性
- en: Rendering *hard-coded* UI in your custom components is perfectly fine and has
    its uses. But the components can also take *properties* and render or behave differently,
    depending on the values of the properties. Think about the `<a>` element in HTML
    and how it acts differently based on the value of the `href` attribute. The idea
    of properties in React is similar (and so is the JSX syntax).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在自定义组件中渲染*硬编码*的UI是完全可以的，并且具有其用途。但是组件也可以接受*属性*并根据属性值的不同进行渲染或行为上的差异。考虑HTML中的`<a>`元素及其根据`href`属性值的不同而行为不同。React中的属性概念与此类似（JSX语法也是如此）。
- en: 'In class components all properties are available via the `this.props` object.
    Let’s see an example:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在类组件中，所有属性都可以通过`this.props`对象访问。让我们看一个例子：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-38
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: As demonstrated in this example, you can open curly braces and sprinkle JavaScript
    values (and expressions too) within your JSX. You’ll learn more about this behavior
    as you progress with the book.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如此示例所示，您可以打开花括号，并在您的JSX中添加JavaScript值（包括表达式）。随着您在本书中的进展，您将了解更多有关此行为的信息。
- en: 'Passing a value for the `name` property when rendering the component looks
    like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当渲染组件时为`name`属性传递一个值的示例如下所示：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The result is shown in [Figure 2-2](#FIG0202).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示在[图 2-2](#FIG0202)中。
- en: '![rur2 0202](Images/rur2_0202.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![rur2 0202](Images/rur2_0202.png)'
- en: Figure 2-2\. Using component properties (*02.05.this.props.html*)
  id: totrans-44
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-2\. 使用组件属性（*02.05.this.props.html*）
- en: It’s important to remember that `this.props` is read-only. It’s meant to carry
    on configuration from parent components to children, but it’s not a general-purpose
    storage of values. If you feel tempted to set a property of `this.props`, just
    use additional local variables or properties of your component’s class instead
    (meaning use `this.thing` as opposed to `this.props.thing`).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的重要一点是`this.props`是只读的。它旨在从父组件传递配置到子组件，但它不是通用的值存储器。如果您感到诱惑设置`this.props`的属性，只需使用额外的局部变量或组件类的属性即可（意思是使用`this.thing`而不是`this.props.thing`）。
- en: Properties in Function Components
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数组件中的属性
- en: 'In function components, there’s no `this` (in JavaScript’s *strict* mode),
    or `this` refers to the global object (in non-strict, dare we say *sloppy*, mode).
    So instead of `this.props`, you get a `props` object passed to your function as
    the first argument:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数组件中，没有`this`（在JavaScript的*严格*模式下），或者`this`指向全局对象（在非严格模式下，我们可以说是*松散*模式）。所以，你不再使用`this.props`，而是将一个`props`对象作为第一个参数传递给你的函数：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'A common pattern is to use JavaScript’s *destructuring assignment* and assign
    the property values to local variables. In other words the preceding example becomes:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的模式是使用JavaScript的*解构赋值*将属性值分配给局部变量。换句话说，前面的例子变成了：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can have as many properties as you want. If, for example, you need two
    properties (`name` and `job`), you can use them like:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以拥有任意多的属性。例如，如果你需要两个属性（`name`和`job`），你可以像这样使用它们：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Default Properties
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认属性
- en: Your component may offer a number of properties, but sometimes a few of the
    properties may have default values that work well for the most common cases. You
    can specify default property values using `defaultProps` property for both function
    and class components.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你的组件可能提供多个属性，但有时少数属性可能有适合大多数情况的默认值。你可以为函数和类组件使用`defaultProps`属性来指定默认属性值。
- en: 'Function component:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 函数组件：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Class component:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 类组件：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In both cases, the result is the output:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，结果都是输出：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Tip
  id: totrans-61
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Notice how the `render()` method’s `return` statement wraps the returned value
    in parentheses. This is just because of JavaScript’s *automatic semi-colon insertion*
    (ASI) mechanism. A `return` statement followed by a new line is the same as `return;`
    which is the same as `return undefined;` which is definitely not what you want.
    Wrapping the returned expression in parentheses allows for better code formatting
    while retaining the correctness.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`render()`方法的`return`语句如何用括号包裹返回的值。这只是因为JavaScript的*自动分号插入*（ASI）机制。跟在新行后面的`return`语句相当于`return;`，这等同于`return
    undefined;`，这绝对不是你想要的。用括号包裹返回的表达式可以在保持正确性的同时，提供更好的代码格式化。
- en: State
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态
- en: The examples so far were pretty static (or “stateless”). The goal was just to
    give you an idea of the building blocks of composing your UI. But where React
    really shines (and where old-school browser DOM manipulation and maintenance gets
    complicated) is when the data in your application changes. React has the concept
    of *state*, which is any data that components want to use to render themselves.
    When state changes, React rebuilds the UI in the DOM without you having to do
    anything. After you build your UI initially in your `render()` method (or in the
    rendering function in case of a function component) all you care about is updating
    the data. You don’t need to worry about UI changes at all. After all, your render
    method/function has already provided the blueprint of what the component should
    look like.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的例子都比较静态（或称为“无状态”）。目标仅仅是让你了解如何组合你的UI的构建模块。但是，React真正闪耀的地方（以及旧式浏览器DOM操作和维护变得复杂的地方）是当你的应用程序中的数据发生变化时。React具有*状态*的概念，它是组件想要用来渲染自己的任何数据。当状态发生变化时，React会在DOM中重新构建UI，而你无需做任何事情。在你的`render()`方法（或函数组件的渲染函数）中首次构建UI后，你只需关心更新数据。你根本不需要担心UI的变化。毕竟，你的渲染方法/函数已经提供了组件应该看起来像什么的蓝图。
- en: Note
  id: totrans-65
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: “Stateless” is not a bad word, not at all. Stateless components are much easier
    to manage and think about. However, while going stateless whenever you can is
    usually preferable, applications are complicated and you do need state.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: “无状态”并不是一个坏词，一点也不是。无状态组件更容易管理和思考。然而，尽可能地使组件无状态通常是可取的，但应用程序是复杂的，你确实需要状态。
- en: Similarly to how you access properties via `this.props`, you *read* the state
    via the object `this.state`. To *update* the state, you use `this.setState()`.
    When `this.setState()` is called, React calls the render method of your component
    (and all of its children) and updates the UI.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 与通过`this.props`访问属性类似，你通过`this.state`对象*读取*状态。要*更新*状态，你使用`this.setState()`。当调用`this.setState()`时，React调用你组件的渲染方法（及其所有子组件），并更新UI。
- en: The updates to the UI after calling `this.setState()` are done using a queuing
    mechanism that efficiently batches changes. Updating `this.state` directly can
    have unexpected behavior and you shouldn’t do it. As with `this.props`, consider
    the `this.state` object read-only, not only because it’s semantically a bad idea,
    but because it can act in ways you don’t expect. Similarly, don’t ever call `this.render()`
    yourself—instead, leave it to React to batch changes, figure out the least amount
    of work, and call `render()` when and if appropriate.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`this.setState()`后更新UI是通过一个高效批处理更改的队列机制完成的。直接更新`this.state`可能会产生意外的行为，你不应该这样做。和`this.props`一样，考虑`this.state`对象为只读，不仅因为在语义上这是一个不好的主意，而且因为它可能以你意想不到的方式行事。同样，不要自行调用`this.render()`—而是让React来批处理更改、找出最少的工作量，并在适当时调用`render()`。
- en: A textarea Component
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个文本域组件
- en: Let’s build a new component—a `textarea` that keeps count of the number of characters
    typed in (as shown in [Figure 2-3](#FIG0203)).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个新组件——一个`textarea`，它会计算键入字符的数量（如[图2-3](#FIG0203)所示）。
- en: '![rur2 0203](Images/rur2_0203.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![rur2 0203](Images/rur2_0203.png)'
- en: Figure 2-3\. The end result of the custom `textarea` component
  id: totrans-72
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-3\. 自定义`textarea`组件的最终结果
- en: 'You (as well as other future consumers of this amazingly reusable component)
    can use the new component like so:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你（以及其他未来使用这个非常可重用组件的人）可以像这样使用新组件：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, let’s implement the component. Start first by creating a “stateless” version
    that doesn’t handle updates; this is not too different from all the previous examples:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来实现这个组件。首先创建一个不处理更新的“无状态”版本，这与之前的所有示例并没有太大不同：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-77
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You may have noticed that the `<textarea>` in the preceding snippet takes a
    `defaultValue` property, as opposed to a text child node, as you’re accustomed
    to in regular HTML. This is because there are some slight differences between
    React and old-school HTML when it comes to form elements. These are discussed
    further in the book but rest assured, there are not too many of them. Additionally,
    you’ll find that these differences make your life as a developer easier.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在前面的片段中，`<textarea>`使用`defaultValue`属性而不是像你在常规HTML中习惯的文本子节点。这是因为在React和老式HTML之间存在一些细微差别。这些差异在书中进一步讨论，但请放心，它们并不多。此外，你会发现这些差异使开发者的生活更轻松。
- en: As you can see, the `TextAreaCounter` component takes an optional `text` string
    property and renders a `textarea` with the given value, as well as an `<h3>` element
    that displays the string’s `length`. If the `text` property is not supplied, the
    default “Count me as I type” value is used.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`TextAreaCounter`组件接受一个可选的`text`字符串属性，并渲染一个带有给定值的`textarea`，以及一个显示字符串长度的`<h3>`元素。如果未提供`text`属性，则使用默认的“Count
    me as I type”值。
- en: Make It Stateful
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使其具有状态
- en: The next step is to turn this *stateless* component into a *stateful* one. In
    other words, let’s have the component maintain some data (state) and use this
    data to render itself initially and later on update itself (re-render) when data
    changes.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将这个*无状态*组件转换为一个*有状态*组件。换句话说，让组件维护一些数据（状态），并使用这些数据来初始化自身，并在数据变化时更新自身（重新渲染）。
- en: First, you need to set the initial state in the class constructor using `this.state`.
    Bear in mind that the constructor is the only place where it’s OK to set the state
    directly without calling `this.setState()`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要在类构造函数中使用`this.state`来设置初始状态。请记住，构造函数是唯一可以直接设置状态而不调用`this.setState()`的地方。
- en: Initializing `this.state` is required; if you don’t do it, consecutive access
    to `this.state` in the `render()` method will fail.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化`this.state`是必需的；如果不这样做，在`render()`方法中连续访问`this.state`将失败。
- en: 'In this case it’s not necessary to initialize `this.state.text` with a value
    as you can fallback to the property `this.prop.text` (try *02.12.this.state.html*
    in the book’s repo):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，不需要使用一个值来初始化`this.state.text`，因为你可以回退到属性`this.prop.text`（尝试在书的仓库中查看*02.12.this.state.html*）：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-86
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Calling `super()` in the constructor is required before you can use `this`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`this`之前，需要在构造函数中调用`super()`。
- en: 'The data this component maintains is the contents of the `textarea`, so the
    state has only one property called `text`, which is accessible via `this.state.text`.
    Next you need to update the state. You can use a helper method for this purpose:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件维护的数据是`textarea`的内容，因此状态只有一个名为`text`的属性，可以通过`this.state.text`访问。接下来，你需要更新状态。你可以使用一个辅助方法来实现这个目的：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You always update the state with `this.setState()`, which takes an object and
    merges it with the already existing data in `this.state`. As you might guess,
    `onTextChange()` is an event handler that takes an `event` object and reaches
    into it to get the contents of the `textarea` input.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你总是使用 `this.setState()` 更新状态，它接受一个对象并将其与 `this.state` 中已有的数据合并。你可能已经猜到，`onTextChange()`
    是一个事件处理程序，它接收一个 `event` 对象并从中获取 `textarea` 输入的内容。
- en: 'The last thing left to do is update the `render()` method to set up the event
    handler:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要做的是更新 `render()` 方法来设置事件处理程序：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now whenever the user types into the `textarea`, the value of the counter updates
    to reflect the contents (see [Figure 2-4](#FIG0204)).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当用户在 `textarea` 中输入时，计数器的值都会更新以反映其内容（见[图 2-4](#FIG0204)）。
- en: Note that before you had `<textarea defaultValue...>`, which is now `<textarea
    value...>` in the preceding code. This is because of the way inputs work in HTML
    where their state is maintained by the browser. But React can do better. In this
    example implementing `onChange` means that the `textarea` is now *controlled*
    by React. More on *controlled components* is coming later in the book.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在之前你使用了 `<textarea defaultValue...>`，现在在前述代码中改为了 `<textarea value...>`。这是因为
    HTML 中输入的工作方式，浏览器通过维护它们的状态来完成。但是 React 可以做得更好。在这个例子中，实现 `onChange` 意味着 `textarea`
    现在被 React *控制*。关于*受控组件*的更多内容将在本书后面介绍。
- en: '![rur2 0204](Images/rur2_0204.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![rur2 0204](Images/rur2_0204.png)'
- en: Figure 2-4\. Typing in the `textarea` (*02.12.this.state.html*)
  id: totrans-96
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-4\. 在 `textarea` 中输入（*02.12.this.state.html*）
- en: A Note on DOM Events
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DOM 事件的一则说明
- en: 'To avoid any confusion, a few clarifications are in order regarding the following
    line:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免混淆，以下是关于以下行的一些澄清：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: React uses its own *synthetic* events system for performance (as well as convenience
    and sanity). To help understand why, you need to consider how things are done
    in the pure DOM world.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: React 使用自己的*合成*事件系统以提升性能（以及便利性和理智）。为了理解其中的原因，你需要考虑纯 DOM 世界中的工作方式。
- en: Event Handling in the Olden Days
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 旧日的事件处理
- en: 'It’s convenient to use *inline* event handlers to do things like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*内联*事件处理程序来做这样的事情非常方便：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: While convenient and easy to read (the event listener is right there with the
    UI code), it’s inefficient to have too many event listeners scattered like this.
    It’s also hard to have more than one listener on the same button, especially if
    said button is in somebody else’s “component” or library and you don’t want to
    go in there and “fix” or fork their code. That’s why in the DOM world it’s common
    to use `element.addEventListener` to set up listeners (which now leads to having
    code in two places or more) and *event delegation* (to address the performance
    issues). Event delegation means you listen to events at some parent node, say
    a `<div>` that contains many buttons, and you set up one listener for all the
    buttons, instead of one listener per button. Hence you *delegate* the event handling
    to a parent authority.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管方便且易于阅读（事件监听器直接与 UI 代码并列），但是如此散落的事件监听器过多效率低下。尤其是在同一个按钮上安装多个监听器，特别是当该按钮位于他人的“组件”或库中，你不想进去“修复”或分叉他们的代码时。这就是为什么在
    DOM 世界中使用 `element.addEventListener` 来设置监听器是常见的（这导致代码分布在两个或更多地方），并且*事件委托*（以解决性能问题）。事件委托意味着你在某个父节点（如包含多个按钮的
    `<div>`）上监听事件，并为所有按钮设置一个监听器，而不是每个按钮都设置一个监听器。因此，你*委托*事件处理给父级授权。
- en: 'With event delegation you do something like:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用事件委托，你可以这样做：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This works and performs fine, but there are drawbacks:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法确实有效且运行良好，但也存在一些缺点：
- en: Declaring the listener is further away from the UI component, which makes code
    harder to find and debug.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明监听器离 UI 组件更远，这使得代码更难找到和调试。
- en: Using delegation and always `switch`-ing creates unnecessary boilerplate code
    even before you get to do the actual work (responding to a button click in this
    case).
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用委托和总是进行 `switch` 创建不必要的样板代码，甚至在实际工作（例如响应按钮点击）之前。
- en: Browser inconsistencies (omitted here) actually require this code to be longer.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器不一致性（此处省略）实际上要求这段代码更长。
- en: 'Unfortunately, when it comes to taking this code live in front of real users,
    you need a few more additions if you want to support old browsers:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，当你将此代码发布到真实用户面前时，如果想支持旧版本浏览器，你需要添加更多内容：
- en: You need `attachEvent` in addition to `addEventListener`.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要在 `addEventListener` 之外还要使用 `attachEvent`。
- en: You need `const event = event || window.event;` at the top of the listener.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要在监听器顶部添加 `const event = event || window.event;`。
- en: You need `const button = event.target || event.srcElement;`.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当涉及到在`render()`方法中显示你的组件时，你需要`const button = event.target || event.srcElement;`。
- en: All of these are necessary and annoying enough that you end up using an event
    library of some sort. But why add another library (and study more APIs) when React
    comes bundled with a solution to the event-handling nightmares?
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是必要的，而且足够让人讨厌，以至于最终你会使用某种事件库。但是当React已经捆绑了处理事件噩梦的解决方案时，为什么要再添加另一个库（并学习更多的API）呢？
- en: Event Handling in React
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React中的事件处理
- en: React uses *synthetic events* to wrap and normalize the browser events, which
    means no more browser inconsistencies. You can always rely on the fact that `event.target`
    is available to you in all browsers. That’s why in the `TextAreaCounter` snippet
    you only need `event.target.value` and it just works. It also means the API to
    cancel events is the same in all browsers; in other words, `event.stopPropagation()`
    and `event.preventDefault()` work even in old versions of Internet Explorer.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: React使用*合成事件*来包装和规范化浏览器事件，这意味着不再存在浏览器的不一致性。你始终可以依赖于`event.target`在所有浏览器中都是可用的。这就是为什么在`TextAreaCounter`片段中，你只需要`event.target.value`，它就能正常工作。这也意味着取消事件的API在所有浏览器中都是相同的；换句话说，`event.stopPropagation()`和`event.preventDefault()`即使在旧版的Internet
    Explorer中也能工作。
- en: The syntax makes it easy to keep the UI and the event listeners together. It
    looks like old-school inline event handlers, but behind the scenes it’s not. Actually,
    React uses event delegation for performance reasons.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法使得将UI和事件监听器放在一起变得容易。它看起来像是旧式的内联事件处理程序，但在幕后并非如此。实际上，React出于性能原因使用了事件委托。
- en: React uses camelCase syntax for the event handlers, so you use `onClick` instead
    of `onclick`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: React使用驼峰式语法来处理事件处理程序，因此你使用`onClick`而不是`onclick`。
- en: If you need the original browser event for whatever reason, it’s available to
    you as `event.nativeEvent`, but it’s unlikely that you’ll ever need to go there.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果因为某种原因需要原始的浏览器事件，可以通过`event.nativeEvent`获取到，但你很少会需要这样做。
- en: 'And one more thing: the `onChange` event (as used in the `textarea` example)
    behaves as you’d expect: it fires when the user types, as opposed to after they’ve
    finished typing and have navigated away from the field, which is the behavior
    in plain DOM.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事：`onChange`事件（就像在`textarea`示例中使用的那样）的行为与你期望的一样：用户输入时触发，而不是在他们完成输入并离开字段后触发，这是纯DOM中的行为。
- en: Event-Handling Syntax
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件处理语法
- en: 'The preceding example used an arrow function to call the helper `onTextChange`
    event:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例使用箭头函数调用辅助的`onTextChange`事件：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is because the shorter `onChange={this.onTextChange}` wouldn’t have worked.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为短语法`onChange={this.onTextChange}`不起作用的原因。
- en: 'Another option is to bind the method, like so:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是像这样绑定方法：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'And yet another option, and a common pattern, is to bind all the event-handling
    methods in the constructor:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项，也是一个常见模式，是在构造函数中绑定所有事件处理方法：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It’s a bit of necessary boilerplate, but this way the event handler is bound
    only once, as opposed to every time the `render()` method is called, which helps
    reduce the memory footprint of your app.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一些必要的样板代码，但通过这种方式，事件处理程序仅绑定一次，而不是每次调用`render()`方法时都绑定，这有助于减少应用程序的内存占用。
- en: This common pattern was largely superseded once it became possible to use functions
    as class properties in JavaScript.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在JavaScript中可以将函数用作类属性，这种常见模式就大部分被取代了。
- en: 'Before:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 之前：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'After:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 之后：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: See *02.12.this.state2.html* in the book’s repo for a complete example.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在书的存储库中查看*02.12.this.state2.html*以获取完整的示例。
- en: Props Versus State
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性与状态的区别
- en: Now you know that you have access to `this.props` and `this.state` when it comes
    to displaying your component in your `render()` method. You may be wondering when
    you should use one versus the other.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道在渲染你的组件时，可以访问`this.props`和`this.state`。你可能想知道何时使用其中的一个而不是另一个。
- en: Properties are a mechanism for the outside world (users of the component) to
    configure your component. State is your internal data maintenance. So if you consider
    an analogy with object-oriented programming, `this.props` is like a collection
    of all the arguments passed to a class constructor, while `this.state` is a bag
    of your private properties.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 属性是外部世界（组件的用户）配置你的组件的机制。状态是你的内部数据维护。因此，如果将其与面向对象编程进行类比，`this.props`就像是传递给类构造函数的所有参数的集合，而`this.state`则是你的私有属性的集合。
- en: In general, prefer to split your application in a way that you have fewer *stateful*
    components and more *stateless* ones.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，最好将你的应用程序拆分为更少的*有状态*组件和更多的*无状态*组件。
- en: 'Props in Initial State: an Antipattern'
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Props 在初始状态中的使用：反模式
- en: 'In the preceding `textarea` example, it’s tempting to use `this.props` to set
    the initial `this.state`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述 `textarea` 示例中，很容易使用 `this.props` 设置初始的 `this.state`：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This is considered an antipattern. Ideally, you use any combination of `this.state`
    and `this.props` as you see fit to build your UI in your `render()` method. But
    sometimes you want to take a value passed to your component and use it to construct
    the initial state. There’s nothing wrong with this, except that the callers of
    your component may expect the property (`text` in the preceding example) to always
    have the latest value, and the preceding code would violate this expectation.
    To set the expectation straight, a simple naming change is sufficient—for example,
    calling the property something like `defaultText` or `initialValue` instead of
    just `text`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这被视为一种反模式。理想情况下，您可以根据需要结合 `this.state` 和 `this.props` 在 `render()` 方法中构建您的 UI。但有时，您可能希望使用传递给组件的值来构建初始状态。这本身没有问题，但您组件的调用者可能期望属性（例如前述示例中的
    `text`）始终具有最新的值，而前述代码将违反此预期。为了明确预期，仅需进行简单的命名更改即可，例如将属性命名为 `defaultText` 或 `initialValue`
    而不仅仅是 `text`：
- en: Note
  id: totrans-145
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '[Chapter 4](ch04.xhtml#ch4) illustrates how React solves this for its implementation
    of inputs and `textarea`s where people may have expectations coming from their
    prior HTML knowledge.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 4 章](ch04.xhtml#ch4) 展示了 React 如何解决其输入和 `textarea` 的实现，人们可能会从他们先前的 HTML
    知识中有所期待。'
- en: Accessing the Component from the Outside
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从外部访问组件
- en: You don’t always have the luxury of starting a brand new React app from scratch.
    Sometimes you need to hook into an existing application or a website and migrate
    to React one piece at a time. Luckily, React was designed to work with any preexisting
    codebase you might have. After all, the original creators of React couldn’t stop
    the world and rewrite an entire huge application (Facebook.com) completely from
    scratch, especially in the early days when React was young.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您并非总能够奢侈地从头开始创建一个全新的 React 应用程序。有时候，您需要连接到现有的应用程序或网站，并逐步迁移到 React。幸运的是，React
    设计时考虑到了您可能有的任何预先存在的代码库。毕竟，在 React 刚刚起步的早期，原始的 React 创建者并没有办法停止整个世界并完全从头开始重写一个庞大的应用程序（如
    Facebook.com）。
- en: 'One way your React app can communicate with the outside world is to get a reference
    to a component you render with `ReactDOM.render()` and use it from outside of
    the component:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: React 应用程序与外部世界通信的一种方法是获取您使用 `ReactDOM.render()` 渲染的组件的引用，然后从组件外部使用它：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now you can use `myTextAreaCounter` to access the same methods and properties
    you normally access with `this` when inside the component. You can even play with
    the component using your JavaScript console (as shown in [Figure 2-5](#FIG0205)).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用 `myTextAreaCounter` 访问与在组件内部使用 `this` 访问的相同方法和属性。甚至可以使用您的 JavaScript
    控制台玩弄该组件（如 [图 2-5](#FIG0205) 所示）。
- en: '![rur2 0205](Images/rur2_0205.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![rur2 0205](Images/rur2_0205.png)'
- en: Figure 2-5\. Accessing the rendered component by keeping a reference
  id: totrans-153
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-5\. 通过保持引用访问渲染的组件
- en: 'In this example, `myTextAreaCounter.state` checks the current state (initially
    empty); `myTextAreaCounter.props` checks the properties and this line sets a new
    state:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`myTextAreaCounter.state` 检查当前状态（最初为空）；`myTextAreaCounter.props` 检查属性，并通过此行设置新状态：
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This line gets a reference to the main parent DOM node that React created:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此行获取了 React 创建的主父 DOM 节点的引用：
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This is the first child of the `<div id="app">`, which is where you told React
    to do its magic.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `<div id="app">` 的第一个子元素，这是您告诉 React 进行其魔术的地方。
- en: Note
  id: totrans-159
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You have access to the entire component API from outside of your component.
    But you should use your new superpowers sparingly, if at all. It may be tempting
    to fiddle with the state of components you don’t own and “fix” them, but you’d
    be violating expectations and cause bugs down the road because the component doesn’t
    anticipate such intrusions.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从组件外部访问整个组件 API。但是，如果可能的话，应该谨慎使用您的新超能力。也许您会心生把控不属于您的组件状态并“修复”它们的诱惑，但这会违反预期，从而在未来引起
    bug，因为该组件并不预期此类干预。
- en: Lifecycle Methods
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生命周期方法
- en: 'React offers several so-called *lifecycle* methods. You can use the lifecycle
    methods to listen to changes in your component as far as the DOM manipulation
    is concerned. The life of a component goes through three steps:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: React 提供了几个所谓的 *生命周期* 方法。您可以使用生命周期方法监听组件在 DOM 操作方面的变化。组件的生命周期经历三个步骤：
- en: Mounting
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 挂载
- en: The component is added to the DOM initially.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时将组件添加到 DOM 中。
- en: Updating
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 更新
- en: The component is updated as a result of calling `setState()` and/or a prop provided
    to the component has changed.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 组件通过调用 `setState()` 和/或者提供给组件的 prop 发生变化而更新。
- en: Unmounting
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 卸载
- en: The component is removed from the DOM.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 将组件从 DOM 中移除。
- en: 'React does part of its work before updating the DOM. This is also called the
    *rendering phase*. Then it updates the DOM and this phase is called a *commit
    phase*. With this background, let’s consider some lifecycle methods:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: React 在更新 DOM 之前会做一部分工作。这也被称为 *渲染阶段*。然后它更新 DOM，这个阶段称为 *提交阶段*。在此背景下，让我们考虑一些生命周期方法：
- en: After the initial mounting and after the commit to the DOM, your component’s
    `componentDidMount()` method is called, if it exists. This is the place to do
    any initialization work that requires the DOM. Any initialization work that *does
    not* require the DOM should be in the constructor. And most of your initialization
    shouldn’t require the DOM. But in this method you can, for example, measure the
    height of the component that was just rendered, add any event listeners (e.g.
    `addEventListener('resize')`), or fetch data from the server.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在初始挂载和提交到 DOM 之后，如果存在，你的组件的 `componentDidMount()` 方法会被调用。这是进行任何需要 DOM 的初始化工作的地方。任何不需要
    DOM 的初始化工作应该在构造函数中完成。大多数初始化工作不应该依赖 DOM。但在这个方法中，你可以例如测量刚刚渲染的组件的高度，添加任何事件监听器（例如
    `addEventListener('resize')`），或从服务器获取数据。
- en: Right before the component is removed from the DOM, the method `componentWillUnmount()`
    is called. This is the place to do any cleanup work you may need. Any event handlers,
    or anything else that may leak memory, should be cleaned up here. After this,
    the component is gone forever.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在组件从 DOM 中被移除之前，方法 `componentWillUnmount()` 会被调用。这是进行任何可能需要的清理工作的地方。任何事件处理程序或其他可能会泄露内存的东西都应该在这里清理。之后，组件永远消失了。
- en: Before the component is updated (e.g., as a result of `setState()`), you can
    use `getSnapshotBeforeUpdate()`. This method receives the previous properties
    and state as arguments. And it can return a “snapshot” value, which is any value
    you want to pass over to the next lifecycle method called `componentDidUpdate()`.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在组件更新之前（例如通过 `setState()` 的结果），你可以使用 `getSnapshotBeforeUpdate()`。该方法接收先前的属性和状态作为参数。它可以返回一个“快照”值，这个值可以传递给下一个生命周期方法
    `componentDidUpdate()`。
- en: '`componentDidUpdate(previousProps, previousState, snapshot)`. This is called
    whenever the component was updated. Since at this point `this.props` and `this.state`
    have updated values, you get a copy of the previous ones. You can use this information
    to compare the old and the new state and potentially make more network requests
    if necessary.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentDidUpdate(previousProps, previousState, snapshot)`。每当组件被更新时调用此方法。由于此时
    `this.props` 和 `this.state` 已经更新了，你会得到之前的副本。你可以用这些信息比较旧状态和新状态，并在必要时进行更多的网络请求。'
- en: And then there’s `shouldComponentUpdate(newProps, newState)`, which is an opportunity
    for an optimization. You’re given the state-to-be, which you can compare with
    the current state and decide not to update the component, in which case its `render()`
    method is not called.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后是 `shouldComponentUpdate(newProps, newState)`，这是一个优化的机会。你可以拿到即将更新的状态，与当前状态进行比较，决定是否更新组件，如果不更新，其
    `render()` 方法就不会被调用。
- en: Of these, `componentDidMount()` and `componentDidUpdate()` are the most common
    ones.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，`componentDidMount()` 和 `componentDidUpdate()` 是最常见的方法之一。
- en: 'Lifecycle Example: Log It All'
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生命周期示例：全部记录下来
- en: 'To better understand the life of a component, let’s add some logging in the
    `TextAreaCounter` component. Simply implement all of the lifecycle methods to
    log to the console when they are invoked, together with any arguments:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解组件的生命周期，让我们在 `TextAreaCounter` 组件中添加一些日志记录。简单地实现所有的生命周期方法，在它们被调用时在控制台打印日志及相关参数：
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: After loading the page, the only message in the console is `componentDidMount`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 页面加载后，控制台中唯一的消息是 `componentDidMount`。
- en: Next, what happens when you type “b” to make the text “Bobb” (see [Figure 2-6](#FIG0206))?
    `shouldComponentUpdate()` is called with the new props (same as the old) and the
    new state. Since this method returns `true`, React proceeds with calling `getSnapshotBeforeUpdate()`
    passing the old props and state. This is your chance to do something with them
    and with the old DOM and pass any resulting information as a snapshot to the next
    method. For example, this is an opportunity to do some element measurements or
    a scroll position and snapshot them to see if they change after the update. Finally,
    `componentDidUpdate()` is called with the old info (you have the new one in `this.state`
    and `this.props`) and any snapshot defined by the previous method.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，当您键入“b”以使文本变为“Bobb”（参见[图2-6](#FIG0206)）时，`shouldComponentUpdate()`将使用新的props（与旧的相同）和新的状态进行调用。由于此方法返回`true`，React继续调用`getSnapshotBeforeUpdate()`，传递旧的props和状态。这是您处理它们和旧的DOM并将任何生成的信息作为快照传递给下一个方法的机会。例如，这是一个机会来做一些元素的测量或滚动位置，并将它们快照以查看它们是否在更新后改变。最后，`componentDidUpdate()`被调用时使用旧信息（您在`this.state`和`this.props`中有新的信息）以及由前一个方法定义的任何快照。
- en: '![rur2 0206](Images/rur2_0206.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![rur2 0206](Images/rur2_0206.png)'
- en: Figure 2-6\. Updating the component
  id: totrans-182
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-6\. 更新组件
- en: Let’s update the `textarea` one more time, this time typing “y”. The result
    is shown in [Figure 2-7](#FIG0207).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次更新`textarea`，这次键入“y”。结果显示在[图2-7](#FIG0207)中。
- en: '![rur2 0207](Images/rur2_0207.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![rur2 0207](Images/rur2_0207.png)'
- en: Figure 2-7\. One more update to the component
  id: totrans-185
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-7\. 对组件的又一次更新
- en: 'Finally, to demonstrate `componentWillUnmount()` in action (using the example
    *02.14.lifecycle.html* from this book’s GitHub repo) you can type in the console:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了演示`componentWillUnmount()`的实际效果（使用本书GitHub存储库中的示例*02.14.lifecycle.html*），您可以在控制台中键入：
- en: '[PRE34]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This replaces the whole `textarea` component with a new `<p>` component. Then
    you can see the log message `componentWillUnmount` in the console (shown in [Figure 2-8](#FIG0208)).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这将整个`textarea`组件替换为一个新的`<p>`组件。然后，您可以在控制台中看到`componentWillUnmount`的日志消息（显示在[图2-8](#FIG0208)中）。
- en: '![rur2 0208](Images/rur2_0208.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![rur2 0208](Images/rur2_0208.png)'
- en: Figure 2-8\. Removing the component from the DOM
  id: totrans-190
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-8\. 从DOM中移除组件
- en: Paranoid State Protection
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 偏执状态保护
- en: 'Say you want to restrict the number of characters to be typed in the `textarea`.
    You should do this in the event handler `onTextChange()`, which is called as the
    user types. But what if someone (a younger, more naive you?) calls `setState()`
    from the outside of the component (which, as mentioned earlier, is a bad idea)?
    Can you still protect the consistency and well-being of your component? Sure.
    You can do the validation in `componentDidUpdate()` and if the number of characters
    is greater than allowed, revert the state back to what it was. Something like:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想要限制在`textarea`中键入的字符数。您应该在事件处理程序`onTextChange()`中执行此操作，该事件在用户键入时调用。但是如果有人（比如一个更年轻、更天真的你？）从组件外部调用`setState()`会怎么样（正如前面提到的，这是一个坏主意）？你仍然可以保护组件的一致性和健康。您可以在`componentDidUpdate()`中进行验证，如果字符数超过允许的限制，将状态恢复到原来的状态。类似这样：
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The condition `prevState.text || this.props.text` is in place for the very first
    update when there’s no previous state.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 条件`prevState.text || this.props.text`是在第一次更新时没有前一个状态时的情况下。
- en: 'This may seem overly paranoid, but it’s still possible to do. Another way to
    accomplish the same protection is by leveraging `shouldComponentUpdate()`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来过于偏执，但仍然是可能的。实现相同保护的另一种方法是利用`shouldComponentUpdate()`：
- en: '[PRE36]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: See *02.15.paranoid.html* in the book’s repo to play with these concepts.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在书籍的存储库中查看*02.15.paranoid.html*以尝试这些概念。
- en: Note
  id: totrans-198
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In the preceding code, using `_` as a name of a function argument is a convention
    signaling to a future reader of the code, “I know there’s another argument in
    the function’s signature, but I’m not going to use it.”
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，将`_`作为函数参数名是一种约定，向代码的未来读者传达：“我知道函数签名中还有另一个参数，但我不打算使用它。”
- en: 'Lifecycle Example: Using a Child Component'
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生命周期示例：使用子组件
- en: You know you can mix and nest React components as you see fit. So far you’ve
    only seen `ReactDOM` components (as opposed to custom ones) in the `render()`
    methods. Let’s take a look at another simple custom component to be used as a
    child.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您知道您可以根据需要混合和嵌套React组件。到目前为止，您只在`render()`方法中看到了`ReactDOM`组件（而不是自定义组件）。让我们看看另一个简单的自定义组件，可以用作子组件。
- en: Let’s isolate the part responsible for the counter into its own component. After
    all, divide and conquer is what it’s all about!
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将负责计数的部分隔离到自己的组件中。毕竟，分而治之就是这一切的关键！
- en: First, let’s isolate the lifestyle logging into a separate class and have the
    two components inherit it. Inheritance is almost never warranted when it comes
    to React because for UI work, *composition* is preferable, and for non-UI work,
    a regular JavaScript module would do. Still, it’s useful to know how it works,
    and it helps you to avoid copy-pasting the logging methods.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将生活方式日志记录单独隔离到一个独立的类中，并让这两个组件继承它。在 React 中，几乎从不需要继承，因为对于 UI 工作，*组合* 更可取，对于非
    UI 工作，普通的 JavaScript 模块就可以了。不过，了解它的工作原理是有用的，它可以帮助你避免复制粘贴日志记录方法。
- en: 'This is the parent:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这是父组件：
- en: '[PRE37]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The new `Counter` component simply shows the count. It doesn’t maintain state
    but displays the `count` property given by the parent:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `Counter` 组件只显示计数。它不维护状态，而是显示父组件给出的 `count` 属性：
- en: '[PRE38]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `textarea` component sets up a static `getName()` method:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`textarea` 组件设置了一个静态的 `getName()` 方法：'
- en: '[PRE39]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'And finally, the `textarea`’s `render()` gets to use `<Counter/>` and use it
    conditionally; if the count is 0, nothing is displayed:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`textarea` 的 `render()` 可以使用 `<Counter/>` 并有条件地使用它；如果计数为 0，则不显示任何内容：
- en: '[PRE40]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note
  id: totrans-212
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Notice the conditional statement in JSX. You wrap the expression in `{}` and
    conditionally render either `<Counter/>` or nothing (`null`). And just for demonstration:
    another option is to move the condition outside the `return`. Assigning the result
    of a JSX expression to a variable is perfectly fine.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 JSX 中的条件语句。你将表达式包裹在 `{}` 中，有条件地渲染 `<Counter/>` 或什么都不渲染（`null`）。只是为了演示：另一个选项是将条件移到
    `return` 外。将 JSX 表达式的结果赋给变量是完全可以的。
- en: '[PRE41]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now you can observe the lifecycle methods being logged for both components.
    Open *02.16.child.html* from the book’s repo in your browser to see what happens
    when you load the page and then change the contents of the `textarea`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以观察到两个组件的生命周期方法被记录下来。在书的存储库中打开 *02.16.child.html*，在浏览器中查看当加载页面然后更改 `textarea`
    内容时会发生什么。
- en: 'During initial load, the child component is mounted and updated before the
    parent. You see in the console log:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始加载时，子组件会在父组件之前挂载和更新。你可以在控制台日志中看到：
- en: '[PRE42]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'After deleting two characters you see how the child is updated, then the parent:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 删除两个字符后，你会看到子组件如何更新，然后是父组件：
- en: '[PRE43]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'After deleting the last character, the child component is completely removed
    from the DOM:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 删除最后一个字符后，子组件完全从 DOM 中移除：
- en: '[PRE44]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, typing a character brings back the counter component to the DOM:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，输入一个字符会将计数组件带回 DOM 中：
- en: '[PRE45]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Performance Win: Prevent Component Updates'
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能优化：阻止组件更新
- en: You already know about `shouldComponentUpdate()` and saw it in action. It’s
    especially important when building performance-critical parts of your app. It’s
    invoked before `componentWillUpdate()` and gives you a chance to cancel the update
    if you decide it’s not necessary.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解了 `shouldComponentUpdate()` 并看到它的作用。在构建应用程序的性能关键部分时，这一点尤为重要。它在 `componentWillUpdate()`
    之前被调用，让你有机会取消更新，如果你认为不必要的话。
- en: There is a class of components that use only `this.props` and `this.state` in
    their `render()` methods and no additional function calls. These components are
    called “pure” components. They can implement `shouldComponentUpdate()` and compare
    the state and the properties before and after an update and if there aren’t any
    changes, return `false` and save some processing power. Additionally, there can
    be pure static components that use neither props nor state. These can straight
    out return `false`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 有一类组件在其 `render()` 方法中只使用 `this.props` 和 `this.state`，没有额外的函数调用。这些组件被称为“纯”组件。它们可以实现
    `shouldComponentUpdate()`，在更新前后比较状态和属性，如果没有任何变化，则返回 `false`，节省一些处理能力。此外，还可以有纯静态组件，既不使用
    props 也不使用 state。这些组件可以直接返回 `false`。
- en: 'React can make it easier to use the common (and generic) case of checking all
    props and state in `shouldComponentUpdate()`: instead of repeating this work,
    you can have your components inherit `React.PureComponent` instead of `React.Component`.
    This way you don’t need to implement `shouldComponentUpdate()`—it’s done for you.
    Let’s take advantage and tweak the previous example.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: React 可以更容易地使用常见（和通用）情况下在 `shouldComponentUpdate()` 中检查所有 props 和 state：而不是重复这项工作，你可以让你的组件继承
    `React.PureComponent` 而不是 `React.Component`。这样你就不需要实现 `shouldComponentUpdate()`
    —— 它已经为你做好了。让我们利用这一点并调整前面的例子。
- en: 'Since both components inherit the logger, all you need is:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 由于两个组件都继承了日志记录器，你只需要：
- en: '[PRE46]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now both components are *pure*. Let’s also add a log message in the `render()`
    methods:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这两个组件都是*纯的*。让我们还在`render()`方法中添加一个日志消息：
- en: '[PRE47]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now loading the page (*02.17.pure.html* from the repo) prints out:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在加载页面（从存储库中的*02.17.pure.html*）打印出：
- en: '[PRE48]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Changing “Bob” to “Bobb” gives us the expected result of rendering and updating:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 将“Bob”更改为“Bobb”会得到预期的渲染和更新结果：
- en: '[PRE49]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now if you *paste* the string “LOLz” replacing “Bobb” (or any string with 4
    characters), you see:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你将字符串“LOLz”粘贴到替换“Bobb”（或任何包含4个字符的字符串），你会看到：
- en: '[PRE50]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: As you see there’s no reason to re-render `<Counter>`, because its props have
    not changed. The new string has the same number of characters.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，无需重新渲染`<Counter>`，因为它的 props 没有改变。新字符串的字符数相同。
- en: Whatever Happened to Function Components?
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数组件究竟发生了什么？
- en: You may have noticed that function components dropped out of this chapter by
    the time `this.state` got involved. They come back later in the book, when you’ll
    also learn the concept of *hooks*. Since there’s no `this` in functions, there
    needs to be another way to approach the management of state in a component. The
    good news is that once you understand the concepts of state and props, the function
    component differences are just syntax.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，一旦`this.state`参与其中，函数组件就不再本章中。它们在本书的后面会再次出现，那时你还会学到*hooks*的概念。因为函数中没有`this`，所以在组件中管理状态需要另一种方法。好消息是，一旦你理解了状态和
    props 的概念，函数组件的差异只是语法问题。
- en: As much “fun” as it was to spend all this time on a `textarea`, let’s move on
    to something more challenging. In the next chapter, you’ll see where React’s benefits
    come into play—namely, focusing on your *data* and having React take care of any
    and all UI updates.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管花费大量时间在一个`textarea`上是多么“有趣”，让我们转向更具挑战性的内容。在下一章中，你将看到 React 的好处体现在哪里——即专注于你的*数据*，而让
    React 处理所有的 UI 更新。
