- en: Chapter 9\. Details
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章。细节
- en: When the now-near-ubiquitous air freshener Febreze was first released, it was
    a dud. The original ads showed people using the product to remove specific bad
    smells, such as cigarette smoke, resulting in poor sales. Faced with this disappointing
    outcome, the marketing team shifted focus to using Febreze as a finishing detail.
    Now, the ads depicted someone cleaning a room, fluffing the pillows, and completing
    the tasks of refreshing a room with a spritz of Febreze. This reframing of the
    product caused sales to skyrocket.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当现在几乎无处不在的空气清新剂 Febreze 首次发布时，它一无是处。最初的广告展示了人们使用该产品去除特定的恶臭，如香烟烟雾，导致销售疲软。面对这令人失望的结果，营销团队将焦点转移到将
    Febreze 用作完美细节。现在，广告描绘了有人在清理房间，拍打枕头，并完成了使用 Febreze 给房间喷雾的任务。这种重新定义产品的方式使销售额飙升。
- en: This is a great example of the fact that *details matter*. Right now we have
    a working API, but it’s lacking the finishing touches that will allow us to put
    it into production. In this chapter we’ll implement some web and GraphQL application
    security and user experience best practices. These details, far exceeding a spritz
    of air freshener, will be critical to the safety, security, and usability of our
    application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的例子，*细节很重要*。现在我们有一个工作中的 API，但缺少让它投入生产的最后修饰。在本章中，我们将实施一些 Web 和 GraphQL
    应用程序安全和用户体验最佳实践。这些远远超过空气清新剂的喷雾的细节将对我们应用程序的安全性、可用性和易用性至关重要。
- en: Web Application and Express.js Best Practices
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web 应用程序和 Express.js 最佳实践
- en: Express.js is the underlying web application framework that powers our API.
    We can make a few small tweaks to our Express.js code to provide a solid basis
    for our application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Express.js 是支持我们 API 的底层 Web 应用程序框架。我们可以对 Express.js 代码进行一些小的调整，以为我们的应用程序提供坚实的基础。
- en: Express Helmet
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Express Helmet
- en: The Express [Helmet middleware](https://oreil.ly/NGae1) is a collection of small
    security-minded middleware functions. These will adjust our application’s HTTP
    headers to be more secure. While many of these are specific to browser-based applications,
    enabling Helmet is a simple step to protect our application from common web vulnerabilities.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Express [Helmet 中间件](https://oreil.ly/NGae1) 是一组小型的以安全为导向的中间件函数。这些函数将调整我们应用程序的
    HTTP 头部以提升安全性。尽管其中许多是针对基于浏览器的应用程序的，启用 Helmet 是保护我们应用程序免受常见网络漏洞的简单步骤。
- en: 'To enable Helmet, we’ll require the middleware in our application and instruct
    Express to use it early in our middleware stack. In the *./src/index.js* file,
    add the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用 Helmet，我们将在我们的应用程序中引入中间件，并指示 Express 在我们的中间件堆栈中早期使用它。在 *./src/index.js*
    文件中，添加以下内容：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: By adding the Helmet middleware, we’re quickly enabling common web security
    best practices for our application.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加 Helmet 中间件，我们可以快速为我们的应用启用常见的网络安全最佳实践。
- en: Cross-Origin Resource Sharing
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨域资源共享
- en: Cross-Origin Resource Sharing (CORS) is the means by which we allow resources
    to be requested from another domain. Because our API and UI code will live separately,
    we’ll want to enable credentials from other origins. If you’re interested in learning
    the ins and outs of CORS, I highly recommend the [Mozilla CORS Guide](https://oreil.ly/E1lXZ).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 跨域资源共享（CORS）是允许从另一个域请求资源的手段。因为我们的 API 和 UI 代码将分开存放，我们希望从其他来源启用凭据。如果你有兴趣了解 CORS
    的方方面面，我强烈推荐 [Mozilla CORS Guide](https://oreil.ly/E1lXZ)。
- en: 'To enable CORS, we’ll use the Express.js [CORS middleware](https://oreil.ly/lYr7g)
    package in our *.src/index.js* file:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用 CORS，我们将在我们的 *.src/index.js* 文件中使用 Express.js [CORS 中间件](https://oreil.ly/lYr7g)
    包：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: By adding the middleware in this way, we are enabling cross-origin requests
    from *all* domains. This works well for us for now, as we’re in development mode
    and will likely be using domains generated by our hosting providers, but by using
    the middleware, we could also limit the requests to those of specific origins.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式添加中间件，我们可以允许来自 *所有* 域的跨源请求。目前这对我们来说效果很好，因为我们处于开发模式，可能会使用由我们的托管提供商生成的域，但通过使用中间件，我们也可以限制请求来自特定来源。
- en: Pagination
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分页
- en: Currently our `notes` and `users` queries return the full list of notes and
    users in the database. This works fine for local development, but as our application
    grows it will become unsustainable, as a query that returns potentially hundreds
    (or thousands) of notes is expensive and will slow down our database, server,
    and network. Instead, we can paginate those queries, returning only a set number
    of results.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的`notes`和`users`查询返回数据库中所有笔记和用户的完整列表。这在本地开发中运行良好，但随着应用程序的增长，这将变得难以维护，因为查询可能会返回数百（甚至数千）个笔记，这样的开销会拖慢我们的数据库、服务器和网络。因此，我们可以对这些查询进行分页，仅返回一定数量的结果。
- en: There are two common types of pagination that we could implement. The first
    type, *offset pagination*, works by the client passing an offset number and returning
    a limited amount of data. For example, if each page of data were limited to 10
    records, and we wanted to request the third page of data, we could pass an offset
    of 20\. While this is the most straightforward approach conceptually, it can run
    into scaling and performance issues.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以实现两种常见的分页方式。第一种类型，*偏移分页*，通过客户端传递偏移数，并返回有限数量的数据。例如，如果每页数据限制为10条记录，我们想要请求第三页数据，我们可以传递偏移量为20。尽管这在概念上是最直观的方法，但它可能会遇到扩展和性能问题。
- en: The second type of pagination is *cursor-based pagination*, in which a time-based
    cursor or unique identifier is passed as a starting point. We then request a specific
    amount of data that follows this record. This approach gives us the greatest control
    over our pagination. Additionally, because Mongo’s object IDs are ordered (they
    begin with a 4-byte time value), we can easily utilize them as our cursor. To
    learn more about Mongo’s object ID, I recommend reading [the corresponding MongoDB
    documentation](https://oreil.ly/GPE1c).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种分页方式是*基于游标的分页*，其中传递一个基于时间或唯一标识的游标作为起始点。然后，我们请求跟随此记录的特定数据量。这种方法能够给我们最大程度上的分页控制。此外，因为Mongo的对象ID是有序的（它们以4字节的时间值开头），我们可以很容易地将它们用作游标。要了解更多关于Mongo对象ID的信息，建议阅读[对应的MongoDB文档](https://oreil.ly/GPE1c)。
- en: If this sounds overly conceptual to you, that’s OK. Let’s walk through implementing
    a paginated feed of notes as a GraphQL query. First, let’s define what we’ll be
    creating, followed by our schema updates, and lastly our resolver code. For our
    feed we’ll want to query our API while optionally passing a cursor as a parameter.
    The API should then return a limited amount of data, a cursor point representing
    the last item in the data set, and a Boolean value if there is an additional page
    of data to query.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这对你来说听起来过于概念化，没关系。让我们一起来实现一个基于GraphQL查询的分页笔记Feed。首先，我们定义我们将要创建的内容，接着是我们的模式更新，最后是我们的解析器代码。对于我们的Feed，我们希望在查询API时可选地传递一个游标作为参数。API应返回有限的数据量，一个表示数据集中最后一项的游标点，并一个布尔值，表示是否有另一页数据可查询。
- en: 'With this description, we can update our *src/schema.js* file to define this
    new query. First, we’ll need to add a `NoteFeed` type to our file:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个描述，我们可以更新我们的*src/schema.js*文件，定义这个新的查询。首先，我们需要在文件中添加一个`NoteFeed`类型：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we’ll add our `noteFeed` query:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加我们的`noteFeed`查询：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With our schema updated, we can write the resolver code for our query. In *./src/resolvers/query.js*,
    add the following to the exported object:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的模式更新后，我们可以为我们的查询编写解析器代码。在*./src/resolvers/query.js*中，向导出对象添加以下内容：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With this resolver in place, we can query our `noteFeed`, which will return
    a maximum of 10 results. In the GraphQL Playground, we can write a query as follows
    to receive a list of notes, their object IDs, their “created at” timestamp, the
    cursor, and the next page boolean:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个解析器，我们可以查询我们的`noteFeed`，它将最多返回10个结果。在GraphQL Playground中，我们可以编写以下查询来接收笔记列表，它们的对象ID，它们的“创建时间”时间戳，游标，以及下一页的布尔值：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Since we have more than 10 notes in our database, this returns a cursor as
    well as a `hasNextPage` value of `true`. With that cursor, we can query the second
    page of the feed:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的数据库中有超过10条笔记，这会返回一个游标以及`hasNextPage`值为`true`。通过这个游标，我们可以查询Feed的第二页：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can continue to do this for each cursor where the `hasNextPage` value is
    `true`. With this implementation in place, we’ve created a paginated feed of notes.
    This will both allow our UI to request a specific feed of data as well as reduce
    the burden on our server and database.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续为每个游标执行此操作，其中`hasNextPage`值为`true`。有了这个实现，我们已经创建了一个分页笔记Feed。这不仅允许我们的UI请求特定数据Feed，还可以减少服务器和数据库的负担。
- en: Data Limitations
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据限制
- en: In addition to establishing pagination, we’ll want to limit the amount of data
    that can be requested through our API. This prevent queries that could overload
    our server or database.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 除了建立分页之外，我们还希望限制可以通过我们的 API 请求的数据量。这可以防止可能会使我们的服务器或数据库超载的查询。
- en: 'A simple first step in this process is to limit the amount of data that a query
    can return. Two of our queries, `users` and `notes`, return all of the matching
    data from the database. We could address this by setting a `limit()` method on
    our database queries. For example, in our *.src/resolvers/query.js* file, we can
    update our `notes` query as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中的一个简单的第一步是限制查询可以返回的数据量。我们的两个查询，`users` 和 `notes`，返回数据库中所有匹配的数据。我们可以通过在数据库查询上设置
    `limit()` 方法来解决这个问题。例如，在我们的 *.src/resolvers/query.js* 文件中，我们可以更新我们的 `notes` 查询如下：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: While limiting data is a solid start, currently our queries can be written with
    an unlimited depth. This means that a single query could be written to retrieve
    a list of notes, the author information for each of those notes, the list of favorites
    of each author, the author information for each of those favorites, and so on.
    That’s a lot of data in one query, and we could keep going! To prevent these types
    of overnested queries, we can *limit the depth* of queries against our API.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管限制数据是一个很好的开始，但是当前我们的查询可以写成无限深度。这意味着可以写一个单一查询来检索一系列笔记，每个笔记的作者信息，每个作者的收藏列表，每个收藏的作者信息，依此类推。这是一个很多数据的查询，我们还可以继续！为了防止这些过度嵌套的查询，我们可以*限制查询的深度*。
- en: Additionally, we might have complex queries that are not overly nested, but
    still require heavy computation to return the data. We can protect against these
    types of requests by *limiting query complexity*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可能有复杂的查询，虽然不是过于嵌套，但仍需要大量计算来返回数据。我们可以通过*限制查询复杂性*来防止这些类型的请求。
- en: 'We can implement these limits by using the `graphql-depth-limit` and `graphql-validation-complexity`
    packages in our *./src/index.js* file:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在我们的 *./src/index.js* 文件中使用 `graphql-depth-limit` 和 `graphql-validation-complexity`
    包来实现这些限制：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With these package additions, we’ve added extra query protection to our API.
    For more information on securing a GraphQL API from malicious queries, check out
    the [fantastic article](https://oreil.ly/_r5tl) from Max Stoiber, CTO of Spectrum.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加这些包，我们为我们的 API 添加了额外的查询保护。有关如何保护 GraphQL API 免受恶意查询的更多信息，请查看 Spectrum 的首席技术官
    Max Stoiber 的[精彩文章](https://oreil.ly/_r5tl)。
- en: Other Considerations
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他考虑事项
- en: After building our API, you should have a solid understanding of the fundamentals
    of GraphQL development. If you’re eager to dig in more on the topics, some excellent
    places to go next would be testing, GraphQL subscriptions, and Apollo Engine.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建完我们的 API 后，您应该对 GraphQL 开发的基础知识有了坚实的理解。如果您渴望深入了解更多主题，一些继续学习的好去处包括测试、GraphQL
    订阅和 Apollo Engine。
- en: Testing
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试
- en: 'OK, I’ll admit it: I feel guilty for not writing about tests in this book.
    Testing our code is important because it allows us to comfortably make changes
    and improves our collaboration with other developers. One of the great things
    about our GraphQL setup is that resolvers are simply functions, taking some parameters
    and returning data. This makes our GraphQL logic straightforward to test.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我承认：我没有在这本书中写关于测试，我感到有些内疚。测试我们的代码很重要，因为它使我们能够放心地进行更改，并改善与其他开发人员的协作。我们的 GraphQL
    设置中的一大优势是解析器只是简单的函数，接受一些参数并返回数据。这使得我们的 GraphQL 逻辑易于测试。
- en: Subscriptions
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 订阅
- en: Subscriptions are an incredibly powerful feature of GraphQL, which offers a
    straightforward way to integrate the publish-subscribe pattern in our application.
    This means that a UI can subscribe to be notified or updated when data is published
    on the server. This makes GraphQL servers an ideal solution for applications that
    work with real-time data. For more information about GraphQL subscriptions, take
    a look at the [Apollo Server documentation](https://oreil.ly/YwI5_).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅是 GraphQL 的一个非常强大的功能，它提供了一种简单的方法在我们的应用程序中集成发布-订阅模式。这意味着用户界面可以订阅在服务器上发布数据时进行通知或更新。这使得
    GraphQL 服务器成为处理实时数据的理想解决方案。有关 GraphQL 订阅的更多信息，请查看[Apollo Server 文档](https://oreil.ly/YwI5_)。
- en: Apollo GraphQL Platform
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Apollo GraphQL 平台
- en: Throughout the development of our API, we’ve been using the Apollo GraphQL library.
    In future chapters we’ll also be using the Apollo client libraries to interface
    with our API. I’ve chosen these libraries because they are industry standards
    and offer a great developer experience for working with GraphQL. If you take your
    application to production, Apollo, the company who maintains these libraries,
    also offers a platform that provides monitoring and tooling for GraphQL APIs.
    You can learn more at [Apollo’s website](https://www.apollographql.com).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发我们的API的整个过程中，我们一直在使用Apollo GraphQL库。在将来的章节中，我们还将使用Apollo客户端库与我们的API进行交互。我选择这些库是因为它们是行业标准，并且为使用GraphQL的开发者提供了极好的开发体验。如果你把你的应用程序投入生产，维护这些库的公司Apollo还提供了一个平台，为GraphQL
    API提供监控和工具支持。您可以在[Apollo的网站](https://www.apollographql.com)上了解更多。
- en: Conclusion
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter we added some finishing touches to our application. Though there
    are many other options we could implement, at this point we have developed a solid
    MVP (minimum viable product). In this state, we are ready to launch our API! In
    the next chapter, we’ll deploy our API to a public web server.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们为我们的应用程序添加了一些最后的修饰。虽然我们可以实现许多其他选项，但在这一点上，我们已经开发出了一个坚实的MVP（最小可行产品）。在这个状态下，我们已经准备好启动我们的API！在下一章中，我们将把我们的API部署到一个公共Web服务器上。
