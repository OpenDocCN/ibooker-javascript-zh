- en: Chapter 2\. Routing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。路由
- en: This chapter looks at recipes using React routes and the `react-router-dom`
    library.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨使用React路由和`react-router-dom`库的技巧。
- en: '`react-router-dom` uses *declarative routing*, which means you treat routes
    as you would any other React component. Unlike buttons, text fields, and blocks
    of text, React routes have no visual appearance. But in most other ways, they
    are similar to buttons and blocks of text. Routes live in the virtual DOM tree
    of components. They listen for changes in the current browser location and allow
    you to switch on and switch off parts of the interface. They are what give SPAs
    the appearance of multipage applications.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '`react-router-dom` 使用*声明式路由*，这意味着你将路由看作是任何其他React组件。与按钮、文本字段和文本块不同，React路由没有视觉外观。但在大多数其他方面，它们与按钮和文本块类似。路由存在于组件的虚拟DOM树中。它们监听当前浏览器位置的变化，并允许您打开和关闭界面的部分。它们使得单页面应用程序看起来像是多页面应用程序。'
- en: Used well, they can make your application feel like any other website. Users
    will be able to bookmark sections of your application, as they might bookmark
    a page from Wikipedia. They can go backward and forward in their browser history,
    and your interface will behave properly. If you are new to React, then it is well
    worth your time to look deeply into the power of routing.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用得当，它们可以使您的应用程序感觉像任何其他网站。用户可以将您的应用程序的部分添加到书签中，就像他们可能会将维基百科的页面添加到书签中一样。他们可以在浏览器历史记录中前进和后退，并且您的界面将正常工作。如果您对React不熟悉，深入了解路由的强大功能是非常值得的。
- en: Create Interfaces with Responsive Routes
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建具有响应式路由的界面
- en: Problem
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: People use most applications on both mobile and laptop computers, which means
    you probably want your React application to work well across all screen sizes.
    Making your application responsive involves relatively simple CSS changes to adjust
    the sizing of text and screen layout, and more substantial changes, which can
    give mobile and desktop users very different experiences when navigating around
    your site.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序在移动设备和笔记本电脑上都有用户使用，这意味着您可能希望您的React应用程序在所有屏幕尺寸上都能良好运行。使您的应用程序响应式涉及相对简单的CSS更改，以调整文本和屏幕布局的大小，并且更深入的更改可以使移动设备和桌面用户在浏览站点时有非常不同的体验。
- en: Our example application shows the names and addresses of a list of people. In
    [Figure 2-1](#ch02_image_1), you can see the application running on a desktop
    machine.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例应用程序显示了一组人员的姓名和地址。在[图2-1](#ch02_image_1)中，您可以看到应用程序在桌面机器上运行。
- en: '![](Images/recb_0201.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_0201.png)'
- en: Figure 2-1\. The desktop view of the app
  id: totrans-9
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-1\. 应用程序的桌面视图
- en: But this layout won’t work very well on a mobile device, which might have space
    to display either the list of people or the details of one person, but not both.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这种布局在移动设备上效果不佳，可能只能显示人员列表或者一个人的详细信息，但不能同时显示。
- en: What can we do in React to provide a custom navigation experience for both mobile
    and desktop users without creating two completely separate versions of the application?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中，我们能做些什么来为移动设备和桌面用户提供定制的导航体验，而不需要创建完全不同的应用程序版本？
- en: Solution
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'We’re going to use *responsive routes*. A responsive route changes according
    to the size of the user’s display. Our existing application uses a single route
    for displaying the information for a person: */people/:id*.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用*响应式路由*。响应式路由会根据用户显示器的大小而变化。我们现有的应用程序使用单一路由显示一个人员的信息：*/people/:id*。
- en: When you navigate to this route, the browser shows the page in [Figure 2-1](#ch02_image_1).
    You can see the people listed down the left side. The page highlights the selected
    person and displays their details on the right.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当您导航到这个路由时，浏览器将显示[图2-1](#ch02_image_1)中的页面。您可以看到人员列表显示在左侧。页面突出显示所选人员并在右侧显示其详细信息。
- en: 'We’re going to modify our application to cope with an additional route at */people*.
    Then we will make the routes responsive so that the user will see different things
    on different devices:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改我们的应用程序以处理在*/people*路由上的附加路由。然后我们将使路由具有响应能力，以便用户在不同设备上看到不同的内容：
- en: '| Route | Mobile | Desktop |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 路由 | 移动设备 | 桌面 |'
- en: '| --- | --- | --- |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| /people | Shows list of people | Redirects to *people*:someId |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| /people | 显示人员列表 | 重定向到*people*:someId |'
- en: '| *people*:id | Shows details for :id | Shows list of people and details of
    :id |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| *people*:id | 显示:id的详细信息 | 显示人员列表和:id的详细信息 |'
- en: 'What ingredients will we need to do this? First, we need to install `react-router-dom`
    if our application does not already have it:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要哪些要素来实现这一点？首先，如果我们的应用程序尚未安装，我们需要安装`react-router-dom`：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `react-router-dom` library allows us to coordinate the browser’s current
    location with the state of our application. Next, we will install the `react-media`
    library, which allows us to create React components that respond to changes in
    the display screen size:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`react-router-dom` 库允许我们将浏览器当前位置与应用程序的状态协调一致。接下来，我们将安装 `react-media` 库，这样我们就可以创建响应式的
    React 组件，以响应显示屏尺寸的变化：'
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now we’re going to create a responsive `PeopleContainer` component that will
    manage the routes we want to create. On small screens, our component will display
    *either* a list of people or the details of a single person. On large screens,
    it will show a combined view of a list of people on the left and the details of
    a single person on the right.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建一个响应式的 `PeopleContainer` 组件，它将管理我们想要创建的路由。在小屏幕上，我们的组件将显示人员列表或单个人员的详细信息中的*一个*。在大屏幕上，它将显示左侧人员列表和右侧单个人员详细信息的组合视图。
- en: 'The `PeopleContainer` will use the `Media` component from `react-media`. The
    `Media` component performs a similar job to the CSS `@media` rule: it allows you
    to generate output for a specified range of screen sizes. The `Media` component
    accepts a `queries` property that allows you to specify a set of screen sizes.
    We’re going to define a single screen size—small—that we’ll use as the break between
    mobile and desktop screens:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`PeopleContainer` 将使用 `react-media` 中的 `Media` 组件。`Media` 组件的作用类似于 CSS 的 `@media`
    规则：它允许您生成适用于指定屏幕尺寸范围的输出。`Media` 组件接受一个 `queries` 属性，允许您指定一组屏幕尺寸。我们将定义一个单独的屏幕尺寸—`small`，它将用作移动和桌面屏幕之间的断点：'
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `Media` component takes a single child component, which it expects to be
    a function. This function is given a `size` object that can be used to tell what
    the current screen size is. In our example, the `size` object will have a `small`
    attribute, which we can use to decide what other components to display:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`Media` 组件接受一个子组件，期望它是一个函数。这个函数会传入一个 `size` 对象，用于获取当前屏幕尺寸信息。在我们的例子中，`size`
    对象会包含一个 `small` 属性，我们可以用它来决定显示哪些其他组件：'
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Before we look at the details of what code we are going to return for large
    and small screens, it’s worth taking a look at how we will mount the `PeopleContainer`
    in our application. The following code is going to be our main `App` component:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看返回的代码细节之前，我们需要看一下如何在应用程序中挂载 `PeopleContainer`。下面的代码将是我们的主要 `App` 组件：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We are using the `BrowserRouter` from `react-router-dom`, which links our code
    and the HTML5 history API in the browser. We need to wrap all of our routes in
    a `Router` to give them access to the browser’s current address.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用来自 `react-router-dom` 的 `BrowserRouter`，它将我们的代码与浏览器的 HTML5 历史记录 API 连接起来。我们需要将所有路由包装在
    `Router` 中，以便它们可以访问浏览器的当前地址。
- en: Inside the `BrowserRouter`, we have a `Switch`. The `Switch` looks at the components
    inside it, looking for a `Route` that matches the current location. Here we have
    a single `Route` matching paths that begin with */people*. If that’s true, we
    display the `PeopleCon⁠tainer`. If no route matches, we fall through to the end
    of the `Switch` and render a `Link` to the */people* path. So when someone goes
    to the front page of the application, they see only a link to the `People` page.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `BrowserRouter` 内部，我们有一个 `Switch`。`Switch` 会查看内部的组件，寻找与当前位置匹配的 `Route`。这里有一个单独的
    `Route`，匹配路径以 */people* 开头。如果条件成立，我们展示 `PeopleContainer`。如果没有匹配的路由，我们会继续查看 `Switch`
    的末尾，并渲染一个指向 */people* 路径的 `Link`。所以，当有人访问应用程序的首页时，他们只会看到一个指向 `People` 页面的链接。
- en: The code will match routes beginning with the specified `path`, unless the `exact`
    attribute is specified, in which case a route will be displayed only if the entire
    path matches.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将匹配以指定 `path` 开头的路由，除非指定了 `exact` 属性，在这种情况下，只有整个路径匹配时才会显示路由。
- en: 'So we know if we’re in the `PeopleContainer`, we’re already on a route that
    begins with */people/…*. If we’re on a small screen, we need to either show a
    list of people or display the details of a single person, but not both. We can
    do this with `Switch`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们在 `PeopleContainer` 内部，我们已经在以 */people/…* 开头的路径上。如果在小屏幕上，我们需要显示人员列表或显示单个人员的详细信息，但不能同时显示。我们可以使用
    `Switch` 来实现这一点：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: On a small device, the `Media` component will call its child function with a
    value that means `size.small` is `true`. Our code will render a `Switch` that
    will show a `Person` component if the current path contains an `id`. Otherwise,
    the `Switch` will fail to match that `Route` and will instead render a `PeopleList`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在小设备上，`Media`组件将使用一个值调用其子函数，该值表示`size.small`为`true`。我们的代码将渲染一个`Switch`，如果当前路径包含一个`id`，则显示`Person`组件。否则，`Switch`将无法匹配该`Route`，而是渲染一个`PeopleList`。
- en: Ignoring the fact that we’ve yet to write the code for large screens, if we
    were to run this code right now on a mobile device and hit the `People` link on
    the front page, we would navigate to *people*, which could cause the application
    to render the `PeopleList` component. The `PeopleList` component displays a set
    of links to people with paths of the form */people/id*.^([1](ch02.xhtml#idm46634431789304))
    When someone selects a person from the list, our components are re-rendered, and
    this time `PeopleContainer` displays the details of a single person (see [Figure 2-2](#ch02_image_2)).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们还没有为大屏幕编写代码，如果我们现在在移动设备上运行此代码并点击首页的`People`链接，我们将导航至*people*，这可能会导致应用程序渲染`PeopleList`组件。`PeopleList`组件显示一组以*/people/id*形式的路径链接的人员。^([1](ch02.xhtml#idm46634431789304))
    当有人从列表中选择一个人时，我们的组件将重新渲染，这次`PeopleContainer`将显示单个人员的详细信息（参见[图 2-2](#ch02_image_2)）。
- en: '![](Images/recb_0202.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_0202.png)'
- en: 'Figure 2-2\. In mobile view: the list of people (left) that links to a person’s
    details (right)'
  id: totrans-39
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-2\. 在移动视图中：左侧的人员列表链接到右侧的个人详情
- en: 'So far, so good. Now we need to make sure that our application still works
    for larger screens. We need to generate responsive routes in `PeopleContainer`
    for when `size.small` is `false`. If the current route is of the form */people/id*,
    we can display the `PeopleList` component on the left and the `Person` component
    on the right:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 目前为止一切顺利。现在我们需要确保我们的应用程序仍然适用于大屏幕。我们需要在`PeopleContainer`中生成响应式路由，以便当`size.small`为`false`时，如果当前路由形式为*/people/id*，我们可以在左侧显示`PeopleList`组件，在右侧显示`Person`组件：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Unfortunately, that doesn’t handle the case where the current path is */people*.
    We need another `Switch` that either will display the details for a single person
    or will *redirect* to */people/first-person-id* for the first person in the list
    of people.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这并不能处理当前路径为*/people*的情况。我们需要另一个`Switch`，要么显示单个人员的详细信息，要么将重定向到列表中第一个人员的*/people/first-person-id*。
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `Redirect` component doesn’t perform an *actual* browser redirect. It simply
    updates the current path to */people/first-person-id*, which causes the `PeopleContainer`
    to re-render. It’s similar to making a call to `history.push()` in JavaScript,
    except it doesn’t add an extra page to the browser history. If a person navigates
    to */people*, the browser will simply change its location to */people/first-person-id*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`Redirect`组件并不执行*实际*的浏览器重定向。它只是更新当前路径为*/people/first-person-id*，这会导致`PeopleContainer`重新渲染。这类似于在JavaScript中调用`history.push()`，但它不会在浏览器历史记录中添加额外页面。如果一个人导航至*/people*，浏览器将简单地将其位置更改为*/people/first-person-id*。'
- en: If we were now to go to */people* on a laptop or larger tablet, we would see
    the list of people next to the details for the first person ([Figure 2-3](#ch02_image_3)).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在在笔记本电脑或更大的平板电脑上转到*/people*，我们将看到人员列表旁边的第一个人员的详细信息（[图 2-3](#ch02_image_3)）。
- en: '![](Images/recb_0203.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_0203.png)'
- en: Figure 2-3\. What you see at http://localhost:3000/people on a large display
  id: totrans-47
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-3\. 在大屏幕上查看 http://localhost:3000/people 时看到的内容
- en: 'Here is the final version of our `PeopleContainer`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`PeopleContainer`的最终版本：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Discussion
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Declarative routing inside components can seem an odd thing when you first meet
    it. Suppose you’ve used a centralized routing model before. In that case, declarative
    routes may at first seem messy because they spread the wiring of your application
    across several components rather than in a single file. Instead of creating clean
    components that know nothing of the outside world, you are suddenly giving the
    intimate knowledge of the paths used in the application, which might make them
    less portable.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件内部声明式路由可能在初次接触时显得奇怪。假设您以前使用过集中式路由模型。在这种情况下，声明式路由可能一开始看起来很混乱，因为它们将应用程序的连接分布在多个组件中，而不是在单个文件中。而不是创建干净的组件，这些组件对外界一无所知，突然之间您需要给出应用程序中使用的路径的详细知识，这可能会使它们不太便携。
- en: 'However, responsive routes show the real power of declarative routing. If you’re
    concerned about your components knowing too much about the paths in your application,
    consider extracting the path strings into a shared file. That way, you will have
    the best of both worlds: components that modify their behavior based upon the
    current path and a centralized set of path configurations.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，响应式路由展示了声明式路由的真正威力。如果您担心您的组件对应用程序中的路径了解过多，请考虑将路径字符串提取到一个共享文件中。这样，您既可以根据当前路径修改组件行为，又可以有一个集中的路径配置。
- en: You can download the source for this recipe from the [GitHub site](https://oreil.ly/tZzMD).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[GitHub网站](https://oreil.ly/tZzMD)下载此示例的源代码。
- en: Move State into Routes
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将状态移入路由
- en: Problem
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: 'It is often helpful to manage the internal state of a component using the route
    that displays it. For example, this is a React component that displays two tabs
    of information: one for */people* and one for */offices*:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用显示它的路由来管理组件的内部状态通常很有帮助。例如，这是一个显示两个信息选项卡的React组件：一个用于*/people*，一个用于*/offices*：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When a user clicks a tab, an internal `tabId` variable is updated, and the `People`
    or `Offices` component is displayed (see [Figure 2-4](#ch02_image_4)).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击选项卡时，内部的`tabId`变量会更新，并显示`People`或`Offices`组件（参见[图2-4](#ch02_image_4)）。
- en: '![](Images/recb_0204.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_0204.png)'
- en: Figure 2-4\. By default, the OldAbout component shows people’s details
  id: totrans-60
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-4。默认情况下，OldAbout组件显示人员的详细信息
- en: What’s the problem? The component works, but if we select the Offices tab and
    then refresh the page, the component resets to the People tab. Likewise, we can’t
    bookmark the page when it’s on the Offices tab. We can’t create a link anywhere
    else in the application, which takes us directly to Offices. Accessibility hardware
    is less likely to notice that the tabs are working as hyperlinks because they
    are not rendered in that way.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在哪里？组件是有效的，但如果我们选择Offices选项卡然后刷新页面，组件将重置为People选项卡。同样地，当页面在Offices选项卡上时，我们无法将其作为书签保存。我们无法在应用程序的其他位置创建直接导航到Offices的链接。辅助功能硬件可能不会注意到选项卡作为超链接的工作方式，因为它们没有以那种方式呈现。
- en: Solution
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: We are going to move the `tabId` state from the component into the current browser
    location. So instead of rendering the component at */about* and then using `onClick`
    events to change the internal state, we are instead going to have routes to */about/people*
    and */about/offices*, which display one tab or the other. The tab selection will
    survive a browser refresh. We can bookmark the page on a given tab or create a
    link to a given tab. And we make the tabs actual hyperlinks, which will be recognized
    as such by anyone navigating with a keyboard or screen reader.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从组件中移动`tabId`状态到当前浏览器位置。因此，不再在*/about*路径渲染组件，然后使用`onClick`事件来改变内部状态，而是将路由设置为*/about/people*和*/about/offices*，显示其中一个选项卡。选项卡选择将在浏览器刷新时保留。我们可以将页面上的特定选项卡书签保存或创建链接到特定选项卡。并且我们将选项卡实际作为超链接，这样键盘或屏幕阅读器导航的人就会认识到它们。
- en: 'What ingredients do we need? Just one: `react-router-dom`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要哪些成分？只需一个：`react-router-dom`：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`react-router-dom` will allow us to synchronize the current browser URL with
    the components that we render on the screen.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`react-router-dom`将允许我们将当前浏览器的URL与我们在屏幕上呈现的组件同步。'
- en: 'Our existing application is already using `react-router-dom` to display the
    `OldAbout` component at path */oldabout* as you can see from this fragment of
    code from the *App.js* file:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现有的应用程序已经使用`react-router-dom`在路径*/oldabout*显示`OldAbout`组件，如您可以从*App.js*文件的这段代码片段中看到的那样：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can see the complete code for this file at the [GitHub repository](https://oreil.ly/WmZ18).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[GitHub存储库](https://oreil.ly/WmZ18)中查看此文件的完整代码。
- en: 'We’re going to create a new version of the `OldAbout` component called `About`,
    and we’re going to mount it at its own route:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为`About`的`OldAbout`组件的新版本，并将其挂载到自己的路由上：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This addition allows us to open both versions of the code in the example application.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此添加允许我们在示例应用程序中打开两个版本的代码。
- en: Our new version is going to appear to be virtually identical to the old component.
    We’ll extract the `tabId` from the component and move it into the current path.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新版本看起来几乎与旧组件相同。我们将`tabId`从组件中提取出来，并移入当前路径。
- en: Setting the path of the `Route` to */about/:tabId?* means that */about*, */about/offices*,
    and */about/people* will all mount our component. The `?` indicates that the `tabId`
    parameter is optional.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `Route` 的路径设置为 */about/:tabId?* 意味着 */about*、*/about/offices* 和 */about/people*
    都将装载我们的组件。`?` 表示 `tabId` 参数是可选的。
- en: 'We’ve now done the first part: we’ve put the component’s state into the path
    that displays it. We now need to update the component to interact with the route
    rather than an internal state variable.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了第一部分：我们已经将组件的状态放入了显示它的路径中。现在我们需要更新组件，使其与路由交互，而不是与内部状态变量交互。
- en: 'In the `OldAbout` component, we had `onClick` listeners on each of the tabs:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `OldAbout` 组件中，我们在每个选项卡上都有 `onClick` 监听器：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We’re going to convert these into `Link` components, going to */about/people*
    and */about/offices*. In fact, we’re going to convert them into `NavLink` components.
    A `NavLink` is like a link, except it has the ability to set an additional class
    name, if the place it’s linking to is the current location. This means we don’t
    need the `className` logic in the original code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这些转换为 `Link` 组件，转到 */about/people* 和 */about/offices*。事实上，我们将它们转换为 `NavLink`
    组件。`NavLink` 就像一个链接，但是它有能力在其链接的位置是当前位置时设置额外的类名。这意味着我们不需要原始代码中的 `className` 逻辑：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We no longer set the value of a `tabId` variable. We instead go to a new location
    with a new `tabId` value in the path.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再设置 `tabId` 变量的值。我们改为在路径中跳转到新位置，并带有新的 `tabId` 值。
- en: 'But what do we do to read the `tabId` value? The `OldAbout` code displays the
    current tab contents like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们该如何读取 `tabId` 的值呢？`OldAbout` 代码像这样显示当前选项卡内容：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This code can be replaced with a `Switch` and a couple of `Route` components:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以替换为一个 `Switch` 和几个 `Route` 组件：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We’re now *almost* finished. There’s just one step remaining: deciding what
    to do if the path is */about* and contains no `tabId`.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在*几乎*完成了。只剩下一步：如果路径是 */about* 且不包含 `tabId`，我们该如何决定。
- en: 'The `OldAbout` sets a default value for `tabId` when it first creates the state:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`OldAbout` 在首次创建状态时为 `tabId` 设置了默认值：'
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can achieve the same effect by adding a `Redirect` to the end of our `Switch`.
    The `Switch` will process its child components in order until it finds a matching
    `Route`. If no `Route` matches the current path, it will reach the `Redirect`,
    which will change the address to */about/people*. This will cause a re-render
    of the `About` component, and the People tab will be selected by default:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在 `Switch` 结尾添加一个 `Redirect` 来实现相同的效果。`Switch` 会按顺序处理其子组件，直到找到匹配的 `Route`。如果当前路径没有匹配的
    `Route`，它将达到 `Redirect`，这将把地址更改为 */about/people*。这将导致 `About` 组件重新渲染，并且默认选择 People
    标签：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can make `Redirect` conditional on the current path by giving it a `from`
    attribute. In this case, we could set `from` to `/about` so that only routes matching
    `/about` are redirected to `/about/people`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过为 `Redirect` 提供一个 `from` 属性来使其在当前路径上有条件地执行。在这种情况下，我们可以将 `from` 设置为 `/about`，这样只有匹配
    `/about` 的路由才会被重定向到 `/about/people`。
- en: 'This is our completed `About` component:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们完成的 `About` 组件：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We no longer need an internal `tabId` variable, and we now have a purely declarative
    component (see [Figure 2-5](#ch02_image_5)).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再需要内部的 `tabId` 变量，现在我们有一个纯声明的组件（参见[图 2-5](#ch02_image_5)）。
- en: '![](Images/recb_0205.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_0205.png)'
- en: Figure 2-5\. Going to http://localhost/about/offices with the new component
  id: totrans-95
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-5\. 使用新组件访问 http://localhost/about/offices
- en: Discussion
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Moving state out of your components and into the address bar can simplify your
    code, but this is merely a fortunate side effect. The real value is that your
    application starts to behave less like an application and more like a website.
    We can bookmark pages, and the browser’s Back and Forward buttons work correctly.
    Managing more state in routes is not an abstract design decision; it’s a way of
    making your application less surprising to users.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 将状态从组件移至地址栏可能会简化您的代码，但这只是一个幸运的副作用。真正的价值在于，您的应用程序开始表现得不像应用程序，而更像一个网站。我们可以书签页，并且浏览器的“后退”和“前进”按钮能正常工作。在路由中管理更多状态不是抽象的设计决策；这是使您的应用程序对用户来说不那么令人惊讶的一种方式。
- en: You can download the source for this recipe from the [GitHub site](https://oreil.ly/myAGj).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 [GitHub 站点](https://oreil.ly/myAGj) 下载此示例的源代码。
- en: Use MemoryRouter for Unit Testing
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用 MemoryRouter 进行单元测试
- en: Problem
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: We use routes in React applications so that we make more of the facilities of
    the browser. We can bookmark pages, create deep links into an app, and go backward
    and forward in history.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在React应用程序中使用路由，以便更好地利用浏览器的功能。我们可以收藏页面，创建应用程序的深链接，并在历史记录中前进和后退。
- en: 'However, once we use routes, we make the component dependent upon something
    outside itself: the browser location. That might not seem like too big an issue,
    but it does have consequences.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一旦我们使用路由，我们使组件依赖于其外部的某些东西：浏览器位置。这可能看起来不是太大的问题，但它确实有后果。
- en: Let’s say we want to unit test a route-aware component. As an example, let’s
    create a unit test for the `About` component we built in [“Move State into Routes”](#ch02-02):^([2](ch02.xhtml#idm46634430499464))
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要对一个路由感知的组件进行单元测试。例如，让我们为我们在[“将状态移到路由”](#ch02-02)中构建的`About`组件创建一个单元测试：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This unit test renders the component and then checks that it can find the name
    “Kip Russel” appearing in the output. When we run this test, we get the following
    error:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单元测试渲染组件，然后检查它是否能在输出中找到“Kip Russel”这个名字。当我们运行这个测试时，我们得到以下错误：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The error occurred because a `NavLink` could not find a `Router` higher in the
    component tree. That means we need to wrap the component in a `Router` before
    we test it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 错误发生是因为`NavLink`找不到组件树中更高级别的`Router`。这意味着我们需要在测试之前将组件包装在`Router`中。
- en: Also, we might want to write a unit test that checks that the `About` component
    works when we mount it on a specific route. Even if we provide a `Router` component,
    how will we fake a particular route?
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我们可能希望编写一个单元测试，检查`About`组件在特定路由上挂载时的工作情况。即使我们提供一个`Router`组件，我们如何伪造一个特定的路由？
- en: It’s not just an issue with unit tests. If we’re using a library tool like Storybook,^([3](ch02.xhtml#idm46634430461864))
    we might want to show an example of how a component appears when we mount it on
    a given path.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅仅是单元测试的问题。如果我们使用像Storybook这样的库工具，我们可能希望展示一个组件在特定路径上挂载时的示例。
- en: We need something like an actual browser router but that allows us to specify
    its behavior.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要像实际浏览器路由器那样的东西，但允许我们指定其行为。
- en: Solution
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'The `react-router-dom` library provides just such a router: `MemoryRouter`.
    The `MemoryRouter` appears to the outside world just like `BrowserRouter`. The
    difference is that while the `BrowserRouter` is an interface to the underlying
    browser history API, the `MemoryRouter` has no such dependency. It can keep track
    of the current location, and it can go backward and forward in history, but it
    achieves this through simple memory structures.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`react-router-dom`库提供了这样一个路由器：`MemoryRouter`。`MemoryRouter`在外界看来与`BrowserRouter`一样。不同之处在于，虽然`BrowserRouter`是底层浏览器历史记录API的接口，但`MemoryRouter`没有这样的依赖。它可以跟踪当前位置，并可以在历史记录中前进和后退，但它通过简单的内存结构实现了这一点。'
- en: 'Let’s take another look at that failing unit test. Instead of just rendering
    the `About` component, let’s wrap it in a `MemoryRouter`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看看那个失败的单元测试。不只是渲染`About`组件，让我们把它包装在`MemoryRouter`中：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, when we run the test, it works. That’s because the `MemoryRouter` injects
    a mocked-up version of the API into the context. That makes it available to all
    of its child components. The `About` component can now render a `Link` or `Route`
    because the history is available.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行测试时，它可以工作了。这是因为`MemoryRouter`将一个模拟版本的API注入到上下文中。这使得它对所有子组件都可用。`About`组件现在可以呈现`Link`或`Route`，因为历史记录可用。
- en: 'But the `MemoryRouter` has an additional advantage. Because it’s faking the
    browser history API, it can be given a completely fake history, using the `initialEntries`
    property. The `initialEntries` property should be set to an array of history entries.
    If you pass a single value array, it will be interpreted as the current location.
    That allows you to write unit tests that check for component behavior when it’s
    mounted on a given route:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 但是`MemoryRouter`有一个额外的优势。因为它伪造了浏览器的历史记录API，它可以使用`initialEntries`属性提供完全虚假的历史记录。`initialEntries`属性应该设置为历史记录条目的数组。如果传递一个单值数组，它将被解释为当前位置。这使您能够编写单元测试，检查组件在给定路由上挂载时的行为：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We can use a real `BrowserRouter` inside Storybook because we’re in a real browser,
    but the `MemoryRouter` also allows us to fake the current location, as we do in
    the `ToAboutOffices` Storybook story (see [Figure 2-6](#ch02_image_6)).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Storybook中使用真实的`BrowserRouter`，因为我们在真实的浏览器中，但`MemoryRouter`也允许我们伪造当前位置，就像我们在`ToAboutOffices`
    Storybook故事中所做的那样（见[图 2-6](#ch02_image_6)）。
- en: '![](Images/recb_0206.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_0206.png)'
- en: Figure 2-6\. Using MemoryRouter, we can fake the /about/offices route
  id: totrans-120
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-6\. 使用 `MemoryRouter`，我们可以模拟 `/about/offices` 路由。
- en: Discussion
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Routers let you separate the details of *where* you want to go from *how* you’re
    going to get there. In this recipe, we see one advantage of this separation: we
    can create a fake browser location to examine component behavior on different
    routes. This separation allows you to change the way the application follows links
    without breaking. If you convert your SPA to an SSR application, you swap your
    `BrowserRouter` for a `StaticRouter`. The links used to make calls into the browser’s
    history API will become native hyperlinks that cause the browser to make native
    page loads. Routers are an excellent example of the advantages of splitting policy
    (what you want to do) from mechanisms (how you’re going to do it).'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器允许您将希望去哪里的详细信息与如何到达目的地分开。在这个示例中，我们看到了这种分离的一个优势：我们可以创建一个虚拟的浏览器位置来检查不同路由上组件的行为。这种分离允许您更改应用程序跟随链接的方式，而不会导致中断。如果将单页应用程序转换为服务器端渲染应用程序，可以将
    `BrowserRouter` 替换为 `StaticRouter`。用于调用浏览器历史 API 的链接将成为导致浏览器进行本机页面加载的本机超链接。路由器是分离策略（您想做什么）和机制（您将如何做到）优势的一个很好的例子。
- en: You can download the source for this recipe from the [GitHub site](https://oreil.ly/1NW8e).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 [GitHub 网站](https://oreil.ly/1NW8e) 下载此配方的源代码。
- en: Use Prompt for Page Exit Confirmations
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `Prompt` 进行页面退出确认
- en: Problem
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Sometimes you need to ask a user to confirm that they want to leave a page if
    they’re in the middle of editing something. This seemingly simple task can be
    complicated because it relies on spotting when the user clicks the Back button
    and then finding a way to intercept the move back through history and potentially
    canceling it (see [Figure 2-7](#ch02_image_7)).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，如果用户正在编辑某些内容，需要询问用户是否确认离开页面。这个看似简单的任务可能会很复杂，因为它依赖于识别用户何时点击“返回”按钮，然后找到拦截历史记录移动并可能取消其行为的方法（见[图 2-7](#ch02_image_7)）。
- en: '![](Images/recb_0207.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_0207.png)'
- en: Figure 2-7\. Asking for a confirmation before leaving
  id: totrans-128
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-7\. 离开前询问确认
- en: What if there are several pages in the application that need the same feature?
    Is there a simple way to create this feature across any component that needs it?
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序中有多个页面需要相同的功能，该如何简单地创建此功能以覆盖任何需要它的组件？
- en: Solution
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: The `react-router-dom` library includes a component called `Prompt`, which asks
    users to confirm that they want to leave a page.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`react-router-dom` 库包含一个名为 `Prompt` 的组件，用于要求用户确认是否离开页面。'
- en: 'The only ingredient we need for this recipe is the `react-router-dom` library
    itself:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此处我们唯一需要的配料是 `react-router-dom` 库本身：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let’s say we have a component called `Important` mounted at */important*, which
    allows a user to edit a piece of text:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个名为 `Important` 的组件，安装在 */important*，允许用户编辑一段文本：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`Important` is already tracking whether the text in the `textarea` has changed
    from the original value. If the text is different, the value of `dirty` is `true`.
    How do we ask the user to confirm they want to leave the page if they click the
    Back button when `dirty` is `true`?'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`Important` 已经在跟踪 `textarea` 中的文本是否与原始值不同。如果文本不同，`dirty` 的值为 `true`。当 `dirty`
    为 `true` 时，我们如何要求用户确认他们是否希望离开页面，如果他们点击“返回”按钮？'
- en: 'We add a `Prompt` component:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个 `Prompt` 组件：
- en: '[PRE26]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If the user edits the text and then hits the Back button, the `Prompt` appears
    (see [Figure 2-8](#ch02_image_8)).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户编辑文本，然后点击“返回”按钮，将显示 `Prompt`（见[图 2-8](#ch02_image_8)）。
- en: '![](Images/recb_0207.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_0207.png)'
- en: Figure 2-8\. The `Prompt` asks the user to confirm they want to leave
  id: totrans-141
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-8\. `Prompt` 要求用户确认他们希望离开
- en: Adding the confirmation is easy, but the default prompt interface is a simple
    JavaScript dialog. It would be helpful to decide for ourselves how we want the
    user to confirm they’re leaving.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 添加确认信息很容易，但默认的提示界面是一个简单的 JavaScript 对话框。我们希望能够自行决定用户确认离开页面的方式。
- en: 'To demonstrate how we can do this, let’s add the Material-UI component library
    to the application:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示我们如何做到这一点，让我们将 Material-UI 组件库添加到应用程序中：
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The Material-UI library is a React implementation of Google’s Material Design
    standard. We’ll use it as an example of how to replace the standard `Prompt` interface
    with something more customized.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Material-UI 库是 Google Material Design 标准的 React 实现。我们将使用它作为一个示例，说明如何用更定制化的内容替换标准的
    `Prompt` 界面。
- en: The `Prompt` component does not render any UI. Instead, the `Prompt` component
    asks the current `Router` to show the confirmation. By default, `BrowserRouter`
    shows the default JavaScript dialog, but you can replace this with your own code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`Prompt`组件不会呈现任何UI。相反，`Prompt`组件请求当前的`Router`显示确认对话框。默认情况下，`BrowserRouter`显示默认的JavaScript对话框，但可以用自己的代码替换它。'
- en: 'When the `BrowserRouter` is added to the component tree, we can pass it a property
    called `getUserConfirmation`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 将`BrowserRouter`添加到组件树中后，我们可以传递一个名为`getUserConfirmation`的属性：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `getUserConfirmation` property is a function that accepts two parameters:
    the message it should display and a callback function.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`getUserConfirmation`属性是一个接受两个参数的函数：要显示的消息和一个回调函数。'
- en: When the user clicks the Back button, the `Prompt` component will run `getUserCon⁠firmation`
    and then wait for the callback function to be called with the value `true` or
    `false`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户单击“返回”按钮时，`Prompt`组件将运行`getUserCon⁠firmation`，然后等待回调函数被调用，参数为`true`或`false`。
- en: The callback function returns the user’s response asynchronously. The `Prompt`
    component will wait while we ask the user what they want to do. That allows us
    to create a custom interface.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数以异步方式返回用户的响应。`Prompt`组件会等待我们询问用户想要做什么。这使我们能够创建一个自定义界面。
- en: 'Let’s create a custom Material-UI dialog called `Alert`. We’ll show this instead
    of the default JavaScript modal:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`Alert`的自定义Material-UI对话框。我们将使用这个对话框代替默认的JavaScript模态框：
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Of course, there is no reason why we need to display a dialog. We could show
    a countdown timer or a snackbar message or automatically save the user’s changes.
    But we will display a custom `Alert` dialog.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们没有必要显示对话框。我们可以显示倒计时器或者Snackbar消息，或者自动保存用户的更改。但我们将显示一个自定义的`Alert`对话框。
- en: 'How will we use the `Alert` component in our interface? The first thing we’ll
    need to do is create our own `getUserConfirmation` function. We’ll store the message
    and the callback function and then set a Boolean value saying that we want to
    open the `Alert` dialog:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将如何在界面中使用`Alert`组件？首先，我们需要创建自己的`getUserConfirmation`函数。我们将存储消息和回调函数，然后设置一个布尔值，表示我们要打开`Alert`对话框：
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: It’s worth noting that when we store the callback function, we use `setConfirmCallback(()
    => callback)` instead of simply writing `setConfirmCallback(callback)`. That’s
    because the setters returned by the `useState` hook will execute any function
    passed to them, rather than store them.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，当我们存储回调函数时，我们使用`setConfirmCallback(() => callback)`而不是简单地写`setConfirmCallback(callback)`。这是因为`useState`钩子返回的设置器将执行传递给它们的任何函数，而不是仅仅存储它们。
- en: We can then use the values of `confirmMessage`, `confirmCallback`, and `confirmOpen`
    to render the `Alert` in the interface.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用`confirmMessage`、`confirmCallback`和`confirmOpen`的值来渲染界面中的`Alert`。
- en: 'This is the complete *App.js* file:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完整的*App.js*文件：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now when a user backs out of an edit, they see the custom dialog, as shown in
    [Figure 2-9](#ch02_image_9).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当用户退出编辑时，他们会看到自定义对话框，如[图 2-9](#ch02_image_9)所示。
- en: '![](Images/recb_0209.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_0209.png)'
- en: Figure 2-9\. The custom Alert appears when the user clicks the Back button
  id: totrans-163
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-9\. 当用户单击“返回”按钮时，自定义警报框将出现
- en: Discussion
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'In this recipe, we have re-implemented the `Prompt` modal using a component
    library, but you don’t need to be limited to just replacing one dialog box with
    another. There is no reason why, if someone leaves a page, that you couldn’t do
    something else: such as store the work-in-progress somewhere so that they could
    return to it later. The asynchronous nature of the `getUserConfirmation` function
    allows this flexibility. It’s another example of how `react-router-dom` abstracts
    away a cross-cutting concern.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用组件库重新实现了`Prompt`模态框，但你不必仅仅将一个对话框替换为另一个对话框。如果有人离开页面，你完全可以做其他的事情：比如将工作进度保存在某个地方，以便稍后返回。`getUserConfirmation`函数的异步特性允许这种灵活性。这是`react-router-dom`如何抽象出横切关注点的另一个例子。
- en: You can download the source for this recipe from the [GitHub site](https://oreil.ly/1FyoE).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[GitHub网站](https://oreil.ly/1FyoE)下载此示例的源代码。
- en: Create Transitions with React Transition Group
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React Transition Group创建过渡效果
- en: Problem
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Native and desktop applications often use animation to connect different elements
    visually. If you tap an item in a list, it expands to show you the details. Swiping
    left or right can be used to indicate whether a user accepts or rejects an option.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 原生和桌面应用程序通常使用动画来在视觉上连接不同的元素。如果您点击列表中的一个项目，它会展开以显示详细信息。左右滑动可以用来指示用户接受或拒绝一个选项。
- en: Animations, therefore, are often used to indicate a location change. They zoom
    in on the details. They take you to the next person on the list. We reflect a
    change in the URL with a matching animation.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，动画通常用于指示位置变化。它们放大细节。它们带你去列表中的下一个人。我们用匹配的动画反映了URL的变化。
- en: But how do we create an animation when we move from one location to another?
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当我们从一个位置移动到另一个位置时，如何创建动画呢？
- en: Solution
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'For this recipe, we’re going to need the `react-router-dom` library and the
    `react-transition-group` library:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将需要`react-router-dom`库和`react-transition-group`库：
- en: '[PRE32]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We’re going to animate the `About` component that we’ve used previously.^([4](ch02.xhtml#idm46634429149288))
    The `About` component has two tabs called People and Offices, which are displayed
    for the routes */about/people* and */about/offices*.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对我们先前使用的`About`组件进行动画化处理。^([4](ch02.xhtml#idm46634429149288)) `About`组件有两个称为People和Offices的选项卡，它们分别显示在*/about/people*和*/about/offices*路由上。
- en: When someone clicks one of the tabs, we’re going to fade out the old tab’s content
    and then fade in the content of the new tab. Although we’re using a fade, there’s
    no reason why we couldn’t use a more complex animation, such as sliding the tab
    contents left or right.^([5](ch02.xhtml#idm46634429145480)) However, a simple
    fade animation will more clearly demonstrate how it works.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当有人点击其中一个选项卡时，我们将淡出旧选项卡的内容，然后淡入新选项卡的内容。虽然我们使用了淡出效果，但我们也可以使用更复杂的动画，比如将选项卡内容向左或向右滑动。^([5](ch02.xhtml#idm46634429145480))
    然而，简单的淡入淡出动画将更清楚地展示其工作原理。
- en: 'Inside the `About` component, the tab contents are rendered by `People` and
    `Offices` components within distinct routes:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在`About`组件内部，选项卡内容由`People`和`Offices`组件在不同的路由内呈现：
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We need to animate the components inside the `Switch` component. We’ll need
    two things to do this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为`Switch`组件内部的组件添加动画效果。为此，我们需要两样东西：
- en: Something to track when the location has changed
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些事情需要跟踪位置何时发生了变化
- en: Something to animate the tab contents when that happens
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些事情需要在选项卡内容发生变化时进行动画处理
- en: 'How do we know when the location has changed? We can get the current location
    from the `useLocation` hook from `react-router-dom`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何知道位置何时发生了变化？我们可以从`react-router-dom`的`useLocation`钩子中获取当前位置：
- en: '[PRE34]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now on to the more complex task: the animation itself. What follows is quite
    a complex sequence of events, but taking time to understand it is worth it.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在进入更复杂的任务：动画本身。接下来是一系列相当复杂的事件，但花时间理解它是值得的。
- en: When we are animating from one component to another, we need to keep both components
    on the page. As the `Offices` component fades out, the `People` component fades
    in.^([6](ch02.xhtml#idm46634428965384)) We can do this by keeping both components
    in a *transition group*. A transition group is a set of components, some of which
    are appearing and others are disappearing.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从一个组件动画到另一个组件时，我们需要保持页面上的两个组件。随着`Offices`组件的淡出，`People`组件淡入。^([6](ch02.xhtml#idm46634428965384))
    我们可以通过将这两个组件放在*转换组*中来实现这一点。转换组是一组组件，其中一些出现，而其他一些消失。
- en: We can create a transition group by wrapping our animation in a `TransitionGroup`
    component. We also need a `CSSTransition` component to coordinate the details
    of the CSS animation.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将我们的动画包裹在`TransitionGroup`组件中来创建一个过渡组。我们还需要一个`CSSTransition`组件来协调CSS动画的细节。
- en: 'Our updated code wraps the `Switch` in both a `TransitionGroup` and a `CSSTransition`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更新的代码将`Switch`同时包裹在`TransitionGroup`和`CSSTransition`中：
- en: '[PRE35]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Notice that we pass the `location.key` to the `key` of the `CSSTransition`
    group, and we pass the `location` to the `Switch` component. The `location.key`
    is a hash value of the current location. Passing the `location.key` to the transition
    group will keep the `CSSTransition` in the virtual DOM until the animation is
    complete. When the user clicks one of the tabs, the location changes, which refreshes
    the `About` component. The `TransitionGroup` will keep the existing `CSSTransition`
    in the tree of components until its timeout occurs: in 500 milliseconds. But it
    will now also have a second `CSSTransition` component.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们将 `location.key` 传递给 `CSSTransition` 组的 `key`，并将 `location` 传递给 `Switch`
    组件。`location.key` 是当前位置的哈希值。将 `location.key` 传递给过渡组件将使 `CSSTransition` 在动画完成之前保持在虚拟
    DOM 中。当用户点击其中一个标签时，位置会发生变化，这将刷新 `About` 组件。`TransitionGroup` 将在组件树中保留现有的 `CSSTransition`
    直到其超时结束：即 500 毫秒。但现在它还会有第二个 `CSSTransition` 组件。
- en: Each of these `CSSTransition` components will keep their child components alive
    (see [Figure 2-10](#ch02_image_10)).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `CSSTransition` 组件都将保持其子组件的活动状态（见[图 2-10](#ch02_image_10)）。
- en: '![](Images/recb_0210.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_0210.png)'
- en: Figure 2-10\. The TransitionGroup keeps both the old and new components in the
    virtual DOM
  id: totrans-192
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-10\. 过渡组件在虚拟 DOM 中保留了旧组件和新组件
- en: 'We need to pass the `location` value to the `Switch` components: we need the
    `Switch` for the old tab, and we need the `Switch` for the new tab to keep rendering
    their routes.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将 `location` 值传递给 `Switch` 组件：我们需要旧标签页的 `Switch`，并且我们需要新标签页的 `Switch` 来持续渲染它们的路由。
- en: So now, on to the animation itself. The `CSSTransition` component accepts a
    property called `classNames`, which we have set to the value `fade`. Note that
    `classNames` is a plural to distinguish it from the standard `className` attribute.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看动画本身。`CSSTransition` 组件接受一个名为 `classNames` 的属性，我们将其设置为值 `fade`。请注意，`classNames`
    是复数形式，以区分它与标准的 `className` 属性。
- en: '`CSSTransition` will use `classNames` to generate four distinct class names:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`CSSTransition` 将使用 `classNames` 生成四个不同的类名：'
- en: '`fade-enter`'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fade-enter`'
- en: '`fade-enter-active`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fade-enter-active`'
- en: '`fade-exit`'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fade-exit`'
- en: '`fade-exit-active`'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fade-exit-active`'
- en: The `fade-enter` class is for components that are about to start to animate
    into view. The `fade-enter-active` class is applied to components that are actually
    animating. `fade-exit` and `fade-exit-active` are for components that are beginning
    or animating their disappearance.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`fade-enter` 类用于即将开始动画进入视图的组件。`fade-enter-active` 类应用于实际动画中的组件。`fade-exit`
    和 `fade-exit-active` 用于即将开始或正在消失动画中的组件。'
- en: The `CSSTransition` component will add these class names to their immediate
    children. If we are animating from the Offices tab to the People tab, then the
    old `CSSTransition` will add the `fade-enter-active` class to the `People` HTML
    and will add the `fade-exit-active` to the `Offices` HTML.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`CSSTransition` 组件将这些类名添加到其直接子元素。如果我们从 Offices 标签页到 People 标签页进行动画处理，那么旧的 `CSSTransition`
    将在 `People` HTML 中添加 `fade-enter-active` 类，并在 `Offices` HTML 中添加 `fade-exit-active`
    类。'
- en: 'All that’s left to do is define the CSS animations themselves:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的事情就是定义 CSS 动画本身：
- en: '[PRE36]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `fade-enter-` classes use CSS transitions to change the opacity of the component
    from 0 to 1\. The `fade-exit-` classes animate the opacity from 1 back to 0\.
    It’s generally a good idea to keep the animation class definitions in a separate
    CSS file. That way, we can reuse them for other animations.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`fade-enter-` 类使用 CSS 过渡效果将组件的不透明度从 0 变为 1\. `fade-exit-` 类将组件的不透明度从 1 变为 0\.
    通常建议将动画类定义放在单独的 CSS 文件中。这样，我们可以在其他动画中重用它们。'
- en: The animation is complete. When the user clicks a tab, they see the contents
    cross-fade from the old data to the new data ([Figure 2-11](#ch02_image_11)).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 动画完成。当用户点击标签时，他们会看到内容从旧数据向新数据交叉淡出（见[图 2-11](#ch02_image_11)）。
- en: '![](Images/recb_0211.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_0211.png)'
- en: Figure 2-11\. The contents of the tab fade from offices to people
  id: totrans-207
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-11\. 标签页内容从 Offices 淡出到 People
- en: Discussion
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Animations can be pretty irritating when used poorly. Each animation you add
    should have some intent. If you find that you want to add an animation just because
    you think it will be attractive, you will almost certainly find users will dislike
    it. Generally, it is best to ask a few questions before adding an animation:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当动画使用不当时，它们可能非常恼人。每个添加的动画都应该有其意图。如果您只是因为认为它会很吸引人而添加动画，那么几乎可以肯定用户会不喜欢它。通常，在添加动画之前最好先问几个问题：
- en: Will this animation clarify the relationship between the two routes? Are you
    zooming in to see more detail or moving across to look at a related item?
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此动画是否会澄清两个路由之间的关系？您是放大以查看更多细节，还是横向移动以查看相关项目？
- en: How short should the animation be? Any longer than half a second is probably
    too much.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画的时长应该多长？超过半秒可能太长了。
- en: What is the impact on performance? CSS transitions usually have minimal effect
    if the browser hands the work off to the GPU. But what happens in an old browser
    on a mobile device?
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能会受到什么影响？如果浏览器将工作交给 GPU 处理，CSS 过渡通常影响很小。但在旧浏览器和移动设备上会发生什么？
- en: You can download the source for this recipe from the [GitHub site](https://oreil.ly/UCu75).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 [GitHub 网站](https://oreil.ly/UCu75) 下载此示例的源代码。
- en: Create Secured Routes
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建安全路由
- en: Problem
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Most applications need to prevent access to particular routes until a person
    logs in. But how do you secure some routes and not others? Is it possible to separate
    the security mechanisms from the user interface elements for logging in and logging
    out? And how do you do it without writing a vast amount of code?
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序需要阻止访问特定路由，直到某人登录。但如何保护某些路由而不是其他路由？是否可以将安全机制与用于登录和退出登录的用户界面元素分离？而且如何在不编写大量代码的情况下实现？
- en: Solution
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Let’s look at one way to implement route-based security in a React application.
    This application contains a home page (/), it has a public page with no security
    (*/public*), and it also has two private pages (*/private1* and */private2*) that
    we need to secure:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在 React 应用程序中实现基于路由的安全性的一种方法。此应用程序包含一个主页（/），一个没有安全性的公共页面（*/public*），以及两个私密页面（*/private1*
    和 */private2*）需要我们保护：
- en: '[PRE37]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We’re going to build the security system using a context. A context is where
    data can be stored by a component and made available to the component’s children.
    A `BrowserRouter` uses a context to pass routing information to the `Route` components
    within it.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用上下文构建安全系统。上下文是组件可以存储数据并使其可用于子组件的地方。`BrowserRouter` 使用上下文将路由信息传递给其内部的 `Route`
    组件。
- en: 'We’re going to create a custom context called `SecurityContext`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为 `SecurityContext` 的自定义上下文：
- en: '[PRE38]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The default value of our context is an empty object. We need something that
    will add functions into the context for logging in and logging out. We’ll do that
    by creating a `SecurityProvider`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文的默认值是一个空对象。我们需要一些东西将登录和注销函数添加到上下文中。我们将通过创建一个 `SecurityProvider` 来实现：
- en: '[PRE39]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The code would be very different in a real system. You would probably create
    a component that logged in and logged out using a web service or third-party security
    system. But in our example, the `SecurityProvider` keeps track of whether we have
    logged in using a simple `loggedIn` Boolean value. The `SecurityProvider` puts
    three things into the context:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际系统中，代码可能会有很大不同。您可能会创建一个组件，该组件使用 web 服务或第三方安全系统进行登录和注销。但在我们的示例中，`SecurityProvider`
    使用简单的 `loggedIn` 布尔值来跟踪我们是否已登录。`SecurityProvider` 将三件事放入上下文中：
- en: A function for logging in (`login`)
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于登录的函数（`login`）
- en: A function for logging out (`logout`)
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于注销的函数（`logout`）
- en: A Boolean value saying whether we have logged in or out (`loggedIn`)
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个布尔值，表示我们是否已登录或退出（`loggedIn`）
- en: 'These three things will be available to any components placed inside a `SecurityPro⁠vider`
    component. To allow any component inside a `SecurityProvider` to access these
    functions, we’ll add a custom hook called `useSecurity`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这三件事将对放置在 `SecurityProvider` 组件内的任何组件可用。为了允许 `SecurityProvider` 内的任何组件访问这些函数，我们将添加一个名为
    `useSecurity` 的自定义钩子：
- en: '[PRE40]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now that we have a `SecurityProvider`, we need to use it to secure a subset
    of the routes. We’ll create another component, called `SecureRoute`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了 `SecurityProvider`，我们需要使用它来保护一部分路由。我们将创建另一个名为 `SecureRoute` 的组件：
- en: '[PRE41]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `SecureRoute` component gets the current `loggedIn` status from the `SecurityCon⁠text`
    (using the `useSecurity` hook), and if the user is logged in, it renders the contents
    of the route. If the user is not logged in, it displays a login form.^([7](ch02.xhtml#idm46634427920808))
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`SecureRoute` 组件从 `SecurityContext` 中获取当前的 `loggedIn` 状态（使用 `useSecurity` 钩子），如果用户已登录，则呈现路由内容。如果用户未登录，则显示登录表单。^([7](ch02.xhtml#idm46634427920808))'
- en: The `LoginForm` calls the `login` function, which—if successful—will re-render
    the `SecureRoute` and then show the secured data.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoginForm` 调用 `login` 函数，如果成功，则重新渲染 `SecureRoute`，然后显示安全数据。'
- en: 'How do we use all of these new components? Here is an updated version of the
    *App.js* file:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如何使用所有这些新组件？这里是*App.js*文件的更新版本：
- en: '[PRE42]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `SecurityProvider` wraps our whole routing system, making `login()`, `logout()`,
    and `loggedIn` available to each `SecureRoute`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`SecurityProvider`包裹了我们整个路由系统，使得`login()`、`logout()`和`loggedIn`对每个`SecureRoute`都可用。'
- en: You can see the application running in [Figure 2-12](#ch02_image_12).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[图 2-12](#ch02_image_12)中看到应用程序正在运行。
- en: '![](Images/recb_0212.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_0212.png)'
- en: Figure 2-12\. The home page has links to the other pages
  id: totrans-240
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-12\. 主页链接到其他页面
- en: If we click the *Public Page* link, the page appears (see [Figure 2-13](#ch02_image_13)).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击*公共页面*链接，页面会显示（见[图 2-13](#ch02_image_13)）。
- en: '![](Images/recb_0213.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_0213.png)'
- en: Figure 2-13\. The public page is available without logging in
  id: totrans-243
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-13\. 公共页面在未登录时可用
- en: But if we click *Private Page 1*, we’re presented with the login screen ([Figure 2-14](#ch02_image_14)).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们点击*私密页面 1*，将呈现登录屏幕（见[图 2-14](#ch02_image_14)）。
- en: '![](Images/recb_0214.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_0214.png)'
- en: Figure 2-14\. You need to log in before you can see Private Page 1
  id: totrans-246
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-14\. 您需要先登录才能查看私密页面 1
- en: If you log in with the username *fred* and password *password*, you will then
    see the private content (see [Figure 2-15](#ch02_image_15)).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用用户名*fred*和密码*password*登录，然后您将看到私密内容（见[图 2-15](#ch02_image_15)）。
- en: '![](Images/recb_0215.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/recb_0215.png)'
- en: Figure 2-15\. The content of Private Page 1 after login
  id: totrans-249
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-15\. 登录后的私密页面 1 的内容
- en: Discussion
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Real security is only ever provided by secured backend services. However, secured
    routes prevent a user from stumbling into a page that can’t read data from the
    server.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的安全性只能由安全的后端服务提供。然而，安全路由可以防止用户误入无法从服务器读取数据的页面。
- en: A better implementation of the `SecurityProvider` would defer to some third-party
    OAuth tool or other security services. But by splitting the `SecurityProvider`
    from the security UI (`Login` and `Logout`) and the main application, you can
    modify the security mechanisms over time without changing a lot of code in your
    application.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的`SecurityProvider`实现将委托给某些第三方OAuth工具或其他安全服务。但通过将`SecurityProvider`与安全UI（`Login`和`Logout`）及主应用程序分离，您可以随时间修改安全机制而不需大量更改应用程序中的代码。
- en: If you want to see how your components behave when people log in and out, you
    can always create a mocked version of the `SecurityProvider` for use in unit tests.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想看看组件在用户登录和退出时的行为，您可以在单元测试中创建`SecurityProvider`的模拟版本。
- en: You can download the source for this recipe from the [GitHub site](https://oreil.ly/Kut73).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[GitHub 网站](https://oreil.ly/Kut73)下载此配方的源代码。
- en: ^([1](ch02.xhtml#idm46634431789304-marker)) We won’t show the code for the `PeopleList`
    here, but it is available on [GitHub](https://oreil.ly/tZzMD).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch02.xhtml#idm46634431789304-marker)) 我们在这里不会展示`PeopleList`的代码，但它在[GitHub](https://oreil.ly/tZzMD)上是可用的。
- en: ^([2](ch02.xhtml#idm46634430499464-marker)) We are using the React Testing Library
    in this example.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch02.xhtml#idm46634430499464-marker)) 在这个例子中，我们使用了React测试库。
- en: ^([3](ch02.xhtml#idm46634430461864-marker)) See [“Use Storybook for Component
    Development”](ch01_split_000.xhtml#ch01-09).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch02.xhtml#idm46634430461864-marker)) 请参阅[“使用Storybook进行组件开发”](ch01_split_000.xhtml#ch01-09)。
- en: ^([4](ch02.xhtml#idm46634429149288-marker)) See Recipes [2.2](#ch02-02) and
    [2.3](#ch02-03).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch02.xhtml#idm46634429149288-marker)) 请参阅配方 [2.2](#ch02-02) 和 [2.3](#ch02-03)。
- en: ^([5](ch02.xhtml#idm46634429145480-marker)) This is a common feature of third-party
    tabbed components. The animation reinforces in the user’s mind that they are moving
    left and right through the tabs.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch02.xhtml#idm46634429145480-marker)) 这是第三方选项卡组件的常见特性。动画增强了用户的印象，他们在选项卡之间左右移动。
- en: ^([6](ch02.xhtml#idm46634428965384-marker)) The code uses relative positioning
    to place both components in the same position during the fade.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch02.xhtml#idm46634428965384-marker)) 该代码使用相对定位在淡出期间将两个组件放置在同一位置。
- en: ^([7](ch02.xhtml#idm46634427920808-marker)) We’ll omit the contents of the `Login`
    component here, but the code is available on the GitHub repository.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch02.xhtml#idm46634427920808-marker)) 我们将在此省略`Login`组件的内容，但代码可在GitHub存储库中找到。
