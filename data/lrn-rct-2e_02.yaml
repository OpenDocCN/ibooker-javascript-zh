- en: Chapter 2\. JavaScript for React
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章 JavaScript用于React
- en: 'Since its release in 1995, JavaScript has gone through many changes. At first,
    we used JavaScript to add interactive elements to web pages: button clicks, hover
    states, form validation, etc.. Later, JavaScript got more robust with DHTML and
    AJAX. Today, with Node.js, JavaScript has become a real software language that’s
    used to build full-stack applications. JavaScript is everywhere.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 自1995年发布以来，JavaScript经历了许多变化。起初，我们使用JavaScript为网页添加交互元素：按钮点击、悬停状态、表单验证等。后来，JavaScript通过DHTML和AJAX变得更加强大。如今，通过Node.js，JavaScript已经成为一种真正用于构建全栈应用程序的软件语言。JavaScript无处不在。
- en: JavaScript’s evolution has been guided by a group of individuals from companies
    that use JavaScript, browser vendors, and community leaders. The committee in
    charge of shepherding the changes to JavaScript over the years is the European
    Computer Manufacturers Association (ECMA). Changes to the language are community-driven,
    originating from proposals written by community members. Anyone [can submit a
    proposal](https://tc39.github.io/process-document) to the ECMA committee. The
    responsibility of the ECMA committee is to manage and prioritize these proposals
    to decide what’s included in each spec.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的演变由使用JavaScript的公司的个人、浏览器供应商和社区领导者组成的团体指导。负责在多年来引导JavaScript变更的委员会是欧洲计算机制造商协会（ECMA）。语言的变更是由社区驱动的，起源于由社区成员撰写的提案。任何人都可以向ECMA委员会提交提案。ECMA委员会的责任是管理和优先处理这些提案，决定每个规范包含什么内容。
- en: The first release of ECMAScript was in 1997, ECMAScript1\. This was followed
    in 1998 by ECMAScript2\. ECMAScript3 came out in 1999, adding regular expressions,
    string handling, and more. The process of agreeing on an ECMAScript4 became a
    chaotic, political mess that proved to be impossible. It was never released. In
    2009, ECMAScript5(ES5) was released, bringing features like new array methods,
    object properties, and library support for JSON.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript的第一个版本是1997年的ECMAScript1。接着在1998年发布了ECMAScript2。ECMAScript3于1999年发布，添加了正则表达式、字符串处理等功能。就ECMAScript4达成协议的过程而言，变得混乱、政治化，最终被证明是不可能的。它从未发布。2009年，ECMAScript5（ES5）发布，引入了新的数组方法、对象属性以及对JSON的库支持。
- en: Since then, there has been a lot more momentum in this space. After ES6 or ES2015
    was released in, yes, 2015, there have been yearly releases of new JS features.
    Anything that’s part of the stage proposals is typically called ESNext, which
    is a simplified way of saying this is the next stuff that will be part of the
    JavaScript spec.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 自那时起，这个领域的发展势头非常强劲。在ES6或ES2015于2015年发布后，每年都会发布新的JS功能。任何属于阶段建议的东西通常被称为ESNext，简单来说，这是即将成为JavaScript规范一部分的新东西。
- en: Proposals are taken through clearly defined stages, from stage 0, which represents
    the newest proposals, up through stage 4, which represents the finished proposals.
    When a proposal gains traction, it’s up to the browser vendors like Chrome and
    Firefox to implement the features. Consider the `const` keyword. When creating
    variables, we used to use `var` in all cases. The ECMA committee decided there
    should be a `const` keyword to declare constants (more on that later in the chapter).
    When `const` was first introduced, you couldn’t just write `const` in JavaScript
    code and expect it to run in a browser. Now you can because browser vendors have
    changed the browser to support it.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 建议从明确定义的阶段开始，从阶段0代表最新的建议，一直到阶段4代表完成的建议。当一个建议获得认可时，就由像Chrome和Firefox等浏览器供应商来实现这些功能。考虑`const`关键字。在创建变量时，我们过去在所有情况下都使用`var`。ECMA委员会决定应该有一个`const`关键字来声明常量（本章稍后详细介绍）。当`const`首次引入时，你不能简单地在JavaScript代码中写`const`并期望它在浏览器中运行。现在可以了，因为浏览器供应商已经改变了浏览器以支持它。
- en: Many of the features we’ll discuss in this chapter are already supported by
    the newest browsers, but we’ll also be covering how to compile your JavaScript
    code. This is the process of transforming new syntax that the browser doesn’t
    recognize into older syntax that the browser understands. The [kangax compatibility
    table](https://oreil.ly/oe7la) is a great place to stay informed about the latest
    JavaScript features and their varying degrees of support by browsers.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章中我们将讨论的许多功能已经得到最新浏览器的支持，但我们还将讲述如何编译您的JavaScript代码。这是将浏览器不识别的新语法转换为浏览器理解的旧语法的过程。[kangax兼容性表](https://oreil.ly/oe7la)
    是一个了解最新JavaScript功能及其在各浏览器支持程度的好去处。
- en: In this chapter, we’ll show you all the JavaScript syntax we’ll be using throughout
    the book. We hope to provide a good baseline of JavaScript syntax knowledge that
    will carry you through all of your work with React. If you haven’t made the switch
    to the latest syntax yet, now would be a good time to get started. If you’re already
    comfortable with the latest language features, skip to the next chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将展示本书中将使用的所有JavaScript语法。我们希望提供JavaScript语法知识的良好基础，这将贯穿您的React工作。如果您尚未切换到最新的语法，请现在开始。如果您已经对最新的语言特性感到满意，请跳到下一章。
- en: Declaring Variables
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明变量
- en: Prior to ES2015, the only way to declare a variable was with the `var` keyword.
    We now have a few different options that provide improved functionality.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES2015之前，声明变量的唯一方法是使用`var`关键字。现在我们有几种不同的选项，提供了改进的功能。
- en: The const Keyword
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`const`关键字'
- en: A constant is a variable that cannot be overwritten. Once declared, you cannot
    change its value. A lot of the variables that we create in JavaScript should not
    be overwritten, so we’ll be using `const` a lot. Like other languages had done
    before it, JavaScript introduced constants with ES6.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 常量是一种不能被覆盖的变量。一旦声明，您不能更改其值。在JavaScript中，我们创建许多变量不应该被覆盖，因此我们将经常使用`const`。与其他语言一样，JavaScript在ES6中引入了常量。
- en: 'Before constants, all we had were variables, and variables could be overwritten:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在常量出现之前，我们只有变量，并且变量可以被覆盖：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We cannot reset the value of a constant variable, and it will generate a console
    error (as shown in [Figure 2-1](#overwrite_constant)) if we try to overwrite the
    value:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法重置常量变量的值，如果尝试覆盖值，会生成控制台错误（如[图 2-1](#overwrite_constant)所示）：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![Overwriting a constant](assets/lrc2_0201.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![覆盖常量](assets/lrc2_0201.png)'
- en: Figure 2-1\. An attempt at overwriting a constant
  id: totrans-17
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-1\. 尝试覆盖常量
- en: The let Keyword
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`let`关键字'
- en: JavaScript now has *lexical variable scope*. In JavaScript, we create code blocks
    with curly braces (`{}`). In functions, these curly braces block off the scope
    of any variable declared with `var`. On the other hand, consider `if/else` statements.
    If you’re coming from other languages, you might assume that these blocks would
    also block variable scope. This was not the case until `let` came along.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript现在具有*词法变量作用域*。在JavaScript中，我们使用大括号（`{}`）创建代码块。在函数中，这些大括号会阻止使用`var`声明的任何变量的作用域。另一方面，考虑`if/else`语句。如果您来自其他语言，您可能会假设这些块也会阻止变量作用域。直到`let`出现之前，情况并非如此。
- en: 'If a variable is created inside of an `if/else` block, that variable is not
    scoped to the block:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`if/else`块内部创建变量，则该变量不会作用域于该块：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `topic` variable inside the `if` block resets the value of `topic` outside
    of the block.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在`if`块内部的`topic`变量重置了块外的`topic`的值。
- en: 'With the `let` keyword, we can scope a variable to any code block. Using `let`
    protects the value of the global variable:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`let`关键字，我们可以将变量作用域限定在任何代码块中。使用`let`可以保护全局变量的值：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The value of `topic` is not reset outside of the block.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`topic`的值在块外部不会被重置。'
- en: 'Another area where curly braces don’t block off a variable’s scope is in `for`
    loops:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个大括号不阻止变量作用域的区域是`for`循环：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this loop, we create five `div`s to appear within a container. Each `div`
    is assigned an `onclick` handler that creates an alert box to display the index.
    Declaring `i` in the `for` loop creates a global variable named `i`, then iterates
    over it until its value reaches `5`. When you click on any of these boxes, the
    alert says that `i` is equal to `5` for all `div`s, because the current value
    for the global `i` is `5` (see [Figure 2-2](#i_equal_5)).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个循环中，我们创建了五个`div`，它们出现在一个容器内。每个`div`都被分配了一个`onclick`处理程序，用于创建一个警报框来显示索引。在`for`循环中声明`i`创建了一个名为`i`的全局变量，然后迭代直到其值达到`5`。当您点击这些框中的任何一个时，警报显示所有`div`的`i`均等于`5`，因为全局`i`的当前值为`5`（参见[图 2-2](#i_equal_5)）。
- en: '![image](assets/lrc2_0202.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/lrc2_0202.png)'
- en: Figure 2-2\. i is equal to 5 for each box
  id: totrans-30
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-2\. 每个框中的`i`均等于5
- en: 'Declaring the loop counter `i` with `let` instead of `var` does block off the
    scope of `i`. Now clicking on any box will display the value for `i` that was
    scoped to the loop iteration (see [Figure 2-3](#loop_counter_i)):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`let`声明循环计数器`i`而不是`var`可以保护`i`的作用域。现在点击任何框都会显示与循环迭代作用域关联的`i`的值（见[图 2-3](#loop_counter_i)）：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![image](assets/lrc2_0203.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/lrc2_0203.png)'
- en: Figure 2-3\. The scope of `i` is protected with `let`
  id: totrans-34
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-3\. 使用`let`保护`i`的作用域
- en: The scope of `i` is protected with `let`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`let`保护`i`的作用域。
- en: Template Strings
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板字符串
- en: Template strings provide us with an alternative to string concatenation. They
    also allow us to insert variables into a string. You’ll hear these referred to
    as template strings, template literals, or string templates interchangeably.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字符串为我们提供了替代字符串连接的方法。它们还允许我们在字符串中插入变量。你会听到这些被称为模板字符串、模板文字或字符串模板，可以互换使用。
- en: 'Traditional string concatenation uses plus signs to compose a string using
    variable values and strings:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的字符串连接使用加号来使用变量值和字符串来组合字符串：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With a template, we can create one string and insert the variable values by
    surrounding them with `${ }`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通过模板，我们可以创建一个字符串，并通过`${ }`将变量值插入其中：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Any JavaScript that returns a value can be added to a template string between
    the `${ }` in a template string.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 任何返回值的JavaScript都可以在模板字符串的`${ }`之间添加到模板字符串中。
- en: 'Template strings honor whitespace, making it easier to draft up email templates,
    code examples, or anything else that contains whitespace. Now you can have a string
    that spans multiple lines without breaking your code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字符串遵循空白字符，使得更容易草拟电子邮件模板、代码示例或任何包含空白字符的内容。现在，你可以拥有跨越多行的字符串而不会破坏你的代码：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Previously, using an HTML string directly in our JavaScript code was not so
    easy to do because we’d need to run it together on one line. Now that the whitespace
    is recognized as text, you can insert formatted HTML that is easy to read and
    understand:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，在JavaScript代码中直接使用HTML字符串并不容易，因为我们需要将其连成一行。现在，空白字符被识别为文本，你可以插入格式化的HTML，这样更容易阅读和理解：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice that we can include variables for the page title and article text as
    well.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还可以为页面标题和文章文本包含变量。
- en: Creating Functions
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建函数
- en: Any time you want to perform some sort of repeatable task with JavaScript, you
    can use a function. Let’s take a look at some of the different syntax options
    that can be used to create a function and the anatomy of those functions.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你想用JavaScript执行一些可重复的任务时，你可以使用函数。让我们看看可以用来创建函数的不同语法选项以及这些函数的解剖学。
- en: Function Declarations
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数声明
- en: 'A function declaration or function definition starts with the `function` keyword,
    which is followed by the name of the function, `logCompliment`. The JavaScript
    statements that are part of the function are defined between the curly braces:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 函数声明或函数定义以`function`关键字开头，后面跟着函数名`logCompliment`。作为函数的一部分的JavaScript语句定义在花括号之间：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once you’ve declared the function, you’ll invoke or call it to see it execute:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦声明了函数，你将调用它以查看其执行结果：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Once invoked, you’ll see the compliment logged to the console.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦调用，你会看到赞美语句被记录在控制台上。
- en: Function Expressions
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数表达式
- en: 'Another option is to use a function expression. This just involves creating
    the function as a variable:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是使用函数表达式。这只涉及将函数创建为变量：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The result is the same, and `You're doing great!` is logged to the console.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是相同的，`You're doing great!`被记录在控制台上。
- en: 'One thing to be aware of when deciding between a function declaration and a
    function expression is that function declarations are hoisted and function expressions
    are not. In other words, you can invoke a function before you write a function
    declaration. You cannot invoke a function created by a function expression. This
    will cause an error. For example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定使用函数声明还是函数表达式时要注意的一件事是，函数声明是被提升的，而函数表达式不是。换句话说，你可以在编写函数声明之前调用函数。你不能调用由函数表达式创建的函数。这将导致错误。例如：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This works. You’ll see the alert appear in the browser. It works because the
    function is hoisted, or moved up, to the top of the file’s scope. Trying the same
    exercise with a function expression will cause an error:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这有效。你会看到警报出现在浏览器中。它有效是因为该函数被提升，或者说被移动到文件作用域的顶部。如果尝试使用函数表达式进行相同的练习，将会导致错误：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is obviously a small example, but this TypeError can occasionally arise
    when importing files and functions in a project. If you see it, you can always
    refactor as a declaration.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是一个小例子，但在项目中导入文件和函数时偶尔会出现这种TypeError。如果你看到它，你可以随时重构为声明。
- en: Passing arguments
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传递参数
- en: 'The `logCompliment` function currently takes in no arguments or parameters.
    If we want to provide dynamic variables to the function, we can pass named parameters
    to a function simply by adding them to the parentheses. Let’s start by adding
    a `firstName` variable:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`logCompliment`函数当前不接受任何参数或参数。如果我们想为函数提供动态变量，可以通过将它们添加到括号中来将命名参数传递给函数。让我们首先添加一个`firstName`变量：'
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now when we call the `logCompliment` function, the `firstName` value sent will
    be added to the console message.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们调用`logCompliment`函数时，发送的`firstName`值将添加到控制台消息中。
- en: 'We could add to this a bit by creating another argument called `message`. Now,
    we won’t hard-code the message. We’ll pass in a dynamic value as a parameter:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建一个名为`message`的新参数来进一步扩展此功能。现在，我们不会硬编码消息。我们将作为参数传入一个动态值：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Function returns
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数返回
- en: 'The `logCompliment` function currently logs the compliment to the console,
    but more often, we’ll use a function to return a value. Let’s add a `return` statement
    to this function. A `return` statement specifies the value returned by the function.
    We’ll rename the function `createCompliment`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`logCompliment`函数当前将赞美语句记录到控制台，但更常见的是，我们将使用函数来返回一个值。让我们为这个函数添加一个`return`语句。`return`语句指定函数返回的值。我们将函数重命名为`createCompliment`：'
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you wanted to check to see if the function is executing as expected, just
    wrap the function call in a `console.log`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想检查函数是否按预期执行，只需在`console.log`中包裹函数调用：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Default Parameters
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认参数
- en: Languages including C++ and Python allow developers to declare default values
    for function arguments. Default parameters are included in the ES6 spec, so in
    the event that a value is not provided for the argument, the default value will
    be used.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 包括C++和Python在内的语言允许开发人员为函数参数声明默认值。ES6规范中包含默认参数，因此如果未为参数提供值，则将使用默认值。
- en: 'For example, we can set up default strings for the parameters `name` and `activity`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以为参数`name`和`activity`设置默认字符串：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If no arguments are provided to the `logActivity` function, it will run correctly
    using the default values. Default arguments can be any type, not just strings:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`logActivity`函数没有提供参数，它将使用默认值正确运行。默认参数可以是任何类型，不仅仅是字符串：
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Arrow Functions
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 箭头函数
- en: 'Arrow functions are a useful new feature of ES6\. With arrow functions, you
    can create functions without using the `function` keyword. You also often do not
    have to use the `return` keyword. Let’s consider a function that takes in a `firstName`
    and returns a string, turning the person into a lord. Anyone can be a lord:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数是ES6的一个有用的新特性。使用箭头函数，可以创建函数而无需使用`function`关键字。通常也不需要使用`return`关键字。让我们考虑一个函数，它接受一个`firstName`并返回一个字符串，将这个人变成一个领主。任何人都可以成为一个领主：
- en: '[PRE22]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With an arrow function, we can simplify the syntax tremendously:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用箭头函数，我们可以极大地简化语法：
- en: '[PRE23]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: With the arrow, we now have an entire function declaration on one line. The
    `function` keyword is removed. We also remove `return` because the arrow points
    to what should be returned. Another benefit is that if the function only takes
    one argument, we can remove the parentheses around the arguments.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 有了箭头，我们现在可以将整个函数声明放在一行上。移除了`function`关键字。我们还移除了`return`，因为箭头指向了应该返回的内容。另一个好处是，如果函数只接受一个参数，我们可以移除参数周围的括号。
- en: 'More than one argument should be surrounded by parentheses:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 多个参数应该用括号括起来：
- en: '[PRE24]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can keep this as a one-line function because there is only one statement
    that needs to be returned. If there are multiple lines, you’ll use curly braces:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个函数保持为一行，因为只有一个语句需要返回。如果有多行，你将使用大括号：
- en: '[PRE26]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: These `if/else` statements are surrounded with brackets but still benefit from
    the shorter syntax of the arrow function.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这些`if/else`语句被括号包围，但仍然从箭头函数的更短语法中受益。
- en: Returning objects
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回对象
- en: 'What happens if you want to return an object? Consider a function called `person`
    that builds an object based on parameters passed in for `firstName` and `lastName`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想返回一个对象会发生什么？考虑一个名为`person`的函数，它基于传入的参数`firstName`和`lastName`构建一个对象：
- en: '[PRE27]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As soon as you run this, you’ll see the error: `Uncaught SyntaxError: Unexpected
    token :`. To fix this, just wrap the object you’re returning with parentheses:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '一旦运行，你会看到错误：`Uncaught SyntaxError: Unexpected token :`。要解决这个问题，只需用括号包裹你返回的对象：'
- en: '[PRE28]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: These missing parentheses are the source of countless bugs in JavaScript and
    React apps, so it’s important to remember this one!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这些缺少的括号是JavaScript和React应用程序中无数错误的根源，因此记住这一点非常重要！
- en: Arrow functions and scope
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 箭头函数和作用域
- en: 'Regular functions do not block `this`. For example, `this` becomes something
    else in the `setTimeout` callback, not the `tahoe` object:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 普通函数不会阻塞 `this`。例如，在 `setTimeout` 回调中，`this` 变成了其他内容，而不是 `tahoe` 对象：
- en: '[PRE29]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This error is thrown because it’s trying to use the `.join` method on what
    `this` is. If we log `this`, we’ll see that it refers to the `Window` object:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出此错误是因为它试图在 `this` 上使用 `.join` 方法。如果我们记录 `this`，我们会发现它指向 `Window` 对象：
- en: '[PRE30]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To solve this problem, we can use the arrow function syntax to protect the
    scope of `this`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以使用箭头函数语法来保护 `this` 的作用域：
- en: '[PRE31]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This works as expected, and we can `.join` the resorts with a comma. Be careful
    that you’re always keeping scope in mind. Arrow functions do not block off the
    scope of `this`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这按预期工作，我们可以用逗号`.join`连接度假胜地。请注意始终牢记作用域。箭头函数不会阻止 `this` 的作用域：
- en: '[PRE32]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Changing the `print` function to an arrow function means that `this` is actually
    the window.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `print` 函数更改为箭头函数意味着 `this` 实际上是 `window`。
- en: Compiling JavaScript
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译 JavaScript
- en: When a new JavaScript feature is proposed and gains support, the community often
    wants to use it before it’s supported by all browsers. The only way to be sure
    that your code will work is to convert it to more widely compatible code before
    running it in the browser. This process is called *compiling*. One of the most
    popular tools for JavaScript compilation is [Babel](http://www.babeljs.io).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个新的 JavaScript 特性被提出并获得支持时，社区经常希望在所有浏览器都支持之前开始使用它。确保您的代码能够正常工作的唯一方法是在浏览器运行之前将其转换为更广泛兼容的代码。这个过程称为*编译*。JavaScript
    编译的最流行工具之一是[Babel](http://www.babeljs.io)。
- en: 'In the past, the only way to use the latest JavaScript features was to wait
    weeks, months, or even years until browsers supported them. Now, Babel has made
    it possible to use the latest features of JavaScript right away. The compiling
    step makes JavaScript similar to other languages. It’s not quite traditional compiling:
    our code isn’t compiled to binary. Instead, it’s transformed into syntax that
    can be interpreted by a wider range of browsers. Also, JavaScript now has source
    code, meaning that there will be some files that belong to your project that don’t
    run in the browser.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，使用最新的 JavaScript 特性的唯一方法是等待几周、几个月，甚至几年，直到浏览器支持它们。现在，Babel 使得立即使用 JavaScript
    的最新特性成为可能。编译步骤使 JavaScript 变得类似于其他语言。它并不完全是传统的编译：我们的代码不会被编译成二进制代码。相反，它被转换为可以被更广泛范围的浏览器解释的语法。此外，JavaScript
    现在有源代码，这意味着你的项目中会有一些文件，在浏览器中不会运行。
- en: 'As an example, let’s look at an arrow function with some default arguments:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看一个带有一些默认参数的箭头函数：
- en: '[PRE33]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If we run Babel on this code, it will generate the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对这段代码运行 Babel，它将生成以下内容：
- en: '[PRE34]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Babel added a “use strict” declaration to run in strict mode. The variables
    `x` and `y` are defaulted using the `arguments` array, a technique you may be
    familiar with. The resulting JavaScript is more widely supported.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Babel 添加了一个“use strict”声明以运行严格模式。变量 `x` 和 `y` 使用 `arguments` 数组进行了默认设置，这是您可能熟悉的一种技术。生成的
    JavaScript 得到了更广泛的支持。
- en: A great way to learn more about how Babel works is to check out the [Babel REPL](https://babeljs.io/repl)
    on the documentation website. Type some new syntax on the left side, then see
    some older syntax created.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 了解 Babel 工作原理的一个好方法是查看文档网站上的[Babel REPL](https://babeljs.io/repl)。在左侧输入一些新语法，然后查看创建的一些旧语法。
- en: The process of JavaScript compilation is typically automated by a build tool
    like webpack or Parcel. We’ll discuss that in more detail later in the book.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 编译的过程通常由像 webpack 或 Parcel 这样的构建工具自动化。我们稍后会更详细地讨论这个问题。
- en: Objects and Arrays
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象和数组
- en: Since ES2016, JavaScript syntax has supported creative ways of scoping variables
    within objects and arrays. These creative techniques are widely used among the
    React community. Let’s take a look at a few of them, including destructuring,
    object literal enhancement, and the spread operator.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 自 ES2016 起，JavaScript 语法支持在对象和数组中创建变量作用域的创造性方式。这些创造性技术在 React 社区中被广泛使用。让我们看看其中一些，包括解构、对象字面量增强和展开运算符。
- en: Destructuring Objects
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解构对象
- en: 'Destructuring assignment allows you to locally scope fields within an object
    and to declare which values will be used. Consider the `sandwich` object. It has
    four keys, but we only want to use the values of two. We can scope `bread` and
    `meat` to be used locally:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 解构赋值允许您在对象内部局部范围字段，并声明将使用哪些值。考虑 `sandwich` 对象。它有四个键，但我们只想使用两个的值。我们可以将 `bread`
    和 `meat` 限定为在本地使用：
- en: '[PRE35]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The code pulls `bread` and `meat` out of the object and creates local variables
    for them. Also, since we declared these destructed variables using `let`, the
    `bread` and `meat` variables can be changed without changing the original sandwich:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 代码从对象中提取 `bread` 和 `meat`，并为它们创建局部变量。此外，由于我们使用 `let` 声明了这些解构变量，因此可以更改 `bread`
    和 `meat` 变量，而不影响原始三明治：
- en: '[PRE36]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can also destructure incoming function arguments. Consider this function
    that would log a person’s name as a lord:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以从传入的函数参数中解构。考虑这个函数，它将一个人的名字记录为贵族：
- en: '[PRE37]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Instead of using dot notation syntax to dig into objects, we can destructure
    the values we need out of `regularPerson`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过解构 `regularPerson` 来获取我们需要的值，而不是使用点符号语法深入对象：
- en: '[PRE38]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let’s take this one level farther to reflect a data change. Now, the `regularPerson`
    object has a new nested object on the `spouse` key:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步反映数据变化。现在，`regularPerson` 对象在 `spouse` 键上有一个新的嵌套对象：
- en: '[PRE39]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If we wanted to lordify the spouse’s first name, we’d adjust the function’s
    destructured arguments slightly:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要将配偶的名字昇华为贵族，我们需要稍微调整函数的解构参数：
- en: '[PRE40]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Using the colon and nested curly braces, we can destructure the `firstname`
    from the `spouse` object.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用冒号和嵌套大括号，我们可以从 `spouse` 对象中解构出 `firstname`。
- en: Destructuring Arrays
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组解构
- en: 'Values can also be destructured from arrays. Imagine that we wanted to assign
    the first value of an array to a variable name:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 值也可以从数组中解构出来。想象一下，我们想要将数组的第一个值分配给一个名为 `name` 的变量：
- en: '[PRE41]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can also pass over unnecessary values with *list matching* using commas.
    List matching occurs when commas take the place of elements that should be skipped.
    With the same array, we can access the last value by replacing the first two values
    with commas:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 *列表匹配* 来跳过不必要的值，使用逗号。当逗号代替应该跳过的元素时，列表匹配发生。使用相同的数组，我们可以通过用逗号替换前两个值来访问最后一个值：
- en: '[PRE42]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Later in this section, we’ll take this example a step farther by combining array
    destructuring and the spread operator.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节后面，我们将通过结合数组解构和扩展操作符来进一步说明这个例子。
- en: Object Literal Enhancement
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象文字增强
- en: '*Object literal enhancement* is the opposite of destructuring. It’s the process
    of restructuring or putting the object back together. With object literal enhancement,
    we can grab variables from the global scope and add them to an object:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*对象文字增强*与解构相反。它是重新构造或将对象重新组合的过程。使用对象文字增强，我们可以从全局范围内获取变量并将它们添加到一个对象中：'
- en: '[PRE43]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`name` and `elevation` are now keys of the `funHike` object.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`name` 和 `elevation` 现在是 `funHike` 对象的键。'
- en: 'We can also create object methods with object literal enhancement or restructuring:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用对象文字增强或重构来创建对象方法：
- en: '[PRE44]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Notice we use `this` to access the object keys.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们使用 `this` 来访问对象键。
- en: 'When defining object methods, it’s no longer necessary to use the `function`
    keyword:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义对象方法时，不再需要使用 `function` 关键字：
- en: '[PRE45]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Object literal enhancement allows us to pull global variables into objects and
    reduces typing by making the `function` keyword unnecessary.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对象文字增强允许我们将全局变量引入对象，并通过使 `function` 关键字不再必要来减少输入。
- en: The Spread Operator
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展操作符
- en: 'The spread operator is three dots (`...`) that perform several different tasks.
    First, the spread operator allows us to combine the contents of arrays. For example,
    if we had two arrays, we could make a third array that combines the two arrays
    into one:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展操作符是三个点（`...`），执行多种不同的任务。首先，扩展操作符允许我们合并数组的内容。例如，如果我们有两个数组，我们可以创建一个第三个数组，将这两个数组合并成一个：
- en: '[PRE46]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: All of the items from `peaks` and `canyons` are pushed into a new array called
    `tahoe`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `peaks` 和 `canyons` 中的所有项推入一个名为 `tahoe` 的新数组。
- en: 'Let’s take a look at how the spread operator can help us deal with a problem.
    Using the `peaks` array from the previous sample, let’s imagine that we wanted
    to grab the last item from the array rather than the first. We could use the `Array.reverse`
    method to reverse the array in combination with array destructuring:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看扩展操作符如何帮助我们解决问题。使用前面示例中的 `peaks` 数组，假设我们想要抓取数组的最后一个项目而不是第一个项目。我们可以使用 `Array.reverse`
    方法结合数组解构来反转数组：
- en: '[PRE47]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'See what happened? The `reverse` function has actually altered or mutated the
    array. In a world with the spread operator, we don’t have to mutate the original
    array. Instead, we can create a copy of the array and then reverse it:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 看到发生了什么了吗？`reverse` 函数实际上已经改变或突变了数组。在有了扩展操作符的世界中，我们不必改变原始数组。相反，我们可以创建一个数组副本，然后反转它：
- en: '[PRE48]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Since we used the spread operator to copy the array, the `peaks` array is still
    intact and can be used later in its original form.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用扩展操作符复制了数组，所以`peaks`数组仍然保持原样，可以稍后以其原始形式使用。
- en: 'The spread operator can also be used to get the remaining items in the array:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展操作符也可以用于获取数组中的剩余项：
- en: '[PRE49]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We can also use the three-dot syntax to collect function arguments as an array.
    When used in a function, these are called `rest parameters`. Here, we build a
    function that takes in *n* number of arguments using the spread operator, then
    uses those arguments to print some console messages:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用三个点语法将函数参数收集为数组。在函数中使用时，这些称为`rest parameters`。在这里，我们构建一个函数，使用扩展操作符接收*n*个参数，然后使用这些参数打印一些控制台消息：
- en: '[PRE50]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `directions` function takes in the arguments using the spread operator.
    The first argument is assigned to the `start` variable. The last argument is assigned
    to a `finish` variable using `Array.reverse`. We then use the length of the `arguments`
    array to display how many towns we’re going through. The number of stops is the
    length of the `arguments` array minus the `finish` stop. This provides incredible
    flexibility because we could use the `directions` function to handle any number
    of stops.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`directions`函数使用扩展操作符接收参数。第一个参数分配给`start`变量。使用`Array.reverse`将最后一个参数分配给`finish`变量。然后使用`arguments`数组的长度来显示我们要经过的城镇数量。停靠的数量是`arguments`数组长度减去`finish`停靠的数量。这提供了
    incredible flexibility，因为我们可以使用`directions`函数处理任意数量的停靠。'
- en: 'The spread operator can also be used for objects (see the GitHub page for [Rest/Spread
    Properties](https://oreil.ly/kCpEL)). Using the spread operator with objects is
    similar to using it with arrays. In this example, we’ll use it the same way we
    combined two arrays into a third array, but instead of arrays, we’ll use objects:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展操作符也可用于对象（请参阅GitHub页面上的[Rest/Spread Properties](https://oreil.ly/kCpEL)）。与数组一样，使用对象的扩展操作符是相似的。在这个例子中，我们将以与合并两个数组为同样的方式使用它，但不是数组，而是对象：
- en: '[PRE51]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Asynchronous JavaScript
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步JavaScript
- en: 'The code samples that have been part of this chapter so far have been synchronous.
    When we write synchronous JavaScript code, we’re providing a list of instructions
    that execute immediately in order. For example, if we wanted to use JavaScript
    to handle some simple DOM manipulation, we’d write the code to do so like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章节的代码示例都是同步的。当我们编写同步JavaScript代码时，我们提供了一系列立即按顺序执行的指令。例如，如果我们想要使用JavaScript处理一些简单的DOM操作，我们会这样写代码：
- en: '[PRE52]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: These are instructions. “Yo, go select that element with an id of `heading`.
    Then when you’re done with that, how about you set that inner HTML to *Hey*.”
    It works synchronously. While each operation is happening, nothing else is happening.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是指示。“嘿，去选择那个id为`heading`的元素。然后当你完成时，把它的内部HTML设置为*嘿*。”它同步工作。在每个操作正在进行时，不会发生其他事情。
- en: With the modern web, we need to perform asynchronous tasks. These tasks often
    have to wait for some work to finish before they can be completed. We might need
    to access a database. We might need to stream video or audio content. We might
    need to fetch data from an API. With JavaScript, asynchronous tasks do not block
    the main thread. JavaScript is free to do something else while we wait for the
    API to return data. JavaScript has evolved a lot over the past few years to make
    handling these asynchronous actions easier. Let’s explore some of the features
    that make this possible.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代网络中，我们需要执行异步任务。这些任务通常必须等待某些工作完成后才能完成。我们可能需要访问数据库。我们可能需要流式传输视频或音频内容。我们可能需要从API获取数据。使用JavaScript，异步任务不会阻塞主线程。JavaScript可以在等待API返回数据时做其他事情。JavaScript在过去几年中已经发展了很多，使处理这些异步操作变得更容易。让我们探讨一些使这成为可能的功能。
- en: Simple Promises with Fetch
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Fetch进行简单的Promise处理
- en: Making a request to a REST API used to be pretty cumbersome. We’d have to write
    20+ lines of nested code just to load some data into our app. Then the `fetch()`
    function showed up and simplified our lives. Thanks to the ECMAScript committee
    for making fetch happen.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，向REST API发出请求相当麻烦。我们必须编写20多行嵌套代码才能将一些数据加载到我们的应用中。然后出现了`fetch()`函数，简化了我们的生活。感谢ECMAScript委员会使fetch成为可能。
- en: 'Let’s get some data from the randomuser.me API. This API has information like
    email address, name, phone number, location, and so on for fake members and is
    great to use as dummy data. `fetch` takes in the URL for this resource as its
    only parameter:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 randomuser.me API 获取一些数据。这个 API 提供了假成员的电子邮件地址、姓名、电话号码、位置等信息，非常适合用作虚拟数据。`fetch`
    接受此资源的 URL 作为其唯一参数：
- en: '[PRE53]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: When we log this, we see that there is a pending promise. *Promises* give us
    a way to make sense out of asynchronous behavior in JavaScript. The promise is
    an object that represents whether the async operation is pending, has been completed,
    or has failed. Think of this like the browser saying, “Hey, I’m going to try my
    best to go get this data. Either way, I’ll come back and let you know how it went.”
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们记录这个时，我们看到有一个待处理的 promise。*Promises* 给了我们在 JavaScript 中理解异步行为的一种方式。Promise
    是一个对象，表示异步操作是挂起、已完成还是失败。可以把这看作浏览器说，“嘿，我会尽力去获取这些数据。无论如何，我会回来告诉你结果的。”
- en: So back to the `fetch` result. The pending promise represents a state before
    the data has been fetched. We need to chain on a function called `.then()`. This
    function will take in a callback function that will run if the previous operation
    was successful. In other words, fetch some data, then do something else.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 所以回到 `fetch` 结果。待处理的 promise 表示在获取数据之前的状态。我们需要链接一个名为 `.then()` 的函数。这个函数将接收一个回调函数，如果上一个操作成功，就会运行这个函数。换句话说，获取一些数据，然后做其他事情。
- en: 'The something else we want to do is turn the response into JSON:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要做的另一件事是将响应转换为 JSON：
- en: '[PRE54]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `then` method will invoke the callback function once the promise has resolved.
    Whatever you return from this function becomes the argument of the next `then`
    function. So we can chain together `then` functions to handle a promise that has
    been successfully resolved:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`then` 方法在 promise 解析后将调用回调函数。从这个函数返回的任何内容都成为下一个 `then` 函数的参数。因此，我们可以链式调用 `then`
    函数来处理已成功解析的 promise：'
- en: '[PRE55]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: First, we use `fetch` to make a GET request to randomuser.me. If the request
    is successful, we’ll then convert the response body to JSON. Next, we’ll take
    the JSON data and return the results, then we’ll send the results to the `console.log`
    function, which will log them to the console. Finally, there is a `catch` function
    that invokes a callback if the `fetch` did not resolve successfully. Any error
    that occurred while fetching data from randomuser.me will be based on that callback.
    Here, we simply log the error to the console using `console.error`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用 `fetch` 发起 GET 请求到 randomuser.me。如果请求成功，我们将把响应主体转换为 JSON。接下来，我们将获取的
    JSON 数据返回结果，然后将结果发送给 `console.log` 函数，它将把它们记录到控制台中。最后，还有一个 `catch` 函数，如果 `fetch`
    未能成功解析，将调用回调。任何从 randomuser.me 获取数据时发生的错误都将基于该回调。在这里，我们简单地使用 `console.error` 将错误记录到控制台。
- en: Async/Await
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步/等待
- en: Another popular approach for handling promises is to create an async function.
    Some developers prefer the syntax of async functions because it looks more familiar,
    like code that’s found in a synchronous function. Instead of waiting for the results
    of a promise to resolve and handling it with a chain of `then` functions, `async`
    functions can be told to wait for the promise to resolve before further executing
    any code found in the function.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 处理 promise 的另一种流行方法是创建一个异步函数。一些开发人员更喜欢异步函数的语法，因为它看起来更像是同步函数中的代码。与等待 promise
    解析并使用一系列 `then` 函数处理不同，`async` 函数可以等待 promise 解析后再执行函数中找到的任何代码。
- en: 'Let’s make another API request but wrap the functionality with an async function:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再发起一个 API 请求，但用异步函数来包装功能：
- en: '[PRE56]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Notice that the `getFakePerson` function is declared using the `async` keyword.
    This makes it an asynchronous function that can wait for promises to resolve before
    executing the code any further. The `await` keyword is used before promise calls.
    This tells the function to wait for the promise to resolve. This code accomplishes
    the exact same task as the code in the previous section that uses `then` functions.
    Well, almost the exact same task…
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`getFakePerson` 函数是使用 `async` 关键字声明的。这使它成为一个异步函数，可以等待 promise 解析后再执行任何后续代码。在
    promise 调用之前使用 `await` 关键字。这告诉函数等待 promise 解析。这段代码完成了与前一节使用 `then` 函数的代码几乎相同的任务……
- en: '[PRE57]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: There we go—now this code accomplishes the exact same task as the code in the
    previous section that uses `then` functions. If the `fetch` call is successful,
    the results are logged to the console. If it’s unsuccessful, then we’ll log the
    error to the console using `console.error`. When using `async` and `await`, you
    need to surround your promise call in a `try`…`catch` block to handle any errors
    that may occur due to an unresolved promise.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样——现在这段代码完成了与上一节使用`then`函数的代码完全相同的任务。如果`fetch`调用成功，结果会被记录到控制台。如果失败，我们将使用`console.error`将错误记录到控制台。当使用`async`和`await`时，需要在`try`…`catch`块中包裹你的承诺调用，以处理由于未解决的承诺可能发生的任何错误。
- en: Building Promises
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建承诺
- en: 'When making an asynchronous request, one of two things can happen: everything
    goes as we hope, or there’s an error. There can be many different types of successful
    or unsuccessful requests. For example, we could try several ways to obtain the
    data to reach success. We could also receive multiple types of errors. Promises
    give us a way to simplify back to a simple pass or fail.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行异步请求时，可能发生两种情况：一切如我们所希望的进行，或者出现错误。成功或失败的请求可能有许多不同类型。例如，我们可以尝试多种方式获取数据以达到成功的目的。我们也可能收到多种类型的错误。承诺为我们提供了一种简化为简单通过或失败的方法。
- en: 'The `getPeople` function returns a new promise. The promise makes a request
    to the API. If the promise is successful, the data will load. If the promise is
    unsuccessful, an error will occur:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`getPeople`函数返回一个新的承诺。该承诺向API发出请求。如果承诺成功，数据将加载。如果承诺失败，将发生错误：'
- en: '[PRE58]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'With that, the promise has been created, but it hasn’t been used yet. We can
    use the promise by calling the `getPeople` function and passing in the number
    of members that should be loaded. The `then` function can be chained on to do
    something once the promise has been fulfilled. When a promise is rejected, any
    details are passed back to the `catch` function, or the `catch` block if using
    `async/await` syntax:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 随   有了这个，承诺已经创建，但尚未使用。我们可以通过调用`getPeople`函数并传入应该加载的成员数量来使用承诺。`then`函数可以链式调用，以在承诺完成后执行某些操作。当承诺被拒绝时，任何细节都会传递回`catch`函数，或者在使用`async/await`语法时传递到`catch`块：
- en: '[PRE59]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Promises make dealing with asynchronous requests easier, which is good, because
    we have to deal with a lot of asynchronicity in JavaScript. A solid understanding
    of asynchronous behavior is essential for the modern JavaScript engineer.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺使处理异步请求变得更加容易，这是很好的，因为我们在JavaScript中需要处理很多异步性。对异步行为的扎实理解对于现代JavaScript工程师至关重要。
- en: Classes
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: Prior to ES2015, there was no official class syntax in the JavaScript spec.
    When classes were introduced, there was a lot of excitement about how similar
    the syntax of classes was to traditional object-oriented languages like Java and
    C++. The past few years saw the React library leaning on classes heavily to construct
    user interface components. Today, React is beginning to move away from classes,
    instead using functions to construct components. You’ll still see classes all
    over the place, particularly in legacy React code and in the world of JavaScript,
    so let’s take a quick look at them.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES2015之前，JavaScript规范中没有官方的类语法。当类被引入时，人们对类的语法与传统的面向对象语言如Java和C++的相似性感到兴奋。过去几年中，React库在构建用户界面组件时大量依赖类。如今，React开始逐渐摆脱类的使用，改用函数来构建组件。你仍然会在各处看到类，特别是在遗留的React代码中以及JavaScript的世界中，所以让我们快速看一下它们。
- en: 'JavaScript uses something called `prototypical inheritance`. This technique
    can be wielded to create structures that feel object-oriented. For example, we
    can create a `Vacation` constructor that needs to be invoked with a `new` operator:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript使用一种叫做`原型继承`的东西。可以利用这种技术创建感觉像面向对象的结构。例如，我们可以创建一个需要使用`new`操作符调用的`Vacation`构造函数：
- en: '[PRE60]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This code creates something that feels like a custom type in an object-oriented
    language. A `Vacation` has properties (destination, length), and it has a method
    (print). The `maui` instance inherits the `print` method through the prototype.
    If you are or were a developer accustomed to more standard classes, this might
    fill you with a deep rage. ES2015 introduced class declaration to quiet that rage,
    but the dirty secret is that JavaScript still works the same way. Functions are
    objects, and inheritance is handled through the prototype. Classes provide a syntactic
    sugar on top of that gnarly prototype syntax:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一种感觉上像是面向对象语言中的自定义类型的东西。`Vacation`有属性（目的地、长度），并且有一个方法（print）。通过原型，`maui`实例继承了`print`方法。如果您是或曾经是习惯于更标准类的开发人员，这可能会让您充满深深的愤怒。ES2015引入了类声明以平息这种愤怒，但肮脏的秘密是JavaScript仍然以同样的方式工作。函数是对象，并且通过原型处理继承。类提供了一种语法糖，覆盖了那个复杂的原型语法：
- en: '[PRE61]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'When you’re creating a class, the class name is typically capitalized. Once
    you’ve created the class, you can create a new instance of the class using the
    `new` keyword. Then you can call the custom method on the class:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建一个类时，类名通常大写。一旦创建了类，可以使用`new`关键字创建类的新实例。然后可以调用类的自定义方法：
- en: '[PRE62]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Now that a class object has been created, you can use it as many times as you’d
    like to create new vacation instances. Classes can also be extended. When a class
    is extended, the subclass inherits the properties and methods of the superclass.
    These properties and methods can be manipulated from here, but as a default, all
    will be inherited.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已创建了一个类对象，可以随意使用它多次创建新的假期实例。类也可以被扩展。当扩展一个类时，子类将继承父类的属性和方法。这些属性和方法可以从这里操作，但默认情况下将全部继承。
- en: 'You can use `Vacation` as an abstract class to create different types of vacations.
    For instance, an `Expedition` can extend the `Vacation` class to include gear:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`Vacation`作为抽象类来创建不同类型的假期。例如，`Expedition`可以扩展`Vacation`类以包括装备：
- en: '[PRE63]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'That’s simple inheritance: the subclass inherits the properties of the superclass.
    By calling the `print` method of `Vacation`, we can append some new content onto
    what is printed in the `print` method of `Expedition`. Creating a new instance
    works the exact same way—create a variable and use the `new` keyword:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这是简单的继承：子类继承了父类的属性。通过调用`Vacation`的`print`方法，我们可以在`Expedition`的`print`方法打印的内容后添加一些新内容。创建新实例的方法与此完全相同——创建一个变量并使用`new`关键字：
- en: '[PRE64]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: ES6 Modules
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ES6模块
- en: 'A JavaScript *module* is a piece of reusable code that can easily be incorporated
    into other JavaScript files without causing variable collisions. JavaScript modules
    are stored in separate files, one file per module. There are two options when
    creating and exporting a module: you can export multiple JavaScript objects from
    a single module or one JavaScript object per module.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的*模块*是可重复使用的代码片段，可以轻松地并入其他JavaScript文件而不会引起变量冲突。JavaScript模块存储在单独的文件中，每个模块一个文件。创建和导出模块有两个选项：可以从单个模块中导出多个JavaScript对象，或者每个模块导出一个JavaScript对象。
- en: 'In *text-helpers.js*, two functions are exported:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在*text-helpers.js*中，导出了两个函数：
- en: '[PRE65]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '`export` can be used to export any JavaScript type that will be consumed in
    another module. In this example, the `print` function and `log` function are being
    exported. Any other variables declared in *text-helpers.js* will be local to that
    module.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`export`可以用于导出将在另一个模块中使用的任何JavaScript类型。在此示例中，导出了`print`函数和`log`函数。在*text-helpers.js*中声明的任何其他变量将局限于该模块。'
- en: 'Modules can also export a single main variable. In these cases, you can use
    `export default`. For example, the *mt-freel.js* file can export a specific expedition:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 模块还可以导出单个主变量。在这些情况下，可以使用`export default`。例如，*mt-freel.js*文件可以导出特定的远征：
- en: '[PRE66]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '`export default` can be used in place of `export` when you wish to export only
    one type. Again, both `export` and `export default` can be used on any JavaScript
    type: primitives, objects, arrays, and functions.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当您希望只导出一个类型时，可以使用`export default`代替`export`。同样，`export`和`export default`可以用于任何JavaScript类型：原始类型、对象、数组和函数。
- en: 'Modules can be consumed in other JavaScript files using the `import` statement.
    Modules with multiple exports can take advantage of object destructuring. Modules
    that use `export default` are imported into a single variable:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`import`语句在其他JavaScript文件中消耗模块。具有多个导出的模块可以利用对象解构。使用`export default`的模块将导入到单个变量中：
- en: '[PRE67]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'You can scope module variables locally under different variable names:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在不同变量名称下本地化模块变量作用域：
- en: '[PRE68]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'You can also import everything into a single variable using `*`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 `*` 将所有内容导入到单个变量中：
- en: '[PRE69]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This `import` and `export` syntax is not yet fully supported by all browsers
    or by Node. However, like any emerging JavaScript syntax, it’s supported by Babel.
    This means you can use these statements in your source code and Babel will know
    where to find the modules you want to include in your compiled JavaScript.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 此 `import` 和 `export` 语法尚未完全被所有浏览器或 Node 支持。但与任何新兴的 JavaScript 语法一样，它受到 Babel
    的支持。这意味着您可以在源代码中使用这些语句，而 Babel 将知道在编译的 JavaScript 中找到您想要包含的模块。
- en: CommonJS
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CommonJS
- en: CommonJS is the module pattern that’s supported by all versions of Node (see
    the [Node.js documentation on modules](https://oreil.ly/CN-gA)). You can still
    use these modules with Babel and webpack. With CommonJS, JavaScript objects are
    exported using `module.exports`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: CommonJS 是由所有 Node 版本支持的模块模式（参见[Node.js 模块文档](https://oreil.ly/CN-gA)）。您仍然可以通过
    Babel 和 webpack 使用这些模块。在 CommonJS 中，JavaScript 对象使用 `module.exports` 导出。
- en: 'For example, in CommonJS, we can export the `print` and `log` functions as
    an object:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 CommonJS 中，我们可以将 `print` 和 `log` 函数导出为一个对象：
- en: '[PRE70]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'CommonJS does not support an `import` statement. Instead, modules are imported
    with the `require` function:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: CommonJS 不支持 `import` 语句。而是使用 `require` 函数导入模块：
- en: '[PRE71]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: JavaScript is indeed moving quickly and adapting to the increasing demands that
    engineers are placing on the language, and browsers are quickly implementing new
    features. For up-to-date compatibility information, see the [ESNext compatibility
    table](https://oreil.ly/rxTcg). Many of the features that are included in the
    latest JavaScript syntax are present because they support functional programming
    techniques. In functional JavaScript, we can think of our code as being a collection
    of functions that can be composed into applications. In the next chapter, we’ll
    explore functional techniques in more detail and will discuss why you might want
    to use them.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 确实在迅速发展，并适应工程师们对语言日益增长的需求，浏览器也在快速实现新特性。有关最新的兼容性信息，请参阅[ESNext 兼容性表](https://oreil.ly/rxTcg)。许多最新
    JavaScript 语法中包含的特性是因为它们支持函数式编程技术。在函数式 JavaScript 中，我们可以将代码视为一组可以组合成应用程序的函数。在接下来的章节中，我们将更详细地探讨函数式技术，并讨论为何您可能希望使用它们。
