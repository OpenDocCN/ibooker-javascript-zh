- en: Chapter 17\. Node Basics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 17 章. Node 基础
- en: The dividing line between “old” and “new” JavaScript occurred when Node.js (referred
    to primarily as just Node) was released to the world. Yes, the ability to dynamically
    modify page elements was an essential milestone, as was the emphasis on establishing
    a path forward to new versions of ECMAScript, but it was Node that really made
    us look at JavaScript in a whole new way. And it’s a way I like—I’m a big fan
    of Node and server-side JavaScript development.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “旧”和“新” JavaScript 之间的分界线是在 Node.js（主要简称为 Node）发布到世界上时发生的。是的，动态修改页面元素的能力是一个重要的里程碑，以及强调为
    ECMAScript 的新版本确立前进路径，但真正让我们以全新的方式看待 JavaScript 的是 Node。而我很喜欢这种方式——我是 Node 和服务器端
    JavaScript 开发的铁杆粉丝。
- en: In this chapter, we’ll explore the basics of Node. At a minimum, you will need
    to have Node installed, as covered in [“Installing the npm Package Manager (with
    Node.js)”](ch01.html#installing_node_npm) or [“Managing Node Versions with Node
    Version Manager”](#use-nvm).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 Node 的基础知识。至少，您需要已安装 Node，如[“安装 npm 包管理器（与 Node.js 一起）”](ch01.html#installing_node_npm)或[“使用
    Node Version Manager 管理 Node 版本”](#use-nvm)中所述。
- en: Managing Node Versions with Node Version Manager
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Node Version Manager 管理 Node 版本
- en: Problem
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to install and manage multiple versions of Node on your development
    machine.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在开发机器上安装和管理多个 Node 版本。
- en: Solution
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use [Node Version Manager (NVM)](https://github.com/nvm-sh/nvm), which allows
    you to install and use any distributed version of Node on a per-shell basis. NVM
    is compatible with Linux, macOS, and Windows Subsystem for Linux.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[Node Version Manager (NVM)](https://github.com/nvm-sh/nvm)，它允许您在每个 shell
    基础上安装和使用任何分发版本的 Node。NVM 兼容 Linux、macOS 和 Windows Subsystem for Linux。
- en: 'To install NVM, run the install script using either `curl` or `wget` in your
    system’s terminal application:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 NVM，请在系统的终端应用程序中使用`curl`或`wget`运行安装脚本：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-10
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you are developing on Windows, we recommend using [`nvm-windows`](https://github.com/coreybutler/nvm-windows),
    which is unaffiliated with the NVM project, but provides similar functionality
    for the Windows operating system. For instructions on how to use `nvm-windows`,
    consult the project’s documentation.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在 Windows 上进行开发，我们建议使用[`nvm-windows`](https://github.com/coreybutler/nvm-windows)，它与
    NVM 项目无关，但提供了类似的功能来支持 Windows 操作系统。有关如何使用`nvm-windows`的说明，请参阅该项目的文档。
- en: 'Once you have installed NVM, you will need to install a version of Node. To
    install the latest version of Node, run:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完 NVM 后，您需要安装一个 Node 版本。要安装最新版本的 Node，请运行：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can also install a specific version of Node:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以安装特定版本的 Node：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once you’ve installed Node, you’ll need to set a default version for new shell
    sessions. This can either be the latest version of Node that has been installed
    or a specific version number:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完 Node 后，您需要为新的 shell 会话设置一个默认版本。这可以是已安装的最新版本 Node 或一个特定的版本号：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To switch the version being used in a shell session, use the `nvm use` command
    followed by a specific installed version:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 shell 会话中切换使用的版本，请使用`nvm use`命令，然后跟上一个特定已安装的版本：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Discussion
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Using NVM allows you to easily download and switch between multiple versions
    of Node on your operating system. This can be incredibly useful when working with
    libraries that support multiple versions and legacy codebases. It also simplifies
    the management of Node within your development environment. You can view the [list
    of releases and support timelines](https://oreil.ly/9IY83) for each release.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 NVM 允许您在操作系统上轻松下载和切换多个 Node 版本。这在处理支持多个版本和遗留代码库的库时非常有用。它还简化了在开发环境中管理 Node。您可以查看每个发布的[发布和支持时间表](https://oreil.ly/9IY83)。
- en: 'When using NVM, it’s possible to list out all of the versions installed on
    your machine using the `nvm ls` command. This will show all of the installed versions,
    the default version for new shell sessions, and any LTS versions that you do not
    have installed:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 NVM 可以通过`nvm ls`命令列出您机器上安装的所有版本。这将显示所有已安装的版本、新 shell 会话的默认版本以及您未安装的任何 LTS
    版本：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see, I have several redundant patch versions of major releases installed
    on my machine. To uninstall and remove a specific version, you can use the `nvm
    uninstall` command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，我在我的机器上安装了几个重复的主要版本的冗余补丁版本。要卸载和移除特定版本，您可以使用`nvm uninstall`命令：
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Keeping track of which version of Node a project is designed to use can be
    a challenge. To make this easier, you can add an `.nvmrc` file to your project’s
    root directory. The contents of the file is the version of Node that the project
    is designed to use. For example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要追踪项目设计用于使用哪个 Node 版本可能是个挑战。为了简化这一点，您可以在项目的根目录下添加一个 `.nvmrc` 文件。文件的内容是项目设计使用的
    Node 版本。例如：
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To use the version specified in a project’s `.nvmrc` file, run `nvm use` command
    from the root of the director.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用项目 `.nvmrc` 文件中指定的版本，请从目录的根目录运行 `nvm use` 命令。
- en: Tip
  id: totrans-29
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: For large projects, using a container technology, such as Docker, is an incredibly
    useful way to ensure version matching across environments, including deployment.
    The Node documentation has a helpful guide on [Dockerizing a Node.js web app](https://oreil.ly/phXQZ).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大型项目，使用 Docker 等容器技术是确保版本匹配的极其有用的方式，包括部署。 Node 文档中有一篇关于 [将 Node.js Web 应用程序
    Docker 化](https://oreil.ly/phXQZ) 的有用指南。
- en: Responding to a Simple Browser Request
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应简单的浏览器请求
- en: Problem
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to create a Node application that can respond to a very basic browser
    request.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您想创建一个能够响应非常基本浏览器请求的 Node 应用程序。
- en: Solution
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use the built-in Node HTTP server to respond to requests:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内置的 Node HTTP 服务器来响应请求：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Discussion
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'A web server response to a browser request is the “Hello World” application
    for Node. It demonstrates not only how a Node application functions, but how you
    can communicate with it using a fairly traditional communication method: requesting
    a web resource.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Web 服务器响应浏览器请求是 Node 的“Hello World”应用程序。 它不仅演示了 Node 应用程序的功能，还演示了如何使用一种相当传统的通信方法与其通信：请求
    Web 资源。
- en: Starting from the top, the first line of the solution loads the `http` module
    using Node’s `require()` function. This instructs Node’s modular system to load
    a specific library resource for use in the application. The `http` module is one
    of the many that come, by default, with a Node installation.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从顶部开始，解决方案的第一行使用 Node 的 `require()` 函数加载 `http` 模块。 这指示 Node 的模块化系统加载用于应用程序的特定库资源。
    `http` 模块是默认情况下随 Node 安装的众多模块之一。
- en: Next, an HTTP server is created using `http.createServer()`, passing in an anonymous
    function, known as the `RequestListener` with two parameters. Node attaches this
    function as an event handler for every server request. The two parameters are
    *request* and *response*. The request is an instance of the `http.IncomingMessage`
    object and the response is an instance of the `http.ServerResponse` object.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用 `http.createServer()` 创建一个 HTTP 服务器，传入一个匿名函数，即 `RequestListener`，带有两个参数。
    Node 将此函数附加为每个服务器请求的事件处理程序。 这两个参数是 *request* 和 *response*。 请求是 `http.IncomingMessage`
    对象的一个实例，响应是 `http.ServerResponse` 对象的一个实例。
- en: The `http.ServerResponse` is used to respond to the web request. The `http.IncomingMessage`
    object contains information about the request, such as the request URL. If you
    need to get specific pieces of information from the URL (e.g., query string parameters),
    you can use the Node `url` utility module to parse the string. [Example 17-1](#parsing_url_for_data)
    demonstrates how the query string can be used to return a more custom message
    to the browser.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`http.ServerResponse` 用于响应 Web 请求。 `http.IncomingMessage` 对象包含有关请求的信息，例如请求
    URL。如果您需要从 URL 获取特定信息（例如查询字符串参数），则可以使用 Node 的 `url` 实用程序模块解析字符串。 [示例 17-1](#parsing_url_for_data)
    演示了如何使用查询字符串来向浏览器返回更自定义的消息。'
- en: Example 17-1\. Parsing out query string data
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-1\. 解析查询字符串数据
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A URL like the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示的 URL：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: results in a web page that reads “Hello, Reader!”
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 导致一个显示“Hello, Reader!”的网页。
- en: In the code, the `url` module object has a `parse()` method that parses out
    the URL, returning various components of it (`href`, `protocol`, `host`, etc.).
    If you pass `true` as the second argument, the string is also parsed by another
    module, `querystring`, which returns the query string as an object with each parameter
    as an object property, rather than just returning a string.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，`url` 模块对象具有一个 `parse()` 方法，该方法解析 URL 并返回其各个组件（`href`、`protocol`、`host`
    等）。 如果将 `true` 作为第二个参数传递，字符串还会由另一个模块 `querystring` 解析，后者将查询字符串作为对象返回，每个参数作为对象属性，而不仅仅返回字符串。
- en: 'In both the solution and in [Example 17-1](#parsing_url_for_data), a text message
    is returned as page output, using the `http.ServerResponse` `end()` method. I
    could also have written the message out using `write()`, and then called `end()`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案和 [示例 17-1](#parsing_url_for_data) 中，都返回一个文本消息作为页面输出，使用 `http.ServerResponse`
    的 `end()` 方法。我也可以使用 `write()` 输出消息，然后调用 `end()`：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The important takeaway from either approach is you *must* call the response
    `end()` method after all the headers and response body have been set.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 无论采用哪种方法，重要的是在设置所有标题和响应主体后，*必须*调用响应的 `end()` 方法。
- en: Chained to the end of the `createServer()` function call is another function
    call, this time to `listen()`, passing in the port number for the server to listen
    in on. This port number is also an especially important component of the application.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `createServer()` 函数调用的末尾链接了另一个函数调用，这次是 `listen()`，传入服务器监听的端口号。这个端口号也是应用程序的一个特别重要的组成部分。
- en: Traditionally, port 80 is the default port for most web servers (that aren’t
    using HTTPS, which has a default port of 443). By using port 80, requests for
    the web resource don’t need to specify a port when requesting the service’s URL.
    However, port 80 is also the default port used by our more traditional web server,
    Apache. If you try to run the Node service on the same port that Apache is using,
    your application will fail. The Node application either must be standalone on
    the server, or run off a different port.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，端口 80 是大多数 Web 服务器的默认端口（不使用 HTTPS 的服务器，默认端口是 443）。通过使用端口 80，在请求服务的 URL 时无需指定端口。但端口
    80 也是我们更传统的 Web 服务器 Apache 的默认端口。如果尝试在 Apache 使用的端口上运行 Node 服务，应用程序将失败。Node 应用程序要么必须独立运行在服务器上，要么在不同的端口上运行。
- en: You can also specify an IP address (host) in addition to the port. Doing this
    ensures that people make the request to a specific host, as well as port. Not
    providing the host means the application will listen for the request for any IP
    address associated with the server. You can also specify a domain name, and Node
    resolves the host.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以指定 IP 地址（主机），除了端口。这样做可以确保人们向特定的主机和端口发出请求。如果不提供主机，则应用程序将监听与服务器关联的任何 IP 地址的请求。你也可以指定域名，Node
    将解析主机。
- en: There are other arguments for the methods demonstrated, and a host of other
    methods, but this will get you started. Refer to the [Node documentation](http://nodejs.org/api)
    for more information.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他方法演示的参数，以及大量其他方法，但这将让你入门。有关更多信息，请参阅 [Node 文档](http://nodejs.org/api)。
- en: Interactively Trying Out Node Code Snippets with REPL
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 REPL 交互式尝试 Node 代码片段
- en: Problem
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to easily run server-based Node code snippets.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望轻松运行基于服务器的 Node 代码片段。
- en: Solution
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use Node’s REPL (Read-Evalute-Print-Loop), an interactive command-line version
    of Node that can run any code snippet.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Node 的 REPL（读取-评估-打印-循环），这是 Node 的交互式命令行版本，可以运行任何代码片段。
- en: 'To use REPL, type `node` at the command line without specifying an application
    to run:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 REPL，在命令行中键入 `node` 而不指定要运行的应用程序：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can then specify JavaScript in a simplified Emacs (sorry, no vi) line-editing
    style. You can import libraries, create functions—whatever you can do within a
    static application. The main difference is that each line of code is interpreted
    instantly:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以以简化的 Emacs 风格进行 JavaScript。你可以导入库，创建函数——可以在静态应用程序中做的任何事情。主要区别是每行代码都会立即解释：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When you’re finished, exit the program with `.exit`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，使用 `.exit` 退出程序：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Discussion
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: REPL can be started standalone or within another application if you want to
    set certain features. You type in the JavaScript as if you’re typing in the script
    in a text file. The main behavioral difference is you might see a result after
    typing in each line, such as the `undefined` that shows up in the runtime REPL.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: REPL 可以独立启动，或者在另一个应用程序中启动，如果你想设置某些功能。你输入 JavaScript 就像在文本文件中输入脚本一样。主要的行为差异是在每输入一行后可能会看到一个结果，比如运行时
    REPL 中显示的 `undefined`。
- en: 'But you can import modules:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 但你可以导入模块：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: And you can access the global objects, which we just did when we used `require()`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以访问全局对象，在我们使用 `require()` 时刚刚这样做。
- en: The `undefined` that shows after typing in some code is the return value for
    the execution of the previous line of code. Setting a new variable and creating
    a function are some of the JavaScript that return `undefined`, which can get quickly
    annoying. To eliminate this behavior, as well as make some other modifications,
    you can use the `REPL.start()` function within a small Node application that triggers
    REPL (but with the options you specify).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在键入某些代码后显示的 `undefined` 是前一行代码执行的返回值。设置新变量和创建函数是一些返回 `undefined` 的 JavaScript
    操作，这可能会很快让人厌烦。为了消除这种行为以及进行其他一些修改，可以在一个小的 Node 应用程序中使用 `REPL.start()` 函数触发 REPL（但使用您指定的选项）。
- en: 'The options you can use are:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的选项包括：
- en: '`prompt`'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`prompt`'
- en: Changes the prompt that shows (default is *>*)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 更改显示的提示（默认为 *>*）
- en: '`input`'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`input`'
- en: Changes the input readable stream (default is `process.stdin`, which is the
    standard input)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 更改输入可读流（默认为 `process.stdin`，标准输入）
- en: '`output`'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`output`'
- en: Changes the output writable stream (default is `process.stdout`, the standard
    output)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 更改输出可写流（默认为 `process.stdout`，标准输出）
- en: '`terminal`'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`terminal`'
- en: Set to `true` if the stream should be treated like a TTY, and have ANSI/VT100
    escape codes written
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果流应该像 TTY 一样对待并写入 ANSI/VT100 转义代码，则设置为 `true`
- en: '`eval`'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`eval`'
- en: Function used to replace the asynchronous `eval()` function used to evaluate
    the JavaScript
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 用于替换异步 `eval()` 函数的函数，用于评估 JavaScript
- en: '`useColors`'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`useColors`'
- en: Set to `true` to set output colors for the `writer` function (default is based
    on the terminal’s default values)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 设置为 `true` 为 `writer` 函数设置输出颜色（默认基于终端的默认值）
- en: '`useGlobal`'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`useGlobal`'
- en: Set to `true` to use the `global` object, rather than running scripts in a separate
    context
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 设置为 `true` 可以使用 `global` 对象，而不是在单独的上下文中运行脚本
- en: '`ignoreUndefined`'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`ignoreUndefined`'
- en: Set to `true` to eliminate the `undefined` return values
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 设置为 `true` 以消除 `undefined` 返回值
- en: '`writer`'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`writer`'
- en: The function that returns the formatted result from the evaluated code to the
    display (default is the `util.inspect` function)
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 从评估的代码中返回格式化结果以显示（默认为 `util.inspect` 函数）
- en: 'The following is an example application that starts REPL with a new prompt,
    ignoring the undefined values, and using colors:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例应用程序，它使用新的提示启动 REPL，忽略未定义的值，并使用颜色：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The options we want are defined in the `options` object and then passed as
    parameters to `repl.start()`. When we run the application, REPL is started but
    we no longer have to deal with undefined values:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要的选项在 `options` 对象中定义，然后作为参数传递给 `repl.start()`。当我们运行应用程序时，REPL 被启动，但我们不再需要处理未定义的值：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, this is a cleaner output without all those messy `undefined`
    printouts.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这是一个更清晰的输出，没有所有那些混乱的 `undefined` 打印输出。
- en: 'Extra: Wait a Second, What Global Object?'
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 额外信息：等等，什么是全局对象？
- en: Caught that, did you?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你发现了吗？
- en: 'One difference between JavaScript in Node and JavaScript in the browser is
    the global scoping. Traditionally in a browser, when you create a variable outside
    a function, using `var`, it belongs to the top-level global object, which we know
    as `window`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 在 Node 和浏览器中的一个区别是全局作用域。传统上，在浏览器中，当你在函数外部使用 `var` 创建变量时，它属于顶层全局对象，我们称之为
    `window`：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Similarly, when using `let` or `const` in the browser, the variables are globally
    scoped, though not attached to the `window` object.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在浏览器中使用 `let` 或 `const` 时，变量是全局作用域的，但不附加到 `window` 对象。
- en: In Node, each module operates within its own separate context, so modules can
    declare the same variables, and they won’t conflict if they’re all used in the
    same application.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node 中，每个模块都在自己的独立上下文中运行，因此模块可以声明相同的变量，如果它们都在同一个应用程序中使用，则不会发生冲突。
- en: 'However, there are objects accessible from Node’s `global` object. We’ve used
    a few in previous examples, including `console`, the Buffer object, and `require()`.
    Others include some very familiar old friends: `setTimeout()`, `clearTimeout()`,
    `setInterval()`, and `clearInterval()`.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有些对象可以从 Node 的 `global` 对象访问。在前面的例子中，我们使用了一些，包括 `console`、Buffer 对象和 `require()`。其他包括一些非常熟悉的老朋友：`setTimeout()`、`clearTimeout()`、`setInterval()`
    和 `clearInterval()`。
- en: Reading and Writing File Data
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取和写入文件数据
- en: Problem
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to read from or write to a locally stored file.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要从本地存储的文件中读取或写入。
- en: Solution
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Node’s filesystem management functionality is included as part of the Node
    core, via the `fs` module:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Node 的文件系统管理功能作为 Node 核心的一部分包含在 `fs` 模块中：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To read a file’s contents, use the `readFile()` function:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取文件的内容，请使用 `readFile()` 函数：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To write to a file, use `writeFile()`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要写入文件，请使用`writeFile()`：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `writeFile()` function overwrites the existing file. To append text to
    the file, use `appendText()`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`writeFile()`函数会覆盖现有文件。要向文件追加文本，请使用`appendText()`：'
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Discussion
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Node’s filesystem support is both comprehensive and simple to use. To read
    from a file, use the `readFile()` function, which supports the following parameters:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Node的文件系统支持既全面又简单易用。要从文件中读取，请使用`readFile()`函数，支持以下参数：
- en: The filename, including the operating system path to the file if it isn’t local
    to the application
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件名，包括操作系统路径（如果不是应用程序本地文件）
- en: An options object, with options for `encoding`, as demonstrated in the solution,
    and `flag`, which is set to `r` by default (for reading)
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个选项对象，包括`encoding`选项（如解决方案中所示）和`flag`选项，默认设置为`r`（读取）
- en: A callback function with parameters for an error and the read data
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调函数，带有错误和读取的数据两个参数
- en: In the solution, if I didn’t specify the encoding in my application, Node would
    have returned the file contents as a raw buffer. Since I did specify the encoding,
    the file content is returned as a string.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案中，如果在应用程序中未指定编码，Node将以原始缓冲区形式返回文件内容。由于我指定了编码，文件内容以字符串形式返回。
- en: 'The `writeFile()` and `appendFile()` functions for writing and appending, respectively,
    take parameters similar to `readFile()`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`writeFile()`和`appendFile()`函数用于分别写入和追加数据，其参数类似于`readFile()`：'
- en: The filename and path
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件名和路径
- en: The string or buffer for the data to write to the file
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要写入文件的字符串或缓冲区数据
- en: The options object, with options for `encoding` (`w` as default for `writeFile()`
    and `a` as the default for `appendFile()`) and `mode`, with a default value of
    `438` (`0666` in Octal)
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选项对象，包括`encoding`选项（`writeFile()`默认为`w`，`appendFile()`默认为`a`）和`mode`选项，默认为`438`（八进制中的`0666`）
- en: 'The callback function, with only one parameter: the error'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调函数，只有一个参数：错误信息
- en: The options value of `mode` can be used to set the file’s permissions if the
    file was created by write or append. By default, the file is created as readable
    and writable by the owner, and readable by the group and the world.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件是通过写入或追加创建的，则可以使用`mode`的选项值来设置文件的权限。默认情况下，文件由所有者可读写，并由组和全局用户可读。
- en: I mentioned that the data to write can be either a buffer or a string. A string
    cannot handle binary data, so Node provides the buffer, which is capable of dealing
    with either strings or binary data. Both can be used in all of the filesystem
    functions discussed in this section, but you’ll need to explicitly convert between
    the two types if you want to use them both.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到，要写入的数据可以是缓冲区或字符串。字符串不能处理二进制数据，因此Node提供了缓冲区，可以处理字符串或二进制数据。这两者都可以在本节讨论的所有文件系统函数中使用，但如果要同时使用它们，就需要明确地在两种类型之间进行转换。
- en: 'For example, instead of providing the *utf8* `encoding` option when you use
    `writeFile()`, you convert the string to a buffer, providing the desired encoding
    when you do:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在使用`writeFile()`时，不提供*utf8*的`encoding`选项，而是将字符串转换为缓冲区，并在这样做时提供所需的编码：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The reverse—that is, to convert the buffer to a string—is just as simple:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 反之，将缓冲区转换为字符串同样简单：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The buffer `toString()` function has three optional parameters: encoding, where
    to begin the conversion, and where to end it. By default, the entire buffer is
    converted using the *utf8* encoding.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区的`toString()`函数有三个可选参数：编码、开始转换的位置和结束转换的位置。默认情况下，整个缓冲区使用*utf8*编码进行转换。
- en: 'The `readFile()`, `writeFile()`, and `appendFile()` functions are *asynchronous*,
    meaning they won’t wait for the operation to finish before proceeding in the code.
    This is essential when it comes to notoriously slow operations such as file access.
    There are synchronous versions of each: `readFileSync()`, `writeFileSync()`, and
    `appendFileSync()`. I can’t stress enough that you should *not* use these variations.
    I only include a reference to them to be comprehensive.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`readFile()`、`writeFile()`和`appendFile()`函数是*异步*的，这意味着它们在继续执行代码之前不会等待操作完成。在处理诸如文件访问等速度慢的操作时，这是至关重要的。每个函数还有同步版本：`readFileSync()`、`writeFileSync()`和`appendFileSync()`。我强调不应使用这些同步版本。我只是全面起见才提到它们。'
- en: Advanced
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级
- en: Another way to read or write from a file is to use the `open()` function in
    combination with `read()` for reading the file contents, or `write()` for writing
    to the file. The advantages to this approach is more finite control of what happens
    during the process. The disadvantage is the added complexity associated with all
    of the functions, including only being able to use a buffer for reading from and
    writing to the file.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件中读取或写入的另一种方法是结合使用 `open()` 函数和 `read()` 用于读取文件内容，或 `write()` 用于写入文件。这种方法的优点是在过程中有更精细的控制。缺点是与所有函数相关的额外复杂性，包括只能使用缓冲区进行文件的读取和写入。
- en: 'The parameters for `open()` are:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`open()` 的参数包括：'
- en: Filename and path
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件名和路径
- en: Flag
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标志
- en: Optional mode
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选模式
- en: Callback function
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调函数
- en: 'The same `open()` is used with all operations, with the *flag* controlling
    what happens. There are quite a few flag options, but the ones that interest us
    the most at this time are:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 所有操作都使用相同的 `open()`，标志控制发生的情况。有很多标志选项，但这时我们最感兴趣的是：
- en: '`r`'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`r`'
- en: Opens the file for reading; the file must exist
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件以供读取；文件必须存在
- en: '`r`+'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`r`+'
- en: Opens the file for reading and writing; an exception occurs if the file doesn’t
    exist
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件以供读取和写入；如果文件不存在则引发异常
- en: '`w`'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`w`'
- en: Opens the file for writing, truncates the file, or creates it if it doesn’t
    exist
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件以供写入，如果文件存在则截断文件，否则创建文件
- en: '`wx`'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`wx`'
- en: Opens the file for writing, but fails if the file *does* exist
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件以供写入，但如果文件 *存在* 则失败
- en: '`w`+'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`w`+'
- en: Opens the file for reading and writing; creates the file if it doesn’t exist;
    truncates the file if it exists
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件以供读取和写入；如果文件不存在则创建；如果文件存在则截断文件
- en: '`wx+`'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`wx+`'
- en: Similar to `w+`, but fails if the file exists
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 `w+`，但如果文件存在则失败
- en: '`a`'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`a`'
- en: Opens the file for appending, creates it if it doesn’t exist
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件以供追加，如果文件不存在则创建文件
- en: '`ax`'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`ax`'
- en: Opens the file for appending, fails if the file exists
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件以供追加，如果文件存在则失败
- en: '`a`+'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`a`+'
- en: Opens the file for reading and appending; creates the file if it doesn’t exist
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件以供读取和追加；如果文件不存在则创建文件
- en: '`ax+`'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`ax+`'
- en: Similar to `a+`, but fails if the file exists
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 `a+`，但如果文件存在则失败
- en: 'The mode is the same one mentioned earlier, a value that sets the *sticky*
    and *permission* bits on the file if created, and defaults to `0666`. The callback
    function has two parameters: an error object, if an error occurs, and a *file
    descriptor*, used by subsequent file operations.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 模式与前述相同，设置文件的 *粘性* 和 *权限* 位，如果创建，则默认为 `0666`。回调函数有两个参数：如果发生错误，则为错误对象，否则为 *文件描述符*，用于后续文件操作。
- en: 'The `read()` and `write()` functions share the same basic types of parameters:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`read()` 和 `write()` 函数共享相同类型的基本参数：'
- en: The `open()` methods callback file descriptor
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`open()` 方法回调文件描述符'
- en: The buffer used to either hold data to be written or appended, or read
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于保存待写入或追加的数据或进行读取的缓冲区
- en: The offset where the input/output (I/O) operation begins
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入/输出（I/O）操作开始的偏移量
- en: The buffer length (set by read operation, controls write operation)
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓冲区长度（由读取操作设置，控制写入操作）
- en: Position in the file where the operation is to take place; *null* if the position
    is the current position
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作将进行的文件位置；如果位置是当前位置则为 *null*
- en: 'The callback functions for both methods have three arguments: an error, bytes
    read (or written), and the buffer.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法的回调函数都有三个参数：一个错误、读取（或写入）的字节数和缓冲区。
- en: That’s a lot of parameters and options. The best way to demonstrate how it all
    works is to create a complete Node application that opens a brand new file for
    writing, writes some text to it, writes some more text to it, and then reads all
    the text back and prints it to the `console`. Since `open()` is asynchronous,
    the read and write operations have to occur within the callback function. Be ready
    for it in [Example 17-2](#testing_read_write), because you’re going to get your
    first taste of a concept known as *callback hell*.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这是很多参数和选项。展示如何运作的最佳方式是创建一个完整的 Node 应用程序，用于打开一个全新的文件进行写入，写入一些文本，再写入一些文本，然后读取所有文本并打印到
    `console` 中。由于 `open()` 是异步的，读取和写入操作必须在回调函数内进行。在 [示例 17-2](#testing_read_write)
    中准备好，因为你将首次体验到被称为 *回调地狱* 的概念。
- en: Example 17-2\. Demonstrating open, read, and write
  id: totrans-171
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-2\. 展示打开、读取和写入操作
- en: '[PRE25]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-173
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Taming callbacks is covered in [“Managing Callback Hell”](ch19.html#managing_callback_hell).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 驯服回调函数在 [“管理回调地狱”](ch19.html#managing_callback_hell) 中有介绍。
- en: To find the length of the buffers, I used `length`, which returns the number
    of bytes for the buffer. This value doesn’t necessarily match the length of a
    string in the buffer, but it does work in this usage.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出缓冲区的长度，我使用了`length`，它返回缓冲区的字节数。这个值不一定与缓冲区中字符串的长度匹配，但在这种用法中起作用。
- en: That many levels of indentation can make your skin crawl, but the example demonstrates
    how `open()`, `read()`, and `write()` work. These combinations of functions are
    what’s used within the `readFile()`, `writeFile()`, and `appendFile()` functions
    to manage file access. The higher-level functions just simplify the most common
    file operations.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 那么多级缩进可能会让您毛骨悚然，但该示例演示了`open()`、`read()`和`write()`的工作方式。这些函数的组合是在`readFile()`、`writeFile()`和`appendFile()`函数中用于管理文件访问的。高级函数只是简化了最常见的文件操作。
- en: Note
  id: totrans-177
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: See [“Managing Callback Hell”](ch19.html#managing_callback_hell) for a solution
    to all that nasty indentation.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[“管理回调地狱”](ch19.html#managing_callback_hell)以解决所有这些恶心的缩进问题。
- en: Getting Input from the Terminal
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从终端获取输入
- en: Problem
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to get input from the application user via the terminal.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望通过终端从应用程序用户获取输入。
- en: Solution
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use Node’s Readline module.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Node的Readline模块。
- en: 'To get data from the standard input, use code such as the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要从标准输入获取数据，请使用以下代码：
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Discussion
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The Readline module provides the ability to get lines of text from a readable
    stream. You start by creating an instance of the Readline interface with `createInterface()`
    passing in, at minimum, the readable and writable streams. You need both, because
    you’re writing prompts, as well as reading in text. In the solution, the input
    stream is `process.stdin`, the standard input stream, and the output stream is
    `process.stdout`. In other words, input and output are from, and to, the command
    line.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Readline模块提供了从可读流获取文本行的能力。您首先通过`createInterface()`创建Readline接口的实例，至少传入可读和可写流。您两者都需要，因为您既要写入提示，又要读取文本。在解决方案中，输入流是`process.stdin`，标准输入流，而输出流是`process.stdout`。换句话说，输入和输出来自命令行。
- en: The solution uses the `question()` function to post a question, and provides
    a callback function to process the response. Within the function, `close()` is
    called, which closes the interface, releasing control of the input and output
    streams.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案使用`question()`函数发布问题，并提供回调函数来处理响应。在函数内部，调用了`close()`，它关闭接口，释放输入和输出流的控制权。
- en: You can also create an application that continues to listen to the input, taking
    some action on the incoming data, until something signals the application to end.
    Typically that something is a letter sequence signaling the person is done, such
    as the word *exit*. This type of application makes use of other Readline functions,
    such as `setPrompt()` to change the prompt given the individual for each line
    of text; `prompt()`, which prepares the input area, including changing the prompt
    to the one set by `setPrompt()`; and `write()`, to write out a prompt. In addition,
    you’ll also need to use event handlers to process events, such as `line`, which
    listens for each new line of text.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以创建一个应用程序，继续监听输入，对传入的数据采取一些操作，直到某些信号结束应用程序。通常，这个信号是一系列信号，表示个人已经完成，比如*exit*这个词。这种类型的应用程序还使用其他Readline函数，如`setPrompt()`用于根据每行文本为个人设置提示；`prompt()`准备输入区域，包括更改为`setPrompt()`设置的提示；以及`write()`，用于写出提示。此外，您还需要使用事件处理程序来处理事件，例如`line`，它监听每一行新的文本。
- en: '[Example 17-3](#continuous_loop_of_text) contains a complete Node application
    that continues to process input from the user until they type in `exit`. Note
    that the application makes use of `process.exit()`. This function cleanly terminates
    the Node application.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 17-3](#continuous_loop_of_text)包含一个完整的Node应用程序，该应用程序继续从用户那里处理输入，直到他们输入`exit`。请注意，该应用程序利用了`process.exit()`。这个函数干净地终止了Node应用程序。'
- en: Example 17-3\. Access numbers from stdin until the user types in *exit*
  id: totrans-191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例17-3. 从stdin访问数字，直到用户键入*exit*
- en: '[PRE27]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Running the application with several numbers results in the following output:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序时，使用多个数字会产生以下输出：
- en: '[PRE28]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: I used `console.log()` rather than the Readline interface `write()` to write
    the prompt, followed by a new line, and to differentiate the output from the input.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了`console.log()`而不是Readline接口的`write()`来写入提示，后面跟一个新行，以区分输出和输入。
- en: See Also
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Chapter 19](ch19.html#ch19) covers passing and reading command-line arguments
    in Node applications.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[第19章](ch19.html#ch19)涵盖了在 Node 应用程序中传递和读取命令行参数。'
- en: Getting the Path to the Current Script
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取当前脚本的路径
- en: Problem
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Your application needs to read the path of the script that is being executed.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序需要读取正在执行的脚本的路径。
- en: Solution
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use the `__dirname` or `__filename` variables, which are in the scope of the
    module executing it:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`__dirname`或`__filename`变量，它们在执行模块的作用域中：
- en: '[PRE29]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Discussion
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'The `__dirname` or `__filename` variables appear to be in the global scope,
    but they actually exist in the scope of the module itself. Let’s assume that you
    have a project with the following directory structure:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`__dirname`或`__filename`变量看起来在全局范围内，但它们实际上存在于模块本身的作用域中。假设你有以下目录结构的项目：'
- en: '[PRE30]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If you were to read the `__dirname` in the index.js file, it would be the path
    to the project’s root directory. However, reading the `__dirname` in from a script
    in the *nested.js* file would read the path to the *dir3* directory. This allows
    you to read the path of a module as it’s executed, rather than being limited to
    the parent directory itself.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 index.js 文件中读取`__dirname`，它将是项目根目录的路径。然而，如果在 *nested.js* 文件中从脚本中读取`__dirname`，它将读取到
    *dir3* 目录的路径。这使得你可以在模块执行时读取模块的路径，而不仅仅是限于父目录本身。
- en: 'A useful example of `__dirname` in action is when creating a new file or directory
    within the current directory. In the following example, the script creates a new
    subdirectory named *cache* within the current file’s directory:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`__dirname`在创建当前目录内的新文件或目录时的一个有用的示例。在下面的示例中，脚本在当前文件的目录中创建一个名为*cache*的新子目录：'
- en: '[PRE31]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Working with Node Timers and Understanding the Node Event Loop
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Node 定时器和理解 Node 事件循环
- en: Problem
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to use a timer in a Node application, but you’re not sure which of
    Node’s three timers to use, or how accurate they are.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在 Node 应用程序中使用定时器，但是你不确定应该使用 Node 的哪个定时器，或者它们有多精确。
- en: Solution
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'If your timer doesn’t have to be precise, you can use `setTimeout()` to create
    a single timer event, or `setInterval()` if you want a reccurring timer:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的定时器不需要很精确，你可以使用`setTimeout()`来创建单个定时器事件，或者如果你需要一个重复的定时器，可以使用`setInterval()`：
- en: '[PRE32]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Both function timers can be canceled:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个定时器函数都可以被取消：
- en: '[PRE33]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'However, if you need more finite control of your timer, and immediate results,
    you might want to use `setImmediate()`. You don’t specify a delay for it, as you
    want the callback to be invoked *immediately* after all I/O callbacks are processed
    but before any `setTimeout()` or `setInterval()` callbacks:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你需要更精细地控制你的定时器，并且需要立即得到结果，你可能想要使用`setImmediate()`。你不需要为它指定延迟，因为你希望回调在所有
    I/O 回调处理完毕之后但是在任何`setTimeout()`或`setInterval()`回调之前*立即*被调用：
- en: '[PRE34]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: It, too, can be cleared, with `clearImmediate()`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以通过`clearImmediate()`清除。
- en: Discussion
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Node, being JavaScript based, runs on a single thread. It is *synchronous*.
    However, input/output (I/O) and other native API access either runs *asynchronously*
    or on a separate thread. Node’s approach to managing this timing disconnect is
    the *event loop*.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Node，作为基于 JavaScript 的运行在单线程上。它是*同步*的。然而，输入/输出（I/O）和其他本机 API 访问是*异步*的或在单独的线程上运行。Node
    处理这种时间上的不连续性的方法是*事件循环*。
- en: In your code, when you perform an I/O operation, such as writing a chunk of
    text to a file, you specify a callback function to do any post-write activity.
    Once you’ve done so, the rest of your application code is processed. It doesn’t
    wait for the file write to finish. When the file write has finished, an event
    signaling the fact is returned to Node, and pushed on to a queue, waiting for
    processing. Node processes this event queue, and when it gets to the event signaled
    by the completed file write, it matches the event to the callback, and the callback
    is processed.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的代码中，当你执行 I/O 操作时，比如向文件写入文本块，你会指定一个回调函数来处理写入后的活动。一旦你这样做了，剩下的应用程序代码就会被处理。它不会等待文件写入完成。当文件写入完成时，会返回一个事件来通知
    Node，并被推送到一个队列中等待处理。Node 处理这个事件队列，当它处理到完成文件写入的事件时，它将该事件与回调匹配，并处理该回调。
- en: As a comparison, think of going into a deli and ordering lunch. You wait in
    line to place your order, and are given an order number. You sit down and read
    the paper, or check your Twitter account while you wait. In the meantime, the
    lunch orders go into another queue for deli workers to process the orders. But
    each lunch request isn’t always finished in the order received. Some lunch orders
    may take longer. They may need to bake or grill for a longer time. So the deli
    worker processes your order by preparing your lunch item and then placing it in
    an oven, setting a timer for when it’s finished, and goes on to other tasks.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 作为比较，想象一下走进一家快餐店并点午餐。你排队等候下单，并被分配一个订单号。你坐下来看报纸，或者查看 Twitter 账户等待。与此同时，午餐订单进入另一个队列，供快餐店员工处理订单。但并不是每个午餐请求都会按接收顺序完成。有些午餐订单可能需要更长时间。它们可能需要更长时间烘烤或烤制。因此，快餐店员工通过准备您的午餐项目然后将其放入烤箱，并设置一个定时器以便完成后通知您，然后继续其他任务。
- en: When the timer pings, the deli worker quickly finishes their current task, and
    pulls your lunch order from the oven. You’re then notified that your lunch is
    ready for pickup by your order number being called out. If several time-consuming
    lunch items are being processed at the same time, the deli worker processes them
    as the timer for each item pings, in order.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当定时器触发时，快餐店员工迅速完成当前任务，并从烤箱中取出您的午餐订单。然后通过呼叫您的订单号来通知您可以取餐。如果同时处理多个耗时的午餐项目，则快餐店员工会按顺序处理每个项目的定时器触发。
- en: 'All Node processes fit the pattern of the deli order queue: first in, first
    to be sent to the deli (thread) workers. However, certain operations, such as
    I/O, are like those lunch orders that need extra time to bake in an oven or grill,
    but don’t require the deli worker to stop any other effort and wait for the baking
    and grilling. The oven or grill timers are equivalent to the messages that appear
    in the Node event loop, triggering a final action based on the requested operation.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的 Node 进程都符合快餐店订单队列的模式：先进先出发送到快餐店（线程）工人。但是，某些操作（如 I/O 操作）就像那些需要额外时间在烤箱或烤架中烘烤的午餐订单，但不需要快餐店员工停止任何其他工作等待烘烤和烤制。烤箱或烤架定时器相当于在
    Node 事件循环中出现的消息，触发基于请求操作的最终动作。
- en: You now have a working blend of synchronous and asynchronous processes. But
    what happens with a timer?
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你拥有了同步和异步进程的工作混合体。但是定时器会发生什么呢？
- en: 'Both `setTimeout()` and `setInterval()` fire after the given delay, but what
    happens is a message to this effect is added to the event loop, to be processed
    in turn. So if the event loop is particularly cluttered, there is a delay before
    the the timer functions’ callbacks are called:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`setTimeout()` 和 `setInterval()` 都在给定的延迟后触发，但实际上是将消息添加到事件循环中，按顺序处理。因此，如果事件循环特别拥挤，定时器函数的回调会有延迟：'
- en: It is important to note that your callback will probably not be called in exactly
    (delay) milliseconds. Node.js makes no guarantees about the exact timing of when
    the callback will fire, nor of the ordering things will fire in. The callback
    will be called as close as possible to the time specified.
  id: totrans-229
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 需要注意的是，你的回调函数可能不会在准确的（延迟）毫秒内调用。Node.js 不保证回调函数触发的确切时间，也不保证触发顺序。回调函数会尽可能接近指定的时间调用。
- en: ''
  id: totrans-230
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Node Timers documentation
  id: totrans-231
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Node 定时器文档
- en: For the most part, whatever delay happens is beyond the kin of our human senses,
    but it can result in animations that don’t seem to run smoothly. It can also add
    an odd effect to other applications.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，发生的延迟超出了我们的感知能力，但可能导致看起来不流畅的动画。它也可能给其他应用程序添加一个奇怪的效果。
- en: 'In [Example 17-4](#feeding_scrolling_timeline), I created a scrolling timeline
    in SVG, with data fed to the client via WebSockets. To emulate real-world data,
    I used a three-second timer and randomly generated a number to act as a data value.
    In the server code, I used `setInterval()`, because the timer is reccurring:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 17-4](#feeding_scrolling_timeline) 中，我创建了一个 SVG 滚动时间轴，通过 WebSockets 将数据提供给客户端。为了模拟真实世界的数据，我使用了一个三秒的定时器，并随机生成一个数作为数据值。在服务器端的代码中，我使用了
    `setInterval()`，因为定时器是循环的：
- en: Example 17-4\. Scrolling timeline example
  id: totrans-234
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-4\. 滚动时间轴示例
- en: '[PRE35]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: I included `console.log()` to call in the code so you can see the timer event
    in comparison to the communication responses. When the `setInterval()` function
    is called, it’s pushed into the process. When its callback is processed, the WebSocket
    communications are also pushed into the queue.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我在代码中包含了 `console.log()` 调用，这样你就可以看到计时器事件与通信响应的比较。当调用 `setInterval()` 函数时，它被推送到进程中。当处理其回调时，WebSocket
    通信也被推送到队列中。
- en: The solution uses `setInterval()`, one of Node’s three different types of timers.
    The `setInterval()` function has the same format as the one we use in the browser.
    You specify a callback for the first function, provide a delay time (in milliseconds),
    and any potential arguments. The timer is going to fire in three seconds, but
    we already know that the callback for the timer may not be immediately processed.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案使用了 `setInterval()`，这是 Node 的三种不同类型计时器之一。`setInterval()` 函数的格式与我们在浏览器中使用的格式相同。你为第一个函数指定一个回调，提供延迟时间（以毫秒为单位），以及任何潜在的参数。计时器将在三秒后触发，但我们已经知道计时器的回调可能不会立即被处理。
- en: 'The same applies to the callbacks passed in the WebSocket `sendText()` calls.
    These are based on Node’s Net (or TLS, if secure) sockets, and as the `socket.write()`
    (what’s used for `sendText()`) documentation notes:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 与 WebSocket `sendText()` 调用中传递的回调函数一样。这些基于 Node 的 Net（或者如果安全的话，是 TLS）套接字，正如
    `socket.write()`（用于 `sendText()` 的内容）文档所述：
- en: The optional callback parameter will be executed when the data is finally written
    out—this may not be immediately.
  id: totrans-239
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 可选的回调参数将在数据最终写出时执行 — 这可能不会立即发生。
- en: ''
  id: totrans-240
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Node documentation
  id: totrans-241
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Node 文档
- en: If you set the timer to invoke immediately (giving zero as the delay value),
    you’ll see that the data sent message is interspersed with the communication sent
    message (before the browser client freezes up, overwhelmed by the socket communications—you
    don’t want to use a zero value in the application again).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将计时器设置为立即调用（将延迟值设为零），你会看到发送的数据消息与通信发送消息交错（在浏览器客户端由于套接字通信而冻结之前，你不希望在应用程序中再次使用零值）。
- en: However, the timelines for all the clients remain the same because the communications
    are sent within the timer’s callback function, *synchronously*, so the data is
    the same for all of the communications—it’s just the callbacks that are handled,
    seemingly out of order.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，所有客户端的时间表保持不变，因为通信是在计时器的回调函数中*同步*发送的，所以所有通信的数据都是相同的 — 只是回调处理似乎是无序的。
- en: Earlier I mentioned using `setInterval()` with a delay of zero. In actuality,
    it isn’t exactly zero—Node follows the HTML5 specification that browsers adhere
    to, and “clamps” the timer interval to a minimum value of four milliseconds. While
    this may seem to be too small of an amount to cause a problem, when it comes to
    animations and time-critical processes, the time delay can impact the overall
    appearance and/or function.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过使用延迟为零的 `setInterval()`。实际上，它并不完全是零 — Node 遵循浏览器遵循的 HTML5 规范，并将计时器间隔“夹紧”到最小值四毫秒。虽然这看似过小以至于不会引起问题，但对于动画和时间关键的进程而言，时间延迟可能会影响整体的外观和/或功能。
- en: To bypass the constraints, Node developers utilize Node’s `process.nextTick()`
    instead. The callback associated with `process.nextTick()` is processed on the
    next event loop go around, usually before any I/O callbacks (though there are
    constraints, which I’ll get to in a minute). No more pesky four-millisecond throttling.
    But then, what happens if there’s an enormous number of recursively called `process.nextTick()`
    calls?
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绕过这些约束，Node 开发者使用 Node 的 `process.nextTick()`。与 `process.nextTick()` 关联的回调会在下一个事件循环回合中处理，通常在任何
    I/O 回调之前（虽然有一些限制，我马上会讲到）。不再有讨厌的四毫秒节流了。但是，如果有大量递归调用 `process.nextTick()`，会发生什么呢？
- en: To return to our deli analogy, during a busy lunch hour, workers can be overrun
    with orders and so caught up in trying to process new orders that they don’t respond
    in a timely manner to the oven and grill pings. Things burn when this happens.
    If you’ve ever been to a well-run deli, you’ll notice the counter person taking
    the orders will assess the kitchen before taking the order, tossing in some slight
    delay, or even taking on some of the kitchen duties, letting the people wait just
    a tiny bit longer in the order queue.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的熟食店比喻，在忙碌的午餐时间，工作人员可能被订单压倒，全神贯注于处理新订单，以至于无法及时响应烤箱和烧烤的提示。这时候事物就会烧焦。如果你去过一个运营良好的熟食店，你会注意到接单的服务员在接受订单之前会评估厨房情况，稍微拖延一下，甚至承担一些厨房职责，让顾客在订单队列中稍微等待久一点。
- en: The same happens with Node. If `process.nextTick()` were allowed to be the spoiled
    child, always getting its way, I/O operations would get starved out. Node uses
    another value, `process.maxTickDepth`, with a default value of 1000 to constrain
    the number of `process.next()` callbacks that are processed before the I/O callbacks
    are allowed to play. It’s the counter person in the deli.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Node 也是如此。如果 `process.nextTick()` 被允许一直处于受宠的地位，I/O 操作将会被饿死。Node 使用另一个值 `process.maxTickDepth`，默认值为
    1000，来限制在允许 I/O 回调之前处理的 `process.next()` 回调数量。这就像是熟食店中的服务员。
- en: In more recent releases of Node, the `setImmediate()` function was added. This
    function attempts to resolve all of the issues associated with the timing operations
    and create a happy medium that should work for most folks. When `setImmediate()`
    is called, its callback is added after the I/O callbacks, but before the `setTimeout()`
    and `setInterval()` callbacks. We don’t have the four-millisecond tax for the
    traditional timers, but we also don’t have the brat that is `process.nextTick()`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node 的更新版本中，添加了 `setImmediate()` 函数。此函数试图解决与定时操作相关的所有问题，并创建一个适合大多数人的良好平衡点。调用
    `setImmediate()` 时，其回调将在 I/O 回调之后但在 `setTimeout()` 和 `setInterval()` 回调之前添加。我们不需要传统定时器的四毫秒税，但也不需要
    `process.nextTick()` 这个顽皮的家伙。
- en: To return one last time to the deli analogy, `setImmediate()` is a customer
    in the order queue who sees that the deli workers are overwhelmed with pinging
    ovens, and politely states they’ll wait to give their order.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 再次回到熟食店的比喻中，`setImmediate()` 就像是订单队列中的一个顾客，看到熟食店工作人员忙于处理烤箱和烧烤的提示，礼貌地表示他们愿意等待以便让出订单。
- en: Caution
  id: totrans-250
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: However, you do *not* want to use `setImmediate()` in the scrolling timeline
    example, as it will freeze your browser up faster than you can blink.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在滚动时间轴示例中，*千万不要*使用 `setImmediate()`，因为它会比你眨眼的速度更快地让你的浏览器冻结起来。
