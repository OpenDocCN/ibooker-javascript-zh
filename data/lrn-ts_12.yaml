- en: Chapter 10\. Generics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章 泛型
- en: Variables you
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: declare in the type system?
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在类型系统中声明？
- en: ''
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A whole new (typed) world!
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 全新的（类型化）世界！
- en: All the type syntaxes you’ve learned about so far are meant to be used with
    types that are completely known when they’re being written. Sometimes, however,
    a piece of code may be intended to work with various different types depending
    on how it’s called.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您学到的所有类型语法都是用于在编写时完全知道它们的类型的类型。但有时，一段代码可能旨在根据调用方式与不同类型一起工作。
- en: Take this `identity` function in JavaScript meant to receive an input of any
    possible type and return that same input as output. How would you describe its
    parameter type and return type?
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 拿这个 `identity` 函数作为例子，在 JavaScript 中，它意味着接收任何可能类型的输入，并将相同的输入作为输出返回。您将如何描述其参数类型和返回类型？
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We could declare `input` as `any`, but then the return type of the function
    would also be `any`:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 `input` 声明为 `any`，但那么函数的返回类型也将是 `any`：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Given that `input` is allowed to be any input, we need a way to say that there
    is a relationship between the `input` type and the type the function returns.
    TypeScript captures relationships between types using *generics*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于 `input` 可以是任何输入，我们需要一种方式来表明 `input` 类型与函数返回的类型之间存在关系。TypeScript 使用 *泛型* 来捕获类型之间的关系。
- en: 'In TypeScript, constructs such as functions may declare any number of generic
    *type parameters*: types that are determined for each usage of the generic construct.
    These type parameters are used as types in the construct to represent some type
    that can be different in each instance of the construct. Type parameters may be
    provided with different types, referred to as *type arguments*, for each instance
    of the construct but will remain consistent within that instance.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 中，诸如函数之类的构造物可以声明任意数量的泛型 *类型参数*：这些类型参数用作构造物中的类型，以表示每个实例中可以不同的某种类型。类型参数可以为构造物的每个实例提供不同的类型，称为
    *类型参数*，但在该实例内部保持一致。
- en: Type parameters typically have single-letter names like `T` and `U` or PascalCase
    names like `Key` and `Value`. In all of the constructs covered in this chapter,
    generics may be declared using `<` and `>` brackets, like `someFunction<T>` or
    `SomeInterface<T>`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 类型参数通常使用像`T`和`U`这样的单字母名称，或者像`Key`和`Value`这样的帕斯卡命名。在本章涵盖的所有结构中，泛型可以使用`<`和`>`括号声明，例如`someFunction<T>`或`SomeInterface<T>`。
- en: Generic Functions
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型函数
- en: A function may be made generic by placing an alias for a type parameter, wrapped
    in angle brackets, immediately before the parameters parentheses. That type parameter
    will then be available for usage in parameter type annotations, return type annotations,
    and type annotations inside the function’s body.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以通过在参数括号之前的尖括号内放置类型参数的别名来进行泛型化。该类型参数随后可用于参数类型注释、返回类型注释以及函数体内的类型注释。
- en: 'The following version of `identity` declares a type parameter `T` for its `input`
    parameter, which allows TypeScript to infer that the return type of the function
    is `T`. TypeScript can then infer a different type for `T` every time `identity`
    is called:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 下面版本的 `identity` 声明了一个类型参数 `T` 用于其 `input` 参数，这使得 TypeScript 能够推断函数的返回类型为 `T`。每次调用
    `identity` 时，TypeScript 可以推断出不同的 `T` 类型：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Arrow functions can be generic too. Their generic declarations are also placed
    immediately before the `(` before their list of parameters.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数也可以是泛型的。它们的泛型声明也放置在其参数列表之前的 `(` 之前。
- en: 'The following arrow function is functionally the same as the previous declaration:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下箭头函数在功能上与前面的声明相同：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Warning
  id: totrans-21
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: The syntax for generic arrow functions has some restrictions in *.tsx* files,
    as it conflicts with JSX syntax. See [Chapter 13, “Configuration Options”](ch13.xhtml#configuration_options)
    for workarounds as well as configuring JSX and React support.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型箭头函数的语法在 *.tsx* 文件中有一些限制，因为它与 JSX 语法冲突。参见[第13章，“配置选项”](ch13.xhtml#configuration_options)以获取解决方法，以及配置
    JSX 和 React 支持。
- en: Adding type parameters to functions in this way allows them to be reused with
    different inputs while still maintaining type safety and avoiding `any` types.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式向函数添加类型参数，可以使其能够在不同的输入下重复使用，同时保持类型安全，并避免使用`any`类型。
- en: Explicit Generic Call Types
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显式泛型调用类型
- en: Most of the time when calling generic functions, TypeScript will be able to
    infer type arguments based on how the function is being called. For example, in
    the previous examples’ `identity` functions, TypeScript’s type checker used an
    argument provided to `identity` to infer the corresponding function parameter’s
    type argument.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，在调用泛型函数时，TypeScript 将能够根据函数调用的方式推断出类型参数。例如，在前面示例中的 `identity` 函数中，TypeScript
    的类型检查器使用提供给 `identity` 的参数来推断相应的函数参数类型参数。
- en: Unfortunately, as with class members and variable types, sometimes there isn’t
    enough information from a function’s call to inform TypeScript what its type argument
    should resolve to. This will commonly happen if a generic construct is provided
    another generic construct whose type arguments aren’t known.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，与类成员和变量类型一样，有时从函数调用中没有足够的信息来告诉 TypeScript 其类型参数应该解析为什么。如果泛型结构提供了其类型参数未知的另一个泛型结构，这种情况通常会发生。
- en: TypeScript will default to assuming the `unknown` type for any type argument
    it cannot infer.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于无法推断其类型参数的任何类型参数，TypeScript 将默认为 `unknown` 类型。
- en: 'For example, the following `logWrapper` function takes in a callback with a
    parameter type set to `logWrapper`’s type parameter `Input`. TypeScript can infer
    the type argument if `logWrapper` is called with a callback that explicitly declares
    its parameter type. If the parameter type is implicit, however, TypeScript has
    no way of knowing what `Input` should be:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下面的 `logWrapper` 函数接受一个带有参数类型设置为 `logWrapper` 的类型参数 `Input` 的回调函数。如果 `logWrapper`
    被调用时带有明确声明其参数类型的回调函数，TypeScript 可以推断出类型参数。然而，如果参数类型是隐式的，TypeScript 将无法知道 `Input`
    应该是什么类型：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To avoid defaulting to `unknown`, functions may be called with an explicit generic
    type argument that explicitly tells TypeScript what that type argument should
    be instead. TypeScript will perform type checking on the generic call to make
    sure the parameter being requested matches up to what’s provided as a type argument.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免默认为 `unknown`，函数可以以显式的泛型类型参数调用，明确告诉 TypeScript 应该将该类型参数解析为什么。TypeScript
    将对泛型调用执行类型检查，以确保请求的参数与提供的类型参数匹配。
- en: 'Here, the `logWrapper` seen previously is provided with an explicit `string`
    for its `Input` generic. TypeScript can then infer that the callback’s `input`
    parameter of generic type `Input` resolves to type `string`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，之前看到的 `logWrapper` 被提供了一个显式的 `string` 作为其 `Input` 泛型。然后 TypeScript 可以推断出回调函数的
    `input` 参数的泛型类型 `Input` 解析为 `string` 类型：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Much like explicit type annotations on variables, explicit type arguments may
    always be specified on a generic function but often aren’t necessary. Many TypeScript
    developers generally only specify them when needed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在变量上明确指定类型注解一样，泛型函数上也可以始终指定明确的类型参数，但通常并不是必需的。许多 TypeScript 开发人员通常只在需要时才指定它们。
- en: 'The following `logWrapper` usage explicitly specifies `string` both as a type
    argument and as a function parameter type. Either could be removed:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的 `logWrapper` 使用明确指定了 `string` 作为类型参数和函数参数类型。两者都可以移除：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `Name<Type>` syntax for specifying a type argument will be the same for
    other generic constructs throughout this chapter.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 用于指定类型参数的 `Name<Type>` 语法将与本章节中的其他泛型结构相同。
- en: Multiple Function Type Parameters
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多个函数类型参数
- en: Functions may define any number of type parameters, separated by commas. Each
    call of the generic function may resolve its own set of values for each of the
    type parameters.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以定义任意数量的类型参数，用逗号分隔。泛型函数的每次调用可以为其类型参数解析其自己的一组值。
- en: 'In this example, `makeTuple` declares two type parameters and returns a value
    typed as a read-only tuple with one, then the other:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`makeTuple` 声明了两个类型参数，并返回一个以只读元组的形式分别为一个，然后另一个的值为类型化的值：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that if a function declares multiple type parameters, calls to that function
    must explicitly declare either none of the generic types or all of them. TypeScript
    does not yet support inferring only some of the types of a generic call.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果函数声明了多个类型参数，调用该函数时必须明确声明泛型类型的全部或不含任何泛型类型。TypeScript 尚不支持仅推断泛型调用中的某些类型。
- en: 'Here, `makePair` also takes in two type parameters, so either neither of them
    or both of them must be explicitly specified:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`makePair` 也接受两个类型参数，因此要么两者都不明确指定，要么都明确指定：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Tip
  id: totrans-44
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Try not to use more than one or two type parameters in any generic construct.
    As with runtime function parameters, the more you use, the harder it is to read
    and understand the code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量不要在任何通用结构中使用超过一个或两个类型参数。与运行时函数参数一样，使用越多，代码的可读性和理解性就越差。
- en: Generic Interfaces
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型接口
- en: 'Interfaces may be declared as generic as well. They follow similar generic
    rules to functions: they may have any number of type parameters declared between
    a `<` and `>` after their name. That generic type may later be used elsewhere
    in their declaration, such as on member types.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接口也可以声明为通用的。它们遵循与函数类似的通用规则：它们可以在名称后的`<`和`>`之间声明任意数量的类型参数。该通用类型可以稍后在其声明的其他位置使用，例如在成员类型中。
- en: 'The following `Box` declaration has a `T` type parameter for a property. Creating
    an object declared to be a `Box` with a type argument enforces that the `inside:
    T` property matches that type argument:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '下面的`Box`声明具有`T`类型参数作为属性。使用类型参数声明为`Box`的对象强制`inside: T`属性与该类型参数匹配：'
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Fun fact: the built-in `Array` methods are defined in TypeScript as a generic
    interface! `Array` uses a type parameter `T` to represent the type of data stored
    within an array. Its `pop` and `push` methods look roughly like so:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的事实：内置的`Array`方法在TypeScript中被定义为通用接口！ `Array`使用类型参数`T`来表示数组中存储的数据类型。其`pop`和`push`方法大致如下：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Inferred Generic Interface Types
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 推断泛型接口类型
- en: As with generic functions, generic interface type arguments may be inferred
    from usage. TypeScript will do its best to infer type arguments from the types
    of values provided to a location declared as taking in a generic type.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 与通用函数一样，通用接口类型参数可以从使用中推断出。 TypeScript 将尽其所能从声明为接受通用类型的位置提供的值的类型推断类型参数。
- en: 'This `getLast` function declares a type parameter `Value` that is then used
    for its `node` parameter. TypeScript can then infer `Value` based on the type
    of whatever value is passed in as an argument. It can even report a type error
    when an inferred type argument doesn’t match the type of a value. Providing `getLast`
    with an object that doesn’t include `next`, or whose inferred `Value` type argument
    is the same type, is allowed. Mismatching the provided object’s `value` and `next.value`,
    though, is a type error:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此`getLast`函数声明了一个类型参数`Value`，然后用于其`node`参数。 TypeScript 可以根据传入参数的类型推断出`Value`。当推断出的类型参数与值的类型不匹配时，甚至可以报告类型错误。允许向`getLast`提供不包含`next`属性的对象，或其推断出的`Value`类型参数与给定对象的`value`和`next.value`不匹配是允许的，但是，这是一个类型错误：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Note that if an interface declares type parameters, any type annotations referring
    to that interface must provide corresponding type arguments. Here, the usage of
    `CrateLike` is incorrect for not including a type argument:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果接口声明了类型参数，则任何引用该接口的类型注释都必须提供相应的类型参数。在这里，对`CrateLike`的使用不正确，因为没有包含类型参数：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Later in this chapter, I’ll show how to provide default values for type parameters
    to get around this requirement.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面，我将展示如何为类型参数提供默认值，以避免此要求。
- en: Generic Classes
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型类
- en: Classes, like interfaces, can also declare any number of type parameters to
    be later used on members. Each instance of the class may have a different set
    of type arguments for its type parameters.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 类，就像接口一样，也可以声明任意数量的类型参数，以后可以在其成员上使用。类的每个实例可以具有不同的类型参数集。
- en: 'This `Secret` class declares `Key` and `Value` type parameters, then uses them
    for member properties, constructor parameter types, and a method’s parameter and
    return types:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此`Secret`类声明了`Key`和`Value`类型参数，然后将它们用于成员属性、构造函数参数类型以及方法的参数和返回类型：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As with generic interfaces, type annotations using a class must indicate to
    TypeScript what any generic types on that class are. Later in this chapter, I’ll
    show how to provide default values for type parameters to get around this requirement
    for classes too.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 与通用接口一样，使用类的类型注释必须告诉TypeScript该类上的任何通用类型是什么。在本章的后面，我将展示如何为类提供类型参数的默认值，以避免此要求。
- en: Explicit Generic Class Types
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显式通用类类型
- en: Instantiating generic classes goes by the same type arguments inference rules
    as calling generic functions. If the type argument can be inferred from the type
    of a parameter to the class constructor, such as the `new Secret(12345, "luggage")`
    earlier, TypeScript will use the inferred type. Otherwise, if a class type argument
    can’t be inferred from the arguments passed to its constructor, the type argument
    will default to `unknown`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化泛型类遵循与调用泛型函数相同的类型参数推断规则。如果类型参数可以从传递给类构造函数的参数的类型推断出来，例如之前的 `new Secret(12345,
    "luggage")`，TypeScript 将使用推断类型。否则，如果无法从传递给其构造函数的参数推断出类类型参数，则类型参数将默认为 `unknown`。
- en: 'This `CurriedCallback` class declares a constructor that takes in a generic
    function. If the generic function has a known type—such as from an explicit type
    argument type annotation—then the class instance’s `Input` type argument can be
    informed by it. Otherwise, the class instance’s `Input` type argument will default
    to `unknown`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此 `CurriedCallback` 类声明了一个接受泛型函数的构造函数。如果泛型函数具有已知类型——例如来自显式类型参数类型注释——那么类实例的 `Input`
    类型参数可以由此知情。否则，类实例的 `Input` 类型参数将默认为 `unknown`：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Class instances may also avoid defaulting to `unknown` by providing explicit
    type argument(s) the same way other generic function calls do.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 类实例也可以通过与其他泛型函数调用相同的方式提供显式的类型参数来避免默认为 `unknown`。
- en: 'Here, `CurriedCallback` from before is now being provided with an explicit
    `string` for its `Input` type argument, so TypeScript can infer that the callback’s
    `Input` type parameter resolves to `string`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，之前的 `CurriedCallback` 现在为其 `Input` 类型参数提供了一个显式的 `string`，因此 TypeScript 可以推断出回调的
    `Input` 类型参数解析为 `string`：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Extending Generic Classes
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展泛型类
- en: Generic classes can be used as the base class following an `extends` keyword.
    TypeScript will not attempt to infer type arguments for the base class from usage.
    Any type arguments without defaults will need to be specified using an explicit
    type annotation.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型类可以作为 `extends` 关键字后的基类使用。TypeScript 不会尝试从使用中推断基类的类型参数。任何没有默认值的类型参数都需要使用显式类型注释来指定。
- en: 'The following `SpokenQuote` class provides `string` as the `T` type argument
    for its base class `Quote<T>`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的 `SpokenQuote` 类为其基类 `Quote<T>` 提供了 `string` 作为 `T` 类型参数：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Generic derived classes can alternately pass their own type argument through
    to their base class. The type names don’t have to match; just for fun, this `AttributedQuote`
    passes a differently named `Value` type argument to the base class `Quote<T>`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型派生类可以通过将它们自己的类型参数传递给它们的基类来传递自己的类型参数。类型名称不必匹配；仅仅是为了好玩，这个 `AttributedQuote`
    将一个名为 `Value` 的不同命名的类型参数传递给基类 `Quote<T>`：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Implementing Generic Interfaces
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现泛型接口
- en: 'Generic classes may also implement generic interfaces by providing them any
    necessary type parameters. This works similarly to extending a generic base class:
    any type parameters on the base interface must be declared by the class.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型类也可以通过为其提供任何必要的类型参数来实现泛型接口。这与扩展泛型基类类似：基接口上的任何类型参数必须由类声明。
- en: 'Here, the `MoviePart` class specifies the `ActingCredit` interface’s `Role`
    type argument as `string`. The `IncorrectExtension` class causes a type complaint
    because its `role` is type `boolean` despite it providing `string[]` as a type
    argument to `ActingCredit`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`MoviePart` 类将 `ActingCredit` 接口的 `Role` 类型参数指定为 `string`。`IncorrectExtension`
    类引发类型投诉，因为它的 `role` 类型为 `boolean`，尽管它将 `string[]` 作为 `ActingCredit` 的类型参数提供：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Method Generics
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法泛型
- en: Class methods may declare their own generic types separate from their class
    instance. Each call to a generic class method may have a different type argument
    for each of its type parameters.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 类方法可以声明它们自己的泛型类型，与它们的类实例分开。对泛型类方法的每次调用可能对其类型参数的每个类型参数使用不同的类型参数。
- en: 'This generic `CreatePairFactory` class declares a `Key` type and includes a
    `createPair` method that also declares a separate `Value` generic type. The return
    type for `createPair` is then inferred to be `{ key: Key, value: Value }`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '此泛型 `CreatePairFactory` 类声明了一个 `Key` 类型，并包含一个还声明了一个单独的 `Value` 泛型类型的 `createPair`
    方法。`createPair` 的返回类型然后被推断为 `{ key: Key, value: Value }`：'
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Static Class Generics
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态类泛型
- en: Static members of a class are separate from instance members and aren’t associated
    with any particular instance of the class. They don’t have access to any class
    instances or type information specific to any class instances. As a result, while
    static class methods can declare their own type parameters, they can’t access
    any type parameters declared on a class.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 类的静态成员与实例成员是分离的，并且不与类的任何特定实例关联。它们无法访问任何类实例或特定于任何类实例的类型信息。因此，虽然静态类方法可以声明它们自己的类型参数，但无法访问类上声明的任何类型参数。
- en: 'Here, a `BothLogger` class declares an `OnInstance` type parameter for its
    `instanceLog` method and a separate `OnStatic` type parameter for its static `staticLog`
    method. The static method is not able to access the instance `OnInstance` because
    `OnInstance` is declared for class instances:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`BothLogger`类为其`instanceLog`方法声明了一个`OnInstance`类型参数，为其静态`staticLog`方法声明了一个单独的`OnStatic`类型参数。静态方法无法访问实例`OnInstance`，因为`OnInstance`是为类实例声明的。
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Generic Type Aliases
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型类型别名
- en: 'One last construct in TypeScript that can be made generic with type arguments
    is type aliases. Each type alias may be given any number of type parameters, such
    as this `Nullish` type receiving a `T`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 中的最后一个可以使用类型参数泛化的构造是类型别名。每个类型别名可以给予任意数量的类型参数，例如这个`Nullish`类型接收一个`T`：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Generic type aliases are commonly used with functions to describe the type
    of a generic function:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型类型别名通常与函数一起使用，以描述泛型函数的类型：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Generic Discriminated Unions
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型判别联合
- en: I mentioned back in [Chapter 4, “Objects”](ch04.xhtml#objects) that discriminated
    unions are my favorite feature in all of TypeScript because they beautifully combine
    a common elegant JavaScript pattern with TypeScript’s type narrowing. My favorite
    use for discriminated unions is to add a type argument to create a generic “result”
    type that represents either a successful result with data or a failure with an
    error.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[第4章，“对象”](ch04.xhtml#objects)中提到过，判别联合是 TypeScript 中我最喜欢的功能，因为它们精美地结合了 JavaScript
    的一种常见优雅模式与 TypeScript 的类型缩小。我最喜欢使用判别联合的方式是添加类型参数以创建一个通用的“结果”类型，该类型代表具有数据的成功结果或带有错误的失败结果。
- en: 'This `Result` generic type features a `succeeded` discriminant that must be
    used to narrow a result to whether it’s a success or failure. This means any operation
    that returns a `Result` can indicate an error or data result, and be assured that
    consumers will need to check whether the result succeeded:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此`Result`泛型类型具有必须用于将结果缩小到成功或失败的`succeeded`判别标志。这意味着任何返回`Result`的操作都可以指示错误或数据结果，并确保消费者需要检查结果是否成功：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Put together, generic types and discriminated types provide a wonderful way
    to model reusable types like `Result`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 综合起来，泛型类型和判别类型提供了一种出色的方式来建模可重用的类型，如`Result`。
- en: Generic Modifiers
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用修饰符
- en: TypeScript includes syntax that allows you to modify the behavior of generic
    type parameters.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 包含的语法允许您修改泛型类型参数的行为。
- en: Generic Defaults
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型默认值
- en: I have stated so far that if a generic type is used in a type annotation or
    as the base of a class `extends` or `implements`, it must provide a type argument
    for each type parameter. You can get around explicitly providing type arguments
    by placing an `=` sign followed by a default type after the type parameter’s declaration.
    The default will be used in any subsequent type where the type argument isn’t
    explicitly declared and can’t be inferred.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我已经说明了如果在类型注释中使用泛型类型或作为类的基础（`extends`或`implements`），则必须为每个类型参数提供类型参数。您可以通过在类型参数声明后放置一个`=`符号，然后跟一个默认类型来避免显式提供类型参数。默认值将用于任何后续类型，其中未显式声明类型参数并且无法推断出来。
- en: 'Here, the `Quote` interface takes in a `T` type parameter that defaults to
    `string` if not provided. The `explicit` variable explicitly sets `T` to `number`
    while `implicit` and `mismatch` both resolve to `string`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Quote`接口接收一个`T`类型参数，如果未提供，则默认为`string`。`explicit`变量显式设置`T`为`number`，而`implicit`和`mismatch`均解析为`string`：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Type parameters can default to earlier type parameters in the same declaration
    too. Since each type parameter introduces a new type for the declaration, they
    are available as defaults for later type parameters in that declaration.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 类型参数也可以默认为同一声明中较早的类型参数。由于每个类型参数为声明引入一个新类型，因此它们可作为该声明中后续类型参数的默认值。
- en: 'This `KeyValuePair` type can have different types for its `Key` and `Value`
    generics but defaults to keeping them the same—though because `Key` doesn’t have
    a default, it does still need to be inferrable or provided:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeyValuePair` 类型可以具有不同类型的 `Key` 和 `Value` 泛型，但默认保持它们相同 — 虽然因为 `Key` 没有默认值，它仍然需要可推断或提供：'
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Keep in mind that all default type parameters must come last in their declaration
    list, similar to default function parameters. Generic types without a default
    may not follow generic types with a default.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 所有默认类型参数在其声明列表中必须放在最后，类似于默认函数参数。没有默认值的泛型类型不能跟在有默认值的泛型类型之后。
- en: 'Here, `inTheEnd` is allowed because all generic types without defaults come
    before generic types with defaults. `inTheMiddle` is a problem because a generic
    type without a default follows types with defaults:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在此处，`inTheEnd` 是允许的，因为所有没有默认值的泛型类型在具有默认值的泛型类型之前。`inTheMiddle` 是个问题，因为没有默认值的泛型类型跟在有默认值的类型后面：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Constrained Generic Types
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 受约束的泛型类型
- en: 'Generic types by default can be given any type in the world: classes, interfaces,
    primitives, unions, you name it. However, some functions are only meant to work
    with a limited set of types.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，泛型类型可以赋予世界上任何类型：类、接口、基本类型、联合类型，你名字它。然而，某些函数只能与有限集合的类型一起使用。
- en: 'TypeScript allows for a type parameter to declare itself as needing to *extend*
    a type: meaning it’s only allowed to alias types that are assignable to that type.
    The syntax to constrain a type parameter is to place the `extends` keyword after
    the type parameter’s name, followed by a type to constrain it to.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 允许一个类型参数声明自己需要 *扩展* 一种类型：这意味着它只允许别名为可分配给该类型的类型。约束类型参数的语法是在类型参数名称之后放置
    `extends` 关键字，然后是要将其约束为的类型。
- en: 'For example, by creating a `WithLength` interface to describe anything that
    has a `length: number`, we can then allow our generic function to take in any
    type that has a `length` for its `T` generic. Strings, arrays, and now even objects
    that just so happen to have a `length: number` are allowed, while type shapes
    such as `Date` missing that numeric `length` result in a type error:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，通过创建一个 `WithLength` 接口来描述任何具有 `length: number` 属性的对象，我们可以让我们的泛型函数接受任何具有
    `length` 属性的类型作为其 `T` 泛型。字符串、数组，甚至只是具有 `length: number` 属性的对象，都是允许的，而像 `Date`
    这样缺少数值 `length` 的类型形状会导致类型错误：'
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: I’ll cover more type operations you can perform with generics in [Chapter 15,
    “Type Operations”](ch15.xhtml#type_operations).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在 [第15章，“类型操作”](ch15.xhtml#type_operations) 中详细介绍您可以使用泛型执行的更多类型操作。
- en: keyof and Constrained Type Parameters
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`keyof` 和受约束的类型参数'
- en: The `keyof` operator introduced in [Chapter 9, “Type Modifiers”](ch09.xhtml#type_modifiers_chapter)
    also works well with constrained type parameters. Using `extends` and `keyof`
    together allows a type parameter to be constrained to the keys of a previous type
    parameter. It is also the only way to specify the key of a generic type.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第9章，“类型修饰符”](ch09.xhtml#type_modifiers_chapter) 中引入的 `keyof` 运算符也与受约束的类型参数非常配合。使用
    `extends` 和 `keyof` 结合允许一个类型参数被限制为前一个类型参数的键。这也是指定泛型类型键的唯一方法。
- en: 'Take this simplified version of the `get` method from the popular library Lodash.
    It takes in a container value, typed as `T`, and a `key` name of one of the keys
    of `T` to retrieve from `container`. Because the `Key` type parameter is constrained
    to be a `keyof T`, TypeScript knows this function is allowed to return `T[Key]`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以流行库 Lodash 的 `get` 方法的简化版本为例。它接受一个被定义为 `T` 类型的容器值，以及 `T` 中某个键的 `key` 名称，用于从
    `container` 中检索。因为 `Key` 类型参数被限制为 `T` 的 `keyof`，TypeScript 知道此函数被允许返回 `T[Key]`：
- en: '[PRE28]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Without `keyof`, there would have been no way to correctly type the generic
    `key` parameter.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有 `keyof`，将无法正确地为泛型 `key` 参数设置类型。
- en: 'Note the importance of the `Key` type parameter in the previous example. If
    only `T` is provided as a type parameter, and the `key` parameter is allowed to
    be any `keyof T`, then the return type will be the union type of all property
    values in `Container`. This less-specific function declaration doesn’t indicate
    to TypeScript that each call can have a specific `key` via a type argument:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意前面示例中 `Key` 类型参数的重要性。如果仅提供 `T` 作为类型参数，并且允许 `key` 参数为 `T` 的任何 `keyof`，则返回类型将是
    `Container` 中所有属性值的联合类型。这种不太具体的函数声明并未告知 TypeScript 每次调用可以通过类型参数具有特定的 `key`：
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Be sure when writing generic functions to know when a parameter’s type depends
    on a previous parameter’s type. You’ll often need to use constrained type parameters
    for correct parameter types in those cases.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写泛型函数时，务必了解参数类型依赖于前一个参数类型的情况。在这些情况下，通常需要使用约束类型参数以正确地指定参数类型。
- en: Promises
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Promises
- en: 'Now that you’ve seen how generics work, it’s finally time to talk about a core
    feature of modern JavaScript that relies on their concepts: Promises! To recap,
    a Promise in JavaScript represents something that might still be pending, such
    as a network request. Each Promise provides methods to register callbacks in case
    the pending action “resolves” (completes successfully) or “rejects” (throws an
    error).'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了泛型的工作原理，终于是时候讨论现代JavaScript的核心特性之一：Promises！回顾一下，在JavaScript中，Promise表示可能仍处于挂起状态的某些操作，比如网络请求。每个Promise都提供了方法来注册回调函数，以便在待定操作“解析”（成功完成）或“拒绝”（抛出错误）时调用。
- en: A Promise’s ability to represent similar actions on any arbitrary value types
    is a natural fit for TypeScript’s generics. Promises are represented in the TypeScript
    type system as a `Promise` class with a single type parameter representing the
    eventual resolved value.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一种`Promise`在任意值类型上表示类似操作的能力，是TypeScript泛型的天然适用。`Promise`在TypeScript类型系统中以单一类型参数表示最终解析的值。
- en: Creating Promises
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建Promises
- en: 'The `Promise` constructor is typed in TypeScript as taking in a single parameter.
    That parameter’s type relies on a type parameter declared on the generic `Promise`
    class. A reduced form would look roughly like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript中，`Promise`构造函数被定义为接受一个单一参数的类型。该参数的类型依赖于泛型`Promise`类声明的类型参数。简化形式大致如下：
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Creating a Promise intended to eventually resolve with a value generally necessitates
    explicitly declaring the type argument of the Promise. TypeScript would default
    to assuming the parameter type is `unknown` without that explicit generic type
    argument. Explicitly providing a type argument to the `Promise` constructor would
    allow TypeScript to understand the resultant Promise instance’s resolved type:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个打算最终解析为值的Promise通常需要显式声明Promise的类型参数。如果没有明确的泛型类型参数，TypeScript默认将参数类型视为`unknown`。通过显式提供Promise构造函数的类型参数，TypeScript可以理解结果Promise实例的解析类型：
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: A Promise’s generic `.then` method introduces a new type parameter representing
    the resolved value of the Promise it returns.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise`的泛型`.then`方法引入了一个新的类型参数，表示返回的Promise的解析值。'
- en: 'For example, the following code creates a `textEventually` Promise that resolves
    with a `string` value after a second, as well as a `lengthEventually` that waits
    an additional second to resolve with a `number`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码创建了一个`textEventually` Promise，在一秒后解析为`string`值，以及一个`lengthEventually`，在额外等待一秒后解析为`number`：
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Async Functions
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步函数
- en: Any function declared in JavaScript with the `async` keyword returns a `Promise`.
    If a value returned by an `async` function in JavaScript isn’t a Thenable (an
    object with a `.then()` method; in practice almost always a Promise), it will
    be wrapped in a `Promise` as if `Promise.resolve` was called on it. TypeScript
    recognizes this and will infer the return type of an `async` function to always
    be a `Promise` for whatever value is returned.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中声明带有`async`关键字的任何函数都会返回一个`Promise`。如果JavaScript中`async`函数返回的值不是Thenable（具有`.then()`方法的对象；实际上几乎总是一个Promise），则会像调用`Promise.resolve`一样将其包装在`Promise`中。TypeScript识别这一点，并推断`async`函数的返回类型始终为`Promise`，无论返回的值是什么。
- en: 'Here, `lengthAfterSecond` returns a `Promise<number>` directly, while `lengthImmediately`
    is inferred to return a `Promise<number>` because it is `async` and directly returns
    a `number`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`lengthAfterSecond`直接返回一个`Promise<number>`，而`lengthImmediately`被推断为返回`Promise<number>`，因为它是`async`并直接返回`number`：
- en: '[PRE33]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Any manually declared return type on an `async` function therefore must always
    be a `Promise` type, even if the function doesn’t explicitly mention Promises
    in its implementation:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 任何在`async`函数上手动声明的返回类型都必须始终是`Promise`类型，即使函数在实现中没有明确提到Promises：
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Using Generics Right
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正确使用泛型
- en: As in the `Promise<Value>` implementations earlier in this chapter, although
    generics can give us a lot of flexibility in describing types in code, they can
    become rather complex quite quickly. Programmers new to TypeScript often go through
    a phase of overusing generics to the point of making code confusing to read and
    overly complex to work with. TypeScript best practice is generally to use generics
    only when necessary, and to be clear about what they’re used for when they are.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 就像本章早期的`Promise<Value>`实现一样，尽管泛型可以在代码中描述类型给予我们很大的灵活性，但它们很快就会变得相当复杂。 TypeScript的最佳实践通常是仅在必要时使用泛型，并清楚地说明它们的用途。
- en: Warning
  id: totrans-144
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Most code you write in TypeScript should not heavily use generics to the point
    of confusion. However, types for utility libraries, particularly general-use modules,
    may sometimes need to heavily use them. Understanding generics is particularly
    useful to be able to work effectively with those utility types.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 中，大多数你编写的代码不应该过度使用泛型以至于令人困惑。然而，对于实用程序库的类型，特别是通用模块，有时可能需要大量使用它们。理解泛型特别有助于能够有效地使用这些实用程序类型。
- en: The Golden Rule of Generics
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型的黄金法则
- en: One quick test that can help show whether a type parameter is necessary for
    a function is it should be used at least twice. Generics describe relationships
    between types, so if a generic type parameter only appears in one place, it can’t
    possibly be defining a relationship between multiple types.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一个快速的测试，可以帮助确定是否需要一个类型参数是它应该至少用两次。泛型描述类型之间的关系，因此，如果泛型类型参数只出现在一个地方，它不可能定义多个类型之间的关系。
- en: Each function type parameter should be used for a parameter and then also for
    at least one other parameter and/or the return type of the function.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数类型参数应该用于一个参数，然后也用于至少一个其他参数和/或函数的返回类型。
- en: 'For example, this `logInput` function uses its `Input` type parameter exactly
    once, to declare its `input` parameter:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这个`logInput`函数仅使用其`Input`类型参数一次，来声明其`input`参数：
- en: '[PRE35]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Unlike the `identify` functions earlier in the chapter, `logInput` doesn’t
    do anything with its type parameter such as returning or declaring more parameters.
    There is therefore not much use to declaring that `Input` type parameter. We can
    rewrite `logInput` without it:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 不像本章早期的`identify`函数那样，`logInput`不对其类型参数做任何操作，如返回或声明更多参数。因此，声明`Input`类型参数没有多少用处。我们可以在不声明它的情况下重写`logInput`：
- en: '[PRE36]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*Effective TypeScript* by Dan Vanderkam (O’Reilly, 2019) contains several excellent
    tips for how to work with generics, including a section titled “The Golden Rule
    of Generics.” I highly recommend reading *Effective TypeScript* and that section
    especially if you’re finding yourself spending a lot of time wrestling with generics
    in your code.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*《Effective TypeScript》*（丹·范德坎，O''Reilly，2019）包含了几条关于如何使用泛型的极好建议，其中包括一节名为“泛型的黄金法则”。我强烈推荐阅读*《Effective
    TypeScript》*，特别是如果你在代码中发现自己花费了大量时间与泛型纠结的话。'
- en: Generic Naming Conventions
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型命名约定
- en: The standard naming convention for type parameters in many languages, TypeScript
    included, is to default to calling a first type argument “T” (for “type” or “template”)
    and if subsequent type parameters exist, calling them “U,” “V,” and so on.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 许多语言（包括 TypeScript）的类型参数的标准命名约定是默认将第一个类型参数称为“T”（表示“type”或“template”），如果存在后续类型参数，则称为“U”、“V”等。
- en: 'If some contextual information is known about how the type argument is supposed
    to be used, the convention sometimes extends to using the first letter of the
    term for that usage: for example, state management libraries might refer to a
    generic state as “S.” “K” and “V” often refer to keys and values in data structures.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果关于类型参数如何使用的上下文信息已知，则惯例有时会扩展到使用术语的第一个字母来表示其用途：例如，状态管理库可能会将通用状态称为“S”。数据结构中的“K”和“V”通常指键和值。
- en: 'Unfortunately, naming a type argument with one letter can be just as confusing
    as naming a function or variable with just one character:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，用一个字母命名类型参数可能会和用一个字符命名函数或变量一样令人困惑：
- en: '[PRE37]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'When the intent of a generic isn’t clear from a single-letter `T`, it’s best
    to use descriptive generic type names that indicate what the type is used for:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当单个字母`T`的泛型意图不明确时，最好使用描述性的泛型类型名称，以指示类型的用途：
- en: '[PRE38]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Whenever a construct has multiple type parameters, or the purpose of a single
    type argument isn’t immediately clear, consider using fully written names for
    readability instead of single-letter abbreviations.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个结构有多个类型参数，或者单个类型参数的目的不明确时，请考虑使用完整的名称以提高可读性，而不是使用单个字母的缩写。
- en: Summary
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, you made classes, functions, interfaces, and type aliases
    “generic” by allowing them to work with type parameters:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，通过允许它们使用类型参数，你使类、函数、接口和类型别名变得“通用”：
- en: Using type parameters to represent types different between uses of a construct
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类型参数表示在结构的不同用法之间的不同类型
- en: Providing explicit or implicit type arguments when calling generic functions
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调用泛型函数时提供显式或隐式的类型参数
- en: Using generic interfaces to represent generic object types
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用泛型接口来表示通用对象类型
- en: Adding type parameters to classes, and how that impacts their types
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向类添加类型参数，以及这如何影响它们的类型
- en: Adding type parameters to type aliases, in particular with discriminated type
    unions
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类型别名中添加类型参数，特别是在有歧义的类型联合中
- en: Modifying generic type parameters with defaults (`=`) and constraints (`extends`)
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改泛型类型参数的默认值 (`=`) 和约束 (`extends`)
- en: How Promises and `async` functions use generics to represent asynchronous data
    flow
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Promises 和 `async` 函数如何使用泛型来表示异步数据流
- en: Best practices with generics, including their Golden Rule and naming conventions
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型的最佳实践，包括它们的黄金法则和命名约定
- en: 'Thus concludes the *Features* section of this book. Congratulations: you now
    know all the most important syntax and type-checking features in the TypeScript
    type system for most projects!'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本书的 *特性* 部分到此结束。恭喜：你现在了解了 TypeScript 类型系统中大多数项目的最重要的语法和类型检查特性！
- en: The next section, *Usage*, covers how to configure TypeScript to run on your
    project, interact with external dependencies, and tweak its type checking and
    emitted JavaScript. Those are important features for using TypeScript on your
    own projects.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的章节 *用法* 将介绍如何配置 TypeScript 在你的项目中运行，如何与外部依赖交互，并调整其类型检查和生成的 JavaScript。这些是在你自己的项目中使用
    TypeScript 的重要特性。
- en: There are some other miscellaneous type operations available in TypeScript syntax.
    You don’t need to fully understand them to work in most TypeScript projects—but
    they are interesting and useful to know. I’ve thrown them in [Part IV, “Extra
    Credit”](part04.xhtml#extra_credit) after [Part III, “Usage”](part03.xhtml#usage)
    as a fun little treat if you have the time.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 语法中还有一些其他的杂项类型操作。你不需要完全理解它们就可以在大多数 TypeScript 项目中工作，但它们很有趣，也很有用。我把它们放在了[第
    IV 部分，“额外学分”](part04.xhtml#extra_credit)之后的[第 III 部分，“用法”](part03.xhtml#usage)中，如果你有时间，可以当作一个有趣的小礼物。
- en: Tip
  id: totrans-175
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Now that you’ve finished reading this chapter, practice what you’ve learned
    on [*https://learningtypescript.com/generics*](https://learningtypescript.com/generics).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完成了本章的阅读，可以在[*https://learningtypescript.com/generics*](https://learningtypescript.com/generics)上练习所学内容。
- en: Why do generics anger developers?
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 泛型为何会激怒开发者？
- en: ''
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: They’re always typing arguments.
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 它们总是在输入参数。
