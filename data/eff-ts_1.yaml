- en: Chapter 1\. Getting to Know TypeScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章\. 了解 TypeScript
- en: Before we dive into the details, this chapter helps you understand the big picture
    of TypeScript. What is it and how should you think about it? How does it relate
    to JavaScript? Are its types nullable or are they not? What’s this about `any`?
    And ducks?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入细节之前，本章将帮助你理解 TypeScript 的整体图景。它是什么？你应该如何思考它？它如何与 JavaScript 相关联？它的类型是可空的还是不可空的？`any`
    是什么意思？还有鸭子类型？
- en: TypeScript is a bit unusual as a language in that it neither runs in an interpreter
    (as Python and Ruby do) nor compiles down to a lower-level language (as Java and
    C do). Instead, it compiles to another high-level language, JavaScript. It is
    this JavaScript that runs, not your TypeScript. So TypeScript’s relationship with
    JavaScript is essential, but it can also be a source of confusion. Understanding
    this relationship will help you be a more effective TypeScript developer.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 作为一种语言有些不同寻常，它既不像 Python 和 Ruby 那样在解释器中运行，也不像 Java 和 C 那样编译成低级语言。相反，它将编译为另一种高级语言，即
    JavaScript。运行的是这个 JavaScript 而不是你的 TypeScript。因此，TypeScript 与 JavaScript 的关系至关重要，但也可能引起混淆。了解这种关系将帮助你成为一个更有效的
    TypeScript 开发者。
- en: TypeScript’s type system also has some unusual aspects that you should be aware
    of. Later chapters cover the type system in much greater detail, but this one
    will alert you to some of the surprises that it has in store.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 的类型系统也有一些不寻常的地方，你需要注意。后面的章节会更详细地介绍类型系统，但这一章节将提醒你一些它所隐藏的惊喜。
- en: 'Item 1: Understand the Relationship Between TypeScript and JavaScript'
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'Item 1: 理解 TypeScript 和 JavaScript 之间的关系'
- en: If you use TypeScript for long, you’ll inevitably hear the phrase “TypeScript
    is a superset of JavaScript” or “TypeScript is a typed superset of JavaScript.”
    But what does this mean, exactly? And what is the relationship between TypeScript
    and JavaScript? Since these languages are so closely linked, a strong understanding
    of how they relate to each is the foundation for using TypeScript well.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你长期使用 TypeScript，你必然会听到短语“TypeScript 是 JavaScript 的超集”或“TypeScript 是 JavaScript
    的有类型超集”。但这到底意味着什么？TypeScript 和 JavaScript 之间的关系是什么？由于这些语言之间如此密切相关，对它们如何相互关联的深刻理解是有效使用
    TypeScript 的基础。
- en: 'TypeScript is a superset of JavaScript in a syntactic sense: so long as your
    JavaScript program doesn’t have any syntax errors then it is also a TypeScript
    program. It’s quite likely that TypeScript’s type checker will flag some issues
    with your code. But this is an independent problem. TypeScript will still parse
    your code and emit JavaScript. (This is another key part of the relationship.
    We’ll explore this more in [Item 3](#independent).)'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 从语法角度看，TypeScript 是 JavaScript 的超集：只要你的 JavaScript 程序没有任何语法错误，它也是一个 TypeScript
    程序。很可能 TypeScript 的类型检查器会标记你的代码中的一些问题。但这是一个独立的问题。TypeScript 仍然会解析你的代码并生成 JavaScript。（这是关系的另一个关键部分。我们将在
    [Item 3](#independent) 中进一步探讨这一点。）
- en: TypeScript files use a *.ts* (or *.tsx*) extension, rather than the *.js* (or
    *.jsx*) extension of a JavaScript file. This doesn’t mean that TypeScript is a
    completely different language! Since TypeScript is a superset of JavaScript, the
    code in your *.js* files is already TypeScript. Renaming *main.js* to *main.ts*
    doesn’t change that.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 文件使用 *.ts*（或 *.tsx*）扩展名，而不是 JavaScript 文件的 *.js*（或 *.jsx*）扩展名。这并不意味着
    TypeScript 是一种完全不同的语言！由于 TypeScript 是 JavaScript 的超集，你的 *.js* 文件中的代码已经是 TypeScript
    了。将 *main.js* 重命名为 *main.ts* 并不会改变这一点。
- en: This is enormously helpful if you’re migrating an existing JavaScript codebase
    to TypeScript. It means that you don’t have to rewrite any of your code in another
    language to start using TypeScript and get the benefits it provides. This would
    not be true if you chose to rewrite your JavaScript in a language like Java. This
    gentle migration path is one of the best features of TypeScript. There will be
    much more to say about this topic in [Chapter 8](ch08.html#ch-migrate).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将现有的 JavaScript 代码库迁移到 TypeScript，这是非常有帮助的。这意味着你不必重写任何代码以开始使用 TypeScript
    并获得它提供的好处。如果你选择将你的 JavaScript 重写为像 Java 这样的语言，情况就不一样了。这种渐进式迁移路径是 TypeScript 的最佳特性之一。关于这个主题，我们将在
    [Chapter 8](ch08.html#ch-migrate) 中详细讨论。
- en: 'All JavaScript programs are TypeScript programs, but the converse is not true:
    there are TypeScript programs which are not JavaScript programs. This is because
    TypeScript adds additional syntax for specifying types. (There are some other
    bits of syntax it adds, largely for historical reasons. See [Item 53](ch07.html#avoid-non-ecma).)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 所有JavaScript程序都是TypeScript程序，但反之则不然：有些TypeScript程序不是JavaScript程序。这是因为TypeScript添加了用于指定类型的额外语法。（出于历史原因，它还添加了一些其他语法。见[条目53](ch07.html#avoid-non-ecma)。）
- en: 'For instance, this is a valid TypeScript program:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是一个有效的TypeScript程序：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'But when you run this through a program like `node` that expects JavaScript,
    you’ll get an error:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当你通过像`node`这样期望JavaScript的程序运行时，你会得到一个错误：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `: string` is a type annotation that is specific to TypeScript. Once you
    use one, you’ve gone beyond plain JavaScript (see [Figure 1-1](#ts-vs-js-venn)).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`: string`是特定于TypeScript的类型注解。一旦使用了它，你就超出了纯JavaScript（参见[图1-1](#ts-vs-js-venn)）。'
- en: Figure 1-1\. All JavaScript is TypeScript, but not all TypeScript is JavaScript
  id: totrans-15
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-1\. 所有JavaScript都是TypeScript，但并非所有TypeScript都是JavaScript
- en: 'This is not to say that TypeScript doesn’t provide value for plain JavaScript
    programs. It does! For example, this JavaScript program:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着TypeScript对普通JavaScript程序没有提供价值。它有！例如，这段JavaScript程序：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'will throw an error when you run it:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行它时会抛出一个错误：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There are no type annotations in this program, but TypeScript’s type checker
    is still able to spot the problem:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序中没有类型注解，但TypeScript的类型检查器仍能够发现问题：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You didn’t have to tell TypeScript that the type of `city` was `string`: it
    inferred it from the initial value. Type inference is a key part of TypeScript
    and [Chapter 3](ch03.html#ch-inference) explores how to use it well.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必告诉TypeScript`city`的类型是`string`：它是从初始值推断出来的。类型推断是TypeScript的关键部分，[第3章](ch03.html#ch-inference)探讨了如何使用它。
- en: One of the goals of TypeScript’s type system is to detect code that will throw
    an exception at runtime, without having to run your code. When you hear TypeScript
    described as a “static” type system, this is what it refers to. The type checker
    cannot always spot code that will throw exceptions, but it will try.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript类型系统的目标之一是检测在运行时会抛出异常的代码，而无需运行你的代码。当你听到TypeScript被描述为“静态”类型系统时，就是指这一点。类型检查器并不总能够发现会抛出异常的代码，但它会尝试。
- en: 'Even if your code doesn’t throw an exception, it still might not do what you
    intend. TypeScript tries to catch some of these issues, too. For example, this
    JavaScript program:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你的代码没有抛出异常，它可能仍然无法达到你的意图。TypeScript也试图捕获其中一些问题。例如，这段JavaScript程序：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'will log:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 将记录：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Whoops! What went wrong? This program is valid JavaScript (and hence TypeScript).
    And it ran without throwing any errors. But it clearly didn’t do what you intended.
    Even without adding type annotations, TypeScript’s type checker is able to spot
    the error (and offer a helpful suggestion):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 糟糕！出了什么问题？这段程序是有效的JavaScript（因此也是TypeScript）。它运行时没有抛出任何错误。但显然它没有执行你的意图。即使没有添加类型注解，TypeScript的类型检查器也能够发现错误（并提供有用的建议）：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: While TypeScript can catch errors even if you don’t provide type annotations,
    it’s able to do a much more thorough job if you do. This is because type annotations
    tell TypeScript what your *intent* is, and this lets it spot places where your
    code’s behavior does not match your intent. For example, what if you’d reversed
    the `capital`/`capitol` spelling mistake in the previous example?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript即使没有提供类型注解，也能捕获错误，但如果提供了类型注解，它将能够做得更彻底。这是因为类型注解告诉TypeScript你的*意图*是什么，这使它能够发现代码行为与意图不符的地方。例如，如果在之前的例子中反转了`capital`/`capitol`的拼写错误呢？
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The error that was so helpful before now gets it exactly wrong! The problem
    is that you’ve spelled the same property two different ways, and TypeScript doesn’t
    know which one is right. It can guess, but it may not always be correct. The solution
    is to clarify your intent by explicitly declaring the type of `states`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 之前如此有帮助的错误现在完全错了！问题在于你用两种不同的方式拼写了同一个属性，而TypeScript不知道哪一个是正确的。它可以猜测，但并不总是正确的。解决方法是通过显式声明`states`的类型来澄清你的意图：
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now the errors match the problem and the suggested fix is correct. By spelling
    out our intent, you’ve also helped TypeScript spot other potential problems. For
    instance, had you only misspelled `capitol` once in the array, there wouldn’t
    have been an error before. But with the type annotation, there is:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在错误匹配问题，建议的修复方法是正确的。通过明确表达我们的意图，你还帮助 TypeScript 发现了其他潜在问题。例如，如果你在数组中只错拼了一次
    `capitol`，之前不会有错误。但有了类型注解，就有了：
- en: '[PRE10]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In terms of the Venn diagram, we can add in a new group of programs: TypeScript
    programs which pass the type checker (see [Figure 1-2](#ts-js-typecheck-venn)).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Venn 图的角度来看，我们可以添加一个新的程序组：通过类型检查的 TypeScript 程序（见 [Figure 1-2](#ts-js-typecheck-venn)）。
- en: '![efts 0102](assets/efts_0102.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![efts 0102](assets/efts_0102.png)'
- en: Figure 1-2\. All JavaScript programs are TypeScript programs. But only some
    JavaScript (and TypeScript) programs pass the type checker.
  id: totrans-38
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-2\. 所有 JavaScript 程序都是 TypeScript 程序。但只有一些 JavaScript（和 TypeScript）程序通过了类型检查器。
- en: If the statement that “TypeScript is a superset of JavaScript” feels wrong to
    you, it may be because you’re thinking of this third set of programs in the diagram.
    In practice, this is the most relevant one to the day-to-day experience of using
    TypeScript. Generally when you use TypeScript, you try to keep your code passing
    all the type checks.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果“TypeScript 是 JavaScript 的超集”这种说法让你觉得不对劲，可能是因为你在考虑图中的第三组程序。在实践中，这是使用 TypeScript
    的日常体验中最相关的问题。通常在使用 TypeScript 时，你会努力确保你的代码通过所有类型检查。
- en: 'TypeScript’s type system *models* the runtime behavior of JavaScript. This
    may result in some surprises if you’re coming from a language with stricter runtime
    checks. For example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 的类型系统 *模拟* 了 JavaScript 的运行时行为。如果你来自于有更严格运行时检查的语言，这可能会带来一些意外。例如：
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: These statements both pass the type checker, even though they are questionable
    and do produce runtime errors in many other languages. But this does model the
    runtime behavior of JavaScript, where both expressions result in the string `"23"`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个语句虽然在许多其他语言中会产生运行时错误，但它们都通过了类型检查器。但这确实模拟了 JavaScript 的运行时行为，其中两个表达式都会产生字符串
    `"23"`。
- en: 'TypeScript does draw the line somewhere, though. The type checker flags issues
    in all of these statements, even though they do not throw exceptions at runtime:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，TypeScript 在某些情况下会有所限制。类型检查器会标记所有这些语句中的问题，即使它们在运行时不会抛出异常：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The guiding principle of TypeScript’s type system is that it should model JavaScript’s
    runtime behavior. But in all of these cases, TypeScript considers it more likely
    that the odd usage is the result of an error than the developer’s intent, so it
    goes beyond simply modeling the runtime behavior. We saw another example of this
    in the `capital`/`capitol` example, where the program didn’t throw (it logged
    `undefined`) but the type checker still flagged an error.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 类型系统的指导原则是它应该模拟 JavaScript 的运行时行为。但在所有这些情况下，TypeScript 更可能认为奇怪的使用是错误而不是开发者的意图，因此它超越了简单地模拟运行时行为。我们在
    `capital`/`capitol` 示例中看到了另一个例子，程序没有抛出异常（而是记录了 `undefined`），但类型检查器仍然标记了一个错误。
- en: How does TypeScript decide when to model JavaScript’s runtime behavior and when
    to go beyond it? Ultimately this is a matter of taste. By adopting TypeScript
    you’re trusting the judgment of the team that builds it. If you enjoy adding `null`
    and `7` or `[]` and `12`, or calling functions with superfluous arguments, then
    TypeScript might not be for you!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 如何决定何时模拟 JavaScript 的运行时行为，何时超越它？最终这是一种品味的问题。通过选择 TypeScript，你正在信任构建它的团队的判断。如果你喜欢添加
    `null` 和 `7` 或者 `[]` 和 `12`，或者调用带有多余参数的函数，那么 TypeScript 可能不适合你！
- en: 'If your program type checks, could it still throw an error at runtime? The
    answer is “yes.” Here’s an example:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的程序通过了类型检查，它在运行时仍然可能会抛出错误吗？答案是“是的”。以下是一个例子：
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When you run this, it throws:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码时，会抛出异常：
- en: '[PRE14]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: TypeScript assumed the array access would be within bounds, but it was not.
    The result was an exception.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 假定数组访问将在边界内，但实际并非如此。结果是一个异常。
- en: Uncaught errors also frequently come up when you use the `any` type, which we’ll
    discuss in [Item 5](#any) and in more detail in [Chapter 5](ch05.html#ch-any).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `any` 类型时，也经常会出现未捕获的错误，我们将在 [Item 5](#any) 和 [Chapter 5](ch05.html#ch-any)
    中详细讨论。
- en: 'The root cause of these exceptions is that TypeScript’s understanding of a
    value’s type and reality have diverged. A type system which can guarantee the
    accuracy of its static types is said to be *sound*. TypeScript’s type system is
    very much not sound, nor was it ever intended to be. If soundness is important
    to you, you may want to look at other languages like Reason or Elm. While these
    do offer more guarantees of runtime safety, this comes at a cost: neither is a
    superset of JavaScript, so migration will be more complicated.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这些异常的根本原因是TypeScript对值的类型理解与现实已经有所不同。一个可以保证其静态类型准确性的类型系统被称为*sound*。TypeScript的类型系统在很大程度上不是sound，并且从未打算如此。如果准确性对你很重要，你可能需要考虑其他语言，如Reason或Elm。尽管这些语言提供了更多的运行时安全性保证，但这也带来了代价：它们都不是JavaScript的超集，因此迁移会更加复杂。
- en: Things to Remember
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 要记住的事情
- en: TypeScript is a superset of JavaScript. In other words, all JavaScript programs
    are already TypeScript programs. TypeScript has some syntax of its own, so TypeScript
    programs are not, in general, valid JavaScript programs.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript是JavaScript的超集。换句话说，所有JavaScript程序已经是TypeScript程序。TypeScript有一些自己的语法，因此一般来说，TypeScript程序并不是有效的JavaScript程序。
- en: TypeScript adds a type system that models JavaScript’s runtime behavior and
    tries to spot code which will throw exceptions at runtime. But you shouldn’t expect
    it to flag every exception. It is possible for code to pass the type checker but
    still throw at runtime.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript添加了一个类型系统，模拟了JavaScript的运行时行为，并尝试识别在运行时抛出异常的代码。但你不应该期望它标记每个异常。代码可以通过类型检查器，但仍然可能在运行时抛出异常。
- en: While TypeScript’s type system largely models JavaScript behavior, there are
    some constructs that JavaScript allows but TypeScript chooses to bar, such as
    calling functions with the wrong number of arguments. This is largely a matter
    of taste.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然TypeScript的类型系统主要模拟JavaScript的行为，但也有一些JavaScript允许的构造，但TypeScript选择禁止，例如调用函数时参数数量不正确。这在很大程度上是一种品味问题。
- en: 'Item 2: Know Which TypeScript Options You’re Using'
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条目2：了解你正在使用的TypeScript选项
- en: Does this code pass the type checker?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码通过了类型检查器吗？
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Without knowing which options you’re using, it’s impossible to say! The TypeScript
    compiler has an enormous set of these, nearly 100 at the time of this writing.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 不知道你正在使用哪些选项，是不可能说的！在撰写本文时，TypeScript编译器有一个庞大的选项集，几乎有100个。
- en: 'They can be set via the command line:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可以通过命令行设置：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'or via a configuration file, *tsconfig.json*:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 或通过配置文件，*tsconfig.json*：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You should prefer the configuration file. It ensures that your coworkers and
    tools all know exactly how you plan to use TypeScript. You can create one by running
    `tsc --init`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该偏爱配置文件。它确保你的同事和工具都清楚你计划如何使用TypeScript。你可以通过运行`tsc --init`来创建一个配置文件。
- en: 'Many of TypeScript’s configuration settings control where it looks for source
    files and what sort of output it generates. But a few control core aspects of
    the language itself. These are high-level design choices that most languages do
    not leave to their users. TypeScript can feel like a very different language depending
    on how it is configured. To use it effectively, you should understand the most
    important of these settings: `noImplicitAny` and `strictNullChecks`.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript的许多配置设置控制它查找源文件的位置以及生成什么样的输出。但有一些控制语言核心方面的设置。这些是高级设计选择，大多数语言不会留给用户。根据如何配置它，TypeScript可能感觉像是一种非常不同的语言。要有效使用它，你应该理解其中最重要的设置：`noImplicitAny`和`strictNullChecks`。
- en: '`noImplicitAny` controls whether variables must have known types. This code
    is valid when `noImplicitAny` is off:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`noImplicitAny`控制变量是否必须具有已知类型。当`noImplicitAny`关闭时，此代码是有效的：'
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you mouse over the `add` symbol in your editor, it will reveal what TypeScript
    has inferred about the type of that function:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在编辑器中悬停在`add`符号上，它将显示TypeScript已推断出该函数的类型：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `any` types effectively disable the type checker for code involving these
    parameters. `any` is a useful tool, but it should be used with caution. For much
    more on `any`, see [Item 5](#any) and [Chapter 3](ch03.html#ch-inference).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`any`类型有效地禁用了涉及这些参数的类型检查器。`any`是一个有用的工具，但应谨慎使用。有关更多关于`any`的信息，请参见[条目5](#any)和[第3章](ch03.html#ch-inference)。'
- en: 'These are called *implicit `any`s* because you never wrote the word “any” but
    still wound up with dangerous `any` types. This becomes an error if you set the
    `noImplicitAny` option:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这些称为*implicit `any`s*，因为你从未写过“any”这个词，但最终却得到了危险的`any`类型。如果设置了`noImplicitAny`选项，则会出现错误：
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'These errors can be fixed by explicitly writing type declarations, either `:
    any` or a more specific type:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '可以通过显式编写类型声明来修复这些错误，例如`: any`或更具体的类型：'
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: TypeScript is the most helpful when it has type information, so you should be
    sure to set `noImplicitAny` whenever possible. Once you grow accustomed to all
    variables having types, TypeScript without `noImplicitAny` feels almost like a
    different language.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 在有类型信息时最为有帮助，因此你应尽可能设置`noImplicitAny`。一旦你习惯了所有变量都有类型，没有`noImplicitAny`的
    TypeScript 几乎感觉像是一种不同的语言。
- en: For new projects, you should start with `noImplicitAny` on, so that you write
    the types as you write your code. This will help TypeScript spot problems, improve
    the readability of your code, and enhance your development experience (see [Item
    6](ch02_split_000.html#editor)). Leaving `noImplicitAny` off is only appropriate
    if you’re transitioning a project from JavaScript to TypeScript (see [Chapter 8](ch08.html#ch-migrate)).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于新项目，你应该从`noImplicitAny`开始，这样你编写代码时就能同时编写类型。这将帮助 TypeScript 检测问题，提高代码可读性，并增强开发体验（参见[第
    6 项](ch02_split_000.html#editor)）。仅在从 JavaScript 迁移项目到 TypeScript 时，才适合关闭`noImplicitAny`（参见[第
    8 章](ch08.html#ch-migrate)）。
- en: '`strictNullChecks` controls whether `null` and `undefined` are permissible
    values in every type.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`strictNullChecks`控制在每种类型中是否允许`null`和`undefined`值。'
- en: 'This code is valid when `strictNullChecks` is off:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当`strictNullChecks`关闭时，此代码有效：
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'but triggers an error when you turn `strictNullChecks` on:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 但当你打开`strictNullChecks`时，则会触发错误：
- en: '[PRE23]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: A similar error would have occurred had you used `undefined` instead of `null`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`undefined`而不是`null`，可能会发生类似的错误。
- en: 'If you mean to allow `null`, you can fix the error by making your intent explicit:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的意图是允许`null`，你可以通过明确你的意图来修复错误：
- en: '[PRE24]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If you do not wish to permit `null`, you’ll need to track down where it came
    from and add either a check or an assertion:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不希望允许`null`，你需要跟踪它来自哪里，并添加检查或断言：
- en: '[PRE25]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`strictNullChecks` is tremendously helpful for catching errors involving `null`
    and `undefined` values, but it does increase the difficulty of using the language.
    If you’re starting a new project, try setting `strictNullChecks`. But if you’re
    new to the language or migrating a JavaScript codebase, you may elect to leave
    it off. You should certainly set `noImplicitAny` before you set `strictNullChecks`.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`strictNullChecks`在捕获涉及`null`和`undefined`值的错误方面非常有帮助，但确实增加了使用语言的难度。如果你要开始一个新项目，请尝试设置`strictNullChecks`。但如果你对这种语言不熟悉或者要迁移一个
    JavaScript 代码库，你可能选择不启用它。在设置`strictNullChecks`之前，你应该确保先设置`noImplicitAny`。'
- en: If you choose to work without `strictNullChecks`, keep an eye out for the dreaded
    “undefined is not an object” runtime error. Every one of these is a reminder that
    you should consider enabling stricter checking. Changing this setting will only
    get harder as your project grows, so try not to wait too long before enabling
    it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果选择不使用`strictNullChecks`，请注意可怕的“undefined is not an object”运行时错误。这些错误提醒你应考虑启用更严格的检查。随着项目的增长，改变这个设置会变得越来越困难，因此在启用它之前不要等待太久。
- en: There are many other settings that affect language semantics (e.g., `noImplicitThis`
    and `strictFunctionTypes`), but these are minor compared to `noImplicitAny` and
    `strictNullChecks`. To enable all of these checks, turn on the `strict` setting.
    TypeScript is able to catch the most errors with `strict`, so this is where you
    eventually want to wind up.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他设置影响语言语义（例如`noImplicitThis`和`strictFunctionTypes`），但与`noImplicitAny`和`strictNullChecks`相比，这些都是次要的。要启用所有这些检查，请打开`strict`设置。TypeScript
    能够通过`strict`捕获大部分错误，因此这是你最终想要达到的地方。
- en: Know which options you’re using! If a coworker shares a TypeScript example and
    you’re unable to reproduce their errors, make sure your compiler options are the
    same.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 知道你使用的是哪些选项！如果同事分享了一个 TypeScript 示例，而你无法重现他们的错误，请确保你的编译器选项是相同的。
- en: Things to Remember
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 要记住的事情
- en: The TypeScript compiler includes several settings which affect core aspects
    of the language.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript 编译器包括几个影响语言核心方面的设置。
- en: Configure TypeScript using *tsconfig.json* rather than command-line options.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用*tsconfig.json*配置 TypeScript 而不是命令行选项。
- en: Turn on `noImplicitAny` unless you are transitioning a JavaScript project to
    TypeScript.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非你正在将 JavaScript 项目迁移到 TypeScript，否则请打开`noImplicitAny`。
- en: Use `strictNullChecks` to prevent “undefined is not an object”-style runtime
    errors.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`strictNullChecks`来防止类似“undefined is not an object”的运行时错误。
- en: Aim to enable `strict` to get the most thorough checking that TypeScript can
    offer.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标是启用`strict`，以获取 TypeScript 能提供的最彻底检查。
- en: 'Item 3: Understand That Code Generation Is Independent of Types'
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目 3：了解代码生成独立于类型之外
- en: 'At a high level, `tsc` (the TypeScript compiler) does two things:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在高级别上，`tsc`（TypeScript 编译器）执行两件事：
- en: It converts next-generation TypeScript/JavaScript to an older version of JavaScript
    that works in browsers (“transpiling”).
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将下一代 TypeScript/JavaScript 转换为在浏览器中可用的旧版本 JavaScript（“转换”）。
- en: It checks your code for type errors.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它检查你的代码是否存在类型错误。
- en: What’s surprising is that these two behaviors are entirely independent of one
    another. Put another way, the types in your code cannot affect the JavaScript
    that TypeScript emits. Since it’s this JavaScript that gets executed, this means
    that your types can’t affect the way your code runs.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是这两种行为完全独立于彼此。换句话说，在你的代码中的类型无法影响 TypeScript 生成的 JavaScript。因为执行的是这段 JavaScript
    代码，这意味着你的类型不能影响代码的运行方式。
- en: This has some surprising implications and should inform your expectations about
    what TypeScript can and cannot do for you.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一些令人惊讶的含义，应该让你对 TypeScript 能够做什么以及不能做什么有所期待。
- en: Code with Type Errors Can Produce Output
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存在类型错误的代码可以产生输出
- en: Because code output is independent of type checking, it follows that code with
    type errors can produce output!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因为代码输出与类型检查无关，所以代码存在类型错误时仍然可以产生输出！
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This can be quite surprising if you’re coming from a language like C or Java
    where type checking and output go hand in hand. You can think of all TypeScript
    errors as being similar to warnings in those languages: it’s likely that they
    indicate a problem and are worth investigating, but they won’t stop the build.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前使用过像 C 或 Java 这样的语言，这可能会相当令人惊讶，因为类型检查和输出是紧密相关的。你可以将 TypeScript 中的所有错误看作是那些语言中的警告：它们很可能表示有问题，值得调查，但不会阻止构建。
- en: Code emission in the presence of errors is helpful in practice. If you’re building
    a web application, you may know that there are problems with a particular part
    of it. But because TypeScript will still generate code in the presence of errors,
    you can test the other parts of your application before you fix them.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，即使存在错误，代码的输出也是有帮助的。如果你正在构建一个 Web 应用程序，你可能知道其中的某个部分存在问题。但因为 TypeScript 仍然会生成代码，你可以在修复问题之前测试应用程序的其他部分。
- en: You should aim for zero errors when you commit code, lest you fall into the
    trap of having to remember what is an expected or unexpected error. If you want
    to disable output on errors, you can use the `noEmitOnError` option in *tsconfig.json*,
    or the equivalent in your build tool.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当你提交代码时，应该力求零错误，以免陷入记住什么是预期或意外错误的陷阱。如果你想要在错误时禁用输出，可以在 *tsconfig.json* 中使用 `noEmitOnError`
    选项，或者在你的构建工具中使用等效选项。
- en: You Cannot Check TypeScript Types at Runtime
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你不能在运行时检查 TypeScript 类型。
- en: 'You may be tempted to write code like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会被诱惑编写这样的代码：
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `instanceof` check happens at runtime, but `Rectangle` is a type and so
    it cannot affect the runtime behavior of the code. TypeScript types are “erasable”:
    part of compilation to JavaScript is simply removing all the `interface`s, `type`s,
    and type annotations from your code.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`instanceof` 检查发生在运行时，但 `Rectangle` 是一种类型，因此它不能影响代码的运行行为。TypeScript 类型是“可擦除的”：编译成
    JavaScript 的一部分只是从你的代码中删除所有的 `interface`、`type` 和类型注解。'
- en: 'To ascertain the type of shape you’re dealing with, you’ll need some way to
    reconstruct its type at runtime. In this case you can check for the presence of
    a `height` property:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定你处理的形状的类型，你需要一些方法在运行时重建它的类型。在这种情况下，你可以检查 `height` 属性的存在：
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This works because the property check only involves values available at runtime,
    but still allows the type checker to refine `shape`’s type to `Rectangle`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为属性检查仅涉及运行时可用的值，但仍允许类型检查器将 `shape` 的类型细化为 `Rectangle`。
- en: 'Another way would have been to introduce a “tag” to explicitly store the type
    in a way that’s available at runtime:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是引入一个“标签”，以显式方式存储在运行时可用的类型：
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `Shape` type here is an example of a “tagged union.” Because they make it
    so easy to recover type information at runtime, tagged unions are ubiquitous in
    TypeScript.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的 `Shape` 类型是“标记联合”的一个例子。由于它们可以轻松地在运行时恢复类型信息，标记联合在 TypeScript 中非常常见。
- en: 'Some constructs introduce both a type (which is not available at runtime) and
    a value (which is). The `class` keyword is one of these. Making `Square` and `Rectangle`
    classes would have been another way to fix the error:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有些结构引入了类型（运行时不可用）和值（可用）。`class` 关键字就是其中之一。将 `Square` 和 `Rectangle` 设为类也是解决错误的另一种方法：
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This works because `class Rectangle` introduces both a type and a value, whereas
    `interface` only introduced a type.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这有效是因为 `class Rectangle` 同时引入了类型和值，而 `interface` 只引入了类型。
- en: The `Rectangle` in `type Shape = Square | Rectangle` refers to the *type*, but
    the `Rectangle` in `shape instanceof Rectangle` refers to the *value*. This distinction
    is important to understand but can be quite subtle. See [Item 8](ch02_split_000.html#type-value-space).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`type Shape = Square | Rectangle` 中的 `Rectangle` 指的是*类型*，但 `shape instanceof
    Rectangle` 中的 `Rectangle` 指的是*值*。理解这一区别很重要，但可能相当微妙。请参阅[Item 8](ch02_split_000.html#type-value-space)。'
- en: Type Operations Cannot Affect Runtime Values
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型操作无法影响运行时值
- en: 'Suppose you have a value that could be a string or a number and you’d like
    to normalize it so that it’s always a number. Here’s a misguided attempt that
    the type checker accepts:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一个可能是字符串或数字的值，并且希望将其规范化为始终为数字。这是类型检查器接受的一个错误尝试：
- en: '[PRE31]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Looking at the generated JavaScript makes it clear what this function really
    does:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 查看生成的 JavaScript 可以明确此函数的实际作用：
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'There is no conversion going on whatsoever. The `as number` is a type operation,
    so it cannot affect the runtime behavior of your code. To normalize the value
    you’ll need to check its runtime type and do the conversion using JavaScript constructs:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 根本没有进行任何转换。`as number` 是一种类型操作，因此它不能影响您的代码的运行时行为。要规范化值，您需要检查其运行时类型，并使用 JavaScript
    构造进行转换：
- en: '[PRE33]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: (`as number` is a *type assertion*. For more on when it’s appropriate to use
    these, see [Item 9](ch02_split_000.html#prefer-declarations-to-assertions).)
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: (`as number` 是*类型断言*。有关何时适用这些断言的更多信息，请参阅[Item 9](ch02_split_000.html#prefer-declarations-to-assertions)。)
- en: Runtime Types May Not Be the Same as Declared Types
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行时类型可能与声明类型不同
- en: Could this function ever hit the final `console.log`?
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数是否可能最终触发 `console.log`？
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: TypeScript usually flags dead code, but it does not complain about this, even
    with the `strict` option. How could you hit this branch?
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 通常会标记死代码，但即使使用了 `strict` 选项，它也不会抱怨此代码。如何进入这个分支？
- en: The key is to remember that `boolean` is the *declared* type. Because it is
    a TypeScript type, it goes away at runtime. In JavaScript code, a user might inadvertently
    call `setLightSwitch` with a value like `"ON"`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于记住 `boolean` 是*声明*类型。因为它是 TypeScript 类型，在运行时会消失。在 JavaScript 代码中，用户可能会误将
    `setLightSwitch` 与 `"ON"` 等值一起调用。
- en: 'There are ways to trigger this code path in pure TypeScript, too. Perhaps the
    function is called with a value which comes from a network call:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯 TypeScript 中也有触发此代码路径的方法。也许函数被调用时，其值来自网络调用：
- en: '[PRE35]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You’ve declared that the result of the `/light` request is `LightApiResponse`,
    but nothing enforces this. If you misunderstood the API and `lightSwitchValue`
    is really a `string`, then a string will be passed to `setLightSwitch` at runtime.
    Or perhaps the API changed after you deployed.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您已声明 `/light` 请求的结果为 `LightApiResponse`，但没有任何机制来强制执行此声明。如果误解了 API，并且 `lightSwitchValue`
    实际上是一个 `string`，那么在运行时将传递一个字符串给 `setLightSwitch`。或者也许在部署后 API 发生了变化。
- en: TypeScript can get quite confusing when your runtime types don’t match the declared
    types, and this is a situation you should avoid whenever you can. But be aware
    that it’s possible for a value to have types other than the ones you’ve declared.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的运行时类型与声明类型不匹配时，TypeScript 可能会变得相当混乱，这是您应尽量避免的情况。但请注意，可能会存在值具有不同于您声明类型的类型。
- en: You Cannot Overload a Function Based on TypeScript Types
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 您不能基于 TypeScript 类型重载函数
- en: 'Languages like C++ allow you to define multiple versions of a function that
    differ only in the types of their parameters. This is called “function overloading.”
    Because the runtime behavior of your code is independent of its TypeScript types,
    this construct isn’t possible in TypeScript:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 类似 C++ 的语言允许您定义多个版本的函数，这些函数仅在其参数类型上有所不同。这称为“函数重载”。因为您的代码的运行时行为与其 TypeScript
    类型无关，所以在 TypeScript 中无法使用此构造：
- en: '[PRE36]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'TypeScript *does* provide a facility for overloading functions, but it operates
    entirely at the type level. You can provide multiple declarations for a function,
    but only a single implementation:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript *确实* 提供了一种函数重载的机制，但它完全在类型级别上运作。您可以为函数提供多个声明，但只能有一个实现：
- en: '[PRE37]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The first two declarations of `add` only provide type information. When TypeScript
    produces JavaScript output, they are removed, and only the implementation remains.
    (If you use this style of overloading, take a look at [Item 50](ch06.html#conditional-overload)
    first. There are some subtleties to be aware of.)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`add` 的前两个声明仅提供类型信息。当 TypeScript 生成 JavaScript 输出时，它们将被移除，只剩下实现部分。（如果您使用此类型的重载风格，请首先查看
    [项目 50](ch06.html#conditional-overload)。这里有一些微妙之处需要注意。）'
- en: TypeScript Types Have No Effect on Runtime Performance
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TypeScript 类型对运行时性能没有影响
- en: Because types and type operations are erased when you generate JavaScript, they
    cannot have an effect on runtime performance. TypeScript’s static types are truly
    zero cost. The next time someone offers runtime overhead as a reason to not use
    TypeScript, you’ll know exactly how well they’ve tested this claim!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因为生成 JavaScript 时类型和类型操作被擦除，它们不能影响运行时性能。 TypeScript 的静态类型确实是零成本的。下次有人提出运行时开销不使用
    TypeScript 的理由时，您会准确地知道他们对这种说法进行了多么充分的测试！
- en: 'There are two caveats to this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对此有两个注意事项：
- en: While there is no *runtime* overhead, the TypeScript compiler will introduce
    *build time* overhead. The TypeScript team takes compiler performance seriously
    and compilation is usually quite fast, especially for incremental builds. If the
    overhead becomes significant, your build tool may have a “transpile only” option
    to skip the type checking.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然没有 *运行时* 开销，但 TypeScript 编译器会引入 *构建时* 开销。TypeScript 团队认真对待编译器性能，编译通常相当快，特别是对于增量构建来说。如果开销变得显著，您的构建工具可能有“仅转译”选项以跳过类型检查。
- en: The code that TypeScript emits to support older runtimes *may* incur a performance
    overhead vs. native implementations. For example, if you use generator functions
    and target ES5, which predates generators, then `tsc` will emit some helper code
    to make things work. This may have some overhead vs. a native implementation of
    generators. In any case, this has to do with the emit target and language levels
    and is still independent of the *types*.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript 生成的代码以支持旧版本运行时 *可能* 会导致性能开销与原生实现相比。例如，如果您使用生成器函数并将目标设置为 ES5（比生成器早期），则
    `tsc` 将生成一些辅助代码以使其正常工作。这可能会比生成器的本机实现有一些开销。无论如何，这与发射目标和语言级别有关，并且仍然独立于 *类型*。
- en: Things to Remember
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 要记住的事情
- en: Code generation is independent of the type system. This means that TypeScript
    types cannot affect the runtime behavior or performance of your code.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码生成与类型系统无关。这意味着 TypeScript 类型无法影响代码的运行行为或性能。
- en: It is possible for a program with type errors to produce code (“compile”).
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个带有类型错误的程序可能会生成代码（“编译”）。
- en: TypeScript types are not available at runtime. To query a type at runtime, you
    need some way to reconstruct it. Tagged unions and property checking are common
    ways to do this. Some constructs, such as `class`, introduce both a TypeScript
    type and a value that is available at runtime.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript 类型在运行时不可用。要在运行时查询类型，您需要某种方式来重建它。标签联合和属性检查是常用的方法。一些构造，如 `class`，引入了
    TypeScript 类型和在运行时可用的值。
- en: 'Item 4: Get Comfortable with Structural Typing'
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目 4：熟悉结构化类型
- en: 'JavaScript is inherently duck typed: if you pass a function a value with all
    the right properties, it won’t care how you made the value. It will just use it.
    (“If it walks like a duck and talks like a duck…”) TypeScript models this behavior,
    and it can sometimes lead to surprising results because the type checker’s understanding
    of a type may be broader than what you had in mind. Having a good grasp of structural
    typing will help you make sense of errors and non-errors and help you write more
    robust code.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 本质上是鸭子类型的：如果您将具有所有正确属性的值传递给函数，它不会关心您如何创建该值。它只会使用它。（“如果它走起来像鸭子，叫起来像鸭子……”）TypeScript
    模拟了这种行为，有时可能会导致令人惊讶的结果，因为类型检查器对类型的理解可能比您设想的更广泛。对结构类型有很好的理解将有助于您理解错误和非错误，并帮助您编写更健壮的代码。
- en: 'Say you’re working on a physics library and have a 2D vector type:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在开发一个物理库，并且有一个二维向量类型：
- en: '[PRE38]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You write a function to calculate its length:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您编写一个函数来计算它的长度：
- en: '[PRE39]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now you introduce the notion of a named vector:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你引入了命名向量的概念：
- en: '[PRE40]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `calculateLength` function will work with `NamedVector`s because they have
    `x` and `y` properties, which are `number`s. TypeScript is smart enough to figure
    this out:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`calculateLength` 函数将与 `NamedVector` 一起工作，因为它们具有 `x` 和 `y` 属性，这些属性是 `number`
    类型。TypeScript 足够智能，可以理解这一点：'
- en: '[PRE41]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: What is interesting is that you never declared the relationship between `Vector2D`
    and `NamedVector`. And you did not have to write an alternative implementation
    of `calculateLength` calculateLength for `NamedVector`s. TypeScript’s type system
    is modeling JavaScript’s runtime behavior ([Item 1](#ts-vs-js)). It allowed `calculateLength`
    to be called with a `NamedVector` because its *structure* was compatible with
    `Vector2D`. This is where the term “structural typing” comes from.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，你从未声明过 `Vector2D` 和 `NamedVector` 之间的关系。你也不必为 `NamedVector` 写一个 `calculateLength`
    的替代实现。TypeScript 的类型系统模拟了 JavaScript 的运行时行为（[Item 1](#ts-vs-js)）。它允许 `calculateLength`
    被 `NamedVector` 调用，因为它的*结构*与 `Vector2D` 兼容。这就是“结构化类型”这个术语的来源。
- en: 'But this can also lead to trouble. Say you add a 3D vector type:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 但这也可能带来麻烦。比如你添加了一个 3D 向量类型：
- en: '[PRE42]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'and write a function to normalize them (make their length 1):'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 并编写一个函数将它们归一化（使它们的长度为 1）：
- en: '[PRE43]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If you call this function, you’re likely to get something longer than unit
    length:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你调用这个函数，你可能会得到一个比单位长度长的东西：
- en: '[PRE44]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: So what went wrong and why didn’t TypeScript catch the error?
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 那么出了什么问题，为什么 TypeScript 没有捕获到这个错误？
- en: The bug is that `calculateLength` operates on 2D vectors but `normalize` operates
    on 3D vectors. So the `z` component is ignored in the normalization.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Bug 是 `calculateLength` 在 2D 向量上运行，但 `normalize` 在 3D 向量上运行。因此在归一化中忽略了 `z` 分量。
- en: What’s perhaps more surprising is that the type checker does not catch this
    issue. Why are you allowed to call `calculateLength` with a 3D vector, despite
    its type declaration saying that it takes 2D vectors?
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`calculateLength` 方法没有捕获到这个问题。为什么你可以用 3D 向量调用 `calculateLength`，尽管其类型声明说它只接受
    2D 向量？'
- en: What worked so well with named vectors has backfired here. Calling `calculateLength`
    with an `{x, y, z}` object doesn’t throw an error. So the type checker doesn’t
    complain, either, and this behavior has led to a bug. (If you want this to be
    an error, you have some options. We’ll return to this example in [Item 37](ch04.html#brands).)
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名向量中奏效良好的东西在这里产生了反效果。使用 `{x, y, z}` 对象调用 `calculateLength` 不会抛出错误。因此类型检查器也不会抱怨，这种行为导致了一个
    bug。（如果你希望这是一个错误，你有一些选项。我们将在 [Item 37](ch04.html#brands) 中返回这个例子。）
- en: As you write functions, it’s easy to imagine that they will be called with arguments
    having the properties you’ve declared *and no others*. This is known as a “sealed”
    or “precise” type, and it cannot be expressed in TypeScript’s type system. Like
    it or not, your types are “open.”
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写函数时，很容易想象它们将被调用，参数具有你声明的属性*而且没有其他属性*。这被称为“密封”或“精确”类型，在 TypeScript 的类型系统中无法表达。不管你喜欢与否，你的类型是“开放”的。
- en: 'This can sometimes lead to surprises:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这有时会带来意外：
- en: '[PRE45]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Why is this an error? Since `axis` is one of the keys of `v`, which is a `Vector3D`,
    it should be either `"x"`, `"y"`, or `"z"`. And according to the declaration of
    `Vector3D`, these are all `number`s, so shouldn’t the type of `coord` be `number`?
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这是一个错误？因为 `axis` 是 `v` 的键之一，它是一个 `Vector3D`，所以它应该是 `"x"`、`"y"` 或 `"z"` 之一。根据
    `Vector3D` 的声明，这些都是 `number`，所以 `coord` 的类型不应该是 `number` 吗？
- en: 'Is this error a false positive? No! TypeScript is correct to complain. The
    logic in the previous paragraph assumes that `Vector3D` is sealed and does not
    have other properties. But it could:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误是假阳性吗？不是！TypeScript 正确地抱怨了。前面段落的逻辑假定 `Vector3D` 是密封的，并且没有其他属性。但它可能有：
- en: '[PRE46]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Since `v` could conceivably have any properties, the type of `axis` is `string`.
    TypeScript has no reason to believe that `v[axis]` is a number because, as you
    just saw, it might not be. Iterating over objects can be tricky to type correctly.
    We’ll return to this topic in [Item 54](ch07.html#iterate-objects), but in this
    case an implementation without loops would be better:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `v` 可能具有任何属性，所以 `axis` 的类型是 `string`。TypeScript 没有理由相信 `v[axis]` 是一个数字，因为正如你刚刚看到的，它可能不是。正确地对对象进行迭代可能很棘手。我们将在
    [Item 54](ch07.html#iterate-objects) 中返回到这个话题，但在这种情况下，没有循环的实现会更好：
- en: '[PRE47]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Structural typing can also lead to surprises with `class`es, which are compared
    structurally for assignability:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化类型也可能在比较 `class` 时引发意外，因为它们在分配性上进行结构化比较：
- en: '[PRE48]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Why is `d` assignable to `C`? It has a `foo` property that is a `string`. In
    addition, it has a `constructor` (from `Object.prototype`) that can be called
    with one argument (though it is usually called with zero). So the structures match.
    This might lead to surprises if you have logic in `C`’s constructor and write
    a function that assumes it’s run. This is quite different from languages like
    C++ or Java, where declaring a parameter of type `C` guarantees that it will be
    either `C` or a subclass of it.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么`d`可以赋值给`C`？它有一个`foo`属性，类型是`string`。此外，它有一个可以用一个参数调用的`constructor`（来自`Object.prototype`），尽管通常不带参数调用。所以结构匹配。如果你在`C`的构造函数中有逻辑，并编写一个假设它运行的函数，这可能会带来惊喜。这与
    C++ 或 Java 等语言完全不同，那里声明类型`C`的参数保证它要么是`C`，要么是其子类。
- en: 'Structural typing is beneficial when you’re writing tests. Say you have a function
    that runs a query on a database and processes the results:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写测试时，结构类型是有益的。假设你有一个函数，该函数在数据库上运行查询并处理结果：
- en: '[PRE49]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To test this, you could create a mock `PostgresDB`. But a better approach is
    to use structural typing and define a narrower interface:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试这一点，你可以创建一个模拟`PostgresDB`。但更好的方法是使用结构类型并定义一个更窄的接口：
- en: '[PRE50]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You can still pass `getAuthors` a `PostgresDB` in production since it has a
    `runQuery` method. Because of structural typing, the `PostgresDB` doesn’t need
    to say that it implements `DB`. TypeScript will figure out that it does.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然可以在生产中将`getAuthors`传递给`PostgresDB`，因为它有一个`runQuery`方法。由于结构类型，`PostgresDB`不需要声明它实现了`DB`。TypeScript
    将确定它确实实现了。
- en: 'When you write your tests, you can pass in a simpler object instead:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写测试时，可以传入一个更简单的对象：
- en: '[PRE51]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'TypeScript will verify that our test `DB` conforms to the interface. And your
    tests don’t need to know anything about your production database: no mocking libraries
    necessary! By introducing an abstraction (`DB`), we’ve freed our logic (and tests)
    from the details of a specific implementation (`PostgresDB`).'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 将验证我们的测试`DB`是否符合接口。而且你的测试不需要了解生产数据库的任何内容：无需模拟库！通过引入一个抽象（`DB`），我们从特定实现（`PostgresDB`）的细节中解放出逻辑（和测试）。
- en: Another advantage of structural typing is that it can cleanly sever dependencies
    between libraries. For more on this, see [Item 51](ch06.html#mirror-types-for-deps).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 结构类型的另一个优点是它可以清晰地断开库之间的依赖关系。关于此内容，请参阅[条款 51](ch06.html#mirror-types-for-deps)。
- en: Things to Remember
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需要记住的事情
- en: 'Understand that JavaScript is duck typed and TypeScript uses structural typing
    to model this: values assignable to your interfaces might have properties beyond
    those explicitly listed in your type declarations. Types are not “sealed.”'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 JavaScript 是鸭子类型，并且 TypeScript 使用结构类型来建模：可分配给你的接口的值可能具有超出类型声明中显式列出的属性。类型不是“封闭”的。
- en: Be aware that classes also follow structural typing rules. You may not have
    an instance of the class you expect!
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请注意，类也遵循结构类型规则。你可能不会得到你期望的类的实例！
- en: Use structural typing to facilitate unit testing.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用结构类型来促进单元测试。
- en: 'Item 5: Limit Use of the any Type'
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条款 5：限制对`any`类型的使用
- en: 'TypeScript’s type system is *gradual* and *optional*: *gradual* because you
    can add types to your code bit by bit and *optional* because you can disable the
    type checker whenever you like. The key to these features is the `any` type:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 的类型系统是*渐进的*和*可选的*：*渐进*是因为你可以逐步向你的代码添加类型，*可选*是因为你可以随时禁用类型检查器。这些特性的关键在于`any`类型：
- en: '[PRE52]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The type checker is right to complain here, but you can silence it just by typing
    `as any`. As you start using TypeScript, it’s tempting to use `any` types and
    type assertions (`as any`) when you don’t understand an error, think the type
    checker is incorrect, or simply don’t want to take the time to write out type
    declarations. In some cases this may be OK, but be aware that `any` eliminates
    many of the advantages of using TypeScript. You should at least understand its
    dangers before you use it.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 类型检查器在这里是正确的，但你可以通过输入`as any`来消除它。当你开始使用 TypeScript 时，很容易在你不理解错误时、认为类型检查器是错误的时候，或者简单地不想花时间编写类型声明时，就会使用`any`类型和类型断言(`as
    any`)。在某些情况下，这可能是可以接受的，但请注意`any`消除了使用 TypeScript 的许多优势。在使用之前，你至少应该了解其危险性。
- en: There’s No Type Safety with any Types
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任何类型都没有类型安全性
- en: 'In the preceding example, the type declaration says that `age` is a `number`.
    But `any` lets you assign a `string` to it. The type checker will believe that
    it’s a `number` (that’s what you said, after all), and the chaos will go uncaught:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，类型声明表明`age`是一个`number`。但是`any`让您可以将`string`赋值给它。类型检查器会认为它是一个`number`（毕竟这是您说的），混乱将不会被捕获：
- en: '[PRE53]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: any Lets You Break Contracts
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`any`让您违反了契约'
- en: 'When you write a function, you are specifying a contract: if the caller gives
    you a certain type of input, you’ll produce a certain type of output. But with
    an `any` type you can break these contracts:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当您编写一个函数时，您正在指定一个契约：如果调用者给您某种类型的输入，您将产生某种类型的输出。但是使用`any`类型，您可以打破这些契约：
- en: '[PRE54]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The birth date parameter should be a `Date`, not a `string`. The `any` type
    has let you break the contract of `calculateAge`. This can be particularly problematic
    because JavaScript is often willing to implicitly convert between types. A `string`
    will sometimes work where a `number` is expected, only to break in other circumstances.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 出生日期参数应该是`Date`类型，而不是`string`类型。使用`any`类型允许您违反`calculateAge`的契约。这可能特别问题，因为JavaScript通常愿意在类型之间进行隐式转换。`string`有时可以在期望`number`的地方工作，但在其他情况下会中断。
- en: There Are No Language Services for any Types
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任何类型都没有语言服务
- en: When a symbol has a type, the TypeScript language services are able to provide
    intelligent autocomplete and contextual documentation (as shown in [Figure 1-3](#efts-01in01)).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当符号具有类型时，TypeScript 语言服务能够提供智能自动完成和上下文文档（如[图 1-3](#efts-01in01)所示）。
- en: '![efts 01in01](assets/efts_01in01.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![efts 01in01](assets/efts_01in01.png)'
- en: Figure 1-3\. The TypeScript Language Service is able to provide contextual autocomplete
    for symbols with types.
  id: totrans-216
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-3\. TypeScript 语言服务能够为具有类型的符号提供上下文自动完成。
- en: but for symbols with an `any` type, you’re on your own ([Figure 1-4](#efts-01in02)).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 但对于具有`any`类型的符号，您需要靠自己（见图 [1-4](#efts-01in02)）。
- en: '![efts 01in02](assets/efts_01in02.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![efts 01in02](assets/efts_01in02.png)'
- en: Figure 1-4\. There is no autocomplete for properties on symbols with any types.
  id: totrans-219
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-4\. 对具有任意类型的符号的属性没有自动完成。
- en: 'Renaming is another such service. If you have a Person type and functions to
    format a person’s name:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 重命名是另一种服务。如果您有一个Person类型和用于格式化人名的函数：
- en: '[PRE55]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: then you can select `first` in your editor, choose “Rename Symbol,” and change
    it to `firstName` (see Figures [1-5](#efts-01in03) and [1-6](#efts-01in04)).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然后您可以在编辑器中选择`first`，选择“重命名符号”，并将其更改为`firstName`（参见图 [1-5](#efts-01in03) 和 [1-6](#efts-01in04)）。
- en: '![efts 01in03](assets/efts_01in03.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![efts 01in03](assets/efts_01in03.png)'
- en: Figure 1-5\. Renaming a symbol in vscode.
  id: totrans-224
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-5\. 在 vscode 中重命名符号。
- en: '![img { width: 50% !important; }](assets/efts_01in04.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![img { width: 50% !important; }](assets/efts_01in04.png)'
- en: Figure 1-6\. Choosing the new name. The TypeScript language service ensures
    that all uses of the symbol in the project are also renamed.
  id: totrans-226
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-6\. 选择新名称。TypeScript 语言服务确保项目中使用该符号的所有地方也会被重命名。
- en: 'This changes the `formatName` function but not the `any` version:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这更改了`formatName`函数，但未更改`any`版本：
- en: '[PRE56]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: TypeScript’s motto is “JavaScript that scales.” A key part of “scales” is the
    language services, which are a core part of the TypeScript experience (see [Item
    6](ch02_split_000.html#editor)). Losing them will lead to a loss in productivity,
    not just for you but for everyone else working with your code.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 的座右铭是“可扩展的 JavaScript”。“可扩展”的关键部分是语言服务，这是 TypeScript 经验的核心部分（参见[项目
    6](ch02_split_000.html#editor)）。失去它们将导致生产力损失，不仅对您而言，对所有与您的代码一起工作的人来说也是如此。
- en: any Types Mask Bugs When You Refactor Code
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`any`类型在重构代码时掩盖了错误'
- en: 'Suppose you’re building a web application in which users can select some sort
    of item. One of your components might have an `onSelectItem` callback. Writing
    a type for an Item seems like a hassle, so you just use `any` as a stand-in:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在构建一个 Web 应用程序，用户可以选择某种项目。您的某个组件可能会有一个`onSelectItem`回调。编写一个Item类型似乎很麻烦，因此您只需使用`any`作为替代品：
- en: '[PRE57]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Here’s code that manages that component:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是管理该组件的代码：
- en: '[PRE58]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Later you rework the selector in a way that makes it harder to pass the whole
    `item` object through to `onSelectItem`. But that’s no big deal since you just
    need the ID. You change the signature in `ComponentProps`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 后来，您以使整个`item`对象传递到`onSelectItem`更难的方式重写了选择器。但这没什么大不了，因为您只需要ID。您在`ComponentProps`中更改了签名：
- en: '[PRE59]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: You update the component and everything passes the type checker. Victory!
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 您更新了组件，一切都通过了类型检查器。胜利！
- en: …or is it? `handleSelectItem` takes an `any` parameter, so it’s just as happy
    with an Item as it is with an ID. It produces a runtime exception, despite passing
    the type checker. Had you used a more specific type, this would have been caught
    by the type checker.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: …或者说呢？`handleSelectItem`接受一个`any`参数，因此它对Item和ID一样满意。它会产生一个运行时异常，尽管通过了类型检查器。如果你使用了更具体的类型，类型检查器就会捕捉到这个问题。
- en: any Hides Your Type Design
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`any`隐藏了你的类型设计'
- en: The type definition for complex objects like your application state can get
    quite long. Rather than writing out types for the dozens of properties in your
    page’s state, you may be tempted to just use an `any` type and be done with it.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 像应用程序状态这样的复杂对象的类型定义可能会变得非常长。与其为页面状态中的数十个属性编写类型定义，你可能会诱惑于只使用`any`类型就搞定。
- en: This is problematic for all the reasons listed in this item. But it’s also problematic
    because it hides the design of your state. As [Chapter 4](ch04.html#ch-design)
    explains, good type design is essential for writing clean, correct, and understandable
    code. With an `any` type, your type design is implicit. This makes it hard to
    know whether the design is a good one, or even what the design is at all. If you
    ask a coworker to review a change, they’ll have to reconstruct whether and how
    you changed the application state. Better to write it out for everyone to see.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点存在问题，原因列在此项目中。但它也因为隐藏了你的状态设计而变得棘手。正如[第四章](ch04.html#ch-design)所述，良好的类型设计对于编写干净、正确和易理解的代码至关重要。使用`any`类型时，你的类型设计变得隐含。这使得很难知道设计是否良好，甚至根本不知道设计是什么。如果你让同事审查一个变更，他们将不得不重建应用程序状态的变更情况和方式。最好将其写出来供所有人看到。
- en: any Undermines Confidence in the Type System
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`any`削弱了对类型系统的信心'
- en: Every time you make a mistake and the type checker catches it, it boosts your
    confidence in the type system. But when you see a type error at runtime, that
    confidence takes a hit. If you’re introducing TypeScript on a larger team, this
    might make your coworkers question whether TypeScript is worth the effort. `any`
    types are often the source of these uncaught errors.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你犯错，类型检查器捕获到它时，这会增强你对类型系统的信心。但当你在运行时看到类型错误时，这种信心会受到打击。如果你正在一个较大团队引入TypeScript，这可能会让你的同事质疑是否值得使用TypeScript。`any`类型通常是这些未捕获错误的根源。
- en: TypeScript aims to make your life easier, but TypeScript with lots of `any`
    types can be harder to work with than untyped JavaScript because you have to fix
    type errors *and* still keep track of the real types in your head. When your types
    match reality, it frees you from the burden of having to keep type information
    in your head. TypeScript will keep track of it for you.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript旨在让你的生活更轻松，但带有大量`any`类型的TypeScript可能比无类型的JavaScript更难处理，因为你不仅需要修复类型错误，还需要记住真正的类型。当你的类型与现实匹配时，它将解放你，不再需要将类型信息记在脑中，TypeScript会为你跟踪它。
- en: For the times when you must use `any`, there are better and worse ways to do
    it. For much more on how to limit the downsides of `any`, see [Chapter 5](ch05.html#ch-any).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当你必须使用`any`类型时，有更好和更糟糕的方法。关于如何限制`any`带来的不利影响，详见[第五章](ch05.html#ch-any)。
- en: Things to Remember
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 要记住的事情
- en: The `any` type effectively silences the type checker and TypeScript language
    services. It can mask real problems, harm developer experience, and undermine
    confidence in the type system. Avoid using it when you can!
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`any`类型有效地沉默了类型检查器和TypeScript语言服务。它可能掩盖真正的问题，损害开发者体验，并削弱类型系统的信心。尽量在可以避免使用它的时候避免！'
