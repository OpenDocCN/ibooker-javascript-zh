- en: Chapter 6\. React State Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章：React状态管理
- en: Data is what makes our React components come to life. The user interface for
    recipes that we built in the last chapter is useless without the array of recipes.
    It’s the recipes and the ingredients along with clear instructions that makes
    such an app worthwhile. Our user interfaces are tools that creators will use to
    generate content. In order to build the best tools possible for our content creators,
    we’ll need to know how to effectively manipulate and change data.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 数据是使我们的 React 组件焕发生机的关键。我们在上一章中构建的食谱用户界面没有食谱数组是毫无用处的。正是食谱和配料以及清晰的说明使这样的应用程序值得使用。我们的用户界面是创作者用来生成内容的工具。为了为我们的内容创作者构建最佳工具，我们需要知道如何有效地操纵和更改数据。
- en: 'In the last chapter, we constructed a *component tree*: a hierarchy of components
    that data was able to flow through as properties. Properties are half of the picture.
    State is the other half. The *state* of a React application is driven by data
    that has the ability to change. Introducing state to the recipe application could
    make it possible for chefs to create new recipes, modify existing recipes, and
    remove old ones.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们构建了一个 *组件树*：一个数据能够通过属性流动的组件层次结构。属性是画面的其中一半，状态是另一半。React 应用程序的 *状态* 是由具有改变能力的数据驱动的。向食谱应用程序引入状态可以使厨师能够创建新的食谱，修改现有的食谱，并删除旧的食谱。
- en: State and properties have a relationship with each other. When we work with
    React applications, we gracefully compose components that are tied together based
    on this relationship. When the state of a component tree changes, so do the properties.
    The new data flows through the tree, causing specific leaves and branches to render
    to reflect the new content.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 状态和属性相互关联。当我们使用 React 应用程序时，我们会优雅地组合基于这种关系的组件。当组件树的状态发生变化时，属性也会发生变化。新的数据通过树流动，导致特定的叶子和分支呈现以反映新的内容。
- en: In this chapter, we’re going to bring applications to life by introducing state.
    We’ll learn to create stateful components and how state can be sent down a component
    tree and user interactions back up the component tree. We’ll learn techniques
    for collecting form data from users. And we’ll take a look at the various ways
    in which we can separate concerns within our applications by introducing stateful
    context providers.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过引入状态来使应用程序生动起来。我们将学习如何创建有状态组件，以及如何将状态传递到组件树中，并将用户交互返回到组件树中。我们将学习收集用户表单数据的技巧。我们还将看看在应用程序中通过引入有状态的上下文提供者来分离关注点的各种方式。
- en: Building a Star Rating Component
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构   构建星级评分组件
- en: We would all be eating terrible food and watching terrible movies without the
    five-star rating system. If we plan on letting users drive the content on our
    website, we’ll need a way to know if that content is any good or not. That makes
    the `StarRating` component one of the most important React components you’ll ever
    build (see [Figure 6-1](#star_rating_component)).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有五颗星的评分系统，我们都会吃到糟糕的食物，观看糟糕的电影。如果我们计划让用户主导我们网站上的内容，我们需要一种方式来了解这些内容是否好用。这使得
    `StarRating` 组件成为你将要构建的最重要的 React 组件之一（参见[图6-1](#star_rating_component)）。
- en: '![lrc2 0601](assets/lrc2_0601.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![lrc2 0601](assets/lrc2_0601.png)'
- en: Figure 6-1\. StarRating component
  id: totrans-8
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-1. 星级评分组件
- en: 'The `StarRating` component will allow users to rate content based on a specific
    number of stars. Content that’s no good gets one star. Highly recommended content
    gets five stars. Users can set the rating for specific content by clicking on
    a specific star. First, we’ll need a star, and we can get one from `react-icons`:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`StarRating` 组件将允许用户根据特定数量的星星对内容进行评分。无用的内容得一星。高度推荐的内容得五颗星。用户可以通过点击特定的星星来设置特定内容的评分。首先，我们需要一个星星，我们可以从
    `react-icons` 获取一个：'
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`react-icons` is an npm library that contains hundreds of SVG icons that are
    distributed as React components. By installing it, we just installed several popular
    icon libraries that contain hundreds of common SVG icons. You can browse all the
    icons in the [library](https://react-icons.netlify.com). We’re going to use the
    star icon from the Font Awesome collection:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`react-icons` 是一个 npm 库，包含数百个 SVG 图标，作为 React 组件分发。通过安装它，我们就安装了几个流行的图标库，包含数百个常见的
    SVG 图标。你可以在[库中](https://react-icons.netlify.com)浏览所有图标。我们将使用 Font Awesome 集合中的星形图标：'
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, we’ve created a `StarRating` component that renders five SVG stars that
    we’ve imported from `react-icons`. The first three stars are filled in with red,
    and the last two are grey. We render the stars first because seeing them gives
    us a roadmap for what we’ll have to build. A selected star should be filled in
    with red, and a star that’s not selected should be greyed out. Let’s create a
    component that automatically files the stars based upon the selected property:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个 `StarRating` 组件，它渲染了五个 SVG 星星，我们从 `react-icons` 中导入了这些星星。前三颗星星填充为红色，最后两颗为灰色。我们首先渲染这些星星，因为看到它们可以为我们接下来的构建提供路线图。选中的星星应该填充为红色，未选中的星星应该变灰色。让我们创建一个组件，根据选中的属性自动填充星星：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `Star` component renders an individual star and uses the `selected` property
    to fill it with the appropriate color. If the selected property is not passed
    to this component, we’ll assume that the star should not be selected and by default
    will be filled in with grey.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`Star` 组件渲染单个星星，并使用 `selected` 属性来填充合适的颜色。如果未传递 `selected` 属性给此组件，我们将假定该星星不被选中，默认填充灰色。'
- en: 'The 5-star rating system is pretty popular, but a 10-star rating system is
    far more detailed. We should allow developers to select the total number of stars
    they wish to use when they add this component to their app. This can be accomplished
    by adding a `totalStars` property to the `StarRating` component:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 5星评级系统非常流行，但10星评级系统更加详细。当开发人员将此组件添加到他们的应用程序中时，我们应该允许他们选择希望使用的星星总数。可以通过向 `StarRating`
    组件添加 `totalStars` 属性来实现这一目标：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we added the `createArray` function from [Chapter 2](ch02.html#javascript-for-react).
    All we have to do is supply the length of the array that we want to create and
    we get a new array at that length. We use this function with the `totalStars`
    property to create an array of a specific length. Once we have an array, we can
    map over it and render `Star` components. By default, `totalStars` is equal to
    `5`, which means this component will render `5` grey stars, as shown in [Figure 6-2](#five_stars).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从[第2章](ch02.html#javascript-for-react)中添加了 `createArray` 函数。我们只需提供要创建的数组的长度，就可以得到一个新的数组。我们使用
    `totalStars` 属性调用此函数来创建具有特定长度的数组。一旦我们有了数组，我们就可以对其进行映射并渲染 `Star` 组件。默认情况下，`totalStars`
    等于 `5`，这意味着此组件将渲染 `5` 个灰色星星，如[图6-2](#five_stars)所示。
- en: '![lrc2 0602](assets/lrc2_0602.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![lrc2 0602](assets/lrc2_0602.png)'
- en: Figure 6-2\. Five stars are displayed
  id: totrans-20
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-2\. 显示了五颗星
- en: The useState Hook
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`useState` Hook'
- en: 'It’s time to make the `StarRating` component clickable, which will allow our
    users to change the `rating`. Since the `rating` is a value that will change,
    we’ll store and change that value using React state. We incorporate state into
    a function component using a React feature called *Hooks*. *Hooks* contain reusable
    code logic that is separate from the component tree. They allow us to *hook* up
    functionality to our components. React ships with several built-in hooks we can
    use out of the box. In this case, we want to add state to our React component,
    so the first hook we’ll work with is React’s `useState` hook. This hook is already
    available in the `react` package; we simply need to import it:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候让 `StarRating` 组件可点击，这将允许用户更改 `rating`。由于 `rating` 是一个会变化的值，我们将使用 React
    状态来存储和更改该值。我们使用 React 功能称为 *Hooks* 将状态集成到函数组件中。 *Hooks* 包含与组件树分离的可重用代码逻辑。它们允许我们将功能连接到我们的组件上。React
    默认提供了几个内置的 hook 可供我们直接使用。在这种情况下，我们希望向我们的 React 组件添加状态，因此我们将首先使用 React 的 `useState`
    hook。这个 hook 已经包含在 `react` 包中，我们只需导入它：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The stars the user has selected represents the rating. We’ll create a state
    variable called `selectedStars`, which will hold the user’s rating. We’ll create
    this variable by adding the `useState` hook directly to the `StarRating` component:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 用户选择的星星代表评级。我们将创建一个名为 `selectedStars` 的状态变量，它将保存用户的评级。我们将通过直接向 `StarRating`
    组件添加 `useState` hook 来创建此变量：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We just *hooked* this component up with state. The `useState` hook is a function
    that we can invoke to return an array. The first value of that array is the state
    variable we want to use. In this case, that variable is `selectedStars`, or the
    number of stars the `StarRating` will color red. `useState` returns an array.
    We can take advantage of array destructuring, which allows us to name our state
    variable whatever we like. The value we send to the `useState` function is the
    default value for the state variable. In this case, `selectedStars` will initially
    be set to `3`, as shown in [Figure 6-3](#selected_stars).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚使用了状态将这个组件连接起来。`useState`钩子是一个可以调用以返回数组的函数。数组的第一个值是我们想要使用的状态变量。在这种情况下，那个变量是`selectedStars`，或者`StarRating`要渲染成红色的星星数。`useState`返回一个数组。我们可以利用数组解构，可以给我们的状态变量起任何我们喜欢的名字。我们发送给`useState`函数的值是状态变量的默认值。在这种情况下，`selectedStars`最初将被设置为`3`，如[图 6-3](#selected_stars)所示。
- en: '![lrc2 0603](assets/lrc2_0603.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![lrc2 0603](assets/lrc2_0603.png)'
- en: Figure 6-3\. Three of five stars are selected
  id: totrans-28
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-3\. 五颗星中有三颗被选中
- en: 'In order to collect a different rating from the user, we’ll need to allow them
    to click on any of our stars. This means we’ll need to make the stars clickable
    by adding an `onClick` handler to the `FaStar` component:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从用户那里收集不同的评分，我们需要允许他们点击我们的星星之一。这意味着我们需要通过给`FaStar`组件添加一个`onClick`处理程序来使星星可点击：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, we modified the star to contain an `onSelect` property. Check it out:
    this property is a function. When a user clicks on the `FaStar` component, we’ll
    invoke this function, which can notify its parent that a star has been clicked.
    The default value for this function is `f => f`. This is simply a fake function
    that does nothing; it just returns whatever argument was sent to it. However,
    if we do not set a default function and the `onSelect` property is not defined,
    an error will occur when we click the `FaStar` component because the value for
    `onSelect` must be a function. Even though `f => f` does nothing, it is a function,
    which means it can be invoked without causing errors. If an `onSelect` property
    is not defined, no problem. React will simply invoke the fake function and nothing
    will happen.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们修改了星星组件，添加了一个`onSelect`属性。来看看：这个属性是一个函数。当用户点击`FaStar`组件时，我们将调用这个函数，它可以通知其父组件星星被点击了。这个函数的默认值是`f
    => f`。这只是一个什么都不做的假函数；它只是返回传递给它的任何参数。然而，如果我们不设置默认函数并且`onSelect`属性未定义，当点击`FaStar`组件时将会出现错误，因为`onSelect`的值必须是一个函数。即使`f
    => f`什么都不做，它也是一个函数，这意味着可以调用它而不会出错。如果`onSelect`属性未定义，也没问题。React将简单地调用这个假函数，什么都不会发生。
- en: 'Now that our `Star` component is clickable, we’ll use it to change the state
    of the `StarRating`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的`Star`组件可以点击了，我们将用它来改变`StarRating`的状态：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In order to change the state of the `StarRating` component, we’ll need a function
    that can modify the value of `selectedStars`. The second item in the array that’s
    returned by the `useState` hook is a function that can be used to change the state
    value. Again, by destructuring this array, we can name that function whatever
    we like. In this case, we’re calling it `setSelectedStars`, because that’s what
    it does: it sets the value of `selectedStars`.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改变`StarRating`组件的状态，我们需要一个可以修改`selectedStars`值的函数。由`useState`钩子返回的数组中的第二项是一个可以用来改变状态值的函数。再次通过解构这个数组，我们可以将这个函数命名为任何我们喜欢的名字。在这种情况下，我们称之为`setSelectedStars`，因为它的作用就是设置`selectedStars`的值。
- en: The most important thing to remember about Hooks is that they can cause the
    component they’re hooked into to rerender. Every time we invoke the `setSelectedStars`
    function to change the value of `selectedStars`, the `StarRating` function component
    will be reinvoked by the hook, and it will render again, this time with a new
    value for `selectedStars`. This is why Hooks are such a killer feature. When data
    within the hook changes, they have the power to rerender the component they’re
    hooked into with new data.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Hooks最重要的事情是它们可以导致它们所附着到的组件重新渲染。每当我们调用`setSelectedStars`函数来改变`selectedStars`的值时，`StarRating`函数组件将被钩子重新调用，并且将以新的`selectedStars`值再次渲染。这就是Hooks如此强大的原因。当hook内的数据发生变化时，它们有能力使用新数据重新渲染它们所附着到的组件。
- en: The `StarRating` component will be rerendered every time a user clicks a `Star`.
    When the user clicks the `Star`, the `onSelect` property of that star is invoked.
    When the `onSelect` property is invoked, we’ll invoke the `setSelectedStars` function
    and send it the number of the star that was just selected. We can use the `i`
    variable from the `map` function to help us calculate that number. When the `map`
    function renders the first `Star`, the value for `i` is `0`. This means that we
    need to add `1` to this value to get the correct number of stars. When `setSelectedStars`
    is invoked, the `StarRating` component is invoked with a the value for `selectedStars`,
    as shown in [Figure 6-4](#hooks_react_tools).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 每当用户点击`Star`时，`StarRating`组件都将重新渲染。当用户点击`Star`时，会调用该星星的`onSelect`属性。当调用`onSelect`属性时，我们将调用`setSelectedStars`函数，并将刚刚选中的星星数传递给它。我们可以使用`map`函数中的变量`i`来帮助我们计算该数值。当`map`函数渲染第一个`Star`时，变量`i`的值为`0`。这意味着我们需要将此值加`1`以获取正确的星星数量。当调用`setSelectedStars`时，`StarRating`组件将使用`selectedStars`的值调用，如[图 6-4](#hooks_react_tools)所示。
- en: '![lrc2 0604](assets/lrc2_0604.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![lrc2 0604](assets/lrc2_0604.png)'
- en: Figure 6-4\. Hooks in React developer tools
  id: totrans-38
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-4\. React开发者工具中的Hooks
- en: The React developer tools will show you which Hooks are incorporated with specific
    components. When we render the `StarRating` component in the browser, we can view
    debugging information about that component by selecting it in the developer tools.
    In the column on the right, we can see that the `StarRating` component incorporates
    a state Hook that has a value of `2`. As we interact with the app, we can watch
    the state value change and the component tree rerender with the corresponding
    number of stars selected.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在React开发者工具中，你可以看到哪些Hooks与特定组件集成。当我们在浏览器中渲染`StarRating`组件时，可以通过在开发者工具中选择它来查看关于该组件的调试信息。在右侧列中，我们可以看到`StarRating`组件集成了一个状态Hook，其值为`2`。当我们与应用交互时，可以观察状态值的变化以及组件树根据选择的星星数量重新渲染。
- en: Refactoring for Advanced Reusability
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为高级可重用性重构
- en: Right now, the Star component is ready for production. You can use it across
    several applications when you need to obtain a rating from a user. However, if
    we were to ship this component to npm so that anyone in the world could use it
    to obtain ratings from users, we may want to consider handling a couple more use
    cases.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Star组件已经准备好投入生产。当你需要从用户那里获取评分时，可以在多个应用程序中使用它。然而，如果我们要将此组件发布到npm，以便全世界的任何人都可以使用它来获取用户的评分，我们可能需要考虑处理更多的使用案例。
- en: 'First, let’s consider the `style` property. This property allows you to add
    CSS styles to elements. It is highly possible that a future developer, even yourself,
    could come across the need to modify the style of your entire container. They
    may attempt to do something like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们考虑`style`属性。此属性允许您向元素添加CSS样式。未来的开发人员，甚至是你自己，可能会有必要修改整个容器的样式。他们可能会尝试做类似这样的事情：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: All React elements have style properties. A lot of components also have style
    properties. So attempting to modify the style for the entire component seems sensible.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 所有React元素都有样式属性。许多组件也有样式属性。因此，尝试修改整个组件的样式似乎是合理的。
- en: 'All we need to do is collect those styles and pass them down to the `StarRating`
    container. Currently, the `StarRating` does not have a single container because
    we are using a React fragment. To make this work, we’ll have to upgrade from a
    fragment to a `div` element and pass the styles to that `div`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需收集这些样式并将它们传递给`StarRating`容器。目前，`StarRating`没有单一的容器，因为我们正在使用React片段。为了使其正常工作，我们需要从片段升级到一个`div`元素，并将样式传递给该`div`：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the code above, we replaced the fragment with a `div` element and then applied
    styles to that `div` element. By default we assign that `div` a padding of `5px`,
    and then we use the spread operator to apply the rest of the properties from the
    `style` object to the `div` style.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们将片段替换为一个`div`元素，然后将样式应用于该`div`元素。默认情况下，我们为该`div`分配`5px`的填充，然后使用展开运算符将`style`对象的其余属性应用于`div`样式。
- en: 'Additionally, we may find developers who attempt to implement other common
    properties properties to the entire star rating:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可能会发现开发人员尝试为整个星级评分实现其他常见属性属性：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this sample, the user is trying to add a double-click method to the entire
    `StarRating` component. If we feel it is necessary, we can also pass this method
    along with any other properties down to our containing `div`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，用户正在尝试为整个`StarRating`组件添加双击方法。如果我们认为有必要，我们也可以将此方法与任何其他属性一起传递给包含它的`div`：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The first step is to collect any and all properties that the user may be attempting
    to add to the `StarRating`. We gather these properties using the spread operator:
    `...props`. Next, we’ll pass all of these remaining properties down to the `div`
    element: `{...props}`.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是收集用户可能尝试添加到`StarRating`的任何和所有属性。我们使用展开运算符`...props`收集这些属性。接下来，我们将所有这些剩余的属性传递给`div`元素：`{...props}`。
- en: By doing this, we make two assumptions. First, we are assuming that users will
    add only those properties that are supported by the div element. Second, we are
    assuming that our user can’t add malicious properties to the component.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们做出了两个假设。首先，我们假设用户只会添加div元素支持的属性。其次，我们假设我们的用户不能向组件添加恶意属性。
- en: This is not a blanket rule to apply to all of your components. In fact, it’s
    only a good idea to add this level of support in certain situations. The real
    point is that it’s important to think about how the consumers of your component
    may try to use it in the future.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是适用于所有组件的普遍规则。事实上，只有在某些情况下才添加此级别的支持是一个好主意。真正的重点在于重要性思考消费者可能在未来如何尝试使用组件。
- en: State in Component Trees
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件树中的状态
- en: It’s not a great idea to use state in every single component. Having state data
    distributed throughout too many of your components will make it harder to track
    down bugs and make changes within your application. This occurs because it’s hard
    to keep track of where the state values live within your component tree. It’s
    easier to understand your application’s state, or state for a specific feature,
    if you manage it from one location. There are several approaches to this methodology,
    and the first one we’ll analyze is storing state at the root of the component
    tree and passing it down to child components via props.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个组件中使用状态并不是一个好主意。将状态数据分散到太多的组件中将使得在应用程序中跟踪错误和进行更改变得更加困难。这是因为很难跟踪状态值在组件树中的位置。如果您从一个位置管理应用程序的状态或特定功能的状态，那么理解应用程序的状态会更容易。有几种方法可以实现这种方法，我们将分析的第一种方法是将状态存储在组件树的根部，并通过props将其传递给子组件。
- en: 'Let’s build a small application that can be used to save a list of colors.
    We’ll call the app the “Color Organizer”, and it will allow users to associate
    a list of colors with a custom title and rating. To get started, a sample dataset
    may look like the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个可以用来保存颜色列表的小应用程序。我们将称此应用程序为“颜色组织者”，它将允许用户将一系列颜色与自定义标题和评分关联起来。为了开始，一个示例数据集可能如下所示：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The *color-data.json* file contains an array of three colors. Each color has
    an `id`, `title`, `color`, and `rating`. First, we’ll create a UI consisting of
    React components that will be used to display this data in a browser. Then we’ll
    allow the users to add new colors as well as rate and remove colors from the list.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*color-data.json*文件包含一个包含三种颜色的数组。每种颜色都有一个`id`、`title`、`color`和`rating`。首先，我们将创建一个UI，由React组件组成，用于在浏览器中显示这些数据。然后，我们将允许用户添加新颜色，以及对列表中的颜色进行评分和删除。'
- en: Sending State Down a Component Tree
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向组件树传递状态
- en: 'In this iteration, we’ll store state in the root of the Color Organizer, the
    `App` component, and pass the colors down to child components to handle the rendering.
    The `App` component will be the only component within our application that holds
    state. We’ll add the list of colors to the `App` with the `useState` hook:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个迭代中，我们将状态存储在“颜色组织者”的根部，即`App`组件中，并将颜色传递给子组件以处理渲染。`App`组件将是我们应用程序中唯一拥有状态的组件。我们将使用`useState`钩子将颜色列表添加到`App`中：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `App` component sits at the root of our tree. Adding `useState` to this
    component hooks it up with state management for colors. In this example, the `colorData`
    is the array of sample colors from above. The `App` component uses the `colorData`
    as the initial state for `colors`. From there, the `colors` are passed down to
    a component called the `ColorList`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`App`组件位于我们的树的根部。将`useState`添加到此组件将其与颜色状态管理连接起来。在此示例中，`colorData`是上述示例颜色的数组。`App`组件使用`colorData`作为`colors`的初始状态。从那里，`colors`被传递给一个名为`ColorList`的组件：'
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `ColorList` receives the colors from the `App` component as props. If the
    list is empty, this component will display a message to our users. When we have
    a color array, we can map over it and pass the details about each color farther
    down the tree to the `Color` component:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`ColorList` 作为 `App` 组件的 props 接收颜色。如果列表为空，此组件将向用户显示消息。当我们有一个颜色数组时，我们可以对其进行映射，并将每种颜色的详细信息传递到
    `Color` 组件：'
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `Color` component expects three properties: `title`, `color`, and `rating`.
    These values are found in each `color` object and were passed to this component
    using the spread operator `<Color {...color} />`. This takes each field from the
    `color` object and passes it to the `Color` component as a property with the same
    name as the object key. The `Color` component displays these values. The `title`
    is rendered inside of an `h1` element. The `color` value is displayed as the `backgroundColor`
    for a `div` element. The `rating` is passed farther down the tree to the `StarRating`
    component, which will display the rating visually as selected stars:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`Color` 组件期望三个属性：`title`、`color` 和 `rating`。这些值在每个 `color` 对象中找到，并使用扩展运算符 `<Color
    {...color} />` 将它们作为具有相同名称的属性传递给此组件。`Color` 组件显示这些值。`title` 在 `h1` 元素中呈现。`color`
    值显示为 `div` 元素的 `backgroundColor`。`rating` 被传递到更深层次的 `StarRating` 组件，它将以选定的星星形式可视化显示评级：'
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This `StarRating` component has been modified. We’ve turned it into a pure component.
    A pure component is a function component that does not contain state and will
    render the same user interface given the same props. We made this component a
    pure component because the state for color ratings are stored in the `colors`
    array at the root of the component tree. Remember that the goal of this iteration
    is to store state in a single location and not have it distributed through many
    different components within the tree.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `StarRating` 组件已经被修改。我们把它变成了一个纯组件。纯组件是一个不包含状态的函数组件，给定相同的 props 将呈现相同的用户界面。我们将此组件变为纯组件，因为颜色评级的状态存储在树的根部的
    `colors` 数组中。请记住，此迭代的目标是在单个位置存储状态，而不是在树中的许多不同组件中分布状态。
- en: Note
  id: totrans-70
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: It is possible for the `StarRating` component to hold its own state and receive
    state from a parent component via props. This is typically necessary when distributing
    components for wider use by the community. We demonstrate this technique in the
    next chapter when we cover the `useEffect` hook.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`StarRating` 组件有可能保持其自己的状态，并通过 props 从父组件接收状态。当向社区分发组件以供更广泛使用时，通常需要这样做。在下一章中，我们在讨论
    `useEffect` 钩子时将演示这种技术。'
- en: At this point, we’ve finished passing state down the component tree from the
    `App` component all the way to each `Star` component that’s filled red to visually
    represent the `rating` for each color. If we render the app based on the *color-data.json*
    file that was listed previously, we should see our colors in the browser, as shown
    in [Figure 6-5](#color_organizer).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经从 `App` 组件向每个填充红色以直观表示每种颜色 `rating` 的 `Star` 组件传递了状态。如果我们根据先前列出的 *color-data.json*
    文件渲染应用程序，我们应该在浏览器中看到我们的颜色，如图 [6-5](#color_organizer) 所示。
- en: '![lrc2 0605](assets/lrc2_0605.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![lrc2 0605](assets/lrc2_0605.png)'
- en: Figure 6-5\. Color Organizer rendered in the browser
  id: totrans-74
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-5\. 在浏览器中呈现的颜色组织器
- en: Sending Interactions Back up a Component Tree
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将交互发送回组件树的顶层
- en: So far, we’ve rendered a representation of the `colors` array as UI by composing
    React components and passing data down the tree from parent component to child
    component via props. What happens if we want to remove a color from the list or
    change the rating of a color in our list? The `colors` are stored in state at
    the root of our tree. We’ll need to collect interactions from child components
    and send them back up the tree to the root component where we can change the state.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已通过将数据从父组件传递到子组件的方式，通过组合 React 组件渲染了 `colors` 数组的 UI 表示。如果我们想要从列表中删除颜色或更改颜色的评级，会发生什么？
    `colors` 存储在树的根部的状态中。我们需要从子组件收集交互并将其发送回树的根组件，以便我们可以更改状态。
- en: 'For instance, let’s say we wanted to add a Remove button next to each color’s
    title that would allow users to remove colors from state. We would add that button
    to the `Color` component:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想要在每种颜色的标题旁边添加一个删除按钮，允许用户从状态中删除颜色。我们将该按钮添加到 `Color` 组件中：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we’ve modified the color by adding a button that will allow users to remove
    colors. First, we imported a trash can icon from `react-icons`. Next, we wrapped
    the `FaTrash` icon in a button. Adding an `onClick` handler to this button allows
    us to invoke the `onRemove` function property, which has been added to our list
    of properties along with the `id`. When a user clicks the Remove button, we’ll
    invoke `removeColor` and pass it the `id` of the color that we want to remove.
    That is why the `id` value has also been gathered from the `Color` component’s
    properties.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过添加一个按钮来修改颜色，允许用户移除颜色。首先，我们从`react-icons`中导入了一个垃圾桶图标。接下来，我们将`FaTrash`图标包装在一个按钮中。为此按钮添加一个`onClick`处理程序，允许我们调用添加到我们属性列表中的`onRemove`函数属性，该属性与`id`一起被添加。当用户点击删除按钮时，我们将调用`removeColor`并传递要移除的颜色的`id`。这也是为什么从`Color`组件的属性中收集到`id`值。
- en: 'This solution is great because we keep the `Color` component pure. It doesn’t
    have state and can easily be reused in a different part of the app or another
    application altogether. The `Color` component is not concerned with what happens
    when a user clicks the Remove button. All it cares about is notifying the parent
    that this event has occurred and passing the information about which color the
    user wishes to remove. It’s now the parent’s responsibility to handle this event:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案很棒，因为我们保持了`Color`组件的纯净性。它没有状态，并且可以轻松地在应用程序的不同部分或完全不同的另一个应用程序中重用。`Color`组件并不关心用户点击删除按钮后会发生什么。它只关心通知父组件此事件已发生，并传递关于用户希望移除哪种颜色的信息。现在，处理此事件的责任属于父组件：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `Color` component’s parent is the `ColorList`. This component also doesn’t
    have access to state. Instead of removing the color, it simply passes the event
    up to its parent. It accomplishes this by adding an `onRemoveColor` function property.
    If a `Color` component invokes the `onRemove` property, the `ColorList` will in
    turn invoke its `onRemoveColor` property and send the responsibility for removing
    the color up to its parent. The color’s `id` is still being passed to the `onRemoveColor`
    function.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`Color`组件的父组件是`ColorList`。这个组件也没有访问状态的权限。它不是移除颜色，而是简单地将事件传递给其父组件。它通过添加一个`onRemoveColor`函数属性来实现这一点。如果`Color`组件调用`onRemove`属性，`ColorList`将依次调用其`onRemoveColor`属性，并将移除颜色的责任传递给其父组件。颜色的`id`仍然会传递给`onRemoveColor`函数。'
- en: 'The parent of the `ColorList` is the `App`. This component is the component
    that has been hooked up with state. This is where we can capture the color `id`
    and remove the color in state:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`ColorList`的父组件是`App`。这个组件是已经与状态连接的组件。这是我们可以捕获颜色`id`并在状态中移除颜色的地方：'
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: First, we add a variable for `setColors`. Remember that the second argument
    in the array returned by `useState` is a function we can use to modify the state.
    When the `ColorList` raises an `onRemoveColor` event, we capture the `id` of the
    color to remove from the arguments and use it to filter the list of colors to
    exclude the color the user wants to remove. Next, we change the state. We use
    the `setColors` function to change change the array of colors to the newly filtered
    array.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们添加一个变量`setColors`。记住，`useState`返回的数组的第二个参数是一个函数，我们可以用它来修改状态。当`ColorList`触发`onRemoveColor`事件时，我们捕获要从参数中移除的颜色的`id`，并使用它来过滤颜色列表，以排除用户想要移除的颜色。接下来，我们改变状态。我们使用`setColors`函数将颜色数组更改为新过滤的数组。
- en: Changing the state of the `colors` array causes the `App` component to be rerendered
    with the new list of colors. Those new colors are passed to the `ColorList` component,
    which is also rerendered. It will render `Color` components for the remaining
    colors and our UI will reflect the changes we’ve made by rendering one less color.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 改变`colors`数组的状态会导致`App`组件重新渲染，展示新的颜色列表。这些新的颜色会传递给`ColorList`组件，该组件也会重新渲染。它将为剩余的颜色渲染`Color`组件，我们的UI将反映出我们通过渲染少一个颜色来做出的更改。
- en: 'If we want to rate the `colors` that are stored in the `App` components state,
    we’ll have to repeat the process with an `onRate` event. First, we’ll collect
    the new rating from the individual star that was clicked and pass that value to
    the parent of the `StarRating`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想对存储在`App`组件状态中的`colors`进行评级，我们将不得不重复使用`onRate`事件的过程。首先，我们将从单击的星级中收集新的评分，并将该值传递给`StarRating`的父组件：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, we’ll grab the rating from the `onRate` handler we added to the `StarRating`
    component. We’ll then pass the new rating along with the `id` of the color to
    be rated up to the `Color` component’s parent via another `onRate` function property:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将从我们添加到`StarRating`组件的`onRate`处理程序中获取评分。然后，我们将新的评分与要评分的颜色的`id`一起通过另一个`onRate`函数属性传递给`Color`组件的父组件：
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the `ColorList` component, we’ll have to capture the `onRate` event from
    individual color components and pass them up to its parent via the `onRateColor`
    function property:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ColorList`组件中，我们需要捕获来自各个颜色组件的`onRate`事件，并通过`onRateColor`函数属性将其传递给其父组件：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, after passing the event up through all of these components, we’ll
    arrive at the `App`, where state is stored and the new rating can be saved:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在所有这些组件中传递事件之后，我们将到达`App`，在那里存储状态并可以保存新的评分：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `App` component will change color ratings when the `ColorList` invokes the
    `onRateColor` property with the `id` of the color to rate and the new rating.
    We’ll use those values to construct an array of new colors by mapping over the
    existing colors and changing the rating for the color that matches the `id` property.
    Once we send the `newColors` to the `setColors` function, the state value for
    `colors` will change and the `App` component will be invoked with a new value
    for the `colors` array.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当`ColorList`调用带有颜色`id`和新评分的`onRateColor`属性时，`App`组件将更改颜色评分。我们将使用这些值构建一个新颜色数组，通过映射现有颜色并为匹配`id`属性的颜色更改评分。一旦我们将`newColors`发送到`setColors`函数，`colors`的状态值将更改，并且`App`组件将使用`colors`数组的新值被调用。
- en: Once the state of our `colors` array changes, the UI tree is rendered with the
    new data. The new rating is reflected back to the user via red stars. Just as
    we passed data down a component tree via props, interactions can be passed back
    up the tree along with data via function properties.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的`colors`数组的状态发生变化，UI树就会用新数据重新渲染。新的评分通过红色星星反馈给用户。正如我们通过props向组件树下传递数据一样，交互也可以通过函数属性将数据传回树上。
- en: Building Forms
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建表单
- en: 'For a lot of us, being a web developer means collecting large amounts of information
    from users with forms. If this sounds like your job, then you’ll be building a
    lot of form components with React. All of the HTML form elements that are available
    to the DOM are also available as React elements, which means that you may already
    know how to render a form with JSX:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们许多人来说，作为网页开发人员意味着从用户那里收集大量信息。如果这听起来像是你的工作，那么你将会使用React构建大量的表单组件。所有在DOM中可用的HTML表单元素也可以作为React元素使用，这意味着你可能已经知道如何使用JSX渲染表单：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This `form` element has three child elements: two `input` elements and a `button`.
    The first `input` element is a text input that will be used to collect the `title`
    value for new colors. The second `input` element is an HTML color input that will
    allow users to pick a `color` from a color wheel. We’ll be using basic HTML form
    validation, so we’ve marked both inputs as `required`. The ADD button will be
    used to add a new color.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`form`元素有三个子元素：两个`input`元素和一个`button`。第一个`input`元素是一个文本输入，将用于收集新颜色的`title`值。第二个`input`元素是一个HTML颜色输入，允许用户从颜色选择器中选择`color`。我们将使用基本的HTML表单验证，因此我们已将两个输入标记为`required`。ADD按钮用于添加新颜色。
- en: Using Refs
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Refs
- en: When it’s time to build a form component in React, there are several patterns
    available to you. One of these patterns involves accessing the DOM node directly
    using a React feature called refs. In React, a ref is an object that stores values
    for the lifetime of a component. There are several use cases that involve using
    refs. In this section, we’ll look at how we can access a DOM node directly with
    a ref.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当在React中构建表单组件时，有几种可用的模式供选择。其中一种模式涉及使用React的一个特性直接访问DOM节点，这个特性称为refs。在React中，ref是一个对象，用于在组件的生命周期内存储值。有几种使用refs的用例。在本节中，我们将看看如何使用ref直接访问DOM节点。
- en: 'React provides us with a `useRef` hook that we can use to create a *ref*. We’ll
    use this hook when building the `AddColorForm` component:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: React为我们提供了一个`useRef`钩子，我们可以用它来创建一个*ref*。在构建`AddColorForm`组件时，我们将使用这个钩子：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'First, when creating this component, we’ll also create two refs using the `useRef`
    hook. The `txtTitle` ref will be used to reference the text input we’ve added
    to the form to collect the color title. The `hexColor` ref will be used to access
    hexadecimal color values from the HTML color input. We can set the values for
    these refs directly in JSX using the `ref` property:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在创建此组件时，我们还将使用`useRef`钩子创建两个引用。`txtTitle`引用将用于引用我们添加到表单中以收集颜色标题的文本输入。`hexColor`引用将用于从HTML颜色输入中访问十六进制颜色值。我们可以直接在JSX中使用`ref`属性为这些引用设置值：
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here, we set the value for the `txtTitle` and `hexColor` refs by adding the
    `ref` attribute to these input elements in JSX. This creates a `current` field
    on our ref object that references the DOM element directly. This provides us access
    to the DOM element, which means we can capture its value. When the user submits
    this form by clicking the ADD button, we’ll invoke the `submit` function:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过在JSX中为这些输入元素添加`ref`属性来设置`txtTitle`和`hexColor`引用的值。这会在我们的引用对象上创建一个`current`字段，直接引用DOM元素。这使我们可以访问DOM元素，这意味着我们可以捕获它的值。当用户通过单击“ADD”按钮提交此表单时，我们将调用`submit`函数：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When we submit HTML forms, by default, they send a POST request to the current
    URL with the values of the form elements stored in the body. We don’t want to
    do that. This is why the first line of code in the `submit` function is `e.preventDefault()`,
    which prevents the browser from trying to submit the form with a POST request.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们提交HTML表单时，默认情况下它们会将表单元素的值存储在请求体中，发送POST请求到当前URL。我们不想这样做。这就是为什么`submit`函数中的第一行代码是`e.preventDefault()`，它阻止浏览器尝试使用POST请求提交表单。
- en: Next, we capture the current values for each of our form elements using their
    refs. These values are then passed up to this component’s parent via the `onNewColor`
    function property. Both the title and the hexadecimal value for the new color
    are passed as function arguments. Finally, we reset the `value` attribute for
    both inputs to clear the data and prepare the form to collect another color.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用它们的引用捕获每个表单元素的当前值。这些值随后通过`onNewColor`函数属性传递到此组件的父组件。新颜色的标题和十六进制值都作为函数参数传递。最后，我们重置两个输入的`value`属性以清除数据，并准备收集另一种颜色。
- en: Did you notice the subtle paradigm shift that has occurred by using refs? We’re
    mutating the `value` attribute of DOM nodes directly by setting them equal to
    `""` empty strings. This is imperative code. The `AddColorForm` is now what we
    call an *uncontrolled component* because it uses the DOM to save the form values.
    Sometimes using uncontrolled component can get you out of problems. For instance,
    you may want to share access to a form and its values with code outside of React.
    However, a controlled component is a better approach.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到使用引用（refs）发生的微妙范式转变？我们通过将DOM节点的`value`属性直接设置为`""`空字符串来直接修改它们。这是命令式的代码。`AddColorForm`现在被称为*非受控组件*，因为它使用DOM来保存表单值。有时候，使用非受控组件可以解决问题。例如，你可能希望将表单及其值与React之外的代码共享。然而，受控组件是更好的方法。
- en: Controlled Components
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 受控组件
- en: 'In a *controlled component*, the from values are managed by React and not the
    DOM. They do not require us to use refs. They do not require us to write imperative
    code. Adding features like robust form validation is much easier when working
    with a controlled component. Let’s modify the `AddColorForm` by giving it control
    over the form’s state:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在*受控组件*中，表单值由React管理，而不是由DOM管理。它们不要求我们使用引用。它们不要求我们编写命令式的代码。在使用受控组件时，添加诸如强大的表单验证功能要容易得多。让我们通过使`AddColorForm`控制表单状态来修改它：
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'First, instead of using refs, we’re going to save the values for the `title`
    and `color` using React state. We’ll create variables for `title` and `color`.
    Additionally, we’ll define the functions that can be used to change state: `setTitle`
    and `setColor`.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将不再使用引用，而是使用React状态保存`title`和`color`的值。我们将为`title`和`color`创建变量。此外，我们将定义可以用于更改状态的函数：`setTitle`和`setColor`。
- en: 'Now that the component controls the values for `title` and `color`, we can
    display them inside of the form input elements by setting the `value` attribute.
    Once we set the `value` attribute of an input element, we’ll no longer be able
    to change with the form. The only way to change the value at this point would
    be to change the state variable every time the user types a new character in the
    input element. That’s exactly what we’ll do:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在组件控制了`title`和`color`的值，我们可以通过设置`value`属性在表单输入元素内显示它们。一旦我们设置了输入元素的`value`属性，我们将无法再通过表单更改它。此时改变值的唯一方法是每次用户在输入元素中键入新字符时更改状态变量。这正是我们要做的事情：
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This controlled component now sets the value of both `input` elements using
    the `title` and `color` from state. Whenever these elements raise an `onChange`
    event, we can access the new value using the `event` argument. The `event.target`
    is a reference to the DOM element, so we can obtain the current value of that
    element with `event.target.value`. When the `title` changes, we’ll invoke `setTitle`
    to change the title value in state. Changing that value will cause this component
    to rerender, and we can now display the new value for `title` inside the `input`
    element. Changing the color works exactly the same way.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个受控组件现在使用状态中的`title`和`color`值来设置两个`input`元素的值。每当这些元素引发`onChange`事件时，我们可以使用`event`参数访问新值。`event.target`是对DOM元素的引用，因此我们可以使用`event.target.value`获取该元素的当前值。当`title`改变时，我们将调用`setTitle`来改变状态中的标题值。改变该值将导致此组件重新渲染，我们现在可以在`input`元素内显示新的`title`值。更改颜色的方式完全相同。
- en: 'When it’s time to submit the form, we can simply pass the state values for
    `title` and `color` to the `onNewColor` function property as arguments when we
    invoke it. The `setTitle` and `setColor` functions can be used to reset the values
    after the new color has been passed to the parent component:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当提交表单时，我们可以简单地将`title`和`color`的状态值作为参数传递给`onNewColor`函数属性在调用时。`setTitle`和`setColor`函数可以用于在将新颜色传递给父组件后重置值：
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'It’s called a controlled component because React controls the state of the
    form. It’s worth pointing out that controlled form components are rerendered,
    a lot. Think about it: every new character typed in the `title` field causes the
    `AddColorForm` to rerender. Using the color wheel in the color picker causes this
    component to rerender way more than the `title` field because the color value
    repeatedly changes as the user drags the mouse around the color wheel. This is
    OK—React is designed to handle this type of workload. Hopefully, knowing that
    controlled components are rerendered frequently will prevent you from adding some
    long and expensive process to this component. At the very least, this knowledge
    will come in handy when you’re trying to optimize your React components.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 它被称为受控组件，因为React控制表单的状态。值得指出的是，受控表单组件经常重新渲染。想想看：每在`title`字段中键入一个新字符都会导致`AddColorForm`重新渲染。在颜色选择器中使用颜色轮会导致此组件重新渲染次数比`title`字段多得多，因为颜色值随着用户在颜色轮周围拖动鼠标而重复变化。这没问题——React被设计用来处理这种类型的工作负载。希望知道受控组件经常重新渲染将阻止您向此组件添加一些长时间和昂贵的过程。至少，在优化React组件时，这种知识会很有用。
- en: Creating Custom Hooks
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义钩子
- en: 'When you have a large form with a lot of `input` elements, you may be tempted
    to copy and paste these two lines of code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个包含许多`input`元素的大表单时，你可能会忍不住复制并粘贴这两行代码：
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: It might seem like you’re working faster by simply copying and pasting these
    properties into every form element while tweaking the variable names along the
    way. However, whenever you copy and paste code, you should hear a tiny little
    alarm sound in your head. Copying and pasting code suggests that there’s something
    redundant enough to abstract away in a function.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来通过简单地复制粘贴这些属性到每个表单元素中，并在途中调整变量名，你可能会感觉自己工作速度更快。然而，每当你复制粘贴代码时，你应该听到头脑中响起一个微小的警报声。复制粘贴代码意味着有些东西足够冗余，可以在一个函数中抽象掉。
- en: 'We can package the details necessary to create controlled form components into
    a custom hook. We could create our own `useInput` hook where we can abstract away
    the redundancy involved with creating controlled form inputs:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将创建受控表单组件所需的详细信息打包到自定义钩子中。我们可以创建自己的`useInput`钩子，在其中可以抽象掉创建受控表单输入所涉及的冗余部分：
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This is a custom hook. It doesn’t take a lot of code. Inside of this hook,
    we’re still using the `useState` hook to create a state `value`. Next, we return
    an array. The first value of the array is the object that contains the same properties
    we were tempted to copy and paste: the `value` from state along with an `onChange`
    function property that changes that value in state. The second value in the array
    is a function that can be reused to reset the `value` back to its initial value.
    We can use our hook inside of the `AddColorForm`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个自定义钩子。它不需要很多代码。在这个钩子内部，我们仍然使用`useState`钩子来创建一个状态`value`。接下来，我们返回一个数组。数组的第一个值是一个对象，该对象包含了我们曾试图复制粘贴的相同属性：从状态中获取的`value`以及一个`onChange`函数属性，用于更改状态中的该值。数组的第二个值是一个函数，用于将`value`重置为其初始值。我们可以在`AddColorForm`内部使用我们的钩子：
- en: '[PRE33]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `useState` hook is encapsulated within our `useInput` hook. We can obtain
    the properties for both the title and the color by destructuring them from the
    first value of the returned array. The second value of this array contains a function
    we can use to reset the `value` property back to its initial value, an empty string.
    The `titleProps` and `colorProps` are ready to be spread into their corresponding
    input elements:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`useState`钩子被封装在我们的`useInput`钩子内部。我们可以通过解构从返回的数组的第一个值获取`title`和`color`的属性。数组的第二个值包含一个函数，我们可以使用它来将`value`属性重置为其初始值，即空字符串。`titleProps`和`colorProps`已准备好扩展到相应的输入元素中：'
- en: '[PRE34]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Spreading these properties from our custom hook is much more fun than pasting
    them. Now both the title and the color inputs are receiving properties for their
    value and `onChange` events. We’ve used our hook to create controlled form inputs
    without worrying about the underlying implementation details. The only other change
    we need to make is when this form is submitted:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的自定义钩子中扩展这些属性比粘贴它们更有趣。现在标题和颜色输入都接收到了关于它们的值和`onChange`事件的属性。我们使用我们的钩子创建了受控表单输入，而不用担心底层实现细节。我们需要做的唯一其他更改是在提交此表单时：
- en: '[PRE35]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Within the `submit` function, we need to be sure to grab the `value` for both
    the title and the color from their properties. Finally, we can use the custom
    reset functions that were returned from the `useInput` hook.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在`submit`函数内部，我们需要确保从它们的属性中获取`title`和`color`的`value`。最后，我们可以使用从`useInput`钩子返回的自定义重置函数。
- en: Hooks are designed to be used inside of React components. We can compose hooks
    within other hooks because eventually the customized hook will be used inside
    of a component. Changing the state within this hook still causes the `AddColorForm`
    to rerender with new values for `titleProps` or `colorProps`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 钩子被设计用于在React组件内部使用。我们可以在其他钩子中组合钩子，因为最终自定义的钩子将在组件内部使用。在这个钩子内改变状态仍会导致`AddColorForm`重新渲染，并传入`titleProps`或`colorProps`的新值。
- en: Adding Colors to State
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将颜色添加到状态
- en: Both the controlled form component and the uncontrolled from component pass
    the values for `title` and `color` to the parent component via the `onNewColor`
    function. The parent doesn’t care whether we used a controlled component or an
    uncontrolled component; it only wants the values for the new color.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 控制表单组件和非控制表单组件都通过`onNewColor`函数将`title`和`color`的值传递给父组件。父组件不关心我们使用的是受控组件还是非受控组件；它只想要新颜色的值。
- en: 'Let’s add the `AddColorForm`, whichever one you choose, to the the `App` component.
    When the `onNewColor` property is invoked, we’ll save the new color in state:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`AddColorForm`添加到`App`组件中，无论您选择哪个。当调用`onNewColor`属性时，我们将保存新的颜色到状态中：
- en: '[PRE36]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When a new color is added, the `onNewColor` property is invoked. The `title`
    and hexadecimal value for the new `color` are passed to this function as arguments.
    We use these arguments to create a new array of colors. First, we spread the current
    `colors` from state into the new array. Then we add an entirely new color object
    using the `title` and `color` values. Additionally, we set the `rating` of the
    new color to `0` because it has not yet been rated. We also use the `v4` function
    found in the `uuid` package to generate a new unique `id` for the color. Once
    we have an array of colors that contains our new color, we save it to state by
    invoking `setColors`. This causes the `App` component to rerender with a new array
    of `colors`. That new array will be used to update the UI. We’ll see the new color
    at bottom of the list.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当添加新颜色时，将调用 `onNewColor` 属性。将新颜色的 `title` 和十六进制值作为参数传递给此函数。我们使用这些参数来创建一个新的颜色数组。首先，我们将当前状态中的
    `colors` 展开到新数组中。然后，我们使用 `title` 和 `color` 值添加一个全新的颜色对象。此外，我们将新颜色的 `rating` 设置为
    `0`，因为它尚未被评级。我们还使用 `uuid` 包中的 `v4` 函数生成新的唯一 `id` 来标识该颜色。一旦我们有了包含新颜色的颜色数组，我们通过调用
    `setColors` 将其保存到状态中。这将导致 `App` 组件使用新的颜色数组重新渲染。我们将在列表底部看到新的颜色。
- en: With this change, we’ve completed the first iteration of the Color Organizer.
    Users can now add new colors to the list, remove colors from the list, and rate
    any existing color on that list.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: With this change, we’ve completed the first iteration of the Color Organizer.
    Users can now add new colors to the list, remove colors from the list, and rate
    any existing color on that list.
- en: React Context
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React 上下文
- en: Storing state in one location at the root of our tree was an important pattern
    that helped us all be more successful with early versions of React. Learning to
    pass state both down and up a component tree via properties is a necessary right
    of passage for any React developer—it’s something we should all know how to do.
    However, as React evolved and our component trees got larger, following this principle
    slowly became more unrealistic. It’s hard for many developers to maintain state
    in a single location at the root of a component tree for a complex application.
    Passing state down and up the tree through dozens of components is tedious and
    bug ridden.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 将状态存储在树的根节点的一个位置上是一个重要的模式，这帮助我们所有人在 React 的早期版本中更成功。学会通过属性在组件树上下传递状态是任何 React
    开发者的必经之路——这是我们所有人都应该知道如何做的事情。然而，随着 React 的发展和我们的组件树变得更大，遵循这一原则逐渐变得更不现实。对于许多开发者来说，在组件树的根节点处维护状态对于复杂的应用程序是困难的。通过几十个组件传递状态是繁琐且容易出错的。
- en: The UI elements that most of us work on are complex. The root of the tree is
    often very far from the leaves. This puts data the application depends on many
    layers away from the components that use the data. Every component must receive
    props that they only pass to their children. This will bloat our code and make
    our UI harder to scale.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数我们工作的 UI 元素都很复杂。树的根节点通常离叶子节点很远。这使得应用程序所依赖的数据与使用数据的组件之间相隔多层。每个组件必须接收它们仅传递给子组件的
    props。这会使我们的代码变得臃肿，使我们的 UI 难以扩展。
- en: Passing state data through every component as props until it reaches the component
    that needs to use it is like taking the train from San Francisco to DC. On the
    train, you’ll pass through every state, but you won’t get off until you reach
    your destination (see [Figure 6-6](#fig0606)).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 将状态数据通过每个组件作为 props 传递，直到它达到需要使用它的组件，就像乘坐从旧金山到华盛顿的火车一样。在火车上，你会经过每一个州，但直到你到达目的地才会下车（见[图 6-6](#fig0606)）。
- en: '![lrc2 0607](assets/lrc2_0607.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![lrc2 0607](assets/lrc2_0607.png)'
- en: Figure 6-6\. Train from San Francisco to DC
  id: totrans-147
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-6\. 从旧金山到华盛顿的火车
- en: It’s obviously more efficient to fly from San Francisco to DC. This way, you
    don’t have to pass through every state—you simply fly over them ([Figure 6-7](#fig0607)).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，从旧金山到华盛顿飞行更有效率。这样，你就不必经过每一个州——你只需飞过它们（见[图 6-7](#fig0607)）。
- en: '![lrc2 0608](assets/lrc2_0608.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![lrc2 0608](assets/lrc2_0608.png)'
- en: Figure 6-7\. Flight from San Francisco to DC
  id: totrans-150
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-7\. 从旧金山到华盛顿的飞行
- en: In React, *context* is like jet-setting for your data. You can place data in
    React context by creating a *context provider*. A context provider is a React
    component you can wrap around your entire component tree or specific sections
    of your component tree. The context provider is the departing airport where your
    data boards the plane. It’s also the airline hub. All flights depart from that
    airport to different destinations. Each destination is a *context consumer*. The
    context consumer is the React component that retrieves the data from context.
    This is the destination airport where your data lands, deplanes, and goes to work.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中，*上下文*就像是为您的数据乘坐喷气式飞机。 您可以通过创建*上下文提供者*将数据放入React上下文中。 上下文提供者是您可以包装在整个组件树或特定组件树部分周围的React组件。
    上下文提供者是您的数据登机的出发机场。 它也是航空公司的枢纽。 所有航班从那个机场起飞到不同的目的地。 每个目的地都是一个*上下文消费者*。 上下文消费者是从上下文中检索数据的React组件。
    这是您的数据降落、卸货并开始工作的目的地机场。
- en: Using context still allows to us store state data in a single location, but
    it doesn’t require us to pass that data through a bunch of components that don’t
    need it.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上下文仍然允许我们将状态数据存储在一个位置，但不需要将这些数据传递给不需要它的一堆组件。
- en: Placing Colors in Context
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将颜色放入上下文中
- en: 'In order to use context in React, we must first place some data in a context
    provider and add that provider to our component tree. React comes with a function
    called `createContext` that we can use to create a new context object. This object
    contains two components: a context `Provider` and a `Consumer`.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要在React中使用上下文，我们必须首先将一些数据放入上下文提供者中，并将该提供者添加到我们的组件树中。 React带有一个名为`createContext`的函数，我们可以使用它来创建一个新的上下文对象。
    这个对象包含两个组件：一个上下文`Provider`和一个`Consumer`。
- en: 'Let’s place the default colors found in the *color-data.json* file into context.
    We’ll add context to the *index.js* file, the entry point of our application:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将*color-data.json*文件中找到的默认颜色放入上下文中。 我们将上下文添加到*index.js*文件中，这是我们应用程序的入口点：
- en: '[PRE37]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Using `createContext`, we created a new instance of React context that we named
    `ColorContext`. The color context contains two components: `ColorContext.Provider`
    and `ColorContext.Consumer`. We need to use the provider to place the colors in
    state. We add data to context by setting the `value` property of the `Provider`.
    In this scenario, we added an object containing the `colors` to context. Since
    we wrapped the entire `App` component with the provider, the array of `colors`
    will made available to any context consumers found in our entire component tree.
    It’s important to notice that we’ve also exported the `ColorContext` from this
    location. This is necessary because we will need to access the `ColorContext.Consumer`
    when we want to obtain the `colors` from context.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`createContext`，我们创建了一个名为`ColorContext`的新实例React上下文。 颜色上下文包含两个组件：`ColorContext.Provider`和`ColorContext.Consumer`。
    我们需要使用提供者将颜色放入状态中。 通过设置`Provider`的`value`属性来向上下文添加数据。 在这种情况下，我们向上下文添加了包含`colors`的对象。
    由于我们将整个`App`组件与提供者包装在一起，因此`colors`数组将在我们整个组件树中的任何上下文消费者中都可用。 需要注意的是，我们还从此位置导出了`ColorContext`。
    这是必要的，因为当我们想要从上下文中获取`colors`时，我们将需要访问`ColorContext.Consumer`。
- en: Note
  id: totrans-158
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A context `Provider` doesn’t always have to wrap an entire application. It’s
    not only OK to wrap specific sections components with a context `Provider`, it
    can make your application more efficient. The `Provider` will only provide context
    values to its children.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文`Provider`并不总是需要包装整个应用程序。 将特定部分的组件用上下文`Provider`包装起来不仅可以接受，而且可以使您的应用程序更高效。
    该`Provider`仅将上下文值提供给其子元素。
- en: It’s OK to use multiple context providers. In fact, you may be using context
    providers in your React app already without even knowing it. Many npm packages
    designed to work with React use context behind the scenes.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多个上下文提供者是可以的。 实际上，您可能已经在您的React应用程序中使用上下文提供者，而不需要知道。 许多设计用于与React一起工作的npm包在幕后使用上下文。
- en: Now that we’re providing the `colors` value in context, the `App` component
    no longer needs to hold state and pass it down to its children as props. We’ve
    made the `App` component a “flyover” component. The `Provider` is the `App` component’s
    parent, and it’s providing the `colors` in context. The `ColorList` is the `App`
    component’s child, and it can obtain the `colors` directly on its own. So the
    app doesn’t need to touch the colors at all, which is great because the `App`
    component itself has nothing to do with colors. That responsibility has been delegated
    farther down the tree.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在上下文中提供`colors`值，`App`组件不再需要保持状态并将其作为props传递给其子组件。我们已经使`App`组件成为一个“过渡”组件。`Provider`是`App`组件的父组件，它在上下文中提供`colors`。`ColorList`是`App`组件的子组件，它可以自行直接获取`colors`。因此，应用程序根本不需要触及颜色，这很好，因为`App`组件本身与颜色无关。责任已经委托给了树的更深处。
- en: 'We can remove a lot of lines of code from the `App` component. It only needs
    to render the `AddColorForm` and the `ColorList`. It no longer has to worry about
    the data:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从`App`组件中删除大量代码行。它只需要渲染`AddColorForm`和`ColorList`。它不再需要担心数据：
- en: '[PRE38]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Retrieving Colors with useContext
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用useContext检索颜色
- en: 'The addition of Hooks makes working with context a joy. The `useContext` hook
    is used to obtain values from context, and it obtains those values we need from
    the context `Consumer`. The `ColorList` component no longer needs to obtain the
    array of `colors` from its properties. It can access them directly via the `useContext`
    hook:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Hooks的加入使得处理上下文变得愉快。`useContext`钩子用于从上下文中获取值，并且它获取我们从上下文`Consumer`中需要的那些值。`ColorList`组件不再需要从其属性中获取`colors`数组。它可以通过`useContext`钩子直接访问它们：
- en: '[PRE39]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, we’ve modified the `ColorList` component and removed the `colors=[]` property
    because the `colors` are being retrieved from context. The `useContext` hook requires
    the context instance to obtain values from it. The `ColorContext` instance is
    being imported from the *index.js* file where we create the context and add the
    provider to our component tree. The `ColorList` can now construct a user interface
    based on the data that has been provided in context.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们修改了`ColorList`组件，并移除了`colors=[]`属性，因为`colors`是从上下文中获取的。使用`useContext`钩子需要上下文实例来从中获取值。`ColorContext`实例从*index.js*文件中导入，该文件中创建了上下文并将提供者添加到我们的组件树中。`ColorList`现在可以根据上下文提供的数据构建用户界面。
- en: Using Context Consumer
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用上下文消费者
- en: 'The `Consumer` is accessed within the `useContext` hook, which means that we
    no longer have to work directly with the consumer component. Before Hooks, we
    would have to obtain the colors from context using a pattern called *render props*
    within the context consumer. Render props are passed as arguments to a child function.
    The following example is how you would use the consumer to obtain the colors from
    context:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`Consumer`在`useContext`钩子中访问，这意味着我们不再需要直接使用消费者组件。在Hooks之前，我们必须使用称为*render props*的模式从上下文消费者中获取颜色。渲染props作为参数传递给子函数。以下示例展示了如何使用消费者从上下文中获取颜色：'
- en: '[PRE40]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Stateful Context Providers
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有状态上下文提供者
- en: The context provider can place an object into context, but it can’t mutate the
    values in context on its own. It needs some help from a parent component. The
    trick is to create a stateful component that renders a context provider. When
    the state of the stateful component changes, it will rerender the context provider
    with new context data. Any of the context providers’ children will also be rerendered
    with the new context data.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文提供者可以将对象放入上下文中，但不能单独改变上下文中的值。它需要从父组件获得帮助。关键是创建一个有状态组件来渲染上下文提供者。当有状态组件的状态改变时，它将使用新的上下文数据重新渲染上下文提供者。任何上下文提供者的子级也将使用新的上下文数据重新渲染。
- en: 'The stateful component that renders the context provider is our *custom provider*.
    That is: that’s the component that will be used when it’s time to wrap our `App`
    with the provider. In a brand-new file, let’s create a `ColorProvider`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染上下文提供者的有状态组件是我们的*自定义提供者*。也就是说：当需要将我们的`App`与提供者包装在一起时，将使用该组件。在一个全新的文件中，让我们创建一个`ColorProvider`：
- en: '[PRE41]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `ColorProvider` is a component that renders the `ColorContext.Provider`.
    Within this component, we’ve created a state variable for `colors` using the `useState`
    hook. The initial data for `colors` is still being populated from *color-data.json*.
    Next, the `ColorProvider` adds the `colors` from state to context using the `value`
    property of the `ColorContext.Provider`. Any children rendered within the `ColorProvider`
    will be wrapped by the `ColorContext.Provider` and will have access to the `colors`
    array from context.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`ColorProvider` 是一个渲染 `ColorContext.Provider` 的组件。在此组件内部，我们使用 `useState` 钩子为
    `colors` 创建了一个状态变量。`colors` 的初始数据仍然来自 *color-data.json*。接下来，`ColorProvider` 使用
    `ColorContext.Provider` 的 `value` 属性将状态中的 `colors` 添加到上下文中。在 `ColorProvider` 中呈现的任何子元素都将被
    `ColorContext.Provider` 包裹，并且可以从上下文中访问 `colors` 数组。'
- en: You may have noticed that the `setColors` function is also being added to context.
    This gives context consumers the ability to change the value for colors. Whenever
    `setColors` is invoked, the `colors` array will change. This will cause the `ColorProvider`
    to rerender, and our UI will update itself to display the new `colors` array.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，`setColors` 函数也被添加到上下文中。这使得上下文消费者可以改变颜色的值。每当调用 `setColors` 时，`colors`
    数组将会改变。这将导致 `ColorProvider` 重新渲染，我们的 UI 将更新以显示新的 `colors` 数组。
- en: 'Adding `setColors` to context may not be the best idea. It invites other developers
    and you to make mistakes later on down the road when using it. There are only
    three options when it comes to changing the value of the `colors` array: users
    can add colors, remove colors, or rate colors. It’s a better idea to add functions
    for each of these operations to context. This way, you don’t expose the `setColors`
    function to consumers; you only expose functions for the changes they’re allowed
    to make:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `setColors` 添加到上下文中可能不是一个好主意。这会在以后使用它时邀请其他开发人员和你犯错误。在更改 `colors` 数组的值时，只有三个选项：用户可以添加颜色、移除颜色或者对颜色进行评分。最好为每个操作添加一个函数到上下文中，而不是将
    `setColors` 函数暴露给消费者。这样做，只暴露给他们可以进行更改的函数，会更好：
- en: '[PRE42]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: That looks better. We added functions to context for all of the operations that
    can be made on the colors array. Now, any component within our tree can consume
    these operations and make changes to colors using simple functions that we can
    document.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来更好了。我们为所有可以在颜色数组上进行的操作添加了函数到上下文中。现在，我们树中的任何组件都可以消耗这些操作，并使用我们可以文档化的简单函数来更改颜色。
- en: Custom Hooks with Context
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用上下文的自定义钩子
- en: 'There’s one more killer change we can make. The introduction of Hooks has made
    it so that we don’t have to expose context to consumer components at all. Let’s
    face it: context can be confusing for team members who aren’t reading this book.
    We can make everything much easier for them by wrapping context in a custom hook.
    Instead of exposing the `ColorContext` instance, we can create a hook called `useColors`
    that returns the colors from context:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以做出一个更大的改变。引入 Hooks 已经使得我们根本不必将上下文暴露给消费者组件。面对现实吧：对于没有阅读这本书的团队成员来说，上下文可能会很令人困惑。我们可以通过在自定义钩子中包装上下文来为他们简化一切。我们可以创建一个名为
    `useColors` 的钩子，而不是暴露 `ColorContext` 实例，它返回上下文中的颜色：
- en: '[PRE43]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This one simple change has a huge impact on architecture. We’ve wrapped all
    of the functionality necessary to render and work with stateful colors in a single
    JavaScript module. Context is contained to this module yet exposed through a hook.
    This works because we return context using the `useContext` hook, which has access
    to the `ColorContext` locally in this file. It’s now appropriate to rename this
    module `color-hooks.js` and distribute this functionality for wider use by the
    community.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的变更对架构有着巨大的影响。我们将所有与有状态颜色渲染和操作所需的功能封装在一个单独的 JavaScript 模块中。上下文被包含在此模块中，但通过钩子公开。这是因为我们使用
    `useContext` 钩子返回上下文，在本文件中局部访问 `ColorContext` 是适当的。现在可以将此模块重命名为 `color-hooks.js`，并将此功能分发给社区更广泛地使用。
- en: 'Consuming colors using the `ColorProvider` and the `useColors` hook is a joyous
    event. This is why we program. Let’s take this hook out for a spin in the current
    Color Organizer app. First, we need to wrap our `App` component with the custom
    `ColorProvider`. We can do this in the *index.js* file:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ColorProvider` 和 `useColors` 钩子消费颜色是一件非常愉快的事情。这就是为什么我们编程。让我们在当前的 Color Organizer
    应用程序中试试这个钩子。首先，我们需要用自定义的 `ColorProvider` 包装我们的 `App` 组件。我们可以在 *index.js* 文件中这样做：
- en: '[PRE44]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, any component that’s a child of the `App` can obtain the `colors` from
    the `useColors` hook. The `ColorList` component needs to access the `colors` array
    to render the colors on the screen:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，任何作为 `App` 的子组件的组件都可以通过 `useColors` hook 获取 `colors`。`ColorList` 组件需要访问 `colors`
    数组以在屏幕上渲染颜色：
- en: '[PRE45]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We’ve removed any references to context from this component. Everything it
    needs is now being provided from our hook. The `Color` component could use our
    hook to obtain the functions for rating and removing colors directly:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从这个组件中删除了任何关于上下文的引用。现在，它所需的一切都是通过我们的钩子提供的。`Color` 组件可以使用我们的钩子直接获取评分和删除颜色的功能：
- en: '[PRE46]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, the `Color` component no longer needs to pass events to the parent via
    function props. It has access to the `rateColor` and `removeColor` functions in
    context. They’re easily obtained through the `useColors` hook. This is a lot of
    fun, but we’re not finished yet. The `AddColorForm` can also benefit from the
    `useColors` hook:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Color` 组件不再需要通过函数属性将事件传递给父组件。它可以通过上下文轻松获取 `rateColor` 和 `removeColor` 函数。它们可以通过
    `useColors` hook 轻松获取。这非常有趣，但我们还没有完成。`AddColorForm` 也可以从 `useColors` hook 中受益：
- en: '[PRE47]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `AddColorForm` component can add colors directly with the `addColor` function.
    When colors are added, rated, or removed, the state of the `colors` value in context
    will change. When this change happens, the children of the `ColorProvider` are
    rerendered with new context data. All of this is happening through a simple hook.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddColorForm` 组件可以直接使用 `addColor` 函数添加颜色。当添加、评分或删除颜色时，上下文中 `colors` 值的状态会改变。当此变化发生时，`ColorProvider`
    的子组件将使用新的上下文数据重新渲染。所有这些都是通过一个简单的 hook 实现的。'
- en: Hooks provide software developers with the stimulation they need to stay motivated
    and enjoy frontend programming. This is primarily because they’re an awesome tool
    for separating concerns. Now, React components only need to concern themselves
    with rendering other React components and keeping the user interface up to date.
    React Hooks can concern themselves with the logic required to make the app work.
    Both the UI and Hooks can be developed separately, tested separately, and even
    deployed separately. This is all very good news for React.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Hooks 为软件开发者提供了他们需要保持动力并享受前端编程的刺激。这主要是因为它们是一个很棒的用于分离关注点的工具。现在，React 组件只需要关心渲染其他
    React 组件并保持用户界面的更新。React Hooks 则负责处理使应用程序工作所需的逻辑。UI 和 Hooks 可以分开开发、单独测试，甚至可以单独部署。对于
    React 来说，这些都是非常好的消息。
- en: We’ve only scratched the surface of what can be accomplished with Hooks. In
    the next chapter, we’ll dive a little deeper.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是挖掘了 Hooks 能实现的冰山一角。在下一章中，我们将深入探讨一些内容。
