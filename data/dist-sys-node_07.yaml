- en: Chapter 6\. Deployments
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章。部署
- en: A *deployment*, in the simplest sense, is the movement of code from one location
    to another. With some platforms this is as simple as copying a bunch of files.
    For example, plenty of applications can be deployed by copying raw source code
    files like PHP, Python, and Perl scripts, and subsequent HTTP requests to a web
    server execute the updated files automatically. Static sites are typically deployed
    in the same manner. More complicated applications that run persistently require
    an additional step to stop and start a process. Examples of this include shipping
    Node.js source files, a compiled Go binary, or a Python script.^([1](ch06.html#idm46291185298648))
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*部署*，简而言之，是将代码从一个位置移动到另一个位置。对于某些平台，这只是复制一堆文件的简单过程。例如，许多应用程序可以通过复制原始源代码文件（如
    PHP、Python 和 Perl 脚本）进行部署，随后的 HTTP 请求将自动执行更新后的文件。静态站点通常以相同的方式部署。更复杂的持续运行的应用程序需要额外的步骤来停止和启动进程。这些示例包括发布
    Node.js 源文件、编译的 Go 二进制文件或 Python 脚本。^([1](ch06.html#idm46291185298648))'
- en: Modern applications *should* make themselves consumable by listening on a port
    (see [*https://12factor.net/port-binding*](https://12factor.net/port-binding)
    for details). This is true whether an application is written in a platform that
    is traditionally invoked by a web server (like PHP, where you might include Apache
    and PHP inside of a Docker container) or if the application is written in Node.js
    (where the process listens for requests directly, hopefully with an external reverse
    proxy still involved). Sure, Node.js processes can be restarted when a source
    code file has been changed. Packages like `nodemon` and `forever` provide such
    functionality for making local development easier.^([2](ch06.html#idm46291185269544))
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现代应用程序*应该*通过侦听端口使其可消耗（参见[*https://12factor.net/port-binding*](https://12factor.net/port-binding)以获取详细信息）。无论应用程序是在传统上由
    Web 服务器调用的平台上编写的（例如 PHP，您可能会在 Docker 容器中包含 Apache 和 PHP），还是在 Node.js 中编写的（其中进程直接侦听请求，希望仍然涉及外部反向代理）。当源代码文件发生更改时，Node.js
    进程可以重新启动。像`nodemon`和`forever`这样的包为使本地开发更轻松提供了这种功能。^([2](ch06.html#idm46291185269544))
- en: In practice, a deployment is a much more formal process than “just copying some
    files.” The deployment process is usually made up of many stages, with the copying
    of application code being one of the final stages. Other things need to happen
    as well, such as checking out source code from version control, installing dependencies,
    building/compiling, running automated tests, etc. The collection of stages required
    to deploy an application is referred to as a *build pipeline*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，部署比“只是复制一些文件”要正式得多。部署过程通常由许多阶段组成，其中复制应用程序代码只是最后阶段的一部分。还需要进行其他操作，例如从版本控制检出源代码、安装依赖项、构建/编译、运行自动化测试等。部署应用程序所需的阶段集合被称为*构建流水线*。
- en: Generally one piece of software becomes the most integral component for managing
    the build pipeline. A popular class of software to achieve this is the *Continuous
    Integration* (CI) service. Continuous integration is a software development practice
    where self-contained changes made to an application are constantly being tested,
    merged into a mainline branch, and deployed. A CI server is in charge of managing
    the build pipeline to make such a process feasible.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，软件开发中最重要的部分之一是管理构建流水线的关键组件。一种流行的软件类别是*持续集成*（CI）服务。持续集成是一种软件开发实践，即对应用程序进行的自包含更改不断进行测试、合并到主干分支并部署。CI
    服务器负责管理构建流水线，使这一过程成为可能。
- en: 'Regardless of the tool used for managing a build pipeline, there are some concepts
    that are almost universally used:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 无论用于管理构建流水线的工具是什么，几乎所有地方都会使用一些通用概念：
- en: Build
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 构建
- en: A build is when a snapshot (such as a particular Git commit) of an application’s
    codebase is converted into an executable form. This could involve transpiling
    code with Babel, installing dependencies from npm, and even generating a Docker
    image.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 构建是将应用程序代码库的快照（例如特定的 Git 提交）转换为可执行形式的过程。这可能涉及使用 Babel 转译代码，从 npm 安装依赖项，甚至生成
    Docker 镜像。
- en: Release
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 发布
- en: A release is a combination of a particular build with configuration settings.
    For example, one build might be released to both the staging and production environments
    where it will have two different configurations applied.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 发布是将特定构建与配置设置结合的过程。例如，一个构建可以发布到分别具有两种不同配置的暂存和生产环境。
- en: Artifact
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 构件
- en: An artifact is a file or directory produced at some point during the build pipeline.
    This can be something that is used between multiple stages, like a Docker image,
    or a side effect of the build, like a code coverage report generated by the `nyc`
    package.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 构件是在构建流水线的某个阶段生成的文件或目录。这可以是多个阶段之间使用的内容，如 Docker 镜像，也可以是构建的副产品，例如由`nyc`包生成的代码覆盖报告。
- en: Each new release should have its own name. This name should be a value that
    increments, such as an integer or a timestamp. When an updated application is
    being deployed to a server, it means that the new files representing a release
    are copied to the server, the application is executed, and the previous release
    is torn down.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 每个新版本发布都应有其自己的名称。此名称应为一个递增的值，例如整数或时间戳。当将更新的应用程序部署到服务器时，这意味着新文件（表示一个发布的文件）被复制到服务器，应用程序被执行，并且之前的发布被取消。
- en: When doing this, it’s important to keep several previous releases available
    in some manner. If a new release is found to be faulty, then an engineer should
    be able to revert to a previous release, an action called a *rollback*. Retaining
    previous releases can be as straightforward as keeping old Docker images in a
    Docker repository.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行这些操作时，保留若干之前的发布版本非常重要。如果发现新发布有问题，工程师应能够回滚到之前的版本，这称为 *回滚* 操作。保留之前的发布可以简单地通过在
    Docker 仓库中保留旧的 Docker 镜像来实现。
- en: Now that you’re familiar with some of the concepts around continuous integration
    and build pipelines, it’s time to get familiar with a particular CI service.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经熟悉了关于持续集成和构建流水线的一些概念，是时候熟悉特定的持续集成服务了。
- en: Build Pipeline with Travis CI
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Travis CI 构建流水线
- en: This book mostly considers open source tools, especially those that you can
    run yourself. However, due to the nature of deploying to a remote service, the
    next few sections will make use of free tiers of Platform as a Service (PaaS)
    tools. This is mostly so that you aren’t required to spend money on things like
    server hosting or domain registration, as well as to get you up and running as
    quickly as possible.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本书主要考虑开源工具，特别是您可以自行运行的工具。然而，由于部署到远程服务的特性，接下来的几节将使用平台即服务（PaaS）工具的免费套餐。主要是为了避免您花费在服务器托管或域名注册等方面的资金，以及尽快让您开始运行。
- en: For this section you need to set up two accounts. The first one is with [GitHub](https://github.com).
    You probably already have a GitHub account and may even use it every day. GitHub
    is the world’s most popular service for hosting projects using Git version control.
    Most npm packages, and even the Node.js runtime itself, are hosted on GitHub.
    The second account you’ll need is with [Travis CI](https://travis-ci.com) which,
    as part of sign-up, will require that it be associated with your GitHub account.
    Travis is a popular continuous integration build pipeline service. It, too, is
    used by Node.js and many popular npm packages.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您需要设置两个账户。第一个是 [GitHub](https://github.com)。您可能已经有 GitHub 账户，甚至每天都在使用。GitHub
    是全球最流行的基于 Git 版本控制托管项目的服务。大多数 npm 包，甚至 Node.js 运行时本身，都托管在 GitHub 上。您还需要第二个账户，即
    [Travis CI](https://travis-ci.com)，作为注册的一部分，需要将其与您的 GitHub 账户关联。Travis 是一种流行的持续集成构建流水线服务。它也被
    Node.js 和许多流行的 npm 包使用。
- en: Now that your accounts are squared away, it’s time to create a new repository
    on GitHub. Visit the GitHub website and click the plus sign in the navigational
    bar. This will take you to the [Create a new repository](https://github.com/new)
    screen. On this screen, name the repository *distnode-deploy*. Set the visibility
    to public. Set the description to *Distributed Node.js Sample Project*. Elect
    to initialize the repository with a default *README.md* document. Also, use the
    drop-down menus to choose a default *.gitignore* file for Node.js, and add the
    *MIT License*. Once those options have been selected, click the *Create repository*
    button.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的账户已经准备就绪，是时候在 GitHub 上创建一个新的仓库了。访问 GitHub 网站，点击导航栏中的加号符号。这将带您到[创建一个新仓库](https://github.com/new)的页面。在此页面，命名仓库为
    *distnode-deploy*。设置可见性为公共。描述为 *分布式 Node.js 示例项目*。选择初始化仓库使用默认的 *README.md* 文档。同时，使用下拉菜单选择
    Node.js 的默认 *.gitignore* 文件，并添加 MIT 许可证。选择完这些选项后，点击 *创建仓库* 按钮。
- en: Creating a Basic Project
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个基本项目
- en: 'Once your repository is ready, navigate to your *distributed-node/* directory
    using a terminal. Then, check out the git repository that you just created on
    GitHub. You can do this by running the following command and replacing `<USERNAME>`
    with your GitHub username:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的仓库准备好了，使用终端导航到 *distributed-node/* 目录。然后，通过以下命令进行 git 仓库的检出，替换 `<USERNAME>`
    为你的 GitHub 用户名：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now that you’re inside of the repository you created, initialize a new npm
    project and install a web server package for the project. You can do that by running
    the following commands:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你进入了创建的仓库内部，初始化一个新的 npm 项目，并为该项目安装一个 Web 服务器包。你可以通过运行以下命令来完成：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Next, create a new *distnode-deploy/server.js* file. This will be a fairly simple
    service following similar patterns that you’ve worked with before. Modify the
    file so that its contents contain the code in [Example 6-1](#ex_deploy_server).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个新的 *distnode-deploy/server.js* 文件。这将是一个相对简单的服务，遵循你之前使用过的类似模式。修改文件，使其内容包含
    [示例 6-1](#ex_deploy_server) 中的代码。
- en: Example 6-1\. *distnode-deploy/server.js*
  id: totrans-25
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-1\. *distnode-deploy/server.js*
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Also, create another file named *distnode-deploy/recipe.js*. This file represents
    a model used by the application. Modify the file so that it contains the code
    in [Example 6-2](#ex_deploy_model).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 还要创建另一个名为 *distnode-deploy/recipe.js* 的文件。这个文件代表应用程序使用的模型。修改文件，使其包含 [示例 6-2](#ex_deploy_model)
    中的代码。
- en: Example 6-2\. *distnode-deploy/recipe.js*
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-2\. *distnode-deploy/recipe.js*
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'While you’re at it, modify the *distnode-deploy/package.json* file so that
    whenever the `npm test` command is run, it will pass. You can do this by modifying
    the file and overwriting the `test` field in the `scripts` section to look like
    this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，同时修改 *distnode-deploy/package.json* 文件，以便在运行 `npm test` 命令时能够成功通过。你可以通过修改文件并覆盖
    `scripts` 部分中的 `test` 字段来实现这一点，内容如下：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Finally, create a *distnode-deploy/.travis.yml* file. This is what will be used
    to control Travis CI when it interacts with the repository. Add the content from
    [Example 6-3](#ex_deploy_travisyml) to this file.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，创建一个 *distnode-deploy/.travis.yml* 文件。这将用于控制 Travis CI 在与仓库交互时的行为。将 [示例 6-3](#ex_deploy_travisyml)
    的内容添加到该文件中。
- en: Example 6-3\. *distnode-deploy/.travis.yml*
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-3\. *distnode-deploy/.travis.yml*
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[![1](assets/1.png)](#co_deployments_CO1-1)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_deployments_CO1-1)'
- en: This project will use Node.js v14.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目将使用 Node.js v14。
- en: '[![2](assets/2.png)](#co_deployments_CO1-2)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_deployments_CO1-2)'
- en: The command to run at install time.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 安装时运行的命令。
- en: '[![3](assets/3.png)](#co_deployments_CO1-3)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_deployments_CO1-3)'
- en: The command to run at test time.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 测试时运行的命令。
- en: 'These files represent an early version of the application. Over time you’ll
    make various changes to them. Once you’ve created the files, add them to git and
    push them to *master* by running the following commands:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件代表应用程序的早期版本。随着时间的推移，你将对它们进行各种更改。创建文件后，通过运行以下命令将它们添加到 git 并推送到 *master* 分支：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You’ve now pushed the application changes to GitHub. Switch back to your browser
    where you have the GitHub project page open and refresh. At this point you should
    see an updated listing of the files that you’ve modified.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将应用程序更改推送到 GitHub。切换回你在浏览器中打开 GitHub 项目页面的地方并刷新。此时，你应该看到你修改过的文件的更新列表。
- en: Configuring Travis CI
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 Travis CI
- en: Now that your GitHub repository has some content in it, you’re ready to configure
    Travis to integrate with it. Open the [*https://travis-ci.com*](https://travis-ci.com)
    website in your browser. Next, click your avatar icon in the upper-right corner
    of the navigation bar and select the settings option. This will take you to the
    [repositories settings page](https://oreil.ly/OR86K).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的 GitHub 仓库中已经有了一些内容，你可以配置 Travis 与之集成了。在浏览器中打开 [*https://travis-ci.com*](https://travis-ci.com)
    网站。接下来，点击导航栏右上角的头像图标，选择设置选项。这将带你到 [仓库设置页面](https://oreil.ly/OR86K)。
- en: On this page you should see a button to activate the GitHub Apps Integration.
    Click the Activate button to start the process to authorize Travis to work with
    your repository.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个页面上，你应该看到一个按钮，用于激活 GitHub 应用集成。点击激活按钮开始授权 Travis 和你的仓库进行工作。
- en: You’ll then be taken to the GitHub website where you can choose which repositories
    to enable. By default, the All repositories option is selected. Feel free to keep
    this option if you’d like to use Travis with other repositories. Otherwise, click
    the Only select repositories option. Once you select this option, you’ll be able
    to search for a repository. Find and select the *distnode-deploy* repository.
    Next, click the Approve & Install button on the bottom of the screen.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您将被带到 GitHub 网站，您可以选择启用哪些存储库。默认情况下，选择“所有存储库”选项。如果您想要与其他存储库一起使用 Travis，请随意保留此选项。否则，请单击“仅选择存储库”选项。选择此选项后，您将能够搜索存储库。找到并选择
    *distnode-deploy* 存储库。然后，单击屏幕底部的“批准并安装”按钮。
- en: You will then be taken back to the repositories settings page in the Travis
    interface. This time you should see a list of GitHub-hosted repositories that
    Travis has access to. In particular, you should now see the *distnode-deploy*
    repository listed. Click the Settings button next to the repository name.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您将被带回 Travis 界面中的存储库设置页面。这一次，您应该看到 Travis 可以访问的 GitHub 托管存储库列表。特别是，您现在应该看到列出的
    *distnode-deploy* 存储库。单击存储库名称旁边的“设置”按钮。
- en: This should take you to the settings page for your *distnode-deploy* project.
    By default it is configured to both Build pushed branches and to Build pushed
    pull requests. These default settings are fine.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这将带您到 *distnode-deploy* 项目的设置页面。默认情况下，它配置为构建推送的分支和构建推送的拉取请求。这些默认设置是可以接受的。
- en: Testing a Pull Request
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试拉取请求
- en: With your repository now configured to run commands against pull requests, it’s
    now time to give it a try. Currently, when you run `npm test`, the result is that
    the tests will pass. So, you’ll now simulate a pull request that will cause the
    test to fail. Ideally, the pull request will be prevented from being merged in
    this situation.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的仓库已配置为针对拉取请求运行命令，现在是时候试试了。当前，当您运行 `npm test` 时，测试将通过。因此，您现在将模拟一个拉取请求，导致测试失败。理想情况下，在这种情况下，应阻止合并拉取请求。
- en: 'Switch back to your project files and modify the *package.json* file. This
    time, modify the test line to look like the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 切换回项目文件，并修改 *package.json* 文件。这一次，修改测试行，使其看起来如下所示：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once you’ve modified the file, create a new branch, add the file, commit the
    change, and push it to GitHub. You can do that by running the following commands:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 修改文件后，请创建一个新分支，添加文件，提交更改并将其推送到 GitHub。您可以通过运行以下命令来完成：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now switch back to the GitHub project page for your *distnode-deploy* repository.
    GitHub has detected that you’ve pushed a branch and displays a banner to create
    a pull request, assuming you’re on either the Code or Pull requests tabs. Note
    that you might need to refresh the page if the banner isn’t present. Click the
    Compare & pull request button in the banner to create a pull request based on
    the branch you pushed.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在切换回到您的 *distnode-deploy* 存储库的 GitHub 项目页面。GitHub 检测到您已推送一个分支，并显示一个横幅以创建拉取请求，假设您在“Code”或“Pull
    requests”选项卡上。请注意，如果横幅不存在，您可能需要刷新页面。单击横幅中的“比较并拉取请求”按钮，基于您推送的分支创建拉取请求。
- en: This will take you to the screen to create a pull request. The branch merge
    options should show that you’re attempting to merge a branch named *feature-1*
    into a branch named *master*. The default settings on this screen are fine. Click
    the Create pull request button to officially create a pull request.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这将带您到创建拉取请求的屏幕。分支合并选项应显示，您正在尝试将名为 *feature-1* 的分支合并到名为 *master* 的分支中。此屏幕上的默认设置是可以接受的。单击“创建拉取请求”按钮，以正式创建拉取请求。
- en: This will take you to the pull request screen for your first pull request. Depending
    on how quickly you’ve created the pull request, and how busy the Travis CI build
    servers are, you will see either zero, one, or two failures. Recall that in the
    Travis settings screen for the project, the option to build branches was enabled.
    Because of this, Travis was able to start testing the code as soon as the branch
    was pushed, even before the pull request was created. On my screen, the pull request
    checks look like [Figure 6-1](#fig_github_pr_travis_checks).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这将带您进入第一个拉取请求的拉取请求屏幕。取决于您创建拉取请求的速度以及 Travis CI 构建服务器的繁忙程度，您将看到零个、一个或两个失败。请记住，在项目的
    Travis 设置屏幕上，启用了构建分支选项。因此，即使在创建拉取请求之前，Travis 也能够立即开始测试代码。在我的屏幕上，拉取请求检查看起来像 [Figure
    6-1](#fig_github_pr_travis_checks)。
- en: '![Travis CI - Branch and Travis CI - Pull Request have both failed a GitHub
    pull request](assets/dsnj_0601.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![Travis CI - Branch and Travis CI - Pull Request have both failed a GitHub
    pull request](assets/dsnj_0601.png)'
- en: Figure 6-1\. GitHub pull request failure
  id: totrans-60
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-1\. GitHub拉取请求失败
- en: The messages displayed so far in the pull request aren’t all that useful. It
    does show that something has failed, but it doesn’t say exactly why the failure
    has occurred. Travis does provide more detailed output, but it will take a few
    clicks to find it. Next to each of the failed checks is a link titled Details.
    Click the Details link next to the Travis CI-Pull Request check.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在拉取请求中显示的消息并不是特别有用。它确实显示了某些内容失败了，但并没有准确说明失败的原因。Travis确实提供了更详细的输出，但需要点击几次才能找到。在每个失败检查旁边都有一个名为“详细信息”的链接。点击Travis
    CI-Pull Request检查旁边的“详细信息”链接。
- en: You should now be on a GitHub screen with more details about the failing pull
    request check. This screen provides a little more information about the failed
    pull request test, but it’s still pretty high level, displaying information about
    individual jobs that have run as part of the check. One important button on this
    screen is the Re-run checks button. This will allow you to repeat the checks multiple
    times while retaining the same build settings. This is useful when testing flaky
    tests. However, clicking that button won’t fix this particular test as it’s hardcoded
    to fail.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该在GitHub屏幕上看到有关失败的拉取请求检查的更多详细信息。此屏幕提供了有关失败的拉取请求测试的更多信息，但仍然比较高层次，显示了作为检查一部分运行的单个作业的信息。此屏幕上一个重要的按钮是“重新运行检查”按钮。这将允许您在保持相同构建设置的同时多次重复检查。在测试易错的情况下非常有用。但是，点击该按钮不会修复这个特定的测试，因为它是硬编码以失败。
- en: In the check failure panel, there’s a section titled Build Failed. Right below
    this is some text stating “The build failed,” where the text “The build” is a
    link; click it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查失败面板中，有一个名为“构建失败”的部分。紧接着这部分是一些文字说明“构建失败”，其中“构建”是一个链接；点击它。
- en: This time, you’ve been taken to the Travis CI website. On this screen you should
    see a list of all of the subchecks. This screen is useful for displaying permutations
    of tests. For example, you can configure the tests to run an application using
    different versions of Node.js, environment variables, architectures, and even
    different operating systems (though some of these features require a paid account).
    Click the first failure row.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，您被带到了Travis CI网站。在此屏幕上，您应该看到所有子检查的列表。这个屏幕非常有用，可以显示测试的各种排列组合。例如，您可以配置测试使用不同版本的Node.js运行应用程序，环境变量，架构，甚至不同的操作系统（尽管其中一些功能需要付费账户）。点击第一个失败行。
- en: 'You’re now viewing details about a specific “Job,” which is the term that Travis
    uses to refer to a particular context where your code has been executed. In this
    case, the application was executed using Node.js v14 on the AMD64 platform. Below
    the job overview section is the exciting stuff. The terminal output from all the
    commands that Travis has run is displayed. Looking at this output, you can see
    everything from the steps Travis took to set up the environment to the output
    of the `npm install` command. More importantly, you can see the output of the
    `npm test` command. In my case, I see the following output:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在正在查看有关特定“作业”的详细信息，这是Travis用来指代代码已执行的特定上下文的术语。在这种情况下，应用程序是使用Node.js v14在AMD64平台上执行的。在作业概览部分下面是令人兴奋的内容。Travis运行的所有命令的终端输出都显示在这里。通过查看这些输出，您可以看到从Travis设置环境的步骤到`npm
    install`命令的输出。更重要的是，您可以看到`npm test`命令的输出。在我的情况下，我看到以下输出：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Congratulations! You’ve now got a very simple build pipeline enabled for your
    project. Of course, it’s not that useful just yet since it only runs a fake test
    so far. In the next section you’ll create some useful tests, re-creating some
    of the quality controls that a larger organization might impose. Leave your failing
    pull request unmerged for now; you’ll fix it up soon enough.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您现在为项目启用了一个非常简单的构建流水线。当然，目前它还不是那么有用，因为它只运行了一个虚拟测试。在下一节中，您将创建一些有用的测试，重新创建一些大型组织可能实施的质量控制措施。暂时保持您的失败拉取请求未合并；您很快就会修复它。
- en: Automated Testing
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化测试
- en: Modern application consumers expect a continuous stream of new features and
    bug fixes. In order to provide them with such an experience, the applications
    you work on require continuous integration. Application changes require ample
    testing to give development teams—and the overall organization—the confidence
    required to support such a system. The practice of quarterly releases with vigorous
    QA schedules only applies to the most antiquated of industries. Instead, testing
    needs to be done in an automated manner and be applied to every change.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现代应用程序消费者期望持续获得新功能和bug修复。为了给他们提供这样的体验，您所工作的应用程序需要持续集成。应用程序更改需要充分的测试，以便开发团队——以及整个组织——有信心支持这样的系统。季度发布与严格的质量保证时间表只适用于最过时的行业。相反，测试需要以自动化方式进行，并应用于每一个变更。
- en: There are numerous approaches for testing code before it’s merged into the mainline
    branch. This section covers a few of these approaches and, in particular, how
    they are applied to Node.js applications. But before any of these approaches can
    be used in your application, you’ll first need to set up a testing framework.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码在合并到主分支之前有许多方法。本节介绍了其中一些方法，特别是它们如何应用于Node.js应用程序。但在应用这些方法之前，您首先需要设置一个测试框架。
- en: There are many testing frameworks available on npm. Some of them are very powerful,
    injecting global variables into test files and requiring a special executable
    to run. Others are simpler but may require more manual tweaking to get them to
    suit your needs. For the examples in this section, you’re going to use *Tape*,
    a popular yet simple testing framework, to spruce up your *distnode-deploy* pull
    request.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: npm上有许多可用的测试框架。其中一些非常强大，会将全局变量注入测试文件并需要特殊的可执行文件来运行。其他的则更简单，但可能需要更多的手动调整以满足您的需求。在本节的示例中，您将使用*Tape*，一个流行而简单的测试框架，来优化您的*distnode-deploy*拉取请求。
- en: 'First off, you need a directory to contain your test files. The most common
    pattern is to create a *test/* directory and add JavaScript files containing tests
    to this directory. You’ll also need to install Tape. Run the following commands
    to do just that:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要一个目录来存放测试文件。最常见的模式是创建一个*test/*目录，并将包含测试的JavaScript文件添加到此目录中。您还需要安装Tape。运行以下命令来完成这些操作：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice the `--save-dev` argument with the install command. This ensures that
    the `tape` package is installed as a development dependency. This is because the
    production version of the application shouldn’t have a testing framework deployed
    with it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用安装命令时的`--save-dev`参数。这确保了`tape`包作为开发依赖安装。这是因为生产版本的应用程序不应该部署带有测试框架的版本。
- en: 'When it comes to creating tests, you’ll create individual JavaScript files
    and put them within the *test/* directory. You’ll end up with only two separate
    test files in this section, and in theory, you could hardcode the paths to those
    files and run them. But with more complex test suites like the ones used in real
    production applications, maintaining such a list would be difficult and error-prone.
    Instead, use a glob pattern to run any JavaScript files within the *test/* directory.
    Modify the *package.json* file so that the test command looks like the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建测试时，您将创建独立的JavaScript文件，并将它们放在*test/*目录中。在本节中，您最终将只有两个单独的测试文件，并且理论上，您可以硬编码这些文件的路径并运行它们。但是对于像真实生产应用程序中使用的那些复杂测试套件，维护这样一个列表将会很困难且容易出错。相反，使用glob模式运行*test/*目录中的任何JavaScript文件。修改*package.json*文件，使测试命令看起来像以下内容：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This configures the `npm test` command to run the `tape` executable provided
    by the `tape` package. When npm packages declare that they provide an executable,
    npm will make them available in the *node_modules/.bin/* directory. Later, when
    you execute an npm run script, npm will automatically check that directory for
    an executable. This is why the `npm test` command will be able to run the `tape`
    command, even though trying to run `tape` directly in your shell should result
    in a Command Not Found error.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这配置了`npm test`命令以运行由`tape`包提供的`tape`可执行文件。当npm包声明它们提供一个可执行文件时，npm将在*node_modules/.bin/*目录中使它们可用。稍后，当您执行npm运行脚本时，npm将自动检查该目录以获取可执行文件。这就是为什么`npm
    test`命令能够运行`tape`命令，即使在您的shell中直接运行`tape`应该会导致“命令未找到”错误。
- en: The `./test/**/*.js` argument is a glob pattern, which means that any file ending
    in *.js* within the *test/* directory, no matter how deeply nested, will be used
    as an argument. Tape doesn’t inject any magical globals, and test files can be
    executed directly, but the `tape` binary provides some other niceties that your
    pull request will depend on. For example, if any of the individual test files
    fail, then the overall test run will fail.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`./test/**/*.js`参数是一个 glob 模式，这意味着在*test/*目录中以*.js*结尾的任何文件，无论嵌套多深，都将被用作参数。Tape
    不会注入任何神奇的全局变量，测试文件可以直接执行，但是`tape`二进制文件提供了一些其他便利功能，你的拉取请求将依赖于此。例如，如果任何单个测试文件失败，则整体测试运行将失败。'
- en: With the groundwork now in place, you’re ready to create your first test.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，基础工作已经完成，你可以准备创建你的第一个测试了。
- en: Unit Tests
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: '*Unit testing* is a pattern where individual *units* of code, usually correlating
    to a function, are tested. These tests are applicable to all forms of code, everything
    from npm packages to complete applications. Unit tests should test every nook
    and cranny of a codebase. These tests should cover each branch of logic within
    a function, passing in various anticipated arguments, and even testing failure
    conditions.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*单元测试*是一种模式，其中测试单个代码单元（通常对应一个函数）。这些测试适用于所有形式的代码，从 npm 包到完整的应用程序。单元测试应该测试代码库中的每个角落和缝隙。这些测试应该覆盖函数逻辑的每个分支，传入各种预期的参数，甚至测试失败条件。'
- en: A logical branch refers to things like if/else statements, switch statements,
    loop bodies, etc. Basically, anywhere an application can choose to run one set
    of code or another is considered a branch. When creating tests for real applications,
    be sure to create unit tests for each scenario.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑分支指的是像 if/else 语句、switch 语句、循环体等等。基本上，应用程序可以选择运行一组代码或另一组代码的任何地方都被视为分支。在为真实应用程序创建测试时，请确保为每种情况创建单元测试。
- en: There are a few approaches for laying out the files within an application’s
    *test/* directory. For larger applications it’s pretty common to have the *test/*
    directory structure mimic the application’s directory structure. For example,
    if an application had a *src/models/account.js* file, then it might also have
    a *test/models/account.js* file to test it. However, for this example project,
    you only need a single unit test file. Create a file named *unit.js* within your
    *test/* directory. Within this file, add the content from [Example 6-4](#ex_unit_test).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以布置应用程序*test/*目录中的文件。对于较大的应用程序，让*test/*目录结构与应用程序的目录结构相似是非常常见的。例如，如果一个应用程序有一个*src/models/account.js*文件，那么它可能还会有一个*test/models/account.js*文件来对其进行测试。然而，对于这个示例项目，你只需要一个单元测试文件。在你的*test/*目录中创建一个名为*unit.js*的文件。在此文件中，添加[示例
    6-4](#ex_unit_test)中的内容。
- en: Example 6-4\. *distnode-deploy/test/unit.js*
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-4\. *distnode-deploy/test/unit.js*
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[![1](assets/1.png)](#co_deployments_CO2-1)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_deployments_CO2-1)'
- en: Application code is loaded for testing.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序代码已加载用于测试。
- en: '[![2](assets/2.png)](#co_deployments_CO2-2)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_deployments_CO2-2)'
- en: Every test has a name and a function.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试都有一个名称和一个函数。
- en: '[![3](assets/3.png)](#co_deployments_CO2-3)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_deployments_CO2-3)'
- en: An assertion that two values are equal.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 断言两个值是否相等。
- en: '[![4](assets/4.png)](#co_deployments_CO2-4)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_deployments_CO2-4)'
- en: Tape needs to know when a callback-based test has finished.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Tape 需要知道基于回调的测试何时完成。
- en: This unit test file has two test cases in it. The first one is titled *Recipe#hydrate()*,
    and the second is titled *Recipe#serialize()*. These tests are named so that their
    output in a console tells you what they’re testing. Tests that use async functions
    will finish when the returned promise resolves; however, callback tests require
    a manual call to `t.end()` to signal the end of the test assertions.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此单元测试文件中包含两个测试用例。第一个标题为*Recipe#hydrate()*，第二个标题为*Recipe#serialize()*。这些测试被命名，以便在控制台中输出它们正在测试的内容。使用异步函数的测试将在返回的
    promise 解析时完成；但是，回调测试需要手动调用`t.end()`来表示测试断言的结束。
- en: Each test case can contain multiple assertions within it, though in this case
    each case only contains a single assertion. The function argument for the Tape
    test cases provides a single argument, named `t` in these examples, that contains
    a few assertion methods. The first test case uses `t.equal()`, which asserts that
    the two arguments are loosely equal to each other. If they aren’t, the test case
    will log a failure, and the process will exit with a nonzero exit status.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试用例可以包含多个断言，尽管在这种情况下，每个案例只包含一个断言。Tape测试用例的函数参数提供了一个名为`t`的单一参数，在这些示例中包含几个断言方法。第一个测试用例使用了`t.equal()`，它断言两个参数在宽松相等时。如果它们不相等，测试用例将记录一个失败，并且进程将以非零退出状态退出。
- en: The second test case uses `t.deepLooseEqual()`, which asserts that the two arguments
    are “deeply loosely equal.” The concept of two things being deeply equal is used
    in many different JavaScript testing tools. Basically, it’s a way to recursively
    compare two objects for `==` equality, without requiring that the two objects
    are the exact same object instance. Another method, `t.deepEqual()`, is available
    but fails the test because the actual value is a class instance and the expected
    value is a POJO.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个测试用例使用了`t.deepLooseEqual()`，它断言两个参数是“深度宽松相等”。深度相等的概念在许多不同的JavaScript测试工具中使用。基本上，它是一种递归比较两个对象是否`==`相等的方式，而不要求这两个对象是完全相同的对象实例。另外还有一个方法`t.deepEqual()`可用，但因为实际值是一个类实例而期望值是一个POJO，所以测试失败了。
- en: Tape has other assertion methods. For example, you can use `t.ok()` to assert
    an argument is truthy, `t.notOk()` to assert it’s falsey, `t.throws()` to wrap
    a function that should throw, `t.doesNotThrow()` to do the opposite, and several
    others. Each of these assertions accepts an optional argument for labeling the
    assertion.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Tape还有其他断言方法。例如，你可以使用`t.ok()`来断言一个参数是真值，`t.notOk()`来断言它是假值，`t.throws()`来包装一个应该抛出异常的函数，`t.doesNotThrow()`则相反，并且还有其他几种。每个断言都接受一个可选的标签参数。
- en: 'Now that the file is complete, you’re ready to run your first test. Execute
    the following command to run the current iteration of the test suite:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在文件完成了，你可以运行你的第一个测试。执行以下命令来运行当前迭代的测试套件：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When I run this command, I get the following output:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当我运行这个命令时，我得到了以下输出：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The output isn’t the most attractive—it’s actually designed for machine parsing—but
    it gets the job done. The [Tape npm page](https://www.npmjs.com/package/tape#pretty-reporters)
    provides a list of formatters that can make the output more palatable. This can
    be done by installing an additional development dependency and piping the output
    of the `tape` command through it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 输出并不是最吸引人的部分——实际上，它是为机器解析设计的——但它完成了任务。[Tape npm 页面](https://www.npmjs.com/package/tape#pretty-reporters)提供了一系列格式化工具，可以使输出更加可读。可以通过安装额外的开发依赖项并将`tape`命令的输出导入其中来实现这一点。
- en: The STATUS line isn’t part of the Tape command but is instead a shell command
    that’s printing the exit status from the `tape` command. This value is what will
    ultimately be used by the Travis CI server to determine if the test suite passed
    or not. A value of zero means the tests passed, and any other value represents
    failure.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: STATUS行不是Tape命令的一部分，而是一个Shell命令，用于打印`tape`命令的退出状态。这个值最终将被Travis CI服务器用来确定测试套件是否通过。值为零表示测试通过，任何其他值表示失败。
- en: 'My favorite unit test idiom goes a little like this: “If it touches the network,
    it’s not a unit test.” Don’t worry, the unit test you’ve written so far definitely
    doesn’t touch the network. Tests that involve the network, filesystem access,
    or really any I/O, tend to be slower and flakier.^([3](ch06.html#idm46291184452856))'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我最喜欢的单元测试习惯大致如下：“如果它涉及网络，那就不是单元测试。”不用担心，到目前为止你编写的单元测试确实没有涉及网络。涉及网络、文件系统访问或任何I/O的测试往往会更慢且更不稳定。^([3](ch06.html#idm46291184452856))
- en: Integration Tests
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成测试
- en: '*Integration testing* covers an application at a layer logically higher than
    that covered by unit testing. Integration tests check how different parts of an
    application work together. Consider the unit tests created in the previous section.
    They test individual methods of the recipe model class. However, the request handler
    code should probably be tested as well.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*集成测试*覆盖了比单元测试更高层次的应用程序层面。集成测试检查应用程序的不同部分如何协同工作。考虑在前一节创建的单元测试。它们测试了食谱模型类的各个方法。然而，请求处理程序代码也应该进行测试。'
- en: There are different ways to write tests for route handlers. You could, for example,
    create a file that exports the handler functions. This same file could then be
    imported by a test file, passing in mocked `request` and `reply` objects. This
    would allow you to test the route handling code via unit tests. One way to do
    this is by using a package like *sinon* to create *Stubs* and *Spies*, which are
    special functions that keep track of how they’re called and interacted with.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以为路由处理程序编写测试。例如，您可以创建一个文件来导出处理程序函数。然后，测试文件可以导入此相同文件，传递模拟的`request`和`reply`对象。这将允许您通过单元测试来测试路由处理代码。一种方法是使用像*sinon*这样的包来创建*Stubs*和*Spies*，它们是特殊的函数，用于跟踪它们被调用和交互的方式。
- en: Personally, the approach I like to take is to run the web service, have it listen
    on a port for requests, and send it real HTTP requests from an external client.
    This is the safest way to guarantee that an application actually listens for requests
    and serves them properly.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 就个人而言，我喜欢采用的方法是运行Web服务，让其监听端口以接收请求，并从外部客户端发送真实的HTTP请求。这是确保应用程序确实侦听请求并正确提供服务的最安全方式。
- en: Integration tests are mostly beneficial for applications, though some npm packages
    will benefit from them as well. Unit tests usually run pretty quickly, and integration
    tests often run much slower. This is because more code is loaded and there are
    more moving parts. For example, unit tests might not ever instantiate the underlying
    web framework or other third-party npm packages, while integration tests will.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试对应用程序非常有益，尽管一些npm包也会从中受益。单元测试通常运行速度很快，而集成测试通常运行速度要慢得多。这是因为加载的代码更多，移动的部分也更多。例如，单元测试可能永远不会实例化底层的Web框架或其他第三方npm包，而集成测试会。
- en: 'For the integration tests you’re about to write, you’ll need to install a package
    to help make HTTP requests. Run the following command to install the familiar
    `node-fetch` package as a development dependency:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于即将编写的集成测试，您需要安装一个包来帮助发出HTTP请求。运行以下命令将`node-fetch`包安装为开发依赖项：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Next, create a file in the *test/* directory called *integration.js*. With a
    more complex application, you might have a directory dedicated to integration
    tests. Each file within this directory could contain an individual test file for
    each application feature. This could mean test files like *user-account.js* and
    *gallery-upload.js*. But for this simple app, you’re just going to make a single
    test file. Add the content from [Example 6-5](#ex_integration_test) to this file.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在*test/*目录下创建一个名为*integration.js*的文件。对于更复杂的应用程序，你可能会有一个专门用于集成测试的目录。该目录中的每个文件可以包含一个用于每个应用程序特性的单独测试文件。这可能意味着像*user-account.js*和*gallery-upload.js*这样的测试文件。但对于这个简单的应用程序，你只需要创建一个单独的测试文件。将[Example 6-5](#ex_integration_test)的内容添加到这个文件中。
- en: Example 6-5\. *distnode-deploy/test/integration.js* (first version)
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-5\. *distnode-deploy/test/integration.js*（第一个版本）
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[![1](assets/1.png)](#co_deployments_CO3-1)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_deployments_CO3-1)'
- en: Spawn an instance of *server.js*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 启动*server.js*的一个实例。
- en: '[![2](assets/2.png)](#co_deployments_CO3-2)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_deployments_CO3-2)'
- en: Extract the URL of the server.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 提取服务器的URL。
- en: '[![3](assets/3.png)](#co_deployments_CO3-3)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_deployments_CO3-3)'
- en: Kill the *server.js* instance once the test is complete.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 测试完成后，关闭*server.js*实例。
- en: The `serverStart()` method is an async function that spawns a new instance of
    *server.js*, tells it to listen on a random high port, waits for the first message
    to be printed to *stdout*, then extracts the URL from the message being logged.
    This allows the test to find the random port that *server.js* ends up using. Choosing
    a hardcoded port within the *integration.js* file could cause a headache in the
    future if two instances of the test were to ever run at the same time on the same
    machine.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*serverStart()*方法是一个异步函数，它生成一个*server.js*的新实例，告诉它监听一个随机的高端口，等待第一条消息打印到*stdout*，然后从被记录的消息中提取URL。这允许测试找到*server.js*最终使用的随机端口。如果在同一台机器上同时运行两个测试实例，硬编码端口可能会在将来带来麻烦。'
- en: The test suite then sends an HTTP request to the server after the server has
    been started. Once the response is received, the JSON payload is parsed and the
    response body is compared to the expected value. Finally, once the test case has
    passed, the *server.js* instance is killed and the test is finished.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器启动后，测试套件会向服务器发送HTTP请求。一旦收到响应，就会解析JSON有效载荷，并将响应主体与预期值进行比较。最后，在测试用例通过后，*server.js*实例将被终止，测试完成。
- en: 'Now that you have your integration test in place, it’s time to run your newly
    created tests. Run the following command to execute both your unit test and integration
    test:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经设置好集成测试，是时候运行你新创建的测试了。运行以下命令来执行你的单元测试和集成测试：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The tests will now take a lot longer to run. Previously, just your unit test
    file, the `tape` package, and the recipe model were loaded. This ends up being
    a very fast process. This time, an entire web framework is loaded and network
    requests are made before the tests complete. On my machine this goes from taking
    tens of milliseconds to just over one second.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试将花费更长的时间来运行。之前，仅加载了你的单元测试文件、`tape` 包和配方模型。这最终是一个非常快速的过程。这一次，在测试完成之前加载了整个
    Web 框架并进行了网络请求。在我的机器上，这从几十毫秒增加到了稍微超过一秒。
- en: 'Here’s what the output on my machine looks like. Notice the additional entry
    for the integration test:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我的机器上的输出样式。注意集成测试的额外条目：
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice how the integration test is now running first, and the unit tests are
    run afterwards. This is probably because the files are sorted alphabetically.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意集成测试现在首先运行，然后才运行单元测试。这可能是因为文件按字母顺序排序。
- en: 'And there you have it: a very simple integration test is running where real
    HTTP requests are being made and a real server is responding.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样：一个非常简单的集成测试正在运行，其中正在进行真正的 HTTP 请求，并且一个真实的服务器正在响应。
- en: 'I’ve worked with many different Node.js application codebases and have seen
    many patterns form. A few times I’ve seen the pattern where no real HTTP requests
    are made and, instead, pseudo request objects are provided. For example, consider
    the following contrived test code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾与许多不同的 Node.js 应用程序代码库一起工作，并看到许多模式形成。有几次我看到的模式是，没有进行真正的 HTTP 请求，而是提供了伪请求对象。例如，请考虑以下编造的测试代码：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Can you think of any issues with this example code? Well, one issue is that
    query parameters are usually represented as strings. So, that `bar: 1` value in
    the example should really be `bar: "1"`. The request object being passed in therefore
    represents an impossible manifestation of the request object. In this case, the
    code assumes the `foo.bar` value will be a number and the tests pass, but once
    this handler is invoked by the real web server, it’ll get a string and a logic
    error.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '你能想到这个示例代码有什么问题吗？好吧，其中一个问题是查询参数通常表示为字符串。所以，示例中的 `bar: 1` 值应该是 `bar: "1"`。因此传递的请求对象表示了一个不可能的请求对象的实现。在这种情况下，代码假定
    `foo.bar` 的值将是一个数字，并且测试通过，但一旦这个处理程序被真实的 Web 服务器调用，它将得到一个字符串和一个逻辑错误。'
- en: Here’s another issue that can happen and that did cause an outage for an API
    at a company I once worked for. An engineer switched query string parsing packages
    from an outdated and opinionated package to a well-maintained and highly configurable
    package.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个可能发生的问题，并且曾经导致我曾经工作过的一家公司的 API 发生了故障。一个工程师将查询字符串解析包从一个过时的、固执己见的包切换到一个维护良好且高度可配置的包。
- en: 'One thing the engineer forgot to do was configure the package to treat square
    brackets as array identifiers. This is a syntax that allows a query string like
    `a[]=1&a[]=2` to be converted into an array containing the values 1 and 2, resulting
    in this: `{"a": [1, 2]}`. Instead, the new package ignored the square brackets
    and overwrote repeated keys, resulting in this: `{"a": 2}`. The API would then
    call an array method on a number and crash. The tests passed in hardcoded objects
    representing what the request was assumed to resemble, not the real output from
    the query string library, and when the tests passed, the broken application was
    deployed to production.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '工程师忘记做的一件事是配置包以将方括号视为数组标识符。这是一种语法，允许将像 `a[]=1&a[]=2` 这样的查询字符串转换为包含值 1 和 2 的数组，结果是这样的：`{"a":
    [1, 2]}`。而新的包忽略了方括号并覆盖了重复的键，导致了这样的结果：`{"a": 2}`。然后 API 将在数字上调用数组方法并崩溃。测试通过了硬编码对象，表示了假设的请求应该是什么样的，而不是来自查询字符串库的真实输出，当测试通过时，有问题的应用程序被部署到了生产环境。'
- en: There’s always going to be some unanticipated edge case with how an application
    runs and how it is tested. For that reason, I encourage you to create integration
    tests that interact with your application the same way a client would in production.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 总是会有一些应用程序运行和测试时无法预料的边缘情况。因此，我鼓励你创建与你的应用程序在生产中的客户端相同的集成测试。
- en: Unit tests and integration tests are both powerful ways to test an application’s
    functionality. But how do you ensure that engineers are creating enough tests
    for their features?
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试和集成测试都是测试应用程序功能的强大方式。但是你如何确保工程师为他们的功能创建了足够的测试呢？
- en: Code Coverage Enforcement
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码覆盖强制执行
- en: '*Code coverage* is a way to measure how much of an application’s code is being
    executed when a test suite runs. This value can be measured using different criteria,
    and the tool you’re going to use in this section measures coverage in four areas:
    statements, branches, functions, and lines. Measuring code coverage is beneficial
    for all types of codebases, including both npm packages and complete applications.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码覆盖率* 是一种衡量测试套件运行时执行了多少应用程序代码的方法。这个值可以使用不同的标准来测量，在本节中使用的工具在四个方面测量覆盖率：语句、分支、函数和行。测量代码覆盖率对于所有类型的代码库都有益，包括
    npm 包和完整的应用程序。'
- en: Code coverage is an attempt to require engineers to test every feature that
    they add to a codebase. Not only can it be measured, but it can also be used as
    pull request criteria, failing if a threshold isn’t met.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率试图要求工程师对他们添加到代码库的每个功能进行测试。它不仅可以被测量，而且还可以作为拉取请求的标准，如果未达到阈值，则测试失败。
- en: Warning
  id: totrans-140
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Code coverage measurements should not be the only consideration for the quality
    of a proposed code change. It’s unfortunately easy to write tests that run each
    line of code but don’t actually test the underlying feature. At the end of the
    day, it takes a second engineer to determine if code is properly tested.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率的测量不应该是考虑建议代码更改质量的唯一因素。遗憾的是，很容易编写测试来运行每一行代码，但实际上并不测试底层功能。最终，需要第二位工程师来判断代码是否得到了适当的测试。
- en: 'One of the most popular packages for testing code coverage is *nyc*. Install
    the package by running the following command:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 用于测试代码覆盖率的最流行的包之一是 *nyc*。通过运行以下命令来安装这个包：
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will make a new executable available for use in your npm scripts. It can
    be activated by preceding the test command you would normally execute with `nyc`.
    For your application, modify the *package.json* file to introduce this new command.
    Your test script should now look like the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使得一个新的可执行文件可以在你的 npm 脚本中使用。它可以通过在通常执行的测试命令之前加上`nyc`来激活。对于你的应用程序，修改 *package.json*
    文件以引入这个新命令。现在你的测试脚本应该如下所示：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `nyc` executable can be configured by providing command line arguments.
    But it’s generally cleaner to configure it by writing configuration to a file.
    One way to do this is to create a file named *.nycrc* in the root of a project
    directory. Create a file with this name and add the content from [Example 6-6](#ex_nycrc)
    to it.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过提供命令行参数来配置 `nyc` 可执行文件。但通常更干净的方法是通过将配置写入文件来配置它。做到这一点的一种方法是在项目目录的根目录下创建一个名为
    *.nycrc* 的文件。创建一个带有此名称的文件，并将内容从 [示例 6-6](#ex_nycrc) 添加到其中。
- en: Example 6-6\. *distnode-deploy/.nycrc*
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-6\. *distnode-deploy/.nycrc*
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This configuration file contains several notable entries. The first one, `reporter`,
    describes how the reporting of the code coverage check should happen. The first
    entry, `lcov`, tells nyc to write an HTML summary to disk. This will allow you
    to visually see which parts of the application source code are covered and which
    are not. The second entry, `text-summary`, means that a summary of coverage is
    provided via *stdout*. This allows you to see a summary both when running coverage
    locally, and later when checking CI logs.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置文件包含几个显著的条目。第一个条目 `reporter` 描述了代码覆盖检查报告应该如何进行。第一个条目 `lcov` 告诉 nyc 将 HTML
    摘要写入磁盘。这将允许您可视化地看到应用程序源代码的哪些部分被覆盖，哪些部分没有被覆盖。第二个条目 `text-summary` 意味着通过 *stdout*
    提供覆盖摘要。这允许您在本地运行覆盖率时看到摘要，并在稍后检查 CI 日志时看到摘要。
- en: The next entry, `all`, tells nyc to consider coverage for all JavaScript files,
    not just the ones that are required when the tests run. Without this set to true,
    a developer might forget to test newly added files.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个条目 `all` 告诉 nyc 考虑所有 JavaScript 文件的覆盖率，而不仅仅是在测试运行时需要的文件。如果没有将其设置为 true，开发人员可能会忘记测试新添加的文件。
- en: 'The `check-coverage` entry instructs nyc to fail—by returning a nonzero exit
    code—when code coverage thresholds aren’t met. The final four entries, `branches`,
    `lines`, `functions`, and `statements`, are the code coverage thresholds measured
    in percent. As a rule of thumb, there are only two numbers available here: 100
    and everything else. Setting this value to less than 100% is a nice way to introduce
    testing to an existing codebase, but for new projects, you should strive to hit
    100%.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`check-coverage` 条目指示 nyc 在未达到代码覆盖率阈值时失败——通过返回非零退出码。最后四个条目，`branches`、`lines`、`functions`
    和 `statements`，是以百分比衡量的代码覆盖率阈值。作为一个经验法则，这里只有两个可用的数字：100 和其他任何数字。将该值设置为小于 100%
    是向现有代码库引入测试的一种好方法，但对于新项目，你应该努力达到 100%。'
- en: 'Now that you’ve enforced code coverage, run the following command to run the
    test suite again:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经强制执行了代码覆盖率，请运行以下命令再次运行测试套件：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This time, you should have some additional information about the test suite
    printed after the normal test results. On my machine I get the following output:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，正常的测试结果后，你应该打印出一些关于测试套件的额外信息。在我的机器上，我得到了以下输出：
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is a nice overview, but it doesn’t state exactly why the code coverage
    enforcement has failed. You might be able to guess why by digging through the
    test cases and application code. For example, there’s the `GET /` route that isn’t
    being requested, but is there anything else?
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的概述，但它并没有明确说明为什么代码覆盖强制执行失败。你可以通过查看测试用例和应用程序代码来猜测原因。例如，有一个未被请求的 `GET /`
    路由，但还有其他原因吗？
- en: Since one of the reporters was set to `lcov` in the *.nycrc* file, a report
    containing information about the code coverage has been written to disk. This
    is added to a newly created directory called *coverage/*. This is such a commonly
    used directory for writing code coverage output that the default *.gitignore*
    file created by GitHub already ignores that directory.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其中一个报告者在 *.nycrc* 文件中被设置为 `lcov`，因此已将包含有关代码覆盖率信息的报告写入磁盘。这被添加到一个新创建的名为 *coverage/*
    的目录中。这是一个常用的用于写入代码覆盖输出的目录，GitHub 默认创建的 *.gitignore* 文件已经忽略了该目录。
- en: Open the file located at *coverage/lcov-report/index.html* in a web browser
    to view the coverage report. [Figure 6-2](#fig_nyc_listing) is what the coverage
    report looks like on my computer.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Web 浏览器中打开位于 *coverage/lcov-report/index.html* 的文件，以查看覆盖率报告。[图 6-2](#fig_nyc_listing)
    显示了在我的计算机上覆盖率报告的外观。
- en: This file contains an overall summary at the top of the screen and a listing
    of each file below it. In this case, the *recipe.js* file is completely covered,
    but the *server.js* file is still missing a few things. Click the *server.js*
    link to view coverage details for this specific file. [Figure 6-3](#fig_nyc_file)
    is what this screen looks like on my computer.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件在屏幕顶部包含一个总体摘要，并在其下列出每个文件。在本例中，*recipe.js* 文件完全被覆盖，但 *server.js* 文件仍然缺少一些内容。点击
    *server.js* 链接以查看该特定文件的覆盖率详细信息。[图 6-3](#fig_nyc_file) 显示了在我的计算机上屏幕上的内容。
- en: '![nyc listing for code coverage of recipe.js and server.js](assets/dsnj_0602.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![nyc 显示 recipe.js 和 server.js 的代码覆盖率](assets/dsnj_0602.png)'
- en: Figure 6-2\. nyc listing for recipe.js and server.js
  id: totrans-161
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-2\. 显示 recipe.js 和 server.js 的 nyc 列表
- en: '![nyc code coverage of for server.js](assets/dsnj_0603.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![nyc 显示 server.js 的代码覆盖率](assets/dsnj_0603.png)'
- en: Figure 6-3\. nyc code coverage for server.js
  id: totrans-163
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-3\. server.js 的 nyc 代码覆盖率
- en: The left margin displays a counter for how many times each line in the file
    has been executed. Everything that has been executed has only been executed a
    single time. Lines that only contain whitespace, comments, or the shebang don’t
    have an execution count since they’re never technically executed.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 左边缘显示文件中每行执行的次数计数器。已执行的所有内容仅执行了一次。由于只包含空白、注释或 shebang 的行没有执行计数，因此它们从技术上来说从未执行过。
- en: The handler function for the `GET /` route is highlighted in red. This means
    that the code has not been covered. Hover your mouse cursor over the `return`
    keyword highlighted in red. The tooltip displays the message “statement not covered.”
    Next, hover your mouse cursor over the highlighted `async` keyword. The tooltip
    this time says “function not covered.” This will require a second HTTP request
    to the server to fix this issue.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET /` 路由的处理函数以红色突出显示。这意味着该代码未被覆盖。将鼠标悬停在以红色突出显示的 `return` 关键字上。工具提示显示消息“语句未被覆盖”。接下来，将鼠标悬停在突出显示的
    `async` 关键字上。这次的工具提示显示“函数未被覆盖”。这将需要向服务器发送第二个 HTTP 请求来解决此问题。'
- en: This can be fixed by making a second request from the integration test. Open
    up the *integration.js* file again and add the content from [Example 6-7](#ex_integration_test_two)
    to the end of the file.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过在集成测试中进行第二次请求来解决。再次打开*integration.js*文件，并将内容从[示例 6-7](#ex_integration_test_two)添加到文件末尾。
- en: Example 6-7\. *distnode-deploy/test/integration.js* (second test)
  id: totrans-167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-7\. *distnode-deploy/test/integration.js*（第二个测试）
- en: '[PRE25]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now switch back to the web browser where you were viewing the coverage report.
    Something else in this file is still wrong. Near the top of the file, the default
    port fallback value of 8000 is highlighted in yellow. Hover your mouse cursor
    over the value, and the tooltip will say “branch not covered.” This means that
    the right operand for the *or* operator has never been executed. This is because
    the file is always executed with an environment variable pair of `PORT=0`. The
    zero is passed in as the string `"0"`, which is a truthy value.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在切换回您正在查看覆盖率报告的网络浏览器。文件中仍有其他问题。在文件顶部附近，突出显示了8000的默认端口回退值。将鼠标悬停在该值上，工具提示将显示“分支未覆盖”。这意味着*or*运算符的右操作数从未执行过。这是因为文件始终使用环境变量对`PORT=0`进行执行。传递的零是作为字符串`"0"`，这是一个真值。
- en: 'The easiest way to fix this problem is to instruct nyc to ignore the offending
    line. Add the following line to *server.js* just above the `PORT` assignment line:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 修复这个问题最简单的方法是让nyc忽略有问题的行。在*server.js*的`PORT`分配行上方添加以下行：
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This comment instructs the code coverage checker to ignore the following line.
    There used to be two separate npm packages, one called `istanbul`, and one called
    `nyc`. The two projects were eventually merged. The CLI utility kept the name
    of *nyc*, while the comments used to configure the utility from within code kept
    the prefix of *istanbul*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此注释指示代码覆盖检查器忽略以下行。曾经有两个独立的npm包，一个叫做`istanbul`，另一个叫做`nyc`。这两个项目最终合并了。CLI实用程序保留了*nyc*的名称，而代码中用于配置实用程序的注释则保留了*istanbul*的前缀。
- en: Another way to get past this situation would be to reduce the required code
    coverage value. Since the application is so small, the values would actually have
    to be changed significantly, dropping the branches threshold from 100% to 75%.
    For a larger project, this drop would be much smaller, say from 100% to 99%. As
    tempting as that may be, it is actually a very annoying situation in practice.
    In the situation with sub-100% coverage, if an engineer removes a bunch of code
    from the repository, the code coverage percent will actually drop. Then the engineer
    will need to also reduce the code coverage threshold in *.nycrc* as well, despite
    not adding any untested code.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解决此情况的方法是减少所需的代码覆盖率值。由于应用程序非常小，实际上必须显著更改这些值，将分支阈值从100%降至75%。对于更大的项目，此降幅会小得多，比如从100%降至99%。尽管诱人，但实际上这是一个非常恼人的情况。在不到100%覆盖率的情况下，如果工程师从仓库中移除一些代码，实际上代码覆盖率百分比会下降。然后工程师还需要在*.nycrc*中减少代码覆盖率阈值，尽管没有添加任何未经测试的代码。
- en: Is it okay to not test the default port assignment line? In this case, it depends
    on how the application is intended to be launched in production. If the default
    port is only used to make local development easier, and in production a port is
    always assigned, then go ahead and ignore that line guilt-free.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略默认端口分配行的测试是否可以？在这种情况下，这取决于应用程序在生产环境中的启动方式。如果默认端口仅用于简化本地开发，并且在生产环境中始终分配端口，则可以无忧地忽略该行。
- en: 'Now that you’ve added the new integration test and have added the ignore statement,
    run the test suite again. Run the following command to both run the tests and
    generate a new report:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经添加了新的集成测试并添加了忽略语句，请再次运行测试套件。运行以下命令来运行测试并生成新报告：
- en: '[PRE27]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This time, the coverage summary will show that all four code coverage measurements
    have hit their 100% code coverage requirements! Now you’re ready to commit the
    changes and push them to your branch. Run the following commands to do just that:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，覆盖率摘要将显示所有四个代码覆盖率测量已达到其100%代码覆盖要求！现在您可以提交这些更改并将它们推送到您的分支。运行以下命令来执行这些操作：
- en: '[PRE28]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now that you’ve done that, switch back to your GitHub pull request and reload
    the page. The once-failing checks are now passing and your PR is now ready to
    be merged! Click the green “Merge pull request” button on the pull request screen
    to finish the process. You’ve now got a project happily testing pull requests.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完成了这一步，切换回你的 GitHub 拉取请求页面并重新加载页面。曾经失败的检查现在已经通过，你的 PR 现在已经准备好合并！点击拉取请求页面上的绿色“Merge
    pull request”按钮来完成这个过程。现在你已经拥有一个愉快地测试拉取请求的项目。
- en: 'Switch back to your terminal and run the following commands to get your local
    *master* branch caught up with the remote:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 切换回你的终端并运行以下命令，使本地的*master*分支与远程保持同步：
- en: '[PRE29]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: There are other types of tests that are commonly used to enforce code quality
    standards as well. One class that is very popular, used by projects from open
    source npm packages to closed source enterprise applications, is a code format
    test. By using packages like `eslint` or `standard`, a pull request can fail if
    the newly added code doesn’t follow the required format.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他类型的测试常用于执行代码质量标准的强制性检查。一个非常流行的类别是代码格式测试，它被广泛应用于从开源 npm 包到闭源企业应用的项目中。通过使用像`eslint`或`standard`这样的包，如果新添加的代码不符合要求的格式，拉取请求可能会失败。
- en: Now that your repository is configured to test code quality before merging changes,
    it’s time to configure the project to actually do something with the code once
    it’s been merged. In the next section, you’ll configure your project to automatically
    deploy merged code to production.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的仓库已经配置好在合并更改之前测试代码质量，是时候配置项目在代码合并后实际执行一些操作了。在下一节中，你将配置你的项目自动将合并后的代码部署到生产环境。
- en: Deploying to Heroku
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署到 Heroku
- en: A chapter about deployments wouldn’t be very exciting if you didn’t actually
    end up deploying something. Prepare yourself, for now is your chance. In this
    section you’ll configure Travis CI to execute the commands necessary to deploy
    your application to a production server.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你最终没有部署任何东西，部署章节将不会非常令人兴奋。准备好，现在是你的机会。在这一节中，你将配置 Travis CI 来执行必要的命令将你的应用程序部署到生产服务器上。
- en: For this section, you’ll make use of another SaaS tool, *Heroku*. Heroku is
    a cloud platform that makes it very easy to deploy applications, configure databases,
    and scale out running application instances. It comes with many third-party integrations
    to make deployments easy and can be configured to automatically deploy your Node.js
    application code once a branch is merged in GitHub. This is so easy to configure
    that this section could have been written in a few paragraphs.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节，你将利用另一个 SaaS 工具*Heroku*。Heroku 是一个云平台，使得部署应用程序、配置数据库以及扩展正在运行的应用程序实例变得非常容易。它提供了许多第三方集成，使得部署变得简单，并且可以配置在
    GitHub 合并分支后自动部署你的 Node.js 应用程序代码。这么容易配置，以至于这一节本来可以只写几段话。
- en: But that would be too easy. Instead, you’ll get your hands a bit more dirty
    by configuring Travis CI to execute a deployment script. This script will run
    commands that will interact with Heroku. This is a universal approach that can
    be modified to deploy the application to other platforms.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 但那会太简单了。相反，你将通过配置 Travis CI 来执行一个部署脚本使事情变得更复杂些。这个脚本将运行与 Heroku 交互的命令。这是一个通用的方法，可以修改以将应用程序部署到其他平台。
- en: In the previous section, you configured Travis to build and test your pull requests.
    In this section, Travis will build and test code once it’s merged into the *master*
    branch, and once that passes, it’ll deploy that code to production. It might sound
    redundant to test code both when it’s in a pull request and again once it’s merged
    to *master*. However, it’s possible to do things like rebase or squash or other
    operations where GitHub will otherwise modify the code before it’s merged to *master*.
    It’s also possible to push directly to *master* in your GitHub repository. For
    those reasons, it’s better to test the code again before deploying to ensure only
    (seemingly) valid code is shipped to production.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，你配置了 Travis 来构建和测试你的拉取请求。在这一节中，Travis 将在代码合并到*master*分支后构建和测试代码，一旦通过，它将把该代码部署到生产环境。在拉取请求时和合并到*master*后再次测试代码可能听起来有些冗余。然而，可以进行像变基、压缩或其他
    GitHub 将在合并到*master*之前修改代码的操作。也可以直接推送到 GitHub 仓库的*master*分支。出于这些原因，最好在部署之前再次测试代码，以确保只有（看似）有效的代码被部署到生产环境。
- en: What does it mean to deploy? Well, as you saw in [“Internal Docker Registry”](ch05.html#ch_containers_subsec_registry),
    there is a Docker Registry service that is used for storing Docker images and
    their layers, providing an API to interact with. When you deploy a Docker-based
    application, you trigger two basic steps. The first step is to upload a copy of
    the image to the Docker Registry, and the second step is to run a container based
    on the image. [Figure 6-4](#fig_github_travis_heroku) visually explains this process
    and how you’ll configure it with Travis and Heroku.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 部署意味着什么？正如您在 [“内部 Docker Registry”](ch05.html#ch_containers_subsec_registry)
    中所见，有一个用于存储 Docker 镜像及其层次的 Docker Registry 服务，并提供与之交互的 API。当您部署基于 Docker 的应用程序时，会触发两个基本步骤。第一步是将镜像的副本上传到
    Docker Registry，第二步是基于该镜像运行容器。[图 6-4](#fig_github_travis_heroku) 通过视觉方式解释了此过程，并说明您将如何通过
    Travis 和 Heroku 进行配置。
- en: '![GitHub notifies Travis CI when changes happen, Travis builds changes, Docker
    image is pushed to Heroku registry, and Heroku runs an instance of the image](assets/dsnj_0604.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![GitHub 在代码更改时通知 Travis CI，Travis 进行构建，Docker 镜像推送至 Heroku Registry，Heroku
    运行镜像实例](assets/dsnj_0604.png)'
- en: Figure 6-4\. GitHub, Travis CI, and Heroku
  id: totrans-191
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-4\. GitHub、Travis CI 和 Heroku
- en: In this case, changes to your application’s code living in the *master* branch
    on GitHub trigger a call to Travis. Travis sees the updated code and triggers
    a build. The build will generate a Docker image that gets uploaded to a Docker
    Registry. In this case, the image is sent to the Docker Registry hosted by Heroku
    at [*https://registry.docker.com*](https://registry.docker.com). Once that’s done,
    Travis tells Heroku to deploy the most recent version of your application’s image.
    Heroku then works its magic, downloading the image to a server somewhere, before
    finally running the container.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，GitHub 上 *master* 分支中应用程序代码的更改会触发对 Travis 的调用。Travis 检测到更新的代码并触发构建。该构建将生成一个
    Docker 镜像，然后上传到 Docker Registry。在这种情况下，镜像被发送到由 Heroku 在 [*https://registry.docker.com*](https://registry.docker.com)
    托管的 Docker Registry。完成这些步骤后，Travis 通知 Heroku 部署应用程序的最新版本镜像。Heroku 随后进行处理，在某个服务器上下载镜像，并最终运行容器。
- en: But before you can build all that, you first need to create a Heroku account
    and make your first Heroku application.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 但在构建所有这些之前，您首先需要创建一个 Heroku 帐户并创建您的第一个 Heroku 应用程序。
- en: Create a Heroku App
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Heroku 应用程序
- en: Visit the [Heroku](https://heroku.com) website and create an account. For the
    purpose of this section, the free account tier is enough to deploy and run your
    application.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 [Heroku](https://heroku.com) 网站并创建一个帐户。对于本节目的目的，免费帐户足以部署和运行您的应用程序。
- en: Once you’re logged in to the Heroku site, you should be taken to the [dashboard](https://dashboard.heroku.com/apps)
    screen. The dashboard will normally list your applications, but at this point
    you should have none. Click the drop-down menu titled New in the upper-right corner
    of the screen, then click Create New App.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 登录 Heroku 网站后，您将被带到 [控制面板](https://dashboard.heroku.com/apps) 屏幕。该面板通常列出您的应用程序，但目前应该为空。点击屏幕右上角标题为
    New 的下拉菜单，然后点击 Create New App。
- en: Now that you’re on the Create New App screen, you’re free to describe your application.
    Use the information in [Table 6-1](#table_heroku_new_app) to describe your application.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您位于创建新应用程序屏幕上，可以自由地描述您的应用程序。使用 [表 6-1](#table_heroku_new_app) 中的信息来描述您的应用程序。
- en: Table 6-1\. Create a new Docker app
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-1\. 创建新的 Docker 应用程序
- en: '| App name | `<USERNAME>-distnode` |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| 应用名称 | `<USERNAME>-distnode` |'
- en: '| Region | US |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| 区域 | 美国 |'
- en: '| Pipeline | empty |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 流水线 | 空 |'
- en: 'Heroku gives your application a URL based on the application name you choose.
    This URL isn’t namespaced by your account, so if you were to just call the application
    something like `distnode`, you would be competing with other readers of this book.
    This is why you need to add your own namespace using something like your username.
    Keep track of the name you choose, because you’ll refer to it elsewhere. Your
    application’s URL will end up looking like this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku 根据您选择的应用程序名称为其分配一个 URL。此 URL 不会根据您的帐户命名空间化，因此如果您仅将应用程序命名为 `distnode`，则会与本书其他读者竞争。这就是为什么您需要使用类似您的用户名这样的命名空间。记住您选择的名称，因为您将在其他地方引用它。您的应用程序
    URL 最终将看起来像这样：
- en: '[PRE30]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Once you’ve described your application, click the Create app button to finish
    creating your application.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 描述完您的应用程序后，点击创建应用按钮完成应用程序创建过程。
- en: You’ll need another piece of information to interact with Heroku, specifically
    a string called the Heroku API Key. This string is formatted like a UUID and is
    useful for authenticating with Heroku from within a script.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 您将需要另一段信息才能与 Heroku 互动，具体来说是称为 Heroku API 密钥的字符串。此字符串的格式类似 UUID，对于从脚本中认证与 Heroku
    的操作非常有用。
- en: To get your Heroku API Key, first click your avatar in the top right corner
    of the Heroku website. In the drop-down menu that appears, click the Account settings
    link. Within the [account settings](https://dashboard.heroku.com/account) screen,
    scroll down to the section titled API Key. By default, the content in this field
    is hidden. Click the Reveal button to view it. Copy the key for now; you’ll need
    it soon enough. This key is an important value that you should keep secret. You
    should never check it into a git repository directly, though you will end up checking
    in an encrypted version of the key.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取您的 Heroku API 密钥，请首先点击 Heroku 网站右上角的头像。在出现的下拉菜单中，点击“账户设置”链接。在[账户设置](https://dashboard.heroku.com/account)屏幕中，向下滚动到标题为
    API 密钥的部分。默认情况下，此字段中的内容是隐藏的。点击“显示”按钮查看它。暂时复制此密钥；您很快会需要它。此密钥是一个重要的值，应保密。尽管您最终会检查密钥的加密版本，但永远不应直接将其提交到
    git 代码库中。
- en: Configure Travis CI
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 Travis CI
- en: Now that you’ve created your Heroku application using the web interface, it’s
    time to get back into the console. Open up a terminal window and navigate back
    to your *distnode-deploy/* directory.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经使用 Web 界面创建了 Heroku 应用程序，是时候回到控制台了。打开终端窗口并导航回 *distnode-deploy/* 目录。
- en: 'This time, you’re going to work directly in the *master* branch, pushing changes
    without creating a pull request. Make sure you’re in the right branch by running
    the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，您将直接在 *master* 分支中工作，推送更改而不创建拉取请求。确保您通过运行以下命令位于正确的分支中：
- en: '[PRE31]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The first thing you’re going to do is to encrypt the Heroku API Key that you
    obtained in the previous section. By encrypting the value, you’ll be able to check
    it into the repository without the fear of someone stealing it and using it to
    wreak havoc on your application (or your credit card).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是加密上一节中获取的 Heroku API 密钥。通过加密该值，您可以将其提交到代码库中，而无需担心有人窃取并用其对您的应用程序（或信用卡）造成严重影响。
- en: 'In order to encrypt the value, you’ll need to use the official `travis` executable.
    This executable is obtained differently depending on the operating system you’re
    using. The following commands should help you out. For macOS users, there’s a
    `brew` one-liner. For Linux, you might need to first install a dev package like
    I did before being able to install the `travis` gem package. Try these commands
    to get the executable installed:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要加密该值，您需要使用官方的 `travis` 可执行文件。这个可执行文件根据您使用的操作系统不同而获取方式不同。以下命令应该会帮助您。对于 macOS
    用户，有一个 `brew` 一行命令。对于 Linux 用户，您可能需要先安装类似我之前安装的 dev 包才能安装 `travis` gem 包。试试这些命令以获取可执行文件安装：
- en: '[PRE32]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Documentation on how to install the Travis executable is [readily available
    online](https://github.com/travis-ci/travis.rb) if these commands don’t work out.
    Once you have the tool installed, you’re now ready to encrypt the Heroku API Key
    that you obtained earlier for use as an environment variable within the Travis
    deployment script. Run the following commands to first log in to your Travis account
    using your GitHub credentials and then to generate the encrypted environment variable:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些命令无法正常工作，可以在线找到有关安装 Travis 可执行文件的[文档](https://github.com/travis-ci/travis.rb)。安装了工具后，您现在可以准备加密之前获取的
    Heroku API 密钥，以用作 Travis 部署脚本中的环境变量。运行以下命令首先使用 GitHub 凭据登录到 Travis 账户，然后生成加密的环境变量：
- en: '[PRE33]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `--pro` arguments tell the Travis executable that you’re using a *travis-ci.com*
    account, as opposed to a self-hosted version.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`--pro` 参数告诉 Travis 可执行文件，您正在使用 *travis-ci.com* 账户，而不是自托管版本。'
- en: Keep track of the output from the `travis encrypt` command. You’ll need to add
    it soon. The output string specifically locks the key and value together. By looking
    at the encrypted value, you can’t even tell that the environment variable name
    is `HEROKU_API_KEY`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 记录来自 `travis encrypt` 命令的输出。您很快会需要添加它。输出字符串特别锁定了键和值。通过查看加密值，您甚至无法看出环境变量名称是 `HEROKU_API_KEY`。
- en: Now that you’ve got the encrypted environment variable, you’re ready to make
    some additional changes to the *.travis.yml* that you created previously. Open
    the file and append the content in [Example 6-8](#ex_heroku_travisyml) to the
    end of the file.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经获得了加密的环境变量，可以对之前创建的 *.travis.yml* 进行一些额外的更改。打开文件并将 [示例 6-8](#ex_heroku_travisyml)
    的内容追加到文件末尾。
- en: Example 6-8\. *distnode-deploy/.travis.yml* (amended)
  id: totrans-219
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-8\. *distnode-deploy/.travis.yml*（已修改）
- en: '[PRE34]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[![1](assets/1.png)](#co_deployments_CO4-1)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_deployments_CO4-1)'
- en: The docker image will be built.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 将构建 Docker 镜像。
- en: '[![2](assets/2.png)](#co_deployments_CO4-2)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_deployments_CO4-2)'
- en: The *master* branch will run *deploy-heroku.sh*.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '*master* 分支将运行 *deploy-heroku.sh*。'
- en: '[![3](assets/3.png)](#co_deployments_CO4-3)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_deployments_CO4-3)'
- en: The encrypted environment variable will go here.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 加密的环境变量将在此处进行。
- en: This configures the `deploy` section of the file. Travis CI offers several different
    *provider* options, which are integrations with third-party services. In this
    case, you’re using the *script* provider, which allows you to manually run shell
    commands. All together, this configuration tells Travis to run the *deploy-heroku.sh*
    script when changes are made to the *master* branch.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这样配置了文件的 `deploy` 部分。Travis CI 提供了几种不同的 *provider* 选项，这些选项是与第三方服务的集成。在本例中，您使用的是
    *script* 提供程序，它允许您手动运行 shell 命令。总体而言，此配置告诉 Travis 在 *master* 分支有更改时运行 *deploy-heroku.sh*
    脚本。
- en: 'The other section being configured here is the `env` section, though technically
    you haven’t yet added an entry. Take the output from the `travis encrypt` command
    and add it to *.travis.yml*. It should be on a line of its own, starting with
    four spaces, followed by a hyphen, another space, and then the word “`secure:`”
    and the long encrypted string surrounded in quotes. The *env* section in your
    file should now resemble the following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 此处正在配置的另一个部分是 `env` 部分，尽管从技术上讲，您尚未添加条目。获取 `travis encrypt` 命令的输出，并将其添加到 *.travis.yml*
    中。它应该位于自己的一行上，以四个空格开头，后跟一个连字符，再后跟“`secure:`”，以及用引号括起来的长加密字符串。您的文件中的 *env* 部分现在应该如下所示：
- en: '[PRE35]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You also need to create a Dockerfile. For this example, you can just use a variation
    of the basic Dockerfile you created in previous sections. One thing that makes
    it different is that this Dockerfile sets a default `HOST` environment variable
    to `0.0.0.0`. Add the content from [Example 6-9](#ex_docker_dockerfile) to get
    your application ready to run.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要创建一个 Dockerfile。对于本示例，您可以简单地使用之前部分创建的基本 Dockerfile 的变体。使其与众不同的一点是，该 Dockerfile
    将默认的 `HOST` 环境变量设置为 `0.0.0.0`。添加 [示例 6-9](#ex_docker_dockerfile) 中的内容，以准备好运行您的应用程序。
- en: Example 6-9\. *distnode-deploy/Dockerfile*
  id: totrans-231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-9\. *distnode-deploy/Dockerfile*
- en: '[PRE36]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now that your *.travis.yml* file is configured and your Dockerfile is finished,
    you’re ready to work on deploying your application.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您的 *.travis.yml* 文件已配置完成，您的 Dockerfile 也已完成，可以开始部署您的应用程序。
- en: Deploy Your Application
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署您的应用程序
- en: In the previous section, you added a reference to a shell script named *deploy-heroku.sh*
    to your *.travis.yml* file. Now you’re ready to add the content for this file.
    Create the file and add the content from [Example 6-10](#ex_docker_push_script)
    to it. Note that you’ll need to change the two `--app <USERNAME>-distnode` flags
    to use the name of your Heroku application that you chose previously.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，您向 *.travis.yml* 文件添加了一个名为 *deploy-heroku.sh* 的 shell 脚本的引用。现在您可以为此文件添加内容。创建文件并添加
    [示例 6-10](#ex_docker_push_script) 中的内容。请注意，您需要将两个 `--app <USERNAME>-distnode`
    标志更改为您之前选择的 Heroku 应用程序的名称。
- en: Example 6-10\. *distnode-deploy/deploy-heroku.sh*
  id: totrans-236
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-10\. *distnode-deploy/deploy-heroku.sh*
- en: '[PRE37]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This file uses another CLI utility called `heroku`. This utility allows you
    to configure your Heroku applications from the command line. It’s available for
    install on your local development machine, but in this case, it’s being run in
    an automated fashion on a Travis CI build server. The command doesn’t already
    exist on Travis, so the first `wget` command installs it. The second command installs
    an additional plug-in that allows `heroku` to manage Docker containers.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件使用另一个名为 `heroku` 的 CLI 实用程序。此实用程序允许您从命令行配置 Heroku 应用程序。它可供您在本地开发机器上安装，但在本例中，它是在
    Travis CI 构建服务器上以自动化方式运行的。命令在 Travis 上尚不存在，因此第一个 `wget` 命令将其安装。第二个命令安装了一个额外的插件，允许
    `heroku` 管理 Docker 容器。
- en: The `heroku container:login` subcommand instructs `heroku` to log in to the
    Docker Registry hosted by Heroku. This command will look for an environment variable
    named `HEROKU_API_KEY` in order to log in (otherwise, it will prompt for login
    credentials). That value is provided by the encrypted environment variable you
    configured previously.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`heroku container:login` 子命令指示 `heroku` 登录到由 Heroku 托管的 Docker Registry。此命令将查找名为
    `HEROKU_API_KEY` 的环境变量以便登录（否则，它将提示输入登录凭据）。该值是之前配置的加密环境变量提供的。'
- en: The `heroku container:push` command does two things. First, it builds a Docker
    image based on the Dockerfile in the current directory. Next, it pushes that image
    to the Docker Registry.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`heroku container:push` 命令有两个作用。首先，它基于当前目录中的 Dockerfile 构建一个 Docker 镜像。接下来，它将该镜像推送到
    Docker Registry。'
- en: Finally, the `heroku container:release` command is what tells the Heroku service
    to perform an actual release. This results in the server pulling the image from
    the Docker Registry, running a new container, switching traffic to your URL from
    the old container to the new container, and then destroying the old container.
    These few short commands result in a lot of work being run behind the scenes.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`heroku container:release` 命令告诉 Heroku 服务执行实际的发布。这将导致服务器从 Docker Registry
    拉取镜像，运行新容器，将流量从旧容器切换到新容器的 URL，然后销毁旧容器。这几个简短的命令在幕后运行了大量工作。
- en: 'Now that you’ve finished making the necessary file changes, you’re ready to
    trigger a deployment. Add the files you’ve changed to git, commit them, and then
    push. You can do this by running the following commands:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完成了必要的文件更改，准备触发部署。将你修改的文件添加到 git 中，提交它们，然后推送。你可以通过运行以下命令来完成这些操作：
- en: '[PRE38]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: At this point, you’ve triggered the build pipeline. This can take a minute or
    two to deploy. Since it’s not immediate, you can attempt to view the process while
    it’s happening.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你已经触发了构建流水线。这可能需要一两分钟来部署。由于不是立即的，你可以在部署过程中尝试查看进度。
- en: First, return to the [Travis CI dashboard](https://travis-ci.com/dashboard)
    screen, where you will see a list of your repositories. Then, click the entry
    for your project’s repository.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，返回到 [Travis CI 仪表盘](https://travis-ci.com/dashboard) 屏幕，在那里你会看到你的仓库列表。然后，点击你项目仓库的条目。
- en: The repository screen has a few tabs, with the default tab you’re currently
    looking at called Current. Click the second tab, titled Branches, to view a list
    of branches. This list of branches shows the various branches that Travis has
    seen and has built. You should see two branches listed, the first being the *master*
    branch that’s now being built and the second being the *feature-1* branch that
    previously represented the pull request you made. [Figure 6-5](#fig_travis_branches)
    is what my branch list looks like for my project. Yours should look a little simpler
    because I’ve run more than one build for my *master* branch.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库屏幕有几个选项卡，默认选项卡是当前选项卡，你当前正在查看。点击第二个选项卡，名为 Branches，查看分支列表。这个分支列表显示了 Travis
    见过并构建过的各种分支。你应该能看到列出了两个分支，第一个是正在构建的 *master* 分支，第二个是之前代表你创建的拉取请求的 *feature-1*
    分支。我项目中的分支列表看起来像 [Figure 6-5](#fig_travis_branches)。你的应该会简单一些，因为我对 *master* 分支运行了多次构建。
- en: '![A list of branches in the Travis project](assets/dsnj_0605.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![Travis 项目中的分支列表](assets/dsnj_0605.png)'
- en: Figure 6-5\. Travis branch list
  id: totrans-248
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 6-5\. Travis 分支列表
- en: Click on the build number link next to the *master* branch. In my case, the
    link is titled “# 25 received”; you should see a different number, and depending
    on how quickly you clicked, you might see different text like “# 5 passed.” This
    will take you to the build details screen.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 *master* 分支旁边的构建编号链接。在我的案例中，链接标题是“# 25 received”；你可能会看到不同的编号，取决于你点击的速度，你可能会看到类似“#
    5 passed”的不同文本。这将带你进入构建详细信息屏幕。
- en: On this screen, you should again see an overview of the build process. The screen
    will look a little different from when you previously looked at the pull request
    builds on Travis. For example, this screen lists the new environment variable
    that you created. In this case, it should list `HEROKU_API_KEY=[secure]`, signaling
    that the value is present and has been encrypted. [Figure 6-6](#fig_travis_master)
    is what I see on my screen.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个屏幕上，你应该能再次看到构建过程的概览。这个屏幕看起来与你之前在 Travis 上查看拉取请求构建时有些不同。例如，这个屏幕列出了你创建的新环境变量。在这种情况下，它应该列出
    `HEROKU_API_KEY=[secure]`，表明该值存在且已被加密。我在我的屏幕上看到的是 [Figure 6-6](#fig_travis_master)。
- en: '![Travis build status of the master branch](assets/dsnj_0606.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![主分支的 Travis 构建状态](assets/dsnj_0606.png)'
- en: Figure 6-6\. Travis branch list
  id: totrans-252
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-6\. Travis 分支列表
- en: 'At this point, the job log should be displaying updates as the build process
    writes content to the console. In this output is a new section titled Deploying
    application. If you expand this section, you should see the output from the various
    Docker commands being executed on Travis by the `heroku` executable. Eventually
    you should see the following message displayed:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，作业日志应该会显示构建过程将内容写入控制台的更新。在此输出中，有一个名为“部署应用程序”的新部分。如果您展开此部分，您应该会看到由 `heroku`
    可执行文件在 Travis 上执行的各种 Docker 命令的输出。最终，您应该会看到以下消息显示：
- en: '[PRE39]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note that the Travis CI interface expands and collapses sections as the build
    stage changes, so you might need to go back to expand the section, or even wait
    until the section is available if you opened the page too early in the build process.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Travis CI 界面会随着构建阶段的更改而展开和折叠部分，因此您可能需要返回并展开部分，或者在构建过程中打开页面太早时等待直到该部分可用。
- en: 'Once that message has been displayed, your application is now ready and running
    in production. Open a new tab in your browser and navigate to the following URL,
    adapting it to match your Heroku application name:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦显示了该消息，您的应用程序现在已准备就绪并在生产环境中运行。在浏览器中打开一个新标签页，并导航到以下 URL，以适应您的 Heroku 应用程序名称：
- en: '[PRE40]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If all goes to plan, you should see the message “Hello from Distributed Node.js!”
    displayed in your browser window.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，您应该会在浏览器窗口中看到“来自分布式 Node.js 的问候！”的消息。
- en: Modules, Packages, and SemVer
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块、包和语义化版本
- en: Node.js applications can get complex. While it’s technically possible to run
    everything in a single massive file, and goodness knows some of my earliest projects
    were built this way, an application must be broken up into smaller files to avoid
    driving developers insane. Developers are able to better focus on a smaller part
    of a complex codebase if code is properly isolated to individual files. Smaller
    files also help avoid collisions when multiple developers are making changes to
    a project in version control. This is what modules are for.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 应用程序可能会变得复杂。虽然在一个单一的大文件中运行所有内容在技术上是可能的，而且我知道我的早期项目中有些是这样构建的，但一个应用程序必须被分解成更小的文件以避免使开发人员发疯。如果代码被适当地隔离到单独的文件中，开发人员可以更好地专注于复杂代码库中的一个较小部分。较小的文件还有助于避免在多个开发人员同时对项目进行版本控制更改时的冲突。这就是模块的作用所在。
- en: Code will sometimes need to be reused between multiple applications. When this
    happens, the code is converted into a package. Such code reuse typically falls
    into two categories. In the first category, a package is so generic that it is
    beneficial to other organizations. In the second category, the package may contain
    trade secrets or is otherwise only beneficial to the organization that wrote it,
    but it may still be beneficial to multiple applications within the organization.
    Either way, these packages will need to be versioned and published.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候代码需要在多个应用程序之间重复使用。当这种情况发生时，代码会转换成一个包。这种代码重用通常分为两类。在第一类别中，一个包非常通用，对其他组织有益。在第二类别中，该包可能包含商业机密或其他仅对编写它的组织有利的内容，但仍可能对组织内多个应用程序有益。无论哪种情况，这些包都需要进行版本管理和发布。
- en: But before diving into the complexities of packaging, it’s time to get a solid
    understanding of modules as they’re implemented in Node.js.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 但在深入了解打包复杂性之前，是时候对 Node.js 中实现的模块有一个坚实的理解了。
- en: Node.js Modules
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Node.js 模块
- en: Node.js supports two different module formats. The first format is the [*CommonJS
    module*](https://nodejs.org/api/modules.html) and is the format that Node.js has
    adopted since its beginning. The second format is the [*ECMAScript module*](https://nodejs.org/api/esm.html)
    (ESM), a format that has been under heavy development in recent years and should
    eventually bridge the gap between JavaScript that runs in the browser and JavaScript
    that runs in Node.js. It is very likely that one day most application code will
    be written using ESM, but as of Node.js v14.8, ECMAScript modules are still marked
    as experimental—a designation meaning backward-breaking changes can still be made.
    For this reason, this section—and this book—focuses on CommonJS modules.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 支持两种不同的模块格式。第一种格式是 [*CommonJS 模块*](https://nodejs.org/api/modules.html)，这是
    Node.js 自从开始采用的格式。第二种格式是 [*ECMAScript 模块*](https://nodejs.org/api/esm.html)（ESM），这是近年来积极开发的格式，最终应该能弥合在浏览器和
    Node.js 中运行的 JavaScript 之间的差距。很可能有一天，大多数应用程序代码都将使用 ESM 编写，但截至 Node.js v14.8，ECMAScript
    模块仍然被标记为实验性，这意味着仍可能进行破坏性变更。因此，本节和本书都着重于 CommonJS 模块。
- en: A Node.js module is a JavaScript file that has either been directly executed
    or otherwise required by a Node.js process. JavaScript files being run in this
    manner differ from vanilla JavaScript files being run in a web browser. This is
    mostly due to Node.js adhering to CommonJS. With CommonJS, functionality is exported
    by the use of an object named `exports`, and functionality is imported using a
    function named `require`. Neither of these features are a core part of the JavaScript
    language^([4](ch06.html#idm46291183299560)) and are instead introduced by the
    Node.js runtime.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Node.js 模块是一个 JavaScript 文件，可以直接执行或由 Node.js 进程引入。以这种方式运行的 JavaScript 文件与在
    web 浏览器中运行的普通 JavaScript 文件不同。这主要是因为 Node.js 遵循 CommonJS。在 CommonJS 中，功能通过名为 `exports`
    的对象导出，通过名为 `require` 的函数导入。这些功能都不是 JavaScript 语言的核心部分^([4](ch06.html#idm46291183299560))，而是由
    Node.js 运行时引入的。
- en: 'Another thing that makes Node.js modules different from browser JavaScript
    is that if you declare a variable first thing in a JavaScript file, such as `var
    foo = *bar*`, that value won’t become a global variable. Instead, it will only
    be accessible in the current file. The reason Node.js modules work this way is
    because Node.js automatically wraps each JavaScript file in the following function
    declaration:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 模块与浏览器 JavaScript 不同的另一个方面在于，如果你在 JavaScript 文件的开头声明一个变量，比如 `var foo
    = *bar*`，那么这个值不会成为全局变量。相反，它只能在当前文件中访问。Node.js 模块这样工作的原因是因为 Node.js 自动将每个 JavaScript
    文件包装在以下函数声明中：
- en: '[PRE41]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This [wrapper](https://nodejs.org/api/modules.html#modules_the_module_wrapper)
    makes a few things convenient for application developers. Most importantly, it
    provides `exports` and `require`, which are required by the CommonJS standard.
    Both `__filename` and `__dirname` are strings that make it convenient to know
    where your file is located. Both of them are absolute paths. The `require` function
    is also an object with several properties attached to it. Note that Node.js also
    removes the shebang line, if present, before wrapping the file.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 [包装器](https://nodejs.org/api/modules.html#modules_the_module_wrapper) 为应用程序开发者提供了一些便利。最重要的是，它提供了
    `exports` 和 `require`，这是 CommonJS 标准所需的。`__filename` 和 `__dirname` 都是字符串，方便了解文件的位置。它们都是绝对路径。`require`
    函数也是一个对象，附带了几个属性。请注意，Node.js 在包装文件之前也会删除存在的 shebang 行。
- en: The `module` object contains several properties as well and is used to describe
    the current Node.js module. The `exports` function wrapper argument is a reference
    to the `module.exports` property. The `__filename` variable is a convenient reference
    to `module.filename`, while `__dirname` is a convenience for `path.dirname(__filename)`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`module` 对象也包含几个属性，用于描述当前的 Node.js 模块。`exports` 函数包装器参数是对 `module.exports`
    属性的引用。`__filename` 变量是对 `module.filename` 的便捷引用，而 `__dirname` 则是 `path.dirname(__filename)`
    的便捷引用。'
- en: With this information, you can check to see if the current module happens to
    be the application entry point with `require.main === module`. I’ve seen this
    used when testing a *server.js* file; if the module is the entry point, then start
    the server. If it is not the entry point, export the server instance so that tests
    can interact with it.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些信息，你可以通过 `require.main === module` 来检查当前模块是否是应用程序的入口点。我在测试 *server.js* 文件时见过这种用法；如果模块是入口点，则启动服务器。如果不是入口点，则导出服务器实例，以便测试可以与其交互。
- en: 'It is possible, though almost universally frowned-upon, to set globals within
    Node.js. The V8 engine provides two references to the global object: the newer
    `globalThis` and the older `global`. Browsers have two references to their global
    object: the newer `globalThis` and the older `window`. Of course, Node.js applications
    don’t really have a concept of a “window,” so `global` is used. Due to the popularity
    of sharing JavaScript files between server and browser, `globalThis` was created
    to bridge the gap.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在 Node.js 中设定全局变量几乎被普遍反对，但是它是可能的。V8 引擎提供了两个全局对象的引用：较新的 `globalThis` 和较旧的 `global`。浏览器也有两个全局对象的引用：较新的
    `globalThis` 和较旧的 `window`。当然，Node.js 应用程序并没有“window”概念，所以使用 `global`。由于在服务器和浏览器之间共享
    JavaScript 文件的流行程度，`globalThis` 被创建来弥合这一差距。
- en: 'The `require()` function is something that you’ve likely used many times by
    now. But sometimes it might not behave quite the way you would expect it to. It
    turns out there’s quite a bit of complexity involved when Node.js attempts to
    load a module when you call this function, a process using the [module resolution
    algorithm](https://nodejs.org/api/modules.html#modules_all_together). There’s
    a lot to it, but here are a few examples of what happens when you call `require(mod)`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`require()` 函数是你可能已经多次使用过的东西。但有时它的行为可能不像你期望的那样。事实证明，当你调用这个函数时，Node.js 尝试加载模块的过程中涉及到相当多的复杂性，这是一个使用
    [模块解析算法](https://nodejs.org/api/modules.html#modules_all_together) 的过程。其中有很多内容，但以下是调用
    `require(mod)` 时发生的几个例子：'
- en: If *mod* is the name of a core Node.js module (like `fs`), then load it.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *mod* 是核心 Node.js 模块的名称（如 `fs`），则加载它。
- en: If *mod* starts with “`/`”, “`./`”, or “`../`”, load the resolved path to the
    file or directory.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *mod* 以 “`/`”、“`./`” 或 “`../`” 开头，则加载解析后的文件或目录路径。
- en: If a directory is loaded, look for a *package.json* file with a `main` field
    and load that file.
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果加载的是一个目录，则查找一个带有 `main` 字段的 *package.json* 文件并加载该文件。
- en: If a directory doesn’t contain a *package.json*, try to load *index.js*.
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个目录不包含 *package.json*，尝试加载 *index.js*。
- en: If loading a file, try to load the exact filename, then fall back to adding
    file extensions *.js*, *.json*, and *.node* (native module).
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果加载的是一个文件，尝试加载完全匹配的文件名，然后回退到添加文件扩展名 *.js*、*.json* 和 *.node*（原生模块）。
- en: Look for a directory in *./node_modules* matching the *mod* string.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *./node_modules* 中查找与 *mod* 字符串匹配的目录。
- en: Look for a *node_modules* directory in each parent directory until the root
    directory is encountered.
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个父目录中查找 *node_modules* 目录，直到遇到根目录。
- en: As I mentioned, it’s a bit complex. [Table 6-2](#table_example_module_resolution)
    shows some examples of `require()` calls and where the Node.js runtime will look
    for matching files. This assumes the `require()` is happening within a file at
    */srv/server.js*.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，这有点复杂。[表格 6-2](#table_example_module_resolution) 展示了一些 `require()`
    调用的例子以及 Node.js 运行时将在哪里寻找匹配文件。这假设 `require()` 发生在 */srv/server.js* 文件中。
- en: Table 6-2\. Module resolution within */srv/server.js*
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: Table 6-2\. 在 */srv/server.js* 中的模块解析
- en: '| `require(''url'')` | Core *url* module |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| `require(''url'')` | 核心 *url* 模块 |'
- en: '| `require(''./module.js'')` | */srv/module.js* |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| `require(''./module.js'')` | */srv/module.js* |'
- en: '| `require(''left-pad'')` | */srv/node_modules/left-pad/*, */node_modules/left-pad/*
    |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| `require(''left-pad'')` | */srv/node_modules/left-pad/*, */node_modules/left-pad/*
    |'
- en: '| `require(''foo.js'')` | */srv/node_modules/foo.js/*, */node_modules/foo.js/*
    |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| `require(''foo.js'')` | */srv/node_modules/foo.js/*, */node_modules/foo.js/*
    |'
- en: '| `require(''./foo'')` | */srv/foo.js*, */srv/foo.json*, */srv/foo.node*, */srv/foo/index.js*
    |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| `require(''./foo'')` | */srv/foo.js*, */srv/foo.json*, */srv/foo.node*, */srv/foo/index.js*
    |'
- en: One thing that’s tricky about the examples is the `require('foo.js')` call.
    It appears to be a reference to a JavaScript file, but it actually ends up looking
    for a directory named *foo.js/* within *node_modules* directories.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些例子有一个棘手之处是 `require('foo.js')` 的调用。它看起来是对一个 JavaScript 文件的引用，但实际上它最终会在 *node_modules*
    目录中寻找一个名为 *foo.js/* 的目录。
- en: When it comes to requiring files, it’s generally better to be explicit and provide
    the file extension than to omit it. This can actually cause bugs that might be
    hard to catch. For example, if a directory contains a *contacts.js* file and a
    *contacts.json* file, a `require('./contacts')` call will correctly load the *contact.js*
    file. But when a refactor happens and the *contacts.js* file is removed, the *contacts.json*
    file will then be loaded. This may then cause a bug at runtime.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要引入文件时，通常最好是明确指定文件扩展名，而不是省略它。这样做实际上可以防止可能很难捕捉的错误。例如，如果一个目录中包含 *contacts.js*
    文件和 *contacts.json* 文件，调用 `require('./contacts')` 将正确加载 *contacts.js* 文件。但是当进行重构并移除
    *contacts.js* 文件时，将会加载 *contacts.json* 文件，这可能导致运行时错误。
- en: When modules are loaded within a running Node.js process, they get added to
    something called the *require cache*. The cache is located at `require.cache`
    and is available to every module. The cache is an object where the keys are the
    absolute path to a file and the values are a “Module” object. The `module` variable
    is also a Module object. Among other things, these Module objects contain a property
    called `exports`, which is a reference to the module’s exported functionality.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 当模块在运行的 Node.js 进程中加载时，它们会添加到一个称为 *require cache* 的东西中。该缓存位于 `require.cache`
    中，并且对每个模块都可用。该缓存是一个对象，其中键是文件的绝对路径，值是一个“Module”对象。`module` 变量也是一个 Module 对象。这些
    Module 对象包含一个称为 `exports` 的属性，该属性是模块导出功能的引用，除其他外。
- en: This module cache is important. When a call to `require()` is made and the path
    to the file to be loaded has been resolved, Node.js will first consult with the
    require cache. If a matching entry is encountered, that entry will be used. Otherwise,
    if the file is being loaded for the first time, the file will be read from disk
    and evaluated. This is how Node.js prevents a dependency that was loaded multiple
    times from being executed multiple times.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块缓存非常重要。当调用 `require()` 并解析要加载的文件路径时，Node.js 首先查看 require 缓存。如果找到匹配的条目，则使用该条目。否则，如果文件是第一次加载，则从磁盘读取和评估该文件。这就是
    Node.js 如何防止多次加载的依赖项多次执行。
- en: Now that you know a bit more about Node.js modules, you’re just about ready
    to learn about npm packages. But before you do that, take a look at something
    called SemVer. This is a very important concept when it comes to working with
    npm packages.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对 Node.js 模块有了一些了解，几乎可以开始学习 npm 包了。但在此之前，先了解一下称为 SemVer 的东西。在处理 npm 包时，这是一个非常重要的概念。
- en: SemVer (Semantic Versioning)
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SemVer（语义化版本）
- en: '*SemVer* is short for [Semantic Versioning](https://semver.org). It’s a philosophy
    used for deciding the version number to attach to dependencies as they are updated
    and released. SemVer is used by many different package management platforms and
    is relied on heavily by npm.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '*SemVer* 是 [语义化版本](https://semver.org) 的简称。这是一种用于确定依赖项版本号的哲学，当它们被更新和发布时使用。SemVer
    被许多不同的包管理平台使用，并且被 npm 大量依赖。'
- en: A SemVer version is primarily made up of three separate numbers, such as 1.2.3\.
    The first number is called the major version, the second number is the minor version,
    and the third number is the patch version. Additional information about pre-releases
    can be described by appending a hyphen and an additional string after the version
    string. However, production applications don’t usually use such pre-releases,
    so it won’t be covered here.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: SemVer 版本主要由三个单独的数字组成，例如 1.2.3。第一个数字称为主版本，第二个数字称为次版本，第三个数字称为补丁版本。可以通过在版本字符串后附加连字符和额外字符串来描述关于预发布的其他信息。但是，生产应用程序通常不使用此类预发布，因此这里不会涉及到。
- en: Each component of the overall version number has a special meaning. When a package
    makes a change that breaks backwards compatibility, the major version should be
    incremented. When a package adds a new feature but backwards compatibility is
    maintained, the minor version should be incremented. If a change only results
    in a bug fix and nothing else, then the patch version should be incremented. Whenever
    a version is incremented, the lower versions reset at zero. For example, if a
    major change is introduced to a package at version 1.2.3, it should become 2.0.0
    (not 2.2.3). If a release of a package introduces multiple changes, then the effects
    of the most significant change determine the new version number.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 整体版本号的每个组件都有特定的含义。当一个包进行了破坏性变更以使其向后兼容性被打破时，应该增加主版本号。当一个包添加新功能但保持向后兼容性时，应该增加次要版本号。如果一个变更只导致
    bug 修复而没有其他内容，那么应该增加补丁版本号。每当版本号增加时，较低的版本号都将重置为零。例如，如果在版本 1.2.3 中引入了一个重大变更，它应该变成
    2.0.0（而不是 2.2.3）。如果一个包的发布引入了多个变更，则最重要变更的影响决定了新的版本号。
- en: What does it mean to make a backwards-breaking change or add a new feature?
    Well, every package needs to not only provide functionality, but it also needs
    to document its functionality. This documented functionality is a contract made
    between the package author and anyone who chooses to use the package. Violations
    of this contract will result in pull requests, angry GitHub issues, and forks
    that outlive the original package. It’s the responsibility of every engineer who
    publishes a package to adhere to SemVer and to uphold their documented feature
    list.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是向后不兼容变更或添加新功能？嗯，每个包不仅需要提供功能，还需要记录其功能。这些记录的功能形成了包作者与选择使用包的任何人之间的契约。违反这一契约将导致拉取请求、愤怒的
    GitHub 问题和衍生的分支超过原始包。每个发布包的工程师都有责任遵循 SemVer，并维护其记录的功能列表。
- en: A special case for SemVer is when the most significant digits of a version number
    begin with zero. In these cases, the first nonzero digit is essentially considered
    the major version, the next digit is the minor, etc. What this means is that if
    a breaking change is introduced to a package at version 0.1.2, it becomes version
    0.2.0\. If a package has the version of 0.0.1, then any breaking changes can result
    in a version of 0.0.2.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: SemVer 的一个特殊情况是，当版本号的最高有效数字以零开头时。在这些情况下，第一个非零数字被认为是主版本，接下来的数字是次要版本，依此类推。这意味着，如果在版本
    0.1.2 中引入了一个重大变更，它将变成版本 0.2.0。如果一个包的版本是 0.0.1，那么任何重大变更都可能导致版本变成 0.0.2。
- en: A package author is free to arbitrarily increment any of the version numbers
    at any point in time. For example, if a package is on version 0.0.7 and a significant
    milestone is reached, the author may increment it to 0.1.0\. Generally, once an
    author has determined that a package is ready for production, the package will
    graduate to a version of 1.0.0.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 包作者可以在任何时候任意增加版本号中的任何数字。例如，如果一个包的版本是 0.0.7，并且达到了重要的里程碑，作者可以将其增加到 0.1.0。一般来说，一旦作者确定一个包已经准备好投入生产，该包将升级到版本
    1.0.0。
- en: The real power of SemVer is that an application making use of a package should
    be free to blindly accept all minor or patch updates of a package without any
    fears that their application might break. In practice, authors of npm packages
    aren’t always so disciplined, which is why any updates to an application’s dependencies
    will require that a test suite pass is run. In many cases, the application author
    may need to interact with the application to make sure it continues to work as
    intended.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: SemVer 的真正力量在于使用包的应用程序应该自由地接受所有次要或补丁更新，而无需担心其应用程序可能会崩溃。在实践中，npm 包的作者并不总是如此自律，这就是为什么对应用程序依赖项的任何更新都需要运行测试套件通过的原因。在许多情况下，应用程序作者可能需要与应用程序互动，以确保其按预期工作。
- en: 'Dependencies are specified for a Node.js project using the `dependencies` section
    of the *package.json* file. When running `npm install` or `yarn`, this list of
    dependencies is consulted when determining which packages to copy from the npm
    registry to the local filesystem. Package versions can be specified directly,
    or they can make use of a prefix. They can even make use of more complex syntax
    such as verbose version ranges and asterisks, but that won’t be covered here.
    The following is an example of some dependency strings:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js项目的依赖关系使用*package.json*文件中的`dependencies`部分进行指定。在运行`npm install`或`yarn`时，会根据这些依赖关系来确定从npm注册表复制哪些包到本地文件系统。可以直接指定包版本，也可以使用前缀。甚至可以使用更复杂的语法，如详细的版本范围和星号，但这里不会涉及到。以下是一些依赖字符串的示例：
- en: '[PRE42]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The first package loaded in this list, `fastify`, has a version prefix of `^`
    (caret). What this means is that any future version of the package that is compatible
    with the specified version will be installed. For example, at install time, if
    version 2.11.1 is the most recent, that will be used. Or if version 2.17.0 is
    the most recent, that will be used instead. If version 3.0.0 is available, it
    will not be used. The caret prefix is the default prefix given when running an
    `npm install` command. For this reason, it is vital that every package adheres
    with SemVer. Otherwise, many applications may break when sloppy updates are made
    to an npm package.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表中加载的第一个包`fastify`具有版本前缀`^`（脱字符）。这意味着任何与指定版本兼容的未来版本都将被安装。例如，在安装时，如果版本2.11.1是最新的，那么将使用该版本。或者如果版本2.17.0是最新的，则将使用该版本。如果有3.0.0版本可用，则不会使用。脱字符前缀是运行`npm
    install`命令时的默认前缀。因此，每个包都遵循语义化版本非常重要。否则，在npm包进行松散更新时，可能会导致许多应用程序出现故障。
- en: The next package, `ioredis`, will only accept package updates that contain bug
    fixes (patch updates). It may be upgraded to 4.14.2 but never to 4.15.1\. This
    is a more conservative way to install a package. The third package, `pg`, will
    only ever install the 7.17.1 version of the package. This is even more conservative.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个包`ioredis`只接受包含bug修复（补丁更新）的包更新。它可以升级到4.14.2版本，但永远不会升级到4.15.1版本。这是一种更保守的包安装方式。第三个包`pg`只会安装7.17.1版本的包。这甚至更加保守。
- en: 'Now it’s time for a thought experiment. Pretend that you’re the author of a
    package that exposes a single class. This package is only used by teams within
    your organization. This version of your package, 1.0.0, only contains three methods,
    each of which are documented. The package looks like this:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是思想实验的时候了。假设你是一个暴露单个类的包的作者。这个包只被你组织内的团队使用。这个包的当前版本是1.0.0，仅包含三个方法，每个方法都有文档说明。这个包看起来像这样：
- en: '[PRE43]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'At some point, you discover that some users pass a number into the `setName()`
    method, which later causes a bug with the `nameLength()` method. What version
    number would you pick if you were to modify the `setName()` method in the following
    manner:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，你发现一些用户在`setName()`方法中传递一个数字，后来导致`nameLength()`方法出现了一个bug。如果你要修改`setName()`方法的话，你会选择什么版本号？
- en: '[PRE44]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'At some point, you decide to add a method to check if the name has been set.
    You do this by adding an additional method named `hasName()`. What version number
    would you pick if you did this by adding the following method:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，你决定添加一个方法来检查是否已设置名称。你通过添加一个名为`hasName()`的额外方法来实现这一点。如果你通过添加以下方法来实现这一点，你会选择什么版本号？
- en: '[PRE45]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Finally, you realize that the `nameLength()` method might be a bit unnecessary.
    You ask all of the teams within your organization that rely on your package if
    they are using the method, and everybody tells you no. So you decide to remove
    the `nameLength()` method entirely. What version should you then choose for your
    package?
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你意识到`nameLength()`方法可能有点不必要。你询问组织内依赖于你的包的所有团队是否在使用这个方法，所有人都告诉你不是。因此，你决定彻底移除`nameLength()`方法。那么接下来你应该选择什么版本作为你的包的版本号？
- en: In the first example, the modification to the `setName()` method is considered
    a bug fix. This should result in a patch change, and a new version of 1.0.1\.
    In the second example, the addition of a `hasName()` method adds new functionality.
    The code is nearly 100% backwards compatible with the previous version. This means
    the change is a minor change and should have a version number of 1.1.0\. Finally,
    the third example removes functionality. Sure, you spoke with every team that
    makes use of your package and determined that nobody is using the functionality.
    But this fact only signals that it is okay to make the change; it does not mean
    that the change still isn’t a big deal. For this reason, the change is major and
    the package version should be 2.0.0.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，修改`setName()`方法被视为修复 bug。这应导致补丁更改，新版本为 1.0.1。在第二个示例中，添加`hasName()`方法添加了新功能。代码几乎完全向后兼容以前的版本。这意味着这个更改是一个小的更改，版本号应为
    1.1.0。最后，在第三个示例中，移除了功能。确实，您与每个使用您软件包的团队交流过，并确定没有人在使用此功能。但是这个事实只表明可以进行更改；这并不意味着更改不重要。因此，此更改是一个主要更改，软件包版本应为
    2.0.0。
- en: These examples illustrate the most basic of situations you’ll have to deal with
    when making version updates to your packages. In practice, you’ll often have to
    deal with much harder problems. For example, say that you export a class that
    is an instance of a Node.js `EventEmitter`. This class represents a bucket that
    can have water added to it and emits several events, including `ready`, `empty`,
    and `full`. In version 1.0.0 of your package, the `empty` event is emitted immediately
    *before* the `ready` event. But you do some refactoring and pondering and change
    the package to emit `empty` *after* the `ready` event. What SemVer version change
    would you expect this to result in? Is it just a bug fix? Is it a new feature?
    Is it backwards breaking?
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例展示了在更新软件包版本时可能遇到的最基本情况。在实际操作中，您可能会遇到更为复杂的问题。例如，假设您导出了一个类，它是一个 Node.js 的`EventEmitter`实例。这个类表示一个可以加水的桶，并且会触发多个事件，包括`ready`、`empty`和`full`。在您的软件包版本
    1.0.0 中，`empty`事件在`ready`事件之前被触发。但是在进行一些重构和思考后，您决定在`ready`事件之后触发`empty`事件。这种 SemVer
    版本更新会导致什么样的结果呢？这只是一个修复 bug 吗？还是一个新功能？它是向后不兼容的变更吗？
- en: In these situations, it’s often better to err on the side of a more significant
    version change. If you release this change as a patch change, it could cause production
    bugs and cause people to find their water buckets overflowing. However, if you
    release it as a major change, engineers will need to manually upgrade and should
    then consult your release notes. At this point, they can audit their application
    code to determine if any application code changes must accompany the dependency
    upgrade.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，通常更倾向于选择更显著的版本更改。如果您将此更改发布为补丁更改，可能会导致生产 bug，并且可能会导致水桶溢出。然而，如果您将其作为主要更改发布，工程师们将需要手动升级，并应查阅您的发布说明。此时，他们可以审核其应用程序代码，确定是否需要随依赖项升级而进行任何应用程序代码的更改。
- en: Packages can also have other packages as dependencies. These are often referred
    to as subdependencies. Sometimes, if a package upgrades a subdependency from one
    major version to another, it will require that the package itself receives an
    increment to its major version. This can happen if a subdependency updates its
    required Node.js version. For example, if package A @ 1.2.3 depends on B @ 5.0.0,
    and package B @ 6.0.0 drops support for Node.js v10, then package A would need
    to increment its version to 2.0.0\. Otherwise, if a change to a subdependency
    doesn’t have any public side effects, less severe SemVer version bumps can be
    made.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 软件包也可以将其他软件包作为依赖项。这些依赖项通常称为子依赖项。有时，如果一个软件包将子依赖项从一个主要版本升级到另一个主要版本，那么它将需要自身的主要版本号增加。如果子依赖项更新其所需的
    Node.js 版本，就可能发生这种情况。例如，如果软件包 A @ 1.2.3 依赖于 B @ 5.0.0，并且软件包 B @ 6.0.0 不再支持 Node.js
    v10，则软件包 A 需要将其版本增加到 2.0.0。否则，如果对子依赖项的更改没有任何公共副作用，则可以进行较小的 SemVer 版本增加。
- en: It may be tempting to assign SemVer versions to an application, but often this
    just doesn’t work out. For example, if you’re working on a web application and
    you change the background from red to pink, is this a minor change? Is it a patch
    change? Things like UX changes don’t easily translate to the SemVer paradigm.
    Deciding on API endpoint versions is a completely different beast where SemVer
    is also not applicable.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管将 SemVer 版本分配给应用程序可能很诱人，但通常情况下并不适用。例如，如果您正在开发一个 Web 应用程序，并将背景从红色更改为粉红色，这算是一个小变更吗？它是一个补丁变更吗？像
    UX 变更这样的事情并不容易在 SemVer 范式中进行转换。决定 API 端点版本是完全不同的事情，SemVer 在这里也不适用。
- en: Now that you’re a little more familiar with the nuances of SemVer, it’s time
    to look at npm package development.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您对 SemVer 的微妙之处稍有了解，是时候看看 npm 包开发了。
- en: npm Packages and the npm CLI
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: npm 包和 npm CLI
- en: An npm package is a collection of Node.js modules and other supporting files
    that have been combined into a single tarball file. This tarball file can be uploaded
    to a registry, such as the [public npm registry](https://npmjs.com), a private
    registry, or even distributed as a tarball for manual installation.^([5](ch06.html#idm46291182953960))
    In any case, the `npm` CLI can install these packages into the *node_modules/*
    directory of a particular project.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: npm 包是一组 Node.js 模块和其他支持文件，已合并为单个 tarball 文件。这个 tarball 文件可以上传到注册表，例如 [公共 npm
    注册表](https://npmjs.com)，私有注册表，甚至作为 tarball 进行手动安装。^([5](ch06.html#idm46291182953960))
    无论如何，`npm` CLI 可以将这些包安装到特定项目的 *node_modules/* 目录中。
- en: The Node.js runtime doesn’t technically know what an npm package is. In fact,
    the `dependencies` section of an application’s *package.json* file isn’t even
    consulted by the Node.js runtime. But Node.js does know how to require packages
    located within the *node_modules/* directory. It’s ultimately up to the npm CLI
    to perform the task of taking an application’s list of dependencies and converting
    that into a filesystem hierarchy.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 运行时技术上并不知道什么是 npm 包。事实上，应用程序的 *package.json* 文件中的 `dependencies` 部分甚至不会被
    Node.js 运行时查阅。但是 Node.js 确实知道如何要求位于 *node_modules/* 目录中的包。最终，npm CLI 负责将应用程序的依赖列表转换为文件系统层次结构。
- en: Node.js has a tiny standard library, much smaller than many other languages.
    There’s no official “kitchen sink” package to provide the basic functionality
    required by many applications. The Node.js motto is to keep as many features out
    of the core platform as possible, instead deferring to the community to build
    such functionality and publish it as npm packages. For example, there is no built-in
    mechanism for generating UUID values, but there are dozens of implementations
    available on npm. Node.js only provides the core functionality that these packages
    depend on, such as `crypto.randomBytes()`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 拥有一个非常小的标准库，比许多其他语言的标准库要小得多。没有官方的“万能包”来提供许多应用程序所需的基本功能。Node.js 的座右铭是尽可能地将多数功能留在核心平台之外，而是让社区来构建这样的功能并将其作为
    npm 包发布。例如，没有内置机制来生成 UUID 值，但是在 npm 上有数十种实现可用。Node.js 只提供这些包依赖的核心功能，如 `crypto.randomBytes()`。
- en: Because of the decision to keep core Node.js small, most security vulnerabilities
    for a given Node.js application will require an update to an npm package instead
    of an upgrade of the Node.js runtime. This usually results in quicker turn-around
    for security fixes. Another effect is that many JavaScript developers have published
    many packages. The npm registry is the world’s largest software package repository.
    A package exists for almost anything a developer needs, which has contributed
    to the popularity of Node.js.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 由于决定保持核心 Node.js 的精简，对于给定的 Node.js 应用程序，大多数安全漏洞需要更新 npm 包，而不是升级 Node.js 运行时。这通常会导致安全修复的快速反应。另一个效果是，许多
    JavaScript 开发人员发布了许多包。npm 注册表是世界上最大的软件包仓库。几乎为开发人员需要的任何东西都有一个包，这也促进了 Node.js 的流行。
- en: Controlling package content
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制包内容
- en: 'Now that you’re familiar with some of the theory behind npm packages, it’s
    time that you create one. Run the following commands to create a new directory
    for your package and to initialize a *package.json* file. When prompted, set the
    version to 0.1.0 but otherwise leave the default values:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您对 npm 包理论有了一些了解，是时候创建一个了。运行以下命令为您的包创建一个新目录，并初始化一个 *package.json* 文件。在提示时，将版本设置为
    0.1.0，但否则保留默认值：
- en: '[PRE46]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You now have a directory structure similar to many npm packages. *screenshot.bin*
    represents a file that should be uploaded to a version control repository (for
    example, to provide a screenshot in a GitHub repository’s *README.md* file), though
    it shouldn’t actually be made part of an npm package. *temp.bin* represents a
    side-effect file that shouldn’t be checked into version control or packaged at
    all. The remaining JavaScript files should be checked in and packaged.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了类似许多 npm 包的目录结构。*screenshot.bin* 代表一个应该上传到版本控制库的文件（例如，在 GitHub 仓库的 *README.md*
    文件中提供截图），但实际上不应该作为 npm 包的一部分。*temp.bin* 代表一个不应该被检入版本控制或打包的副作用文件。剩余的 JavaScript
    文件应该被检入和打包。
- en: Run the `**ls -la**` command to view all the files you now have on disk. [Table 6-3](#table_npm_package_file_listing)
    is a list of the files present on my machine.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `**ls -la**` 命令来查看当前磁盘上的所有文件。[Table 6-3](#table_npm_package_file_listing)
    是我机器上的文件列表。
- en: Table 6-3\. File listing output
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-3\. 文件列表输出
- en: '| Size | Filename | Size | Filename | Size | Filename |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| 大小 | 文件名 | 大小 | 文件名 | 大小 | 文件名 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 0 | bar.js | 0 | baz.js | 0 | foo.js |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| 0 | bar.js | 0 | baz.js | 0 | foo.js |'
- en: '| 0 | index.js | 4.0K | node_modules | 260 | package.json |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| 0 | index.js | 4.0K | node_modules | 260 | package.json |'
- en: '| 14K | package-lock.json | 0 | README.md | 1.0M | screenshot.bin |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| 14K | package-lock.json | 0 | README.md | 1.0M | screenshot.bin |'
- en: This doesn’t exactly represent the ideal package contents. The only files that
    are technically needed are the JavaScript files and the *package.json* file. It’s
    customary to ship the *README.md* document as well so that any engineer digging
    through their *node_modules/* directory to fix a bug will have some insight into
    what the package is for.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不完全代表理想的包内容。从技术上讲，唯一需要的文件是 JavaScript 文件和 *package.json* 文件。通常也会包含 *README.md*
    文档，以便任何工程师在浏览 *node_modules/* 目录以修复错误时能够了解包的用途。
- en: The npm CLI tool does come with some sane defaults for ignoring certain files
    that should never be included in an npm package. For example, the *package-lock.json*
    file is only useful for an application and is entirely meaningless when included
    in individual packages. The *node_modules/* directory also shouldn’t be included
    in the package. Instead, the npm CLI will examine all nested dependencies and
    figure out the best filesystem layout.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: npm CLI 工具确实带有一些合理的默认设置，用于忽略某些不应包含在 npm 包中的文件。例如，*package-lock.json* 文件仅对应用程序有用，在单独的包中完全没有意义。*node_modules/*
    目录也不应该包含在包中。相反，npm CLI 将检查所有嵌套依赖项并确定最佳的文件系统布局。
- en: It’s possible to see what the contents of an npm package tarball will look like
    without actually having to generate and upload the package to the npm registry.
    Run the `**npm publish --dry-run**` command to simulate the generation of this
    package.^([6](ch06.html#idm46291182870872)) This command displays the file contents
    of the package and the sizes of the files. [Table 6-4](#table_npm_package_dry_run)
    is the listing that I get on my machine.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 可以查看 npm 包 tarball 的内容，而不必实际生成和上传到 npm 注册表。运行 `**npm publish --dry-run**` 命令来模拟生成此包。^([6](ch06.html#idm46291182870872))
    此命令显示包的文件内容和文件的大小。[Table 6-4](#table_npm_package_dry_run) 是我机器上得到的清单。
- en: Table 6-4\. npm package file listing
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-4\. npm 包文件列表
- en: '| Size | Filename | Size | Filename | Size | Filename |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| 大小 | 文件名 | 大小 | 文件名 | 大小 | 文件名 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 1.0MB | screenshot.bin | 1.0MB | temp.bin | 0 | bar.js |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| 1.0MB | screenshot.bin | 1.0MB | temp.bin | 0 | bar.js |'
- en: '| 0 | baz.js | 0 | foo.js | 0 | index.js |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| 0 | baz.js | 0 | foo.js | 0 | index.js |'
- en: '| 0 | test/index.js | 260B | package.json | 0 | README.md |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| 0 | test/index.js | 260B | package.json | 0 | README.md |'
- en: The default behavior of npm is convenient, but it isn’t completely aware of
    the requirements of this particular package. For example, it has no idea that
    *temp.bin* isn’t required for the package to work. For the remaining unwanted
    files you’ll have to manually create rules to ignore them. The npm CLI honors
    the entries contained in a *.gitignore* file, which you need to edit anyway since
    some files shouldn’t be checked in.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: npm 的默认行为很方便，但并不完全符合此特定包的要求。例如，它不知道 *temp.bin* 对于包的工作并不是必需的。对于其余不需要的文件，您需要手动创建忽略规则。npm
    CLI 遵循 *.gitignore* 文件中包含的条目，您无论如何都需要编辑该文件，因为某些文件不应该被检入。
- en: Create a file named *.gitignore* and add the entries in [Example 6-11](#ex_npm_package_gitignore)
    to the file to prevent the unwanted files from getting added to version control.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为*.gitignore*的文件，并将[示例 6-11](#ex_npm_package_gitignore)中的条目添加到文件中，以防止不需要的文件被添加到版本控制中。
- en: Example 6-11\. *leftish-padder/.gitignore*
  id: totrans-344
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-11\. *leftish-padder/.gitignore*
- en: '[PRE47]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The *node_modules/* directory should never be checked into version control.
    This is universal across all Node.js projects—whether package or application.
    The *temp.bin* file is specific to this package and shouldn’t be included. The
    *package-lock.json* file is a special situation. If you’re building an application,
    this file shouldn’t be ignored; it’s actually pretty important. But with an npm
    package, the contents are ignored at install time, so it’s presence will only
    end up confusing contributors.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '*node_modules/*目录不应该被提交到版本控制中。这适用于所有Node.js项目——无论是包还是应用程序。*temp.bin*文件是这个软件包特有的，不应包含在内。*package-lock.json*文件是一个特殊情况。如果您正在构建一个应用程序，则不应忽略此文件；它实际上非常重要。但是对于npm软件包，在安装时将其内容忽略，因此其存在只会让贡献者感到困惑。'
- en: At this point, you’re free to see what the new package contents will look like.
    Run the `**npm publish --dry-run**` command again to see the new package contents.
    The listing should look the same except that the *temp.bin* file is now missing.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以查看新软件包内容的样子了。再次运行`**npm publish --dry-run**`命令以查看新软件包内容。列表应该看起来一样，只是*temp.bin*文件现在不见了。
- en: Finally, create a new file called *.npmignore*. This file contains entries that
    should be omitted in the resulting npm package. Entries that are already ignored
    by npm, such as the *node_modules/* directory, customarily aren’t added because
    they would be redundant. If you only have a *.gitignore* file, it is honored by
    npm, but once you create a *.npmignore* file, npm will no longer consider *.gitignore*.
    For this reason, you need to repeat entries from *.gitignore* that npm doesn’t
    ignore by default. Add the content from [Example 6-12](#ex_npm_package_npmignore)
    to your new *.npmignore* file.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，创建一个名为*.npmignore*的新文件。该文件包含应在生成的npm软件包中省略的条目。像*node_modules/*目录这样已被npm忽略的条目通常不会被添加，因为它们会显得多余。如果您只有一个*.gitignore*文件，npm将尊重它，但一旦您创建了一个*.npmignore*文件，npm将不再考虑*.gitignore*。因此，您需要重复来自*.gitignore*的npm不会默认忽略的条目。将[示例 6-12](#ex_npm_package_npmignore)中的内容添加到您的新*.npmignore*文件中。
- en: Example 6-12\. *leftish-padder/.npmignore*
  id: totrans-349
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-12\. *leftish-padder/.npmignore*
- en: '[PRE48]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now that you’ve made the final changes, run the `**npm publish --dry-run**`
    command one more time. [Table 6-5](#table_npm_package_dry_run_2) contains the
    list of files I get on my machine.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经做出最终更改，请再次运行`**npm publish --dry-run**`命令。[表 6-5](#table_npm_package_dry_run_2)列出了我在我的计算机上得到的文件列表。
- en: Table 6-5\. npm package file listing with *.gitignore* and *.npmignore* files
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-5\. 带有*.gitignore*和*.npmignore*文件的npm软件包文件列表
- en: '| Size | Filename | Size | Filename | Size | Filename |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| 大小 | 文件名 | 大小 | 文件名 | 大小 | 文件名 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 0 | bar.js | 0 | baz.js | 0 | foo.js |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| 0 | bar.js | 0 | baz.js | 0 | foo.js |'
- en: '| 0 | index.js | 260B | package.json | 0 | README.md |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| 0 | index.js | 260B | package.json | 0 | README.md |'
- en: And there you go! You’ve now fine-tuned the contents of an npm package.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，您已经对npm软件包的内容进行了精细调整。
- en: Tip
  id: totrans-358
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you were to log in to an *npmjs.com* account using the npm CLI and run the
    `npm publish` command, then you would create a new public package named `leftish-padder`
    (assuming another reader didn’t beat you to it). Often the code you’re working
    on represents something that you don’t want to get published. For example, if
    you’re working on a closed source package, or even a Node.js application, then
    running `npm publish` could copy proprietary code to a public location. One thing
    you can do to prevent this is to add a top-level entry to *package.json* containing
    `"private": true`. With this in place, the publish command should fail.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '如果您使用npm CLI登录到*npmjs.com*帐户并运行`npm publish`命令，那么您将创建一个名为`leftish-padder`的新公共软件包（假设没有其他读者比您更快）。通常，您正在处理的代码代表了您不希望发布的内容。例如，如果您正在处理一个闭源软件包，甚至是一个Node.js应用程序，那么运行`npm
    publish`可能会将专有代码复制到公共位置。为了防止这种情况发生，您可以向*package.json*添加一个顶级条目，内容为`"private": true`。有了这个设置，发布命令应该会失败。'
- en: When you publish a package, the versions that are published are essentially
    immutable. The npm registry won’t let you change them. There is a grace period
    of 72 hours during which you can unpublish a package. This is in case you find
    yourself publishing something that shouldn’t have been published, such as private
    credentials. That said, there are plenty of services that constantly crawl the
    npm registry, so any published credentials should be considered compromised no
    matter how fast you unpublish.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 当你发布一个包时，发布的版本基本上是不可变的。npm注册表不允许更改它们。在这之后有一个72小时的宽限期，期间你可以撤销一个包的发布。这是为了防止你发布了不应该发布的内容，比如私密凭证。尽管如此，有许多服务不断地抓取npm注册表，所以任何已发布的凭证都应该被视为已泄露，无论你撤销得有多快。
- en: If you ever publish a “broken” package, like a patch release that introduces
    a breaking change, the recommended way to fix this with SemVer is to immediately
    release a new version of the package that reverts the breaking change and release
    it as another patch release. As an example, if version 1.2.3 of a package is working
    fine and version 1.2.4 introduces the break, republish the code from 1.2.3 (or
    otherwise fix the breaking change) and publish it as 1.2.5\. If you catch the
    problem early enough, you might be able to unpublish 1.2.4.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发布了一个“破坏性”的包，比如一个引入破坏性变更的补丁版本，按照语义化版本控制（SemVer）的推荐方法，应立即发布一个新版本的包，回滚这个破坏性变更，并将其发布为另一个补丁版本。例如，如果版本1.2.3的包正常运行，而版本1.2.4引入了问题，应重新发布1.2.3的代码（或修复破坏性变更），并将其发布为1.2.5。如果问题及时发现，可能可以撤销1.2.4的发布。
- en: The reason that npm doesn’t allow just any package version to be unpublished
    is that doing so can cause breaking changes to other people’s applications. The
    *left-pad* package was [famously unpublished](https://oreil.ly/xJGYx), leading
    to broken application builds across the internet. The 72 hour limit theoretically
    minimizes the damage from an unpublish since the number of *package.json* files
    in the wild referring to the unpublished version should be small.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: npm不允许随意撤销任何包版本的原因是，这样做可能会导致其他人的应用出现破坏性变更。*left-pad* 包因此 [被著名地撤销](https://oreil.ly/xJGYx)，导致互联网上的应用构建失败。理论上，72小时的限制可以最小化从一个撤销中产生的损害，因为引用未发布版本的
    *package.json* 文件数量应该很少。
- en: Dependency hierarchy and deduplication
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 依赖层次结构和去重
- en: A Node.js application will almost always depend on npm packages. Those packages
    will in turn depend on other packages. This leads to a tree structure of dependencies.
    Recall that when the `require()` function determines that the argument resembles
    a package, it will look inside the *node_modules/* directory within the same directory
    as the file calling `require()` and then in each parent directory. This means
    that a naive implementation of an `npm install` algorithm could simply place a
    copy of every package’s subdependencies into a *node_modules/* directory specific
    to that package and be done.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js应用几乎总是依赖于npm包。这些包又会依赖于其他包。这导致了一个依赖树的结构。记住，当 `require()` 函数确定参数像一个包时，它会在调用
    `require()` 的文件所在目录下的 *node_modules/* 目录中查找，然后在每个父目录中查找。这意味着一个简单的 `npm install`
    算法可能会简单地将每个包的子依赖项的副本放置到该包特定的 *node_modules/* 目录中。
- en: 'As an example of this, consider a fictional situation in which an application’s
    *package.json* file depends on two packages, `foo@1.0.0` and `bar@2.0.0`. The
    `foo` package has no dependencies, but the `bar` package also depends on `foo@1.0.0`.
    In this situation, the naive dependency hierarchy looks like this:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，考虑一个虚构的情况，一个应用的 *package.json* 文件依赖于两个包，`foo@1.0.0` 和 `bar@2.0.0`。`foo`
    包没有依赖，但 `bar` 包依赖于 `foo@1.0.0`。在这种情况下，简单的依赖层次结构看起来是这样的：
- en: '[PRE49]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: There are two issues with this approach. The first is that sometimes packages
    can end up with cyclical dependencies. This would then result in an infinitely
    deep *node_modules/* directory. The second issue is that many dependency trees
    will end up with duplicate packages, increasing disk space requirements.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法存在两个问题。第一个问题是，有时包可能会出现循环依赖，导致一个无限深的 *node_modules/* 目录。第二个问题是，许多依赖树最终会出现重复的包，增加磁盘空间需求。
- en: 'To overcome those issues, the npm CLI will attempt to “dedupe” or “hoist” sub-dependencies
    higher up in the *node_modules/* directory. When that happens, a call to `require()`
    in a deeply nested package will ascend the filesystem until it finds the package.
    Following with the previous example, the *node_modules/* directory could instead
    look like this:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这些问题，npm CLI 将尝试在*node_modules/*目录中“合并”或“提升”子依赖项。当这种情况发生时，深度嵌套包中的`require()`调用会向上升级文件系统，直到找到该包。继续上一个示例，*node_modules/*目录可能看起来像这样：
- en: '[PRE50]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: When the `bar` package goes looking for the `foo` package, it will fail to find
    a *node_modules/* directory in its own package but will find it one level higher.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 当`bar`包寻找`foo`包时，它将无法在自己的包中找到*node_modules/*目录，但会在高一级找到它。
- en: 'The algorithm employed by the npm CLI to determine the dependency tree layout
    ends up being rather complex. For example, consider that each package will specify
    in some way or another the version range of the packages it depends on. npm can
    then choose a common version to satisfy multiple version ranges. Also, consider
    that only a single version of a package can exist in a *node_modules/* directory
    at a time, since the directory is named after the package. If the `bar@2.0.0`
    package actually depended on `foo@2.0.0`, then the `foo` package could not have
    been deduped to the root *node_modules/* directory. In that case, the dependency
    tree would look more like this:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: npm CLI 用于确定依赖树布局的算法最终变得相当复杂。例如，考虑每个包都以某种方式指定其依赖包的版本范围。npm 然后可以选择一个通用版本来满足多个版本范围的需求。还要考虑到一次只能在*node_modules/*目录中存在一个包的单个版本，因为该目录是以包命名的。如果`bar@2.0.0`包实际上依赖于`foo@2.0.0`，那么`foo`包就不能被合并到根*node_modules/*目录中。在这种情况下，依赖树将看起来更像这样：
- en: '[PRE51]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Over time, new packages are constantly being published to the npm registry.
    This means that newer versions of packages will be added that satisfy the version
    requirements of your application. This means that there is no guarantee that the
    dependency tree of an application will remain the same between subsequent `npm
    install` runs. Even though you can specify exact package versions in an application’s
    *package.json* file, subdependencies of those dependencies most likely aren’t
    using exact versions, leading to the seemingly nondeterministic dependency tree.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，新的包不断发布到npm注册表中。这意味着将添加满足应用程序版本要求的新版本包。这也意味着不能保证应用程序的依赖树在后续的`npm install`运行之间保持不变。即使您可以在应用程序的*package.json*文件中指定精确的包版本，这些依赖项的子依赖项大多数情况下不使用精确版本，导致看似非确定性的依赖树。
- en: Sometimes, small bugs or behavioral changes can make their way into an application
    when the dependency tree changes. The *package-lock.json* file (and its forgotten
    sibling *npm-shrinkwrap.json*) was created to lock in an entire representation
    of the dependency tree. As new package versions come and go, the dependency tree
    will stay the same with each subsequent `npm install` run. Then, when you’re ready
    to update or add a new a package, you can do so using the appropriate `npm install
    <package>` command. This will result in a change to both *package.json* and *package-lock.json*,
    which can be checked in as a single version control commit.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当依赖树发生变化时，小的错误或行为变化可能会进入应用程序。*package-lock.json*文件（及其被遗忘的姐妹*npm-shrinkwrap.json*）的创建是为了锁定整个依赖树的表示。随着新的包版本的出现，每次后续运行`npm
    install`时，依赖树都将保持不变。然后，当您准备更新或添加新的包时，可以使用适当的`npm install <package>`命令进行。这将导致*package.json*和*package-lock.json*的更改，可以作为单个版本控制提交进行检查。
- en: 'To view a more complex example of this package “deduplication” process, switch
    back to the terminal where you made the `leftish-padder` package. Recall that
    you previously installed `express@4.17.1`. Now run the command **`ls node_modules`**.
    This will give you a list of all the packages that have been hoisted to the top
    level *node_modules/* directory. Even though you only installed the `express`
    package, you should actually see dozens of packages listed. On my machine I see
    a list of 49 packages, and here are the first dozen of them, though you may see
    different results:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这种包“合并”过程的更复杂示例，请切换回您创建`leftish-padder`包的终端。回想一下，您之前安装了`express@4.17.1`。现在运行命令**`ls
    node_modules`**。这将给您列出所有已提升到顶层*node_modules/*目录的包的列表。即使您只安装了`express`包，您实际上应该看到几十个包被列出。在我的机器上，我看到了一个包含
    49 个包的列表，以下是其中的前十二个，尽管您可能会看到不同的结果：
- en: '[PRE52]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This gives the “physical” layout of packages on disk. To view the “logical”
    layout of the dependency tree, run the command **`npm ls`**. This will list the
    dependency tree. Here is a truncated version of the output that I see on my machine:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了包在磁盘上的“物理”布局。要查看依赖树的“逻辑”布局，请运行 **`npm ls`** 命令。这将列出依赖树。以下是我在我的机器上看到的输出的截断版本：
- en: '[PRE53]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In this case, the only top-level dependency is `express@4.17.1`, which makes
    sense because it’s the only package defined in the root *package.json* file. The
    `express` package depends on many packages, including `body-parser`, and `body-parser`
    depends on many packages, including `content-type`. Notice that this last package
    has the string “deduped” next to it. This means that the npm CLI has hoisted the
    package up higher in the dependency tree. The final line shows that the `content-type`
    package is a direct child of `express`.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，唯一的顶级依赖项是 `express@4.17.1`，这是有道理的，因为它是根 *package.json* 文件中唯一定义的包。`express`
    包依赖于许多包，包括 `body-parser`，而 `body-parser` 又依赖于许多包，包括 `content-type`。注意，最后一个包旁边有字符串“deduped”。这意味着
    npm CLI 已将该包提升到依赖树中更高的位置。最后一行显示 `content-type` 包是 `express` 的直接子级。
- en: Be sure to never `require()` a package that isn’t listed as a direct dependency
    of your project. If any module within the `leftish-padder` package were to attempt
    to use a hoisted package, like `require('content-type')`, the require would technically
    work. However, there’s no guarantee that the call will work in the future once
    the dependency tree shifts again.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要确保不要 `require()` 一个未列为项目直接依赖的包。如果 `leftish-padder` 包中的任何模块尝试使用像 `require('content-type')`
    这样的提升包，该 require 在技术上会起作用。然而，不能保证一旦依赖树再次移动，该调用将会正常工作。
- en: Tip
  id: totrans-381
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Be careful when creating *singleton* instances within an npm package. Consider
    a package that creates a singleton database connection when it is first instantiated.
    Depending on how this package has been deduped, it may result in multiple database
    connections being created in one application. Also, be wary of the `instanceof`
    operator when classes are defined within a package. An instance of `foo@1.0.0#MyClass`
    will not pass an `instanceof` check with an instance of `foo@1.0.1#MyClass`.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在 npm 包内创建 *singleton* 实例时要小心。考虑一个在首次实例化时创建单例数据库连接的包。取决于这个包如何被去重，可能会导致一个应用程序中创建多个数据库连接。此外，当在包内定义类时，要注意
    `instanceof` 运算符。`foo@1.0.0#MyClass` 的实例将不能通过与 `foo@1.0.1#MyClass` 的实例的 `instanceof`
    检查。
- en: Internal npm Registry
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内部 npm 注册表
- en: 'The public npmjs.com registry is the go-to source for npm packages. By default,
    the npm CLI utility is configured to download packages from, and publish packages
    to, this registry. That said, many organizations will find that they may need
    to run an internal npm registry. Just like any popular SaaS tool, there will always
    be reasons to host an internal version instead of relying on a public version.
    Here are some of the reasons why an organization may choose to run an internal
    npm registry:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 公共 npmjs.com 注册表是 npm 包的首选来源。默认情况下，npm CLI 实用程序配置为从该注册表下载包，并将包发布到该注册表。尽管如此，许多组织可能会发现他们需要运行一个内部
    npm 注册表。就像任何流行的 SaaS 工具一样，总会有理由运行内部版本而不是依赖公共版本。以下是一个组织选择运行内部 npm 注册表的一些原因：
- en: The npmjs.com registry, like any SaaS tool, will occasionally suffer from an
    outage. This may prevent applications from building and deploying.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像任何 SaaS 工具一样，npmjs.com 注册表偶尔会遇到故障。这可能会阻止应用程序的构建和部署。
- en: An organization may want to host private packages but not want to pay the *npmjs.com*
    fees.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个组织可能希望托管私有包，但又不想支付 *npmjs.com* 的费用。
- en: An organization may want statistics on which packages are being installed by
    its disparate projects.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个组织可能希望了解其各个项目正在安装哪些包的统计数据。
- en: An organization may want to blocklist packages with known vulnerabilities.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个组织可能希望阻止已知存在漏洞的包。
- en: An organization may consume too much bandwidth and either get throttled or blocklisted
    by npm.^([7](ch06.html#idm46291182711784))
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个组织可能会消耗太多带宽，要么会被限速，要么会被 npm 封锁。（参见 [7](ch06.html#idm46291182711784)）
- en: There are many different tools available for hosting an internal npm registry.
    A registry, much like many of the other tools you’ve used in this book, is a service
    that runs somewhere, listening on a port, and is probably associated with a hostname.
    The npm CLI can be configured to interact with this private registry. These registries
    usually come with a proxy feature. Instead of just hosting an organization’s private
    packages, some can download and cache packages available on the public registry.
    This way, an application with both public and private packages is able to get
    every package it needs by only communicating with the internal registry.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的工具可用于托管内部 npm 注册表。像本书中使用过的许多其他工具一样，注册表是一个在某处运行的服务，监听一个端口，并且可能与主机名相关联。npm
    CLI 可以配置为与这个私有注册表交互。这些注册表通常配有代理功能。某些注册表不仅仅托管组织的私有包，还可以下载和缓存公共注册表中可用的包。这样，具有公共和私有包的应用程序可以通过与内部注册表通信来获取所需的每个包。
- en: Running Verdaccio
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行 Verdaccio
- en: In this section, you’ll work with the [Verdaccio](https://verdaccio.org) service.
    It’s an open source npm registry written in Node.js. It can be run by installing
    a global package obtained from npm, though you’ll work with it inside of a Docker
    container.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将使用 [Verdaccio](https://verdaccio.org) 服务。它是一个用 Node.js 编写的开源 npm 注册表。可以通过安装从
    npm 获得的全局包来运行它，尽管您将在 Docker 容器内部使用它。
- en: 'Run the following command to get a copy of the Verdaccio npm registry running
    locally:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以在本地运行 Verdaccio npm 注册表的副本：
- en: '[PRE54]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Once you’ve executed that command, wait for the Docker image layers to be downloaded
    and for the image to run. Then, once your terminal settles down, open the following
    URL in your web browser to view the Verdaccio web interface:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 执行该命令后，请等待 Docker 镜像层下载并运行该镜像。然后，一旦您的终端稳定下来，打开以下 URL 在您的 Web 浏览器中查看 Verdaccio
    网页界面：
- en: '[PRE55]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: At this point, there shouldn’t be any packages listed since you haven’t used
    it yet.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，不应列出任何软件包，因为您尚未使用它。
- en: Configuring npm to Use Verdaccio
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 npm 使用 Verdaccio
- en: 'The menu in the upper-right corner of the Verdaccio web interface has a button
    labeled *LOGIN*. But in order to use it, you’ll first need to create an account.
    Switch back to a terminal and run the following commands:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: Verdaccio 网页界面右上角的菜单有一个标有 *LOGIN* 的按钮。但是，为了使用它，您首先需要创建一个帐户。切换回终端，并运行以下命令：
- en: '[PRE56]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The first command configures the npm CLI to make use of your local Verdaccio
    registry when using future commands. The second command creates a new user with
    the registry. In the second command, the `--registry` flag isn’t needed, but it
    shows how individual npm commands can be overridden to use a specific registry
    URL.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令配置 npm CLI 在将来的命令中使用您的本地 Verdaccio 注册表。第二个命令使用注册表创建了一个新用户。在第二个命令中，不需要 `--registry`
    标志，但它显示了如何覆盖单个 npm 命令以使用特定的注册表 URL。
- en: When prompted, enter a username that you normally use, a password, and your
    email address. Once that’s done, and you’ve authenticated with the npm CLI, switch
    back to the Verdaccio web page and proceed to log in to the interface.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在提示时，输入您通常使用的用户名、密码和电子邮件地址。完成后，并且您已通过 npm CLI 进行了身份验证，请切换回 Verdaccio 网页并继续登录到界面。
- en: The web interface still isn’t that interesting. For that to happen, you need
    to first publish a package. That `leftish-padder` package that you’ve been working
    on is a decent candidate.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 网页界面仍然不是那么有趣。为了实现这一点，您首先需要发布一个包。您一直在工作的 `leftish-padder` 包是一个合适的候选者。
- en: Publishing to Verdaccio
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布到 Verdaccio
- en: 'Switch back to a terminal, and navigate to the directory where you created
    the sample package used in previous sections. Once you’re in that directory, run
    the following `npm publish` command to publish your package to your private npm
    registry:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 切换回终端，并导航到您在前几节中创建示例包的目录。一旦进入该目录，请运行以下 `npm publish` 命令将您的包发布到您的私有 npm 注册表：
- en: '[PRE57]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Similar output should appear from when you previously ran the `publish` command
    with the `--dry-run` flag.^([8](ch06.html#idm46291182617336)) This time, you should
    see the following message printed after the package summary, conveying a successful
    publish:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 与您之前使用 `--dry-run` 标志运行 `publish` 命令时应出现类似的输出。这次，在包摘要后，您应该看到以下消息打印出来，表示成功发布：
- en: '[PRE58]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Now that you’ve published your first package, switch back to the Verdaccio web
    interface and refresh the page. You should now see a listing of packages, and
    in this case, you should only see your `leftish-padder` package installed. From
    this screen, click the *leftish-padder* entry in the listing to be taken to the
    [package details](http://localhost:4873/-/web/detail/leftish-padder) screen.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经发布了你的第一个包，切换回 Verdaccio 的网页界面并刷新页面。你现在应该能看到一个包列表，而在这种情况下，你应该只能看到你安装的 `leftish-padder`
    包。从这个界面，点击列表中的 *leftish-padder* 条目，以进入 [package details](http://localhost:4873/-/web/detail/leftish-padder)
    页面。
- en: 'This screen has four tabs on it. The first tab is titled README and contains
    content from the *README.md* document (though in this case it’s empty, so the
    screen just displays the message “ERROR: No README data found!”). The next tab
    is titled DEPENDENCIES. Click it to see a list of dependencies for the most recent
    version of the package. In this case, you should only see one entry for `express@^4.17.1`.
    Click the third tab, titled VERSIONS, to be taken to a list of versions for this
    package. On this screen, you should see two entries. The first is named *latest*
    and is a pointer to the most recent version. The second is *0.1.0*, which is the
    only version that you’ve published so far.'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '这个页面有四个选项卡。第一个选项卡标题为 README，并包含来自 *README.md* 文档的内容（尽管在这种情况下是空的，所以页面显示“ERROR:
    No README data found!”）。下一个选项卡标题为 DEPENDENCIES。点击它可以查看最新版本包的依赖列表。在这种情况下，你应该只能看到一个条目：`express@^4.17.1`。点击第三个选项卡标题为
    VERSIONS，以查看这个包的版本列表。在这个页面上，你应该能看到两个条目。第一个是 *latest*，指向最新版本。第二个是 *0.1.0*，这是你目前为止唯一发布的版本。'
- en: Unfortunately, there’s a bug with the current version of the package. The *index.js*
    file is empty, and the package does nothing! Switch back to the terminal and edit
    the *index.js* file for your `leftish-padder` package. Add the content from [Example 6-13](#ex_package_content)
    to this file.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，当前版本的包存在一个 bug。*index.js* 文件是空的，这个包什么也做不了！切换回终端并编辑你的 `leftish-padder` 包的
    *index.js* 文件。将 [Example 6-13](#ex_package_content) 中的内容添加到这个文件中。
- en: Example 6-13\. *leftish-padder/index.js*
  id: totrans-412
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-13\. *leftish-padder/index.js*
- en: '[PRE59]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now that you’ve fixed the bugs with the package, you’re ready to publish a
    new version. The first thing you’ll need to do is increment the version of the
    package. Since you’re dealing with a bug fix, only the patch version needs to
    change. Run the following commands to increment the version number and perform
    a publish:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经修复了包的 bug，准备发布一个新版本。你需要做的第一件事就是增加包的版本号。由于你正在处理一个 bug 修复，只需要更改修订版本。运行以下命令来增加版本号并执行发布操作：
- en: '[PRE60]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Now open the Verdaccio web page again and refresh the VERSIONS tab once more.
    You should now see a new entry for version 0.1.1 of your package.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次打开 Verdaccio 网页并刷新 **VERSIONS** 选项卡。你应该能看到你的包的新版本 0.1.1 的新条目。
- en: So far, Verdaccio has been functioning as a tool where you can upload private
    packages. Unfortunately, the name *leftish-padder* might be a bit too generic.
    As of this writing, no package exists with this name, but one might in the near
    future. If that were to happen, the npm CLI would get confused. If you perform
    an installation, what happens if a package name collision occurs? Should you get
    the private or public package?
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，Verdaccio 一直作为一个上传私有包的工具在运行。不幸的是，*leftish-padder* 这个名字可能有点太普通了。截至目前为止，还没有这个名字的包存在，但未来可能会有。如果真的发生了这种情况，npm
    CLI 就会混淆。如果你进行安装，如果出现包名冲突会发生什么？你应该获取私有包还是公共包？
- en: In order to avoid this issue, you could provide a long string at the beginning
    of a package name, like `widget-co-internal-*`. But this would be annoying to
    type, and theoretically someone else could still choose the same package name.
    Instead, you should namespace your packages using something called a *scope*.
    Scopes are the official npm mechanism for namespacing packages. Scope names can
    also be registered so that nobody else can come along and use the same scope.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这个问题，你可以在包名的开头提供一个长字符串，比如 `widget-co-internal-*`。但这样输入会很麻烦，而且理论上其他人仍然可以选择相同的包名。相反，你应该使用一个叫做
    *scope* 的东西来给你的包添加命名空间。Scope 是官方的 npm 机制，用于给包添加命名空间。Scope 名称也可以注册，这样其他人就不能使用相同的作用域了。
- en: 'Open up the *package.json* file for your package and edit the *name* field.
    In this case, you can use a username to scope your package. My username is *tlhunter*,
    so my package name entry looks like this:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的包的 *package.json* 文件，并编辑 *name* 字段。在这种情况下，你可以使用一个用户名来为你的包添加作用域。我的用户名是 *tlhunter*，所以我的包名条目看起来像这样：
- en: '[PRE61]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Run the `publish` command that you’ve been using one more time. Once the publish
    is complete, switch back to your web browser and visit the [homepage](http://localhost:4873)
    for your Verdaccio installation again and refresh the page. You should now see
    an additional entry for the scoped package.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 运行你之前一直在使用的`publish`命令再次。发布完成后，切换回你的网络浏览器，访问你的Verdaccio安装的[主页](http://localhost:4873)，然后刷新页面。现在你应该能看到一个作用域包的额外条目。
- en: By using a scope with the same name as your npm organization, you can be sure
    that nobody else will publish a package with a competing name to the public npm
    repository. Organizations can then publish public packages to the public registry
    using their organization scope and publish private packages to their internal
    registry using the same scope.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用与你的npm组织相同名称的作用域，你可以确保没有其他人会在公共npm仓库中发布一个竞争名称的包。然后组织可以使用他们的组织作用域发布公共包到公共注册表，同时使用相同的作用域将私有包发布到他们的内部注册表。
- en: 'Finally, it’s time to confirm that you’re able to install the private package
    that you published. This can be done by creating a sample project, installing
    the scoped package, and creating a JavaScript file to require and run the package.
    Run the following commands to do just that, replacing `<SCOPE>` with the scope
    you chose:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，确认你能够安装你发布的私有包。这可以通过创建一个示例项目，安装作用域包，创建一个JavaScript文件来需要和运行这个包来完成。运行以下命令来执行这些操作，替换`<SCOPE>`为你选择的作用域：
- en: '[PRE62]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: You should see the string *0010* printed in your console.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在控制台中看到打印出的字符串*0010*。
- en: There you have it! You’re now the proud new owner of a private npm registry.
    Before using this in production, you’ll need to read the Verdaccio Docker documentation
    to configure it to persist changes to disk, give it a permanent hostname, and
    enable security features like TLS.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！你现在是一个私有npm注册表的骄傲所有者。在将其用于生产之前，你需要阅读Verdaccio Docker文档，配置其将更改持久化到磁盘，给它一个永久的主机名，并启用诸如TLS等安全功能。
- en: 'Once you’re done experimenting with Verdaccio, you probably no longer want
    to use it as the registry for your npm CLI. Run the following command to set things
    back to normal:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成对Verdaccio的实验后，你可能不再想将其用作npm CLI的注册表。运行以下命令将一切恢复正常：
- en: '[PRE63]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Your npm CLI is now configured to use the public *npmjs.com* repository again.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的npm CLI已经配置回使用公共*npmjs.com*注册表了。
- en: ^([1](ch06.html#idm46291185298648-marker)) Python, and most other languages,
    can be executed by a separate web server on a request/response basis (perhaps
    with Django), or persistently run itself in memory (à la Twisted).
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch06.html#idm46291185298648-marker)) Python和大多数其他语言可以通过一个单独的Web服务器在请求/响应的基础上执行（也许是Django），或者在内存中持久运行（如Twisted）。
- en: ^([2](ch06.html#idm46291185269544-marker)) In theory, you could run `nodemon`
    on a production server and then just overwrite files with newer versions. But
    you should never do such a thing.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch06.html#idm46291185269544-marker)) 理论上，你可以在生产服务器上运行`nodemon`，然后只需覆盖文件以使用更新版本。但是你绝不应该这样做。
- en: ^([3](ch06.html#idm46291184452856-marker)) “Flaky” is a super-scientific engineering
    term meaning “something sometimes breaks.”
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch06.html#idm46291184452856-marker)) “Flaky”是一个超级科学的工程术语，意思是“有时候会出问题”。
- en: ^([4](ch06.html#idm46291183299560-marker)) Tools like Browserify, Webpack, and
    Rollup make it possible to use CommonJS patterns in the browser.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch06.html#idm46291183299560-marker)) Browserify、Webpack和Rollup等工具使得在浏览器中使用CommonJS模式成为可能。
- en: ^([5](ch06.html#idm46291182953960-marker)) When I worked for Intrinsic, we distributed
    our security product to customers in this manner.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch06.html#idm46291182953960-marker)) 当我在Intrinsic工作时，我们以这种方式向客户分发我们的安全产品。
- en: ^([6](ch06.html#idm46291182870872-marker)) You can also use `npm pack` to generate
    a tarball that you can manually inspect.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch06.html#idm46291182870872-marker)) 你也可以使用`npm pack`生成一个tarball，你可以手动检查。
- en: ^([7](ch06.html#idm46291182711784-marker)) This may sound far-fetched, but it
    did happen to an employer of mine.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch06.html#idm46291182711784-marker)) 这听起来可能有些牵强，但这确实发生在我的雇主身上。
- en: ^([8](ch06.html#idm46291182617336-marker)) If you get a *EPUBLISHCONFLICT* error,
    then some poor reader has published their package to npm and you’ll need to change
    the package name.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch06.html#idm46291182617336-marker)) 如果你遇到*EPUBLISHCONFLICT*错误，那么某些不幸的读者已经将他们的包发布到npm，你需要更改包名称。
