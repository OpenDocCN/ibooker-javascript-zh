- en: Chapter 13\. Persistence
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章 持久性
- en: 'All but the simplest websites and web applications are going to require *persistence*
    of some kind; that is, some way to store data that’s more permanent than volatile
    memory so that your data will survive server crashes, power outages, upgrades,
    and relocations. In this chapter, we’ll be discussing the options available for
    persistence and demonstrating both document databases and relational databases.
    Before we jump in to databases, however, we’ll start with the most basic form
    of persistence: filesystem persistence.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有除了最简单的网站和网络应用程序外，都需要某种形式的**持久性**；也就是说，一些比易失性内存更持久的数据存储方式，以便在服务器崩溃、停电、升级和迁移时数据能够存活下来。在本章中，我们将讨论持久性的可用选项，并演示文档数据库和关系数据库。然而，在进入数据库之前，我们将从最基本的持久性形式开始：文件系统持久性。
- en: Filesystem Persistence
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件系统持久性
- en: One way to achieve persistence is to simply save data to so-called flat files
    (*flat* because there’s no inherent structure in a file; it’s just a sequence
    of bytes). Node makes filesystem persistence possible through the `fs` (filesystem)
    module.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 实现持久性的一种方式是简单地将数据保存到所谓的平面文件中（*平面*因为文件中没有固有的结构；它只是一系列字节的序列）。Node通过`fs`（文件系统）模块实现了文件系统持久性。
- en: Filesystem persistence has some drawbacks. In particular, it doesn’t scale well.
    The minute you need more than one server to meet traffic demands, you will run
    into problems with filesystem persistence, unless all of your servers have access
    to a shared filesystem. Also, because flat files have no inherent structure, the
    burden of locating, sorting, and filtering data will be on your application. For
    these reasons, you should favor databases over filesystems for storing data. The
    one exception is storing binary files, such as images, audio files, or videos.
    While many databases can handle this type of data, they rarely do so more efficiently
    than a filesystem (though information *about* the binary files is usually stored
    in a database to enable searching, sorting, and filtering).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统持久性具有一些缺点。特别是，它不易扩展。一旦您需要多台服务器来满足流量需求，您将会遇到文件系统持久性的问题，除非所有服务器都可以访问共享文件系统。此外，由于平面文件没有固有结构，定位、排序和过滤数据的负担将落在您的应用程序上。因此，出于这些原因，您应优先考虑使用数据库而不是文件系统来存储数据。唯一的例外是存储二进制文件，如图像、音频文件或视频。虽然许多数据库可以处理这类数据，但它们很少比文件系统更有效地处理（尽管通常在数据库中存储有关二进制文件的信息以便于搜索、排序和过滤）。
- en: If you do need to store binary data, keep in mind that filesystem storage still
    has the problem of not scaling well. If your hosting doesn’t have access to a
    shared filesystem (which is usually the case), you should consider storing binary
    files in a database (which usually requires some configuration so the database
    doesn’t grind to a stop) or a cloud-based storage service, like Amazon S3 or Microsoft
    Azure Storage.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您确实需要存储二进制数据，请记住文件系统存储仍然存在不易扩展的问题。如果您的主机没有访问共享文件系统的权限（通常是这种情况），您应考虑将二进制文件存储在数据库中（通常需要一些配置，以防止数据库停滞）或云存储服务，如Amazon
    S3或Microsoft Azure Storage。
- en: 'Now that we have the caveats out of the way, let’s look at Node’s filesystem
    support. We’ll revisit the vacation photo contest from [Chapter 8](ch08.xhtml#ch_form_handling).
    In our application file, let’s fill in the handler that processes that form (*ch13/00-mongodb/lib/handlers.js*
    in the companion repo):'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们解决了注意事项，让我们来看看Node的文件系统支持。我们将回顾来自[第8章](ch08.xhtml#ch_form_handling)的度假照片竞赛。在我们的应用程序文件中，让我们填写处理该表单的处理程序（*ch13/00-mongodb/lib/handlers.js*在伴随代码库中）：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There’s a lot going on there, so let’s break it down. We first create a directory
    to store the uploaded files (if it doesn’t already exist). You’ll probably want
    to add the *data* directory to your *.gitignore* file so you don’t accidentally
    commit uploaded files. Recall from [Chapter 8](ch08.xhtml#ch_form_handling) that
    we’re handling the actual file upload in *meadowlark.js* and calling our handler
    with the files already decoded. What we get is an object (`files`) that contains
    the information about the uploaded files. Since we want to prevent collisions,
    we can’t just use the filename the user uploaded (in case two users both upload
    *portland.jpg*). To avoid this problem, we create a unique directory based on
    the timestamp; it’s pretty unlikely that two users will both upload *portland.jpg*
    in the same millisecond! Then we rename (move) the uploaded file (our file processor
    will have given it a temporary name, which we can get from the `path` property)
    to our constructed name.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这里涉及很多内容，让我们来分解一下。首先，我们创建一个目录来存储上传的文件（如果目录不存在）。您可能希望将 *data* 目录添加到您的 *.gitignore*
    文件中，以防意外提交上传的文件。回想一下 [第8章](ch08.xhtml#ch_form_handling) 中，我们在 *meadowlark.js*
    中处理实际文件上传，并已解码调用我们的处理程序。我们得到的是一个包含有关上传文件信息的对象 (`files`)。因为我们希望避免碰撞，所以不能仅仅使用用户上传的文件名（以防两个用户都上传
    *portland.jpg*）。为了避免这个问题，我们基于时间戳创建一个唯一的目录；两个用户在同一毫秒内都上传 *portland.jpg* 的可能性非常小！然后我们将上传的文件重命名（移动）到我们构造的名称（我们的文件处理器会给它一个临时名称，我们可以从
    `path` 属性中获取）。
- en: Finally, we need some way to associate the files that users upload with their
    email addresses (and the month and year of the submission). We could encode this
    information into the file or directory names, but we are going to prefer storing
    this information in a database. Since we haven’t learned how to do that yet, we’re
    going to encapsulate that functionality in the `vacationPhotoContest` function
    and complete that function later in this chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一种方法将用户上传的文件与他们的电子邮件地址（以及提交的月份和年份）关联起来。我们可以将这些信息编码到文件或目录名称中，但我们更倾向于将这些信息存储在数据库中。因为我们还没有学会如何做到这一点，我们将在本章后面的
    `vacationPhotoContest` 函数中封装该功能并完成它。
- en: Note
  id: totrans-10
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In general, you should never trust anything that the user uploads because it’s
    a possible vector for your website to be attacked. For example, a malicious user
    could easily take a harmful executable, rename it with a *.jpg* extension, and
    upload it as the first step in an attack (hoping to find some way to execute it
    at a later point). Likewise, we are taking a little risk here by naming the file
    using the `name` property provided by the browser; someone could also abuse this
    by inserting special characters into the filename. To make this code completely
    safe, we would give the file a random name, taking only the extension (making
    sure it consists only of alphanumeric characters).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一般情况下，你绝对不应该信任用户上传的任何内容，因为这是攻击你的网站的一个潜在途径。例如，恶意用户可以轻易地将一个有害的可执行文件改名为 *.jpg*
    扩展名，并上传它作为攻击的第一步（希望以后能找到某种方法来执行它）。同样，我们在这里使用浏览器提供的 `name` 属性来命名文件，也存在一定的风险；某些人也可以通过在文件名中插入特殊字符来滥用这一点。为了让这段代码完全安全，我们将为文件命名随机生成一个名称，仅保留扩展名（确保它只包含字母和数字字符）。
- en: Even though filesystem persistence has its drawbacks, it’s frequently used for
    intermediate file storage, and it’s useful to know how to use the Node filesystem
    library. However, to address the deficiencies of filesystem storage, let’s turn
    our attention to cloud persistence.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管文件系统持久性具有其缺点，但它经常用于中间文件存储，了解如何使用 Node 文件系统库是很有用的。然而，为了解决文件系统存储的缺陷，让我们将注意力转向云持久性。
- en: Cloud Persistence
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云持久性
- en: Cloud storage is becoming increasingly popular, and I highly recommend you take
    advantage of one of these inexpensive, robust services.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 云存储变得越来越流行，我强烈建议您利用其中一种价格便宜且稳健的服务。
- en: 'When using cloud services, there’s a certain amount of up-front work you have
    to do. Obviously, you have to create an account, but you also have to understand
    how your application authenticates with the cloud service, and it’s also helpful
    to understand some basic terminology (for example, AWS calls its file storage
    mechanism *buckets*, while Azure calls them *containers*). It’s beyond the scope
    of this book to detail all of that information, and it is well-documented:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用云服务时，您必须进行一定量的前期工作。显然，您需要创建一个帐户，但您还需要了解您的应用程序如何与云服务进行身份验证，了解一些基本术语也很有帮助（例如，AWS将其文件存储机制称为*存储桶*，而Azure称之为*容器*）。详细信息超出本书的范围，并且有充分的文档支持：
- en: '[AWS: Getting Started in Node.js](https://amzn.to/2CCYk9s)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看[AWS：Node.js入门](https://amzn.to/2CCYk9s)获取更多信息。
- en: '[Azure for JavaScript and Node.js Developers](http://bit.ly/2NEkTku)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Azure适用于JavaScript和Node.js开发人员](http://bit.ly/2NEkTku)'
- en: 'The good news is that once you get past this initial configuration, using cloud
    persistence is quite easy. Here’s an example of how easy it is to save a file
    to an Amazon S3 account:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您完成初始配置，使用云持久性就非常简单。以下是一个示例，展示了将文件保存到Amazon S3帐户有多么简单：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: See the [AWS SDK documentation](https://amzn.to/2O3e1MA) for more information.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[AWS SDK文档](https://amzn.to/2O3e1MA)获取更多信息。
- en: 'Here’s an example of how to do the same thing with Microsoft Azure:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何在Microsoft Azure上执行相同操作的示例：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: See the [Microsoft Azure documentation](http://bit.ly/2Kd3rRK) for more information.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[Microsoft Azure文档](http://bit.ly/2Kd3rRK)获取更多信息。
- en: Now that we know a couple of techniques for file storage, let’s consider the
    storage of structured data with databases.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了几种文件存储技术，让我们考虑使用数据库存储结构化数据的方法。
- en: Database Persistence
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库持久性
- en: All except the simplest websites and web applications require a database. Even
    if the bulk of your data is binary and you’re using a shared filesystem or cloud
    storage, the chances are you’ll want a database to help catalog that binary data.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有不是最简单的网站和Web应用程序都需要一个数据库。即使您的大部分数据是二进制的，而且您使用共享文件系统或云存储，您也很可能需要一个数据库来帮助目录化这些二进制数据。
- en: Traditionally, the word *database* is shorthand for *relational database management
    system* (RDBMS). Relational databases, such as Oracle, MySQL, PostgreSQL, or SQL
    Server, are based on decades of research and formal database theory. It is a technology
    that is quite mature at this point, and the power of these databases is unquestionable.
    However, we now have the luxury of expanding our ideas of what constitutes a database.
    NoSQL databases have come into vogue in recent years, and they’re challenging
    the status quo of internet data storage.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，“数据库”一词是“关系数据库管理系统”（RDBMS）的简称。关系数据库，如Oracle、MySQL、PostgreSQL或SQL Server，基于数十年的研究和正式的数据库理论。这项技术现在已经非常成熟，这些数据库的强大是毋庸置疑的。然而，我们现在有幸扩展我们对数据库构成的理解。近年来，NoSQL数据库变得流行起来，它们挑战了互联网数据存储的现状。
- en: It would be foolish to claim that NoSQL databases are somehow better than relational
    databases, but they do have certain advantages (and vice versa). While it is quite
    easy to integrate a relational database with Node apps, there are NoSQL databases
    that seem almost to have been designed for Node.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 声称NoSQL数据库在某种程度上比关系数据库更好是愚蠢的，但它们确实具有某些优势（反之亦然）。虽然将关系数据库与Node应用程序集成非常容易，但也有些NoSQL数据库似乎几乎是为Node设计的。
- en: The two most popular types of NoSQL databases are *document databases* and *key-value*
    databases. Document databases excel at storing objects, which makes them a natural
    fit for Node and JavaScript. Key-value databases, as the name implies, are extremely
    simple and are a great choice for applications with data schemas that are easily
    mapped into key-value pairs.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最流行的两种NoSQL数据库类型是*文档数据库*和*键值数据库*。文档数据库擅长存储对象，这使它们非常适合Node和JavaScript。键值数据库正如其名称所示，非常简单，非常适合具有易于映射为键值对的数据模式的应用程序。
- en: I feel that document databases represent the optimal compromise between the
    constraints of relational databases and the simplicity of key-value databases,
    and for that reason, we will be using a document database for our first example.
    MongoDB is the leading document database and is robust and established at this
    point.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为文档数据库代表了在关系数据库的约束和键值数据库的简单性之间找到的最佳折衷方案，因此，我们将在第一个示例中使用文档数据库。MongoDB是主流的文档数据库，在目前是健壮和成熟的。
- en: For our second example, we’ll be using PostgreSQL, a popular and robust open
    source RDBMS.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第二个示例，我们将使用PostgreSQL，这是一个流行且强大的开源关系型数据库管理系统。
- en: A Note on Performance
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于性能的注记
- en: The simplicity of NoSQL databases is a double-edged sword. Carefully planning
    a relational database can be an involved task, but the benefit of that careful
    planning is a database that offers excellent performance. Don’t be fooled into
    thinking that because NoSQL databases are generally simpler, there isn’t an art
    and a science to tuning them for maximum performance.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL数据库的简单性是双刃剑。仔细规划关系型数据库可能是一个复杂的任务，但仔细规划的好处是提供了性能优异的数据库。不要被误导认为，因为NoSQL数据库通常更简单，就不存在调整它们以获得最大性能的艺术和科学。
- en: Relational databases have traditionally relied on their rigid data structures
    and decades of optimization research to achieve high performance. NoSQL databases,
    on the other hand, have embraced the distributed nature of the internet and, like
    Node, have instead focused on concurrency to scale performance (relational databases
    also support concurrency, but this is usually reserved for the most demanding
    applications).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，关系型数据库依赖其严格的数据结构和数十年的优化研究来实现高性能。另一方面，NoSQL数据库采纳了互联网的分布式特性，并像Node一样，转而专注于并发以提升性能（关系型数据库也支持并发，但通常仅用于最苛刻的应用程序）。
- en: 'Planning for database performance and scalability is a large, complex topic
    that is beyond the scope of this book. If your application requires a high level
    of database performance, I recommend starting with Kristina Chodorow and Michael
    Dirolf’s *[MongoDB: The Definitive Guide](http://bit.ly/Mongo_DB_Guide)* (O’Reilly).'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 规划数据库性能和可扩展性是一个庞大且复杂的主题，超出了本书的范围。如果您的应用程序需要高水平的数据库性能，我建议首先阅读Kristina Chodorow和Michael
    Dirolf的*[MongoDB权威指南](http://bit.ly/Mongo_DB_Guide)*（O’Reilly）。
- en: Abstracting the Database Layer
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象化数据库层
- en: 'In this book, we’ll be implementing the same features and demonstrating how
    to do that with two databases (and not just two databases but two substantially
    different database architectures). While the objective in this book is to cover
    two popular options for database architecture, it reflects a real-world scenario:
    switching a major component of your web application midproject. This could happen
    for many reasons. Usually it boils down to discovering that a different technology
    is going to be more cost-effective or allow you to implement necessary features
    more quickly.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将实施相同的功能，并展示如何在两种数据库中执行（不仅仅是两种数据库，而是两种基本不同的数据库架构）。虽然本书的目标是涵盖两种流行的数据库架构选择，但它反映了现实场景：在项目进行中切换Web应用程序的主要组件。这可能出于许多原因。通常归结为发现不同技术能更具成本效益，或者允许您更快地实施必要的功能。
- en: 'Whenever possible, there is value in *abstracting* your technology choices,
    which refers to writing some kind of API layer to generalize the underlying technology
    choices. If done right, it reduces the cost of switching out the component in
    question. However, it comes at a cost: writing the abstraction layer is one more
    thing you have to write and maintain.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，*抽象*您的技术选择是有价值的，这指的是编写某种API层以泛化底层技术选择。如果做得好，它会减少替换问题组件的成本。然而，这是有代价的：编写抽象层是您必须编写和维护的另一件事情。
- en: 'Happily, our abstraction layer will be very small, as we’re supporting only
    a handful of features for the purposes of this book. For now, the features will
    be as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们的抽象化层将非常小，因为我们只支持本书目的的一小部分功能。目前，这些功能将如下：
- en: Returning a list of active vacations from the database
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从数据库返回一个活动度假列表
- en: Storing the email address of users who want to be notified when certain vacations
    are in season
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储希望在特定度假季节通知时通知的用户的电子邮件地址
- en: While this seems simple enough, there are a lot of details here. What does a
    vacation look like? Do we always want to get all the vacations from the database,
    or do we want to be able to filter them or paginate them? How do we identify vacations?
    And so on.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这看起来足够简单，但这里有很多细节。度假是什么样子的？我们总是希望从数据库获取所有假期吗？还是希望能够过滤或分页它们？我们如何识别度假？等等。
- en: 'We’re going to keep our abstraction layer simple for the purposes of this book.
    We’ll contain it in a file called *db.js* that will export two methods that we’ll
    start by just providing dummy implementations:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保持本书中抽象化层的简单性。我们将其包含在一个名为*db.js*的文件中，该文件将导出两个方法，我们将从简单提供虚拟实现开始：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This sets an expectation about how our database implementation should look to
    the application…and all we have to do is make our databases conform to that interface.
    Note that we’re introducing the concept of vacation “availability”; we’re doing
    this so we can easily disable vacations temporarily instead of deleting them from
    the database. An example use case for this would be a bed and breakfast that contacts
    you to let you know they are closed for several months for remodeling. We’re keeping
    this separate from the concept of being “in season” because we may want to list
    out-of-season vacations on the website because people like to plan in advance.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们的数据库实现向应用程序展示了一个期望……而我们所要做的就是使我们的数据库符合这个接口。请注意，我们引入了“可用性”的概念；我们这样做是为了能够临时禁用假期而不是从数据库中删除它们。一个示例用例是一家小旅馆通知您他们关闭几个月进行翻新。我们将这与“旺季”概念分开，因为我们可能希望在网站上列出淡季假期，因为人们喜欢提前计划。
- en: We also include some very generic “location” information; we’ll be getting more
    specific about this in [Chapter 19](ch19.xhtml#ch_integrating_with_third_party_rest_apis).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还包含一些非常通用的“位置”信息；我们将在[第19章](ch19.xhtml#ch_integrating_with_third_party_rest_apis)中详细介绍这一点。
- en: Now that we have an abstraction foundation for our database layer, let’s look
    at how we can implement database storage with MongoDB.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的数据库层建立了一个抽象的基础，让我们看看如何使用MongoDB实现数据库存储。
- en: Setting Up MongoDB
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置MongoDB
- en: The difficulty involved in setting up a MongoDB instance varies with your operating
    system. For this reason, we’ll be avoiding the problem altogether by using an
    excellent free MongoDB hosting service, mLab.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 设置MongoDB实例的难度取决于您的操作系统。因此，我们将通过使用一个出色的免费MongoDB托管服务mLab来彻底避开这个问题。
- en: Note
  id: totrans-50
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: mLab is not the only MongoDB service available. The MongoDB company itself is
    now offering free and low-cost database hosting through its product [MongoDB Atlas](https://www.mongodb.com).
    Free accounts are not recommended for production purposes, though. Both mLab and
    MongoDB Atlas offer production-ready accounts, so you should look into their pricing
    before making a choice. It will be less hassle to stay with the same hosting service
    when you make the switch to production.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: mLab并不是唯一的MongoDB服务提供商。MongoDB公司现在通过其产品[MongoDB Atlas](https://www.mongodb.com)免费和低成本提供数据库托管服务。虽然免费账户不建议用于生产目的。mLab和MongoDB
    Atlas都提供生产就绪的账户，因此在做选择之前应该了解它们的定价。当您转向生产环境时，与相同的托管服务保持一致将会更加方便。
- en: Getting started with mLab is simple. Just go to [*https://mlab.com*](https://mlab.com)
    and click Sign Up. Fill out the registration form and log in, and you’ll be at
    your home screen. Under Databases, you’ll see “no databases at this time.” Click
    “Create new,” and you will be taken to a page with some options for your new database.
    The first thing you’ll select is a cloud provider. For a free (sandbox) account,
    the choice is largely irrelevant, though you should look for a data center near
    you (not every data center will offer sandbox accounts, however). Select SANDBOX,
    and choose a region. Then choose a database name, and click through to Submit
    Order (it’s still an order even though it’s free!). You will be taken back to
    the list of your databases, and after a few seconds, your database will be available
    for use.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用mLab开始是很简单的。只需访问[*https://mlab.com*](https://mlab.com)，然后点击注册。填写注册表格并登录，您将会进入您的主页。在数据库下，您会看到“此时没有数据库”。点击“创建新数据库”，您将被带到一个包含一些选项的页面。您首先要选择一个云提供商。对于免费（沙盒）账户，选择大体上无关紧要，尽管您应该选择靠近您的数据中心（然而，并非每个数据中心都提供沙盒账户）。选择SANDBOX，然后选择一个区域。然后选择一个数据库名称，点击提交订单（即使它是免费的，也还是一个订单！）。您将被带回到您的数据库列表，并在几秒钟后，您的数据库将可供使用。
- en: Having a database set up is half the battle. Now we have to know how to access
    it with Node, and that’s where Mongoose comes in.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个设置好的数据库是成功的一半。现在我们必须知道如何使用Node访问它，这就是Mongoose的用武之地。
- en: Mongoose
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Mongoose
- en: While there’s a low-level driver available for [MongoDB](http://bit.ly/2Kfw0hE),
    you’ll probably want to use an object document mapper (ODM). The most popular
    ODM for MongoDB is *Mongoose*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有一个低级别的[MongoDB驱动程序](http://bit.ly/2Kfw0hE)可用，但您可能希望使用对象文档映射器（ODM）。对于MongoDB来说，最流行的ODM是*Mongoose*。
- en: One of the advantages of JavaScript is that its object model is extremely flexible.
    If you want to add a property or method to an object, you just do it, and you
    don’t need to worry about modifying a class. Unfortunately, that kind of freewheeling
    flexibility can have a negative impact on your databases because they can become
    fragmented and hard to optimize. Mongoose attempts to strike a balance by introducing
    *schemas* and *models* (combined, schemas and models are similar to classes in
    traditional object-oriented programming). The schemas are flexible but still provide
    some necessary structure for your database.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的一个优点是其对象模型非常灵活。如果你想给一个对象添加属性或方法，你只需要这么做，而不需要担心修改类。不过，这种随意的灵活性可能会对你的数据库产生负面影响，因为它们可能变得碎片化并且难以优化。Mongoose
    试图通过引入*模式*和*模型*来取得平衡（结合起来，模式和模型类似于传统面向对象编程中的类）。这些模式灵活但仍为你的数据库提供了一些必要的结构。
- en: 'Before we get started, we’ll need to install the Mongoose module:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们需要安装 Mongoose 模块：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then we’ll add our database credentials to our *.credentials.development.json*
    file:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将我们的数据库凭据添加到我们的 *.credentials.development.json* 文件中：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You’ll find your connection string on the database page in mLab. From your home
    screen, click the appropriate database. You’ll see a box with your MongoDB connection
    URI (it starts with *mongodb://*). You’ll also need a user for your database.
    To create one, click Users, and then “Add database user.”
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 mLab 的数据库页面上找到连接字符串。从你的主屏幕上，点击相应的数据库。你会看到一个框，里面有你的 MongoDB 连接 URI（它以 *mongodb://*
    开头）。你还需要一个数据库用户。要创建一个用户，点击 Users，然后选择“Add database user”。
- en: Notice that we could establish a second set of credentials for production by
    creating a *.credentials.production.js* file and using `NODE_ENV=production`;
    you’ll want to do this when it’s time to go live!
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以通过创建一个 *.credentials.production.js* 文件并使用 `NODE_ENV=production` 来为生产环境建立第二组凭据；在上线时你会需要这样做！
- en: Now that we have all the configuration done, let’s actually make a connection
    to the database and do something useful!
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们所有的配置都完成了，让我们实际连接到数据库并做一些有用的事情！
- en: Database Connections with Mongoose
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Mongoose 进行数据库连接
- en: 'We’ll start by creating a connection to our database. We’ll put our database
    initialization code in *db.js*, along with the dummy API we created earlier (*ch13/00-mongodb/db.js*
    in the companion repo):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从创建到数据库的连接开始。我们将把我们的数据库初始化代码放在 *db.js* 中，与我们之前创建的虚拟 API 一起（在伴随代码库中为 *ch13/00-mongodb/db.js*）：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Any file that needs to access the database can simply import *db.js*. However,
    we want the initialization to happen right away, before we need the API, so we’ll
    go ahead and import this from *meadowlark.js* (where we don’t need to do anything
    with the API):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 任何需要访问数据库的文件都可以简单地导入 *db.js*。然而，我们希望初始化尽快完成，即在我们需要 API 之前，所以我们会从 *meadowlark.js*
    中导入它（在那里我们不需要对 API 做任何事情）：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now that we’re connecting to the database, it’s time to consider how we’re going
    to structure data that we’re transferring to and from the database.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在连接到数据库，是时候考虑我们将如何结构化我们传输到数据库和从数据库传输的数据了。
- en: Creating Schemas and Models
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建模式和模型
- en: 'Let’s create a vacation package database for Meadowlark Travel. We start by
    defining a schema and creating a model from it. Create the file *models/vacation.js*
    (*ch13/00-mongodb/models/vacation.js* in the companion repo):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为 Meadowlark Travel 创建一个度假套餐数据库。我们首先定义一个模式并从中创建一个模型。创建文件 *models/vacation.js*（在伴随代码库中为
    *ch13/00-mongodb/models/vacation.js*）：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code declares the properties that make up our vacation model, and the types
    of those properties. You’ll see there are several string properties, some numeric
    properties, two Boolean properties, and an array of strings (denoted by `[String]`).
    At this point, we can also define methods on our schema. Each product has a stock
    keeping unit (SKU); even though we don’t think about vacations being “stock items,”
    the concept of an SKU is pretty standard for accounting, even when tangible goods
    aren’t being sold.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码声明了构成我们度假模型的属性及其类型。你会看到有几个字符串属性，一些数值属性，两个布尔属性以及一个字符串数组（用 `[String]` 表示）。在这一点上，我们还可以在我们的模式上定义方法。每个产品都有一个库存单位
    (SKU)；即使我们不认为度假是“库存商品”，但 SKU 的概念在会计中是非常标准的，即使没有实体商品出售时也是如此。
- en: 'Once we have the schema, we create a model using `mongoose.model`: at this
    point, `Vacation` is very much like a class in traditional object-oriented programming.
    Note that we have to define our methods before we create our model.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦有了模式，我们就可以使用 `mongoose.model` 创建一个模型：此时，`Vacation` 就像传统面向对象编程中的类一样。请注意，在创建模型之前必须定义我们的方法。
- en: Note
  id: totrans-75
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Because of the nature of floating-point numbers, you should always be careful
    with financial computations in JavaScript. We could store our prices in cents
    instead of dollars, which would help, but it doesn’t eliminate the problems. For
    the modest purposes of our travel website, we’re not going to worry about it,
    but if your application involves very large or very small financial amounts (for
    example, fractional cents from interest or volume trading), you should consider
    using a library such as [currency.js](https://currency.js.org) or [decimal.js-light](http://bit.ly/2X6kbQ5).
    Also, JavaScript’s [BigInt](https://mzl.la/2Xhs45r) built-in object, which is
    available as of Node 10 (with limited browser support as I write this), can be
    used for this purpose.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于浮点数的性质，在 JavaScript 中进行财务计算时一定要小心。我们可以将价格存储为分而不是美元，这会有所帮助，但并不能完全消除问题。对于我们旅行网站的适度目的，我们不打算担心这些，但是如果您的应用涉及非常大或非常小的财务金额（例如利息的分数美分或交易量），您应该考虑使用类似
    [currency.js](https://currency.js.org) 或 [decimal.js-light](http://bit.ly/2X6kbQ5)
    的库。此外，JavaScript 的 [BigInt](https://mzl.la/2Xhs45r) 内置对象，从 Node 10 开始可用（写作时具有有限的浏览器支持），可以用于此目的。
- en: 'We are exporting the `Vacation` model object created by Mongoose. While we
    could use this model directly, that would be undermining our effort to provide
    a database abstraction layer. So we will choose to import it only from the *db.js*
    file and let the rest of our application use its methods. Add the `Vacation` model
    to *db.js*:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在导出由 Mongoose 创建的 `Vacation` 模型对象。虽然我们可以直接使用这个模型，但这将削弱我们提供数据库抽象层的努力。因此，我们选择仅从
    *db.js* 文件导入它，并让我们的应用程序的其余部分使用其方法。将 `Vacation` 模型添加到 *db.js* 中：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: All of our structures are now defined, but our database isn’t very interesting
    because there’s nothing actually in it. Let’s make it useful by seeding it with
    some data.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们所有的结构都已经定义好了，但是我们的数据库并不是很有趣，因为里面实际上什么都没有。让我们通过一些数据来种植它，使它变得有用。
- en: Seeding Initial Data
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 种植初始数据
- en: 'We don’t yet have any vacation packages in our database, so we’ll add some
    to get us started. Eventually, you may want to create a way to manage products,
    but for the purposes of this book, we’re just going to do it in code (*ch13/00-mongodb/db.js*
    in the companion repo):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '我们的数据库中还没有任何度假套餐，所以我们将添加一些来启动我们。最终，您可能希望创建一种管理产品的方式，但是对于本书的目的，我们只打算在代码中执行它（伴随库中的
    *ch13/00-mongodb/db.js*）:'
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There are two Mongoose methods being used here. The first, `find`, does just
    what it says. In this case, it’s finding all instances of `Vacation` in the database
    and invoking the callback with that list. We’re doing that because we don’t want
    to keep re-adding our seed vacations: if there are already vacations in the database,
    it’s been seeded, and we can go on our merry way. The first time this executes,
    though, `find` will return an empty list, so we proceed to create two vacations
    and then call the `save` method on them, which saves these new objects to the
    database.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用了两个 Mongoose 方法。首先是 `find`，它就像它的名字一样。在这种情况下，它在数据库中找到所有 `Vacation` 的实例，并调用回调函数返回这个列表。我们这样做是因为我们不想不断地重新添加我们的种子假期：如果数据库中已经有了假期，那么它已经被种子化了，我们可以继续进行。然而，第一次执行这个操作时，`find`
    将返回一个空列表，因此我们继续创建两个假期，然后在它们上调用 `save` 方法，将这些新对象保存到数据库中。
- en: Now that data is *in* the database, it’s time to get it back out!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在数据已经存入数据库，是时候取回它了！
- en: Retrieving Data
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检索数据
- en: We’ve already seen the `find` method, which is what we’ll use to display a list
    of vacations. However, this time we’re going to pass an option to `find` that
    will filter the data. Specifically, we want to display only vacations that are
    currently available.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了 `find` 方法，这是我们将用来显示假期列表的方法。但是，这次我们将向 `find` 传递一个选项来过滤数据。具体来说，我们只想显示当前可用的假期。
- en: 'Create a view for the products page, *views/vacations.handlebars*:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为产品页面创建一个视图，*views/vacations.handlebars*：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now we can create route handlers that hook it all up. In *lib/handlers.js*
    (don’t forget to import `../db`), we create the handler:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建路由处理程序来连接所有这些。在 *lib/handlers.js* 中（不要忘记导入 `../db`），我们创建处理程序：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We add a route that calls the handler in *meadowlark.js*:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加一个调用处理程序的路由，在 *meadowlark.js* 中：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you run this example, you’ll see only the one vacation from our dummy database
    implementation. That’s because we’ve initialized the database and seeded its data,
    but we haven’t replaced the dummy implementation with a real one. So let’s do
    that now. Open *db.js* and modify `getVacations`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行此示例，您将只看到我们虚拟数据库实现中的一个假期。这是因为我们已初始化了数据库并且播种了数据，但我们还没有用真实的数据库替换虚拟实现。所以现在让我们来做这个。打开
    *db.js* 并修改 `getVacations`：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: That was easy! A one-liner. Partially this is because Mongoose is doing a lot
    of the heavy lifting for us, and the way we’ve designed our API is similar to
    the way Mongoose works. When we adapt this later to PostgreSQL, you’ll see we
    have to do a little more work.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这太容易了！只是一个一行代码。部分原因是因为 Mongoose 为我们做了很多繁重的工作，而且我们设计的 API 方式类似于 Mongoose 的工作方式。当我们稍后将其适应
    PostgreSQL 时，您会看到我们需要做更多的工作。
- en: Note
  id: totrans-96
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The astute reader may worry that our database abstraction layer isn’t doing
    much to “protect” its technology-neutral objective. For example, a developer may
    read this code and see that they can pass any Mongoose options along to the vacation
    model, and then the application would be using features that are specific to Mongoose,
    which will make it harder to switch databases. We could take some steps to prevent
    this. Instead of just passing things to Mongoose, we could look for specific options
    and handle them explicitly, making it clear that any implementation would have
    to provide those options. But for the sake of this example, we’re going to let
    this slide and keep this code simple.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 机敏的读者可能会担心我们的数据库抽象层并没有太多的“保护”技术中立的目标。例如，开发者可能会阅读这段代码，并且发现他们可以将任何 Mongoose 选项传递给假期模型，这样应用程序就会使用特定于
    Mongoose 的功能，这将使得切换数据库变得更加困难。我们可以采取一些措施来防止这种情况发生。我们不仅仅是将东西传递给 Mongoose，而是要寻找特定的选项并明确地处理它们，以表明任何实现都必须提供这些选项。但是出于本例的考虑，我们将放任这一点，并保持这段代码的简单性。
- en: Most of this should be looking pretty familiar, but there might be some things
    that surprise you. For instance, how we’re handling the view context for the vacation
    listing might seem odd. Why did we map the products returned from the database
    to a nearly identical object? One reason is that we want to display the price
    in a neatly formatted way, so we have to convert it to a formatted string.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数内容应该看起来很熟悉，但可能会有一些令您惊讶的地方。例如，我们如何处理假期列表的视图上下文可能看起来有点奇怪。为什么我们要将从数据库返回的产品映射到一个几乎相同的对象？一个原因是我们想以整齐格式显示价格，所以我们必须将其转换为格式化的字符串。
- en: 'We could have saved some typing by doing this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以通过这样做来节省一些输入：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: That would certainly save us a few lines of code, but in my experience, there
    are good reasons not to pass unmapped database objects directly to views. The
    view gets a bunch of properties it may not need, possibly in formats that are
    incompatible with it. Our example is pretty simple so far, but once it starts
    to get more complicated, you’ll probably want to do even more customization of
    the data that’s passed to a view. It also makes it easy to accidentally expose
    confidential information or information that could compromise the security of
    your website. For these reasons, I recommend mapping the data that’s returned
    from the database and passing only what’s needed onto the view (transforming as
    necessary, as we did with `price`).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这肯定可以节省我们几行代码，但根据我的经验，有很多理由不直接将未映射的数据库对象传递给视图。视图获得了一堆可能不需要的属性，可能还以与其不兼容的格式。我们的示例目前还相当简单，但一旦开始变得更加复杂，您可能希望对传递给视图的数据进行更多定制。此外，这也很容易意外地暴露机密信息或可能危及网站安全的信息。基于这些理由，我建议映射从数据库返回的数据，并仅将必要的内容传递给视图（必要时进行转换，就像我们对
    `price` 做的那样）。
- en: Note
  id: totrans-102
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In some variations of the MVC architecture, a third component called a *view
    model* is introduced. A view model essentially distills and transforms a model
    (or models) so that it’s more appropriate for display in a view. What we’re doing
    here is creating a view model on the fly.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些 MVC 架构的变体中，引入了一个称为 *视图模型* 的第三个组件。视图模型本质上是将一个（或多个）模型提炼和转换，使其更适合在视图中显示。我们在这里所做的是即时创建一个视图模型。
- en: We’ve come a long way at this point. We’re successfully using a database to
    store information about our vacations. But databases wouldn’t be very useful if
    we couldn’t update them. Let’s turn our attention to that aspect of interfacing
    with databases.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经走了很长一段路。我们成功地使用数据库存储了关于我们假期的信息。但是，如果我们不能更新它们，数据库就不会太有用。让我们把注意力转向与数据库接口的这个方面。
- en: Adding Data
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加数据
- en: We’ve already seen how we can add data (we added data when we seeded the vacation
    collection) and how we can update data (we update the count of packages sold when
    we book a vacation), but let’s take a look at a slightly more involved scenario
    that highlights the flexibility of document databases.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何添加数据（在种子化度假集合时添加了数据）以及如何更新数据（在预订度假时更新售出的套餐数量），但让我们看一个稍微复杂的场景，突显文档数据库的灵活性。
- en: 'When a vacation is out of season, we display a link that invites the customer
    to be notified when the vacation is in season again. Let’s hook up that functionality.
    First, we create the schema and model (*models/vacationInSeasonListener.js*):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当度假不在季节时，我们显示一个链接，邀请客户在度假再次进入季节时通知他们。让我们连接这个功能。首先，我们创建模式和模型（*models/vacationInSeasonListener.js*）：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then we’ll create our view, *views/notify-me-when-in-season.handlebars*:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将创建我们的视图，*views/notify-me-when-in-season.handlebars*：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then the route handlers:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是路由处理程序：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, we add a real implementation to *db.js*:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在 *db.js* 中添加了一个真实的实现：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: What magic is this? How can we “update” a record in the `VacationInSeasonListener`
    collection before it even exists? The answer lies in a Mongoose convenience called
    an *upsert* (a portmanteau of “update” and “insert”). Basically, if a record with
    the given email address doesn’t exist, it will be created. If a record does exist,
    it will be updated. Then we use the magic variable `$push` to indicate that we
    want to add a value to an array.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是什么魔法？我们如何在 `VacationInSeasonListener` 集合甚至不存在之前就“更新”记录？答案在于 Mongoose 的一个便利功能叫做
    *upsert*（“update” 和 “insert” 的混成词）。基本上，如果不存在具有给定电子邮件地址的记录，它将被创建。如果记录已存在，则将进行更新。然后，我们使用魔法变量
    `$push` 表示我们要向数组添加一个值。
- en: Note
  id: totrans-116
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意：
- en: This code doesn’t prevent multiple SKUs from being added to the record if the
    user fills out the form multiple times. When a vacation comes into season and
    we find all the customers who want to be notified, we will have to be careful
    not to notify them multiple times.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码不会阻止用户多次填写表单后将多个 SKU 添加到记录中。当度假季节到来时，我们找到所有想收到通知的客户时，必须小心不要多次通知他们。
- en: We’ve certainly covered the important bases by now! We learned how to connect
    to a MongoDB instance, seed it with data, read that data out, and write updates
    to it! However, you may prefer to use an RDBMS, so let’s shift gears and see how
    we can do the same thing with PostgreSQL instead.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在肯定已经涵盖了重要的基础知识！我们学会了如何连接到 MongoDB 实例，向其种子化数据，读取数据，并对其进行更新！然而，你可能更喜欢使用关系数据库管理系统，因此让我们改变思路，看看如何使用
    PostgreSQL 来完成同样的工作。
- en: PostgreSQL
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PostgreSQL
- en: Object databases like MongoDB are great and are generally quicker to get started
    with, but if you’re trying to build a robust application, you may put as much
    work—or more—into structuring your object databases as you would planning out
    a traditional relational database. Furthermore, you may already have experience
    with relational databases, or you might have an existing relational database you
    want to connect with.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 像 MongoDB 这样的对象数据库非常棒，并且通常更快地开始使用，但如果你尝试构建一个强大的应用程序，你可能会像规划传统关系数据库一样多或更多地工作来构建你的对象数据库结构。此外，你可能已经对关系数据库有经验，或者你可能已经有一个现有的关系数据库需要连接。
- en: Fortunately, there is robust support for every major relational database in
    the JavaScript ecosystem, and if you want or need to use a relational database,
    you shouldn’t have any problem.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在 JavaScript 生态系统中，每个主要的关系型数据库都有强大的支持，如果你需要使用关系型数据库，应该不会有任何问题。
- en: Let’s take our vacation database and reimplement it using a relational database.
    For this example, we’ll use PostgreSQL, a popular and sophisticated open source
    relational database. The techniques and principles we’ll use will be similar for
    any relational database.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们拿我们的度假数据库，并使用关系数据库重新实现它。在这个示例中，我们将使用 PostgreSQL，一个流行且复杂的开源关系数据库。我们将使用的技术和原则对任何关系数据库都是类似的。
- en: Similar to the ODM we used for MongoDB, there are object-relational mapping
    (ORM) tools available for relational databases. However, since most readers interested
    in this topic are probably already familiar with relational databases and SQL,
    we’ll use a Node PostgreSQL client directly.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们用于 MongoDB 的对象数据映射（ODM）类似，针对关系数据库也有对象关系映射（ORM）工具可用。然而，由于大多数对此主题感兴趣的读者可能已经熟悉关系数据库和
    SQL，因此我们将直接使用 Node PostgreSQL 客户端。
- en: Like MongoDB, we’ll use a free online PostgreSQL service. Of course, if you’re
    comfortable installing and configuring your own PostgreSQL database, you are welcome
    to do that as well. All that will change is the connection string. If you do use
    your own PostgreSQL instance, make sure you’re using 9.4 or later, because we
    will be using the JSON data type, which was introduced in 9.4 (as I write this,
    I am using 11.3).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 和 MongoDB 一样，我们将使用一个免费的在线 PostgreSQL 服务。当然，如果你习惯于安装和配置自己的 PostgreSQL 数据库，你也可以这样做。所有要改变的只是连接字符串。如果你使用自己的
    PostgreSQL 实例，请确保你使用的是 9.4 或更高版本，因为我们将使用 9.4 引入的 JSON 数据类型（我写这篇文章时，正在使用 11.3）。
- en: 'There are many options for online PostgreSQL; for this example, I’ll be using
    [ElephantSQL](https://www.elephantsql.com). Getting started couldn’t be simpler:
    create an account (you can use your GitHub account to log in), and click Create
    New Instance. All you have to do is give it a name (for example, “meadowlark”)
    and select a plan (you can use their free plan). You’ll also specify a region
    (try to pick the one closest to you). Once you’re all set up, you’ll find a Details
    section that lists information about your instance. Copy the URL (connection string),
    which includes the username, password, and instance location all in one convenient
    string.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多在线 PostgreSQL 的选择；在这个示例中，我将使用 [ElephantSQL](https://www.elephantsql.com)。开始使用简单至极：创建一个账户（你可以使用
    GitHub 账号登录），然后点击创建新实例。你只需要给它一个名字（例如，“meadowlark”）并选择一个计划（你可以使用他们的免费计划）。你还需要指定一个区域（试着选择离你最近的那一个）。一旦你设置好了，你会在详情部分找到一些关于你实例的信息。复制
    URL（连接字符串），里面包括了用户名、密码和实例位置，都在一个便捷的字符串中。
- en: 'Put that string in your *.credentials.development.json* file:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 将该字符串放入你的 *.credentials.development.json* 文件中：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: One difference between object databases and RDBMSs is that you typically do
    more up-front work to define the schema of an RDBMS and use data definition SQL
    to create the schema before adding or retrieving data. In keeping with this paradigm,
    we’ll do that as a separate step instead of letting our ODM or ORM handle it,
    as we did with MongoDB.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对象数据库和关系型数据库（RDBMSs）之间的一个区别是，你通常需要更多的前期工作来定义 RDBMS 的模式，并使用数据定义 SQL 来创建模式，然后再添加或检索数据。为了遵循这个范式，我们将把这作为一个单独的步骤来处理，而不是让我们的
    ODM 或 ORM 来处理，就像我们在 MongoDB 中所做的那样。
- en: We could create SQL scripts and use a command-line client to execute the data
    definition scripts that will create our tables, or we could do this work in JavaScript
    with the PostgreSQL client API, but in a separate step that’s done only once.
    Since this is a book about Node and Express, we’ll do the latter.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建 SQL 脚本，并使用命令行客户端执行数据定义脚本来创建我们的表，或者我们可以使用 PostgreSQL 客户端 API 在 JavaScript
    中完成这项工作，但这是一个只做一次的独立步骤。因为这是关于 Node 和 Express 的书，我们会选择后者来完成这项工作。
- en: 'First, we’ll have to install the `pg` client library (`npm install pg`). Then
    create *db-init.js*, which will be run only to initialize our database and is
    distinct from our *db.js* file, which is used every time the server starts up
    (*ch13/01-postgres/db.js* in the companion repo):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将需要安装 `pg` 客户端库 (`npm install pg`)。然后创建 *db-init.js*，这将只用于初始化我们的数据库，与我们的
    *db.js* 文件有所区别，后者会在每次服务器启动时被使用（在 companion repo 中的 *ch13/01-postgres/db.js*）：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Let’s start at the bottom of this file. We take our database client (`client`)
    and call `connect()` on it, which establishes a database connection and returns
    a promise. When that promise resolves, we can take actions against the database.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从这个文件的底部开始。我们拿到我们的数据库客户端(`client`)并对其调用`connect()`，这将建立数据库连接并返回一个 promise。当
    promise 解析后，我们就可以针对数据库采取行动。
- en: The first thing we do is invoke `client.query(createScript)`, which will create
    our `vacations` table (also known as a *relation*). If we look at `createScript`,
    we’ll see this is data definition SQL. It’s beyond the scope of this book to delve
    into SQL, but if you’re reading this section, I assume you have at least a passing
    understanding of SQL. One thing you may note is that we use snake_case to name
    our fields instead of camelCase. That is, what was “inSeason” has become “in_season.”
    While it is possible to use camelCase to name structures in PostgreSQL, you have
    to quote any identifiers with capital letters, which ends up being more trouble
    than it’s worth. We’ll come back to that a little later.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们会调用 `client.query(createScript)`，这将创建我们的 `vacations` 表（也称为*关系*）。如果我们查看 `createScript`，我们会看到这是数据定义的SQL语句。本书不涉及SQL的深入讨论，但如果你正在阅读这一部分，我假设你至少对SQL有基本的了解。你可能注意到的一件事是，我们使用蛇形命名法（snake_case）来命名字段，而不是驼峰命名法（camelCase）。也就是说，原来的“inSeason”变成了“in_season”。虽然在PostgreSQL中可以使用驼峰命名法来命名结构，但对于任何带有大写字母的标识符都必须加引号，这比它值得的麻烦更多。稍后我们会再次回到这个问题。
- en: You’ll see we’re already having to put more thought into our schema. How long
    can a vacation name be? (We’re arbitrarily capping it at 200 characters here.)
    How long can category names and the SKU be? Notice we’re using PostgreSQL’s `money`
    type for the price and making the slug be our primary key (instead of adding a
    separate ID).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，我们已经开始更深入地思考我们的模式。假期名称可以有多长？（这里我们随意将其限制在200个字符。）类别名称和SKU可以有多长？请注意，我们使用PostgreSQL的
    `money` 类型来表示价格，并且将slug作为我们的主键（而不是添加一个单独的ID）。
- en: If you’re already familiar with relational databases, there won’t be anything
    surprising about this simple schema. However, the way we’ve handled “tags” might
    have jumped out at you.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经熟悉关系数据库，这个简单的模式不会有什么意外。然而，我们处理“标签”的方式可能会引起你的注意。
- en: In traditional database design, we would probably create a new table to relate
    vacations to tags (this is called *normalization*). And we could do that here.
    But here is where we might decide to strike some compromises between traditional
    relational database design and doing things in the “JavaScript way.” If we went
    with two tables (`vacations` and `vacation_tags`, for example), we’d have to query
    data from both tables to create a single object that contains all the information
    about a vacation, as we had in our MongoDB example. And there may be performance
    reasons for that extra complexity, but let’s assume there isn’t, and we just want
    to be able to quickly determine the tags for a particular vacation. We could make
    this a text field and separate our tags with commas, but then we would have to
    parse out our tags, and PostgreSQL gives us a better way in JSON data types. We’ll
    see shortly that by specifying this as JSON (`jsonb`, a binary representation
    that’s usually higher performance), we can store this as a JavaScript array, and
    a JavaScript array comes out, just as we had in MongoDB.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的数据库设计中，我们可能会创建一个新表来将假期与标签关联起来（这称为*规范化*）。我们可以在这里这样做。但是在这里，我们可能会决定在传统关系数据库设计与“JavaScript方式”之间进行一些妥协。如果我们选择两个表（例如`vacations`和`vacation_tags`），我们将不得不从两个表中查询数据，以创建一个包含有关假期所有信息的单个对象，就像我们在MongoDB示例中所做的那样。可能存在性能原因需要增加这种额外的复杂性，但让我们假设没有，我们只想能够快速确定特定假期的标签。我们可以将其作为文本字段，并用逗号分隔我们的标签，但然后我们将不得不解析出我们的标签，而PostgreSQL给了我们一个更好的方法，即JSON数据类型。我们很快将看到，通过将其指定为JSON（`jsonb`，通常更高性能的二进制表示），我们可以将其存储为JavaScript数组，JavaScript数组与我们在MongoDB中看到的一样。
- en: 'Finally, we insert our seed data into the database by using the same basic
    concept as before: if the `vacations` table is empty, we add some initial data;
    otherwise, we assume we’ve already done that.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过使用与之前相同的基本概念将我们的种子数据插入到数据库中：如果 `vacations` 表为空，我们添加一些初始数据；否则，我们假设我们已经完成了这些操作。
- en: You’ll note that inserting our data is a little more unwieldy than it was with
    MongoDB. There are ways to solve this problem, but for this example, I want to
    be explicit about the use of SQL. We could write a function to make insert statements
    more naturally, or we could use an ORM (more on this later). But for now, the
    SQL gets the job done, and it should be comfortable for anyone who already knows
    SQL.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，插入我们的数据比在MongoDB中更加不便。有方法可以解决这个问题，但是对于这个示例，我想明确使用SQL。我们可以编写一个函数来使插入语句更自然，或者我们可以使用ORM（稍后详细介绍）。但是现在，SQL完成了工作，并且对于任何已经了解SQL的人来说，应该是舒适的。
- en: Note that although this script is designed to be run only once to initialize
    and seed our database, we’ve written it in a way that it’s safe to run multiple
    times. We included the `IF NOT EXISTS` option, and we check to see whether the
    `vacations` table is empty before adding seed data.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管此脚本设计为仅运行一次以初始化和填充我们的数据库，但我们已经以安全的方式编写它。我们包含了`IF NOT EXISTS`选项，并检查`vacations`表是否为空，然后再添加种子数据。
- en: 'We can now run the script to initialize our database:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以运行脚本来初始化我们的数据库：
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now that we have our database set up, we can write some code to *use* it in
    our website.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了数据库，我们可以编写一些代码来在我们的网站中*使用*它。
- en: Database servers can typically handle only a limited number of connections at
    a time, so web servers usually implement a strategy called *connection pooling*
    to balance the overhead of establishing a connection with the danger of leaving
    connections open too long and choking the server. Fortunately, the details of
    this are handled for you by the PostgreSQL Node client.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库服务器通常只能同时处理有限数量的连接，因此Web服务器通常实现一种称为*连接池*的策略，以平衡建立连接的开销与长时间保持连接的危险，从而使服务器负载过重。幸运的是，这些细节由PostgreSQL
    Node客户端为您处理。
- en: We’ll take a slightly different strategy with our *db.js* file this time. Instead
    of a file we just require to establish the database connection, it will return
    an API that we write that handles the details of communicating with the database.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们将采用稍微不同的策略处理我们的*db.js*文件。与其仅仅是一个我们需要导入以建立数据库连接的文件不同，它将返回一个API，我们编写它来处理与数据库通信的详细信息。
- en: 'We also have a decision to make about our vacation model. Recall that when
    we created our model, we used snake_case for our database schema, but all of our
    JavaScript code uses camelCase. Broadly speaking, we have three options here:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在度假模型上还有一个决定要做。回想一下，当我们创建我们的模型时，我们在数据库模式中使用了snake_case，但所有我们的JavaScript代码都使用camelCase。总体来说，我们在这里有三个选项：
- en: Refactor our schema to use camelCase. This will make our SQL uglier because
    we have to remember to quote our property names correctly.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构我们的模式以使用camelCase。这将使我们的SQL更加丑陋，因为我们必须记得正确引用我们的属性名。
- en: Use snake_case in our JavaScript. This is less than ideal because we like standards
    (right?).
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的JavaScript中使用snake_case。虽然这不是理想的，因为我们喜欢标准（对吧？）。
- en: Use snake_case on the database side, and translate to camelCase on the JavaScript
    side. This is more work that we have to do, but it keeps our SQL and our JavaScript
    pristine.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数据库端使用snake_case，而在JavaScript端转换为camelCase。这是我们必须做的更多工作，但它可以保持我们的SQL和JavaScript的整洁。
- en: Fortunately, the third option can be done automatically. We could write our
    own function to do that translation, but we’ll rely on a popular utility library
    called [Lodash](https://lodash.com), which makes it extremely easy. Just run `npm
    install lodash` to install it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，第三个选项可以自动完成。我们可以编写自己的函数来进行翻译，但我们将依赖于一个流行的实用库称为[Lodash](https://lodash.com)，这使得操作变得非常简单。只需运行`npm
    install lodash`来安装它。
- en: 'Right now, our database needs are very modest. All we need to do is fetch all
    available vacation packages, so our *db.js* file will look like this (*ch13/01-postgres/db.js*
    in the companion repo):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的数据库需求非常简单。我们只需要获取所有可用的度假套餐，因此我们的*db.js*文件看起来像这样（*ch13/01-postgres/db.js*在配套存储库中）：
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Short and sweet! We’re exporting a single method called `getVacations` that
    does as advertised. It also uses Lodash’s `mapKeys` and `camelCase` functions
    to convert our database properties to camelCase.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 简单明了！我们导出一个名为`getVacations`的单一方法，它按照广告所述执行。它还使用了Lodash的`mapKeys`和`camelCase`函数将我们的数据库属性转换为camelCase。
- en: 'One thing to note is that we have to handle the `price` attribute carefully.
    PostgreSQL’s `money` type is converted to an already-formatted string by the `pg`
    library. And for good reason: as we’ve already discussed, JavaScript has only
    recently added support for arbitrary precision numeric types (`BigInt`), but there
    isn’t yet a PostgreSQL adapter that takes advantage of that (and it might not
    be the most efficient data type in any event). We could change our database schema
    to use a numeric type instead of the `money` type, but we shouldn’t let our frontend
    choices drive our schema. We could also deal with the preformatted strings that
    are being returned from `pg`, but then we would have to change all of our existing
    code, which is relying on `price` being a number. Furthermore, that approach would
    undermine our ability to do numeric calculations on the frontend (such as summing
    the prices of the items in your cart). For all of these reasons, we’re opting
    to parse the string to a number when we retrieve it from the database.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，我们必须小心处理 `price` 属性。PostgreSQL 的 `money` 类型通过 `pg` 库转换为已经格式化的字符串。这是有充分理由的：正如我们已经讨论过的，JavaScript
    最近才添加了对任意精度数值类型（`BigInt`）的支持，但目前还没有一个 PostgreSQL 适配器能够利用它（并且在任何情况下这可能也不是最高效的数据类型）。我们可以改变我们的数据库模式，使用数值类型而不是
    `money` 类型，但我们不应该让我们的前端选择来驱动我们的模式。我们也可以处理从 `pg` 返回的预格式化字符串，但这样做会导致我们所有现有的依赖于 `price`
    为数字的代码都需要改变。此外，这种方法会削弱我们在前端执行数值计算的能力（例如对购物车中商品价格求和）。基于这些原因，我们选择在从数据库检索数据时将字符串解析为数字。
- en: We also take our location information—which is “flat” in the table—and turn
    it into a more JavaScript-like structure. We’re doing this only to achieve parity
    with our MongoDB example; we could use the data structured as it is (or modify
    our MongoDB example to have a flat structure).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将我们的位置信息（“平面”在表中）转换为更接近 JavaScript 结构的形式。我们这样做只是为了与我们的 MongoDB 示例保持一致；我们可以使用其现有的结构（或修改我们的
    MongoDB 示例以具有平面结构）。
- en: The last thing we need to learn to do with PostgreSQL is to update data, so
    let’s fill in the “vacation in season” listener feature.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要学习的最后一件事是如何使用 PostgreSQL 更新数据，所以让我们填写“旺季假期”侦听器功能。
- en: Adding Data
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加数据
- en: 'As with the MongoDB example, we’ll use our “vacation in season” listener example.
    We’ll start by adding the following data definition to the `createScript` string
    in *db-init.js*:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 MongoDB 示例一样，我们将使用我们的“旺季假期”侦听器示例。我们将首先在 *db-init.js* 的 `createScript` 字符串中添加以下数据定义：
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Remember that we took care to write *db-init.js* in a nondestructive fashion
    so we could run it at any time. So we can just run it again to create the `vacation_in_season_listeners`
    table.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们小心地以非破坏性的方式编写了 *db-init.js*，这样我们可以随时运行它。因此，我们可以再次运行它来创建 `vacation_in_season_listeners`
    表。
- en: 'Now we can modify *db.js* to include a method to update this table:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以修改 *db.js* 来包含一个更新这个表的方法：
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: PostgreSQL’s `ON CONFLICT` clause essentially enables upserts. In this case,
    if the exact combination of email and SKU is already present, the user has already
    registered to be notified, so we don’t need to do anything. If we had other columns
    in this table (such as the date of last registration), we might want to use a
    more sophisticated `ON CONFLICT` clause (see the [PostgreSQL INSERT documentation](http://bit.ly/3724FJI)
    for more information). Note also that this behavior is dependent on the way we
    defined the table. We made email and SKU a composite primary key, meaning that
    there can’t be any duplicates, which in turn necessitated the `ON CONFLICT` clause
    (otherwise, the `INSERT` command would result in an error the second time a user
    tried to register for a notification on the same vacation).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL 的 `ON CONFLICT` 子句实际上启用了 upserts。在这种情况下，如果邮箱和 SKU 的确切组合已经存在，用户已经注册以便收到通知，因此我们无需采取任何行动。如果我们在表中有其他列（例如上次注册日期），我们可能需要使用更复杂的
    `ON CONFLICT` 子句（有关更多信息，请参阅 [PostgreSQL INSERT documentation](http://bit.ly/3724FJI)）。还要注意，此行为取决于我们如何定义表格。我们将邮箱和
    SKU 定义为复合主键，这意味着不能有重复，这进而需要 `ON CONFLICT` 子句（否则，当用户尝试在同一个假期上注册通知时，`INSERT` 命令会导致错误）。
- en: 'Now we’ve seen a complete example of hooking up two types of databases, an
    object database and an RDBMS. It should be clear that the function of the database
    is the same: storing, retrieving, and updating data in a consistent and scalable
    fashion. Because the function is the same, we were able to create an abstraction
    layer so we could choose a different database technology. The last thing we might
    need a database for is for persistent session storage, which we hinted at in [Chapter 9](ch09.xhtml#ch_cookies_and_sessions).'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何连接两种类型的数据库的完整示例，一个是对象数据库，另一个是关系数据库管理系统（RDBMS）。可以清楚地看到数据库的功能是一样的：以一种一致和可扩展的方式存储、检索和更新数据。由于功能相同，我们能够创建一个抽象层，以便选择不同的数据库技术。我们可能需要一个数据库的最后一件事是用于持久化会话存储，这在[第
    9 章](ch09.xhtml#ch_cookies_and_sessions)中有所提及。
- en: Using a Database for Session Storage
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数据库进行会话存储
- en: As we discussed in [Chapter 9](ch09.xhtml#ch_cookies_and_sessions), using a
    memory store for session data is unsuitable in a production environment. Fortunately,
    it’s easy to use a database as a session store.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第 9 章](ch09.xhtml#ch_cookies_and_sessions)中讨论的那样，在生产环境中使用内存存储会话数据是不合适的。幸运的是，使用数据库作为会话存储是很容易的。
- en: While we could use our existing MongoDB or PostgreSQL database for a session
    store, a full-blown database is overkill for session storage, which is a perfect
    use case for a key-value database. As I write this, the most popular key-value
    databases for session stores are [Redis](https://redis.io) and [Memcached](https://memcached.org).
    In keeping with the other examples in this chapter, we’ll be using a free online
    service to provide a Redis database.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以使用现有的MongoDB或PostgreSQL数据库作为会话存储，但完整的数据库对于会话存储来说可能有些过度，对于键值数据库来说却是一个完美的使用案例。截至我写这篇文章时，用于会话存储的最流行的键值数据库是[Redis](https://redis.io)和[Memcached](https://memcached.org)。与本章中的其他示例保持一致，我们将使用一个免费的在线服务来提供Redis数据库。
- en: Start by heading over to [Redis Labs](https://redislabs.com) and create an account.
    Then create a free subscription and plan. Choose Cache for the plan and give the
    database a name; you can leave the rest of the settings at their defaults.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请访问[Redis Labs](https://redislabs.com)，创建一个账户。然后创建一个免费的订阅计划。选择缓存作为计划，并给数据库起个名字；其余的设置可以保持默认。
- en: 'You’ll reach a View Database screen, and, as I write this, the critical information
    doesn’t populate for a few seconds, so be patient. What you’ll want is the Endpoint
    field and the Redis Password under Access Control & Security (it’s hidden by default,
    but there’s a little button next to it that will show it). Take these and put
    them in your *.credentials.development.json* file:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您将会看到一个查看数据库的屏幕，就我所知，关键信息需要几秒钟才能显示，请耐心等待。您需要的是端点字段和访问控制与安全下的Redis密码（默认情况下是隐藏的，但旁边有一个按钮可以显示它）。将它们放入您的*.credentials.development.json*文件中：
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Note the slightly odd URL: normally there would be a username before the colon
    preceding your password, but Redis allows connection with a password only; the
    colon that separates username from password is still required, however.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个稍微奇怪的URL：通常在密码前面会有一个用户名，但Redis允许仅使用密码连接；然而，在密码前的冒号仍然是必需的。
- en: 'We’ll be using a package called `connect-redis` to provide Redis session storage.
    Once you’ve installed it (`npm install connect-redis`), we can set it up in our
    main application file. We still use `expression-session`, but now we pass a new
    property to it, `store`, which configures it to use a database. Note that we have
    to pass `expressSession` to the function returned from `connect-redis` to get
    the constructor: this is a pretty common quirk of session stores (*ch13/00-mongodb/meadowlark.js*
    or *ch13/01-postgres/meadowlark.js* in the companion repo):'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个叫做`connect-redis`的包来提供Redis会话存储。一旦你安装了它（`npm install connect-redis`），我们就可以在主应用程序文件中设置它。我们仍然使用`express-session`，但现在我们传递一个新的属性`store`给它，这将配置它使用数据库。请注意，我们必须将`expressSession`传递给从`connect-redis`返回的函数，以获取构造函数：这是会话存储的一个常见特性（在伴随代码库的*ch13/00-mongodb/meadowlark.js*或*ch13/01-postgres/meadowlark.js*中）：
- en: '[PRE27]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Let’s use our newly minted session store for something useful. Imagine we want
    to be able to display vacation prices in different currencies. Furthermore, we
    want the site to remember the user’s currency preference.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将我们新建的会话存储用于实际的用途。假设我们希望能够以不同的货币显示度假价格。此外，我们希望网站记住用户的货币偏好。
- en: 'We’ll start by adding a currency picker at the bottom of our vacations page:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从在度假页面底部添加一个货币选择器开始：
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now here’s a little CSS (you can put this inline in your *views/layouts/main.handlebars*
    file or link to a CSS file in your *public* directory):'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看一些 CSS 代码（你可以将其嵌入到 *views/layouts/main.handlebars* 文件中，或者链接到 *public* 目录下的
    CSS 文件中）：
- en: '[PRE29]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Lastly, we’ll add a route handler to set the currency and modify our route
    handler for */vacations* to display prices in the current currency (*ch13/00-mongodb/lib/handlers.js*
    or *ch13/01-postgres/lib/handlers.js* in the companion repo):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将添加一个路由处理程序来设置货币，并修改我们的 */vacations* 路由处理程序以在当前货币中显示价格（*ch13/00-mongodb/lib/handlers.js*
    或者 *ch13/01-postgres/lib/handlers.js* 在配套代码库中）：
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You’ll also have to add a route for setting the currency in *meadowlark.js*:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要在 *meadowlark.js* 中添加一个设置货币的路由：
- en: '[PRE31]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This isn’t a great way to perform currency conversion, of course. We would want
    to utilize a third-party currency conversion API to make sure our rates are up-to-date.
    But this will suffice for demonstration purposes. You can now switch between the
    various currencies and—go ahead and try it—stop and restart your server. You’ll
    find it remembers your currency preference! If you clear your cookies, the currency
    preference will be forgotten. You’ll notice that now we’ve lost our pretty currency
    formatting; it’s now more complicated, and I will leave that as an exercise for
    the reader.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不是执行货币转换的好方法。我们希望利用第三方货币转换 API 来确保我们的汇率是最新的。但这对于演示目的已经足够了。你现在可以在各种货币之间切换，并且——试试看——停止和重新启动你的服务器。你会发现它记住了你的货币偏好！如果清除了你的
    Cookie，货币偏好将被遗忘。你会注意到，现在我们失去了我们漂亮的货币格式化；现在它更加复杂，我将把这留给读者作为一个练习。
- en: Another reader’s exercise would be to make the `set-currency` route general-purpose
    to make it more useful. Currently, it will always redirect to the vacations page,
    but what if you wanted to use it on a shopping cart page? See if you can think
    of one or two ways of solving this problem.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个读者的练习是将 `set-currency` 路由通用化，使其更有用。目前，它总是重定向到度假页面，但如果你想在购物车页面上使用它呢？看看你能不能想出一两种解决这个问题的方法。
- en: If you look in your database, you’ll find there’s a new collection called *sessions*.
    If you explore that collection, you’ll find a document with your session ID (property
    `sid`) and your currency preference.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看你的数据库，你会发现有一个名为 *sessions* 的新集合。如果你探索该集合，你会找到一个带有你的会话 ID（属性 `sid`）和你的货币偏好的文档。
- en: Conclusion
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: We’ve certainly covered a lot of ground in this chapter. For most web applications,
    the database is at the heart of what makes the application useful. Designing and
    tuning databases is a vast topic that could span many books, but I hope this has
    given you the basic tools you need to connect two types of databases and move
    data around.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们确实涵盖了很多内容。对于大多数 Web 应用程序来说，数据库是使应用程序有用的核心。设计和调优数据库是一个广泛的主题，可能需要多本书来覆盖，但我希望这为你提供了连接两种类型数据库和移动数据所需的基本工具。
- en: Now that we have this fundamental piece in place, we’re going to revisit routing
    and the importance it plays in web applications.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经放置了这个基本的部分，我们将重新访问路由和它在 Web 应用中的重要性。
