- en: Chapter 15\. Type Operations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第15章。类型操作
- en: Conditionals, maps
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 条件语句，映射
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: With great power over types
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 拥有强大的类型控制能力
- en: ''
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: comes great confusion
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 伴随着巨大的混淆而来
- en: TypeScript gives us awesome levels of power to define types in the type system.
    Even the logical modifiers from [Chapter 10, “Generics”](ch10.xhtml#generics_chapter)
    pale in comparison to the capabilities of the type operations in this chapter.
    Once you’ve completed this chapter, you’ll be able to mix, match, and modify types
    based on other types—giving you powerful ways to represent types in the type system.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 在类型系统中为我们提供了强大的类型定义能力。即使是来自[第10章，“泛型”](ch10.xhtml#generics_chapter)的逻辑修饰符，也无法与本章中类型操作的能力相比。完成本章后，您将能够基于其他类型混合、匹配和修改类型，从而为类型系统提供强大的表示方式。
- en: Warning
  id: totrans-7
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'Most of these fancy types are techniques you generally don’t want to use very
    frequently. You’ll want to understand them for the cases where they are useful,
    but beware: they can be difficult to read through when overused. Have fun!'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这些花里胡哨的类型技术通常不是您经常使用的技术。您需要理解它们在有用情况下的用法，但请注意：如果过度使用，它们可能会难以阅读。祝您愉快！
- en: Mapped Types
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射类型
- en: 'TypeScript provides syntax for creating a new type based on the properties
    of another type: in other words, *mapping* from one type to another. A *mapped
    type* in TypeScript is a type that takes in another type and performs some operation
    on each property of that type.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 提供了一种语法，用于基于另一个类型的属性创建一个新类型：换句话说，*映射*从一个类型到另一个类型。在 TypeScript 中，*映射类型*是一种接受另一个类型并对该类型的每个属性执行某些操作的类型。
- en: 'Mapped types create a new type by creating a new property under each key in
    a set of keys. They use a syntax similar to index signatures, but instead of using
    a static key type with `:` like `[i: string]`, they use a computed type from the
    other type with `in` like `[K in OriginalType]`:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '映射类型通过在一组键的每个键下创建一个新属性来创建一个新类型。它们使用类似于索引签名的语法，但是不是使用像`[i: string]`那样的静态键类型，而是使用与`in`一起的来自其他类型的计算类型，比如`[K
    in OriginalType]`：'
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'One common use case for mapped types is to create an object whose keys are
    each of the string literals in an existing union type. This `AnimalCounts` type
    creates a new object type where the keys are each of the values from the `Animals`
    union type and each of the values is `number`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 映射类型的一个常见用例是创建一个对象，其键是现有联合类型中的每个字符串字面量。这个`AnimalCounts`类型创建了一个新的对象类型，其中键是`Animals`联合类型中的每个值，而每个值都是`number`：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Mapped types based on existing literals of unions are a convenient way to save
    space in declaring big interfaces. But mapped types really shine when they can
    act on other types and even add or remove modifiers from members.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 基于联合类型现有文字的映射类型是声明大型接口时节省空间的便捷方式。但是映射类型真正发光的时候，是它们能够作用于其他类型，甚至添加或删除成员修饰符时。
- en: Mapped Types from Types
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从类型映射类型
- en: Mapped types commonly act on existing types using the `keyof` operator to grab
    the keys of that existing type. By instructing a type to map over the keys of
    an existing type, we can *map* from that existing type to a new one.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 映射类型通常使用`keyof`运算符对现有类型进行操作，以抓取该现有类型的键。通过指示一个类型在现有类型的键上进行映射，我们可以从该现有类型映射到一个新类型。
- en: 'This `AnimalCounts` type ends up being the same as the `AnimalCounts` type
    from before by mapping from the `AnimalVariants` type to a new equivalent one:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`AnimalCounts`类型最终与之前的`AnimalCounts`类型相同，通过从`AnimalVariants`类型映射到一个新的等效类型：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The new type keys mapped over a `keyof`—named `K` in the previous snippets—are
    known to be keys of the original type. That means each mapped type member value
    is allowed to reference the original type’s corresponding member value under the
    same key.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，`keyof`命名为`K`的新类型键已知是原始类型的键。这意味着每个映射类型成员值都允许引用原始类型相同键下的成员值。
- en: If the original object is `SomeName` and the mapping is `[K in keyof SomeName]`,
    then each member in the mapped type would be able to refer to the equivalent `SomeName`
    member’s value as `SomeName[K]`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果原始对象是`SomeName`，映射是`[K in keyof SomeName]`，那么映射类型中的每个成员都可以引用等效的`SomeName`成员值，作为`SomeName[K]`。
- en: 'This `NullableBirdVariants` type takes an original `BirdVariants` type and
    adds `| null` to each member:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`NullableBirdVariants`类型接受一个原始的`BirdVariants`类型，并为每个成员添加`| null`：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Instead of painstakingly copying each field from an original type to any number
    of other types, mapped types let you define a set of members once and re-create
    new versions of them en masse as many times as you need.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 与手动复制原始类型的每个字段相比，映射类型允许您一次定义一组成员，并根据需要批量重新创建它们的新版本。
- en: Mapped types and signatures
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射类型和签名
- en: 'In [Chapter 7, “Interfaces”](ch07.xhtml#interfaces), I introduced that TypeScript
    provides two ways of declaring interface members as functions:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 7 章，“接口”](ch07.xhtml#interfaces) 中，我介绍了 TypeScript 提供的两种将接口成员声明为函数的方式：
- en: '*Method* syntax, like `member(): void`: declaring that a member of the interface
    is a function intended to be called as a member of the object'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Method* 语法，如 `member(): void`：声明接口成员是一个函数，预期作为对象的成员进行调用'
- en: '*Property* syntax, like `member: () => void`: declaring that a member of the
    interface is equal to a standalone function'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Property* 语法，如 `member: () => void`：声明接口成员等同于一个独立的函数'
- en: Mapped types don’t distinguish between method and property syntaxes on object
    types. Mapped types treat methods as properties on original types.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Mapped types don’t distinguish between method and property syntaxes on object
    types. Mapped types treat methods as properties on original types.
- en: 'This `ResearcherProperties` type contains both the `property` and `method`
    members of `Researcher`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这种 `ResearcherProperties` 类型包含了 `Researcher` 的 `property` 和 `method` 成员：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The distinction between methods and properties does not show up very often in
    most practical TypeScript code. It’s rare to find a practical use of a mapped
    type that takes in a class type.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数实际的 TypeScript 代码中，方法和属性之间的区别并不常见。很少能找到一个将类类型作为输入的映射类型的实际用途。
- en: Changing Modifiers
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改修饰符
- en: Mapped types can also change the access control modifiers—`readonly` and `?`
    optionality—on the original type’s members. `readonly` or `?` can be placed on
    members of mapped types using the same syntax as typical interfaces.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 映射类型还可以改变原始类型成员的访问控制修饰符——`readonly` 和 `?` 可选性。可以使用与典型接口相同的语法将 `readonly` 或 `?`
    放在映射类型的成员上。
- en: 'The following `ReadonlyEnvironmentalist` type makes a version of the `Environmentalist`
    interface with all members given `readonly`, while `OptionalReadonlyConservationist`
    goes one step further and makes another version that adds `?` to all the `ReadonlyEnvironmentalist`
    members:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的 `ReadonlyEnvironmentalist` 类型创建了一个带有所有成员 `readonly` 的 `Environmentalist`
    接口的版本，而 `OptionalReadonlyConservationist` 更进一步，生成另一个版本，并对所有 `ReadonlyEnvironmentalist`
    成员添加了 `?`：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-37
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `OptionalReadonlyEnvironmentalist` type could alternately be written with
    `readonly [K in keyof Environmentalist]?: Environmentalist[K]`.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`OptionalReadonlyEnvironmentalist` 类型可以使用 `readonly [K in keyof Environmentalist]?:
    Environmentalist[K]` 的方式进行替代。'
- en: Removing modifiers is done by adding a `-` before the modifier in a new type.
    Instead of writing `readonly` or `?:`, you can write `-readonly` or `-?:`, respectively.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在新类型中修饰符之前添加 `-` 来删除修饰符。可以分别使用 `-readonly` 或 `-?:` 来代替 `readonly` 或 `?:`。
- en: 'This `Conservationist` type contains `?` optional and/or `readonly` members
    that are made writable in `WritableConservationist` and then also required in
    `RequiredWritableConservationist`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这种 `Conservationist` 类型包含了一些 `?` 可选和/或 `readonly` 成员，在 `WritableConservationist`
    中这些成员变为可写，并在 `RequiredWritableConservationist` 中也被要求：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-42
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `RequiredWritableConservationist` type could alternately be written with
    `-readonly [K in keyof Conservationist]-?:` `Conservationist[K]`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种写法是使用 `-readonly [K in keyof Conservationist]-?:` `Conservationist[K]` 来替代
    `RequiredWritableConservationist` 类型。
- en: Generic Mapped Types
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用映射类型
- en: The full power of mapped types comes from combining them with generics, allowing
    a single kind of mapping to be reused across different types. Mapped types are
    able to access the `keyof` any type name in their scope, including a type parameter
    on the mapped type itself.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 映射类型的全部威力来自与泛型的结合，允许在不同类型之间重复使用单一映射类型。映射类型能够访问其范围内的任何类型名称的 `keyof`，包括映射类型本身的类型参数。
- en: Generic mapped types are frequently useful for representing how data morphs
    as it flows through an application. For example, it may be desirable for an area
    of the application to be able to take in values of existing types but not be allowed
    to modify the data.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型映射类型经常用于表示数据在应用程序中流动时的变形方式。例如，可能希望应用程序的某个区域能够接收现有类型的值，但不允许修改数据。
- en: 'This `MakeReadonly` generic type takes in any type and creates a new version
    with the `readonly` modifier added to all its members:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这种 `MakeReadonly` 泛型类型接收任何类型，并创建一个在其所有成员上添加 `readonly` 修饰符的新版本。
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Another transform developers commonly need to represent is a function that takes
    in any amount of an interface and returns a fully filled-out instance of that
    interface.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个开发人员通常需要表示的转换是接受接口的任意数量并返回该接口的完全填充实例的函数。
- en: 'The following `MakeOptional` type and `createGenusData` function allow for
    providing any amount of the `GenusData` interface and getting back an object with
    the defaults filled in:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的`MakeOptional`类型和`createGenusData`函数允许提供任意数量的`GenusData`接口，并返回一个填充了默认值的对象：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Some operations done by generic mapped types are so useful that TypeScript provides
    utility types for them out-of-the-box. Making all properties optional, for example,
    is achievable using the built-in `Partial<T>` type. You can find a list of those
    built-in types on [*https://www.typescriptlang.org/docs/handbook/utility-types.html*](https://www.typescriptlang.org/docs/handbook/utility-types.html).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一些由泛型映射类型完成的操作非常有用，TypeScript提供了它们的实用类型。例如，使用内置的`Partial<T>`类型可以使所有属性变为可选。您可以在[*https://www.typescriptlang.org/docs/handbook/utility-types.html*](https://www.typescriptlang.org/docs/handbook/utility-types.html)上找到这些内置类型的列表。
- en: Conditional Types
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件类型
- en: Mapping existing types to other types is nifty, but we haven’t yet added logical
    conditions into the type system. Let’s do that now.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 映射现有类型到其他类型是很巧妙的，但是我们尚未将逻辑条件加入类型系统。现在让我们来做这件事。
- en: 'TypeScript’s type system is an example of a *logic programming language*. It
    allows creating new constructs (types) based on logically checking previous types.
    It does so with the concept of a *conditional type*: a type that resolves to one
    of two possible types, based on an existing type.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript的类型系统是*逻辑编程语言*的一个例子。它允许基于逻辑检查先前的类型创建新的结构（类型）。它使用*条件类型*的概念来实现：一种根据现有类型解析为两种可能类型之一的类型。
- en: 'Conditional type syntax looks like ternaries:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 条件类型的语法看起来像三元运算符：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The logical check in a conditional type is always on whether the left type *extends*,
    or is assignable to, the right type.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 条件类型中的逻辑检查始终是左侧类型*是否扩展*或可分配给右侧类型。
- en: 'The following `CheckStringAgainstNumber` conditional type checks whether `string
    extends number`—or in other words, whether the `string` type is assignable to
    the `number` type. It’s not, so the resultant type is the “if false” case: `false`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的`CheckStringAgainstNumber`条件类型检查`string`是否*扩展*到`number`，换句话说，`string`类型是否可分配给`number`类型。它不行，因此结果类型是“如果为假”的情况：`false`：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Much of the rest of this chapter will involve combining other type system features
    with conditional types. As the code snippets get more complex, remember: each
    conditional type is purely a piece of boolean logic. Each takes in some type and
    results in one of two possible results.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的大部分内容将涉及将其他类型系统特性与条件类型结合使用。随着代码片段变得更加复杂，请记住：每个条件类型都仅仅是布尔逻辑的一部分。每个条件类型接受某种类型并产生两种可能的结果之一。
- en: Generic Conditional Types
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型条件类型
- en: Conditional types are able to check any type name in their scope, including
    a type parameter on the conditional type itself. That means you can write reusable
    generic types to create new types based on any other types.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 条件类型能够检查其范围内的任何类型名称，包括条件类型本身的类型参数。这意味着您可以编写可重用的泛型类型来基于任何其他类型创建新类型。
- en: 'Turning the previous `CheckStringAgainstNumber` type into a generic `CheckAgainstNumber`
    gives a type that is either `true` or `false` based on whether the previous type
    is assignable to `number`. `string` is still not true, while `number` and `0 |
    1` both are:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 将之前的`CheckStringAgainstNumber`类型转换为通用的`CheckAgainstNumber`类型，得到的类型是基于先前的类型是否可分配给`number`的`true`或`false`。`string`仍然是false，而`number`和`0
    | 1`则都是true。
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following `CallableSetting` type is a little more useful. It takes in a
    generic `T` and checks whether `T` is a function. If `T` is, then the resultant
    type is `T`—as with `GetNumbersSetting` where `T` is `() => number[]`. Otherwise,
    the resultant type is a function that returns `T`, as with `StringSetting` where
    `T` is `string`, and so the resultant type is `() => string`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的`CallableSetting`类型更实用一些。它接受一个泛型`T`并检查`T`是否为函数。如果是，则结果类型为`T`，就像`GetNumbersSetting`中`T`为`()
    => number[]`一样。否则，结果类型是返回`T`的函数，就像`StringSetting`中`T`为`string`一样，因此结果类型是`() =>
    string`：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Conditional types are also able to access members of provided types with the
    object member lookup syntax. They can use that information both in their `extends`
    clause and/or in the resultant types.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 条件类型也能够使用对象成员查找语法访问提供的类型的成员。它们可以在其`extends`子句中和/或在结果类型中使用这些信息。
- en: One pattern used by JavaScript libraries that lends itself well to conditional
    generic types is to change the return type of a function based on an options object
    provided to the function.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 库经常使用的一种模式非常适合条件泛型类型，即根据提供给函数的选项对象改变函数的返回类型。
- en: 'For example, many database functions or equivalents might use a property like
    `throwIfNotFound` to change the function to throw an error instead of returning
    `undefined` if a value isn’t found. The following `QueryResult` type models that
    behavior by resulting in the more narrow `string` instead of `string | undefined`
    if the options’ `throwIfNotFound` is specifically known to be `true`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，许多数据库函数或等效函数可能使用像`throwIfNotFound`这样的属性，通过更改函数在值未找到时抛出错误而不是返回`undefined`。以下的`QueryResult`类型通过特定情况下选项的`throwIfNotFound`知道是`true`，模拟了该行为，结果更窄的是`string`而不是`string
    | undefined`：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: By combining a conditional type with a generic type parameter, that `retrieve`
    function is more precise in telling the type system how it will change its program’s
    control flow.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将条件类型与泛型类型参数结合，`retrieve`函数更精确地告诉类型系统它将如何改变程序的控制流。
- en: Type Distributivity
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型分布性
- en: Conditional types *distribute* over unions, meaning their resultant type will
    be a union of applying that conditional type to each of the constituents (types
    in the union type). In other words, `ConditionalType<T | U>` is the same as `Conditional<T>
    | Conditional<U>`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 条件类型在联合类型上*分布*，这意味着它们的结果类型将是将该条件类型应用于联合类型中的每个成员（类型在联合类型中）。换句话说，`ConditionalType<T
    | U>`与`Conditional<T> | Conditional<U>`是相同的。
- en: Type distributivity is a mouthful to explain but is important for how conditional
    types behave with unions.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 类型分布性是一个解释起来比较啰嗦但对于条件类型在联合类型中的行为非常重要的概念。
- en: 'Consider the following `ArrayifyUnlessString` type that converts its type parameter
    `T` to an array unless `T extends string`. `HalfArrayified` is equivalent to `string
    | number[]` because `ArrayifyUnlessString<string | number>` is the same as `ArrayifyUnlessString<string>
    | ArrayifyUnlessString<number>`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下`ArrayifyUnlessString`类型，它将其类型参数`T`转换为一个数组，除非`T`扩展为`string`。`HalfArrayified`等同于`string
    | number[]`，因为`ArrayifyUnlessString<string | number>`与`ArrayifyUnlessString<string>
    | ArrayifyUnlessString<number>`相同：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If TypeScript’s conditional types didn’t distribute across unions, `HalfArrayified`
    would be `(string | number)[]` because `string | number` is not assignable to
    `string`. In other words, conditional types apply their logic to each constituent
    of a union type, not the whole union type.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 TypeScript 的条件类型不能在联合类型中分布，`HalfArrayified`将会是`(string | number)[]`，因为`string
    | number`不能赋值给`string`。换句话说，条件类型将其逻辑应用于联合类型的每个成员，而不是整个联合类型。
- en: Inferred Types
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 推断类型
- en: Accessing members of provided types works well for information stored as a member
    of a type, but it can’t capture other information such as function parameters
    or return types. Conditional types are able to access arbitrary portions of their
    condition by using an `infer` keyword within their extends clause. Placing the
    `infer` keyword and a new name for a type within an extends clause means that
    new type will be available inside the conditional type’s true case.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 访问提供类型的成员对作为类型成员存储的信息很有效，但无法捕获其他信息，如函数参数或返回类型。条件类型能够通过在其扩展子句中使用`infer`关键字来访问其条件的任意部分。在扩展子句中放置`infer`关键字和一个新类型的名称意味着新类型将在条件类型的真实情况中可用。
- en: 'This `ArrayItems` type takes in a type parameter `T` and checks whether the
    `T` is an array of some new `Item` type. If it is, the resultant type is `Item`;
    if not, it’s `T`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`ArrayItems`类型接受一个类型参数`T`，并检查`T`是否是某种新的`Item`类型的数组。如果是，结果类型就是`Item`；如果不是，就是`T`：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Inferred types can work to create recursive conditional types too. The `ArrayItems`
    type seen previously could be extended to retrieve the item type of an array of
    any dimensionality recursively:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 推断类型可以用来创建递归条件类型。之前见过的`ArrayItems`类型可以扩展到递归地检索任意维度数组的项类型：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that while `ArrayItems<string[][]>` resulted in `string[]`, `ArrayItemsRecursive<string[][]>`
    resulted in `string`. That ability for generic types to be recursive allows them
    to keep applying modifications—such as retrieving the element type of an array
    here.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管`ArrayItems<string[][]>`的结果是`string[]`，但`ArrayItemsRecursive<string[][]>`的结果是`string`。泛型类型能够递归的能力使它们能够持续应用修改，比如在此处检索数组元素类型。
- en: Mapped Conditional Types
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射的条件类型
- en: Mapped types apply a change to every member of an existing type. Conditional
    types apply a change to a single existing type. Put together, they allow for applying
    conditional logic to each member of a generic template type.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 映射类型将对现有类型的每个成员应用更改。条件类型将对单个现有类型应用更改。将它们组合在一起，允许对泛型模板类型的每个成员应用条件逻辑。
- en: 'This `MakeAllMembersFunctions` type turns each nonfunction member of a type
    into a function:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此 `MakeAllMembersFunctions` 类型将类型的每个非函数成员转换为函数：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Mapped conditional types are a convenient way to modify all properties of an
    existing type using some logical check.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 映射条件类型是一种方便的方法，用于使用一些逻辑检查修改现有类型的所有属性。
- en: never
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: never
- en: In [Chapter 4, “Objects”](ch04.xhtml#objects), I introduced the `never` type,
    a bottom type, which means it can have no possible values and can’t be reached.
    Adding a `never` type annotation in the right place can tell TypeScript to be
    more aggressive about detecting never-hit code paths in the type system as well
    as in the previous examples of runtime code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第四章，“对象”](ch04.xhtml#objects)中，我介绍了 `never` 类型，即底部类型，这意味着它不能有可能的值，也不能被访问。在类型系统以及之前的运行时代码示例中添加
    `never` 类型注释的合适位置可以告诉 TypeScript 更积极地检测到不可达的代码路径。
- en: never and Intersections and Unions
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: never 和交集和并集
- en: 'Another way of describing the `never` bottom type is that it’s a type that
    can’t exist. That gives `never` some interesting behaviors with `&` intersection
    and `|` union types:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 描述 `never` 底部类型的另一种方式是它是一个无法存在的类型。这使得 `never` 在与 `&` 交集和 `|` 联合类型一起具有一些有趣的行为：
- en: '`never` in an `&` intersection type reduces the intersection type to just `never`.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `&` 交集类型中的 `never` 将交集类型减少到 `never`。
- en: '`never` in a `|` union type is ignored.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `|` 联合类型中的 `never` 被忽略。
- en: 'These `NeverIntersection` and `NeverUnion` types illustrate those behaviors:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 `NeverIntersection` 和 `NeverUnion` 类型说明了这些行为：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In particular, the behavior of being ignored in union types makes `never` useful
    for filtering out values from conditional and mapped types.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是在联合类型中被忽略的行为使得 `never` 对从条件类型和映射类型中过滤值非常有用。
- en: never and Conditional Types
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: never 和条件类型
- en: Generic conditional types commonly use `never` to filter out types from unions.
    Because `never` is ignored in unions, the result of a generic conditional on a
    union of types will only be those that are not `never`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型条件类型通常使用 `never` 从联合类型中过滤出类型。因为在联合中忽略 `never`，所以对于类型联合的泛型条件的结果将只包括那些不是 `never`
    的类型。
- en: 'This `OnlyStrings` generic conditional type filters out types that aren’t strings,
    so the `RedOrBlue` type filters out `0` and `null` from the union:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此 `OnlyStrings` 泛型条件类型可过滤掉不是字符串的类型，因此 `RedOrBlue` 类型可从联合中过滤掉 `0` 和 `null`：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`never` is also commonly combined with inferred conditional types when making
    type utilities for generic types. Type inferences with `infer` have to be in the
    true case of a conditional type, so if the false case is never meant to be used,
    `never` is a suitable type to put there.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当为泛型类型制作类型工具时，`never` 通常与推断的条件类型结合使用。使用 `infer` 进行类型推断时必须位于条件类型的真实情况下，因此如果假设情况永远不会被使用，那么
    `never` 就是适合放置在那里的类型。
- en: 'This `FirstParameter` type takes in a function type `T`, checks if it’s a function
    with an `arg: infer Arg`, and returns that `Arg` if so:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '此 `FirstParameter` 类型接受一个函数类型 `T`，检查它是否为带有 `arg: infer Arg` 的函数，并在是的情况下返回该
    `Arg`：'
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Using `never` in the false case of the conditional type allowed `FirstParameter`
    to extract the type of the function’s first parameter.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在条件类型的假设情况中使用 `never` 允许 `FirstParameter` 提取函数第一个参数的类型。
- en: never and Mapped Types
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: never 和映射类型
- en: 'The `never` behavior in unions makes it useful for filtering out members in
    mapped types too. It’s possible to filter out keys of an object using the following
    three type system features:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 联合类型中的 `never` 行为也使其对在映射类型中过滤成员非常有用。通过以下三种类型系统特性可以过滤对象的键：
- en: '`never` is ignored in unions.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在联合类型中忽略 `never`。
- en: Mapped types can map members of types.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射类型可以映射类型的成员。
- en: Conditional types can be used to turn types into `never` if a condition is met.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件类型可用于在满足条件时将类型转换为 `never`。
- en: Putting the three of those together, we can create a mapped type that changes
    each member of the original type either to the original key or to `never`. Asking
    for the members of that type with `[keyof T]`, then, produces a union of all those
    mapped type results, filtering out `never`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 将这三者组合在一起，我们可以创建一个映射类型，将原始类型的每个成员更改为原始键或 `never`。然后使用 `[keyof T]` 来获取该类型的成员，从而生成所有这些映射类型结果的联合，过滤掉
    `never`。
- en: 'The following `OnlyStringProperties` type turns each `T[K]` member into either
    the `K` key if that member is a string, or `never` if not:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的`OnlyStringProperties`类型将每个`T[K]`成员转换为如果该成员是字符串，则为`K`键，否则为`never`：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Another way of reading the `OnlyStringProperties<T>` type is that it filters
    out all non-`string` properties (switches them to `never`), then gives back all
    the remaining keys (`[keyof T]`).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解读`OnlyStringProperties<T>`类型的方法是过滤掉所有非`string`属性（将它们转换为`never`），然后返回所有剩余的键（`[keyof
    T]`）。
- en: Template Literal Types
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板字面类型
- en: 'We’ve covered a lot on conditional and/or mapped types now. Let’s switch to
    less logic-intensive types and focus on strings for a while instead. So far I’ve
    brought up two strategies for typing string values:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了很多关于条件和/或映射类型的内容。现在让我们转向逻辑较少的类型，专注于字符串一段时间。到目前为止，我提到了两种为字符串值编写类型的策略：
- en: 'The primitive `string` type: for when the value can be any string in the world'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始的`string`类型：当值可以是世界上的任何字符串时使用
- en: 'Literal types such as `""` and `"abc"`: for when the value can only be that
    one type (or a union of them)'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串字面类型如`""`和`"abc"`：当值只能是这一种类型（或其联合体）时使用
- en: 'Sometimes, however, you may want to indicate that a string matches some string
    pattern: part of the string is known, but part of it is not. Enter *template literal
    types*, a TypeScript syntax for indicating that a string type adheres to a pattern.
    They look like template literal strings—hence their name—but with primitive types
    or unions of primitive types interpolated.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时您可能希望指示字符串匹配某些字符串模式：部分字符串已知，但部分字符串未知。输入*模板字面类型*，一种TypeScript语法，用于指示字符串类型符合模式。它们看起来像模板字面字符串一样——因此它们的名字——但插入了原始类型或原始类型的联合体。
- en: 'This template literal type indicates that the string must start with `"Hello"`
    but can end with any string (`string`). Names that start with `"Hello"` such as
    `"Hello, world!"` match, but not `"World! Hello!"` or `"hi"`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板字面类型指示字符串必须以`"Hello"`开头，但可以以任意字符串（`string`）结尾。以`"Hello"`开头的名称（如`"Hello, world!"`）匹配，但不匹配`"World!
    Hello!"`或`"hi"`：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: String literal types—and unions of them—may be used in the type interpolation
    instead of the catchall `string` primitive to restrict template literal types
    to more narrow patterns of strings. Template literal types can be quite useful
    for describing strings that must match a restricted set of allowed strings.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串字面类型及其联合体可以在类型插值中代替通用的`string`原始类型，以限制模板字面类型匹配更窄的字符串模式。模板字面类型非常适合描述必须匹配受限制的允许字符串集合的字符串。
- en: 'Here, `BrightnessAndColor` matches only strings that start with a `Brightness`,
    end with a `Color`, and have a `-` hyphen in-between:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`BrightnessAndColor`仅匹配以`Brightness`开头、以`Color`结尾且中间有`-`连字符的字符串：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Without template literal types, we would have had to laboriously write out all
    four combinations of `Brightness` and `Color`. That would get cumbersome if we
    added more string literals to either of them!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有模板字面类型，我们将不得不费力地写出所有`Brightness`和`Color`的四种组合。如果我们向其中任何一个添加更多的字符串字面类型，这将变得很繁琐！
- en: 'TypeScript allows template literal types to contain any primitives (other than
    `symbol`) or a union thereof: `string`, `number`, `bigint`, `boolean`, `null`,
    or `undefined`.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript允许模板字面类型包含任何原始类型（除了`symbol`）或其联合体：`string`、`number`、`bigint`、`boolean`、`null`或`undefined`。
- en: 'This `ExtolNumber` type allows any string that starts with `"much "`, includes
    a string that looks like a number, and ends with `"wow"`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此`ExtolNumber`类型允许任何以`"much "`开头、包含看起来像数字的字符串，并以`"wow"`结尾的字符串：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Intrinsic String Manipulation Types
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内在的字符串操作类型
- en: 'To assist in working with string types, TypeScript provides a small set of
    intrinsic (meaning: they’re built into TypeScript) generic utility types that
    take in a string and apply some operation to the string. As of TypeScript 4.7.2,
    there are four:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助处理字符串类型，TypeScript提供了一小组内置的通用实用类型，它们接受一个字符串并对该字符串应用某些操作。截至TypeScript 4.7.2，有四种类型：
- en: '`Uppercase`: Converts a string literal type to uppercase.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Uppercase`：将字符串字面类型转换为大写。'
- en: '`Lowercase`: Converts a string literal type to lowercase.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Lowercase`：将字符串字面类型转换为小写。'
- en: '`Capitalize`: Converts a first character of string literal type to uppercase.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Capitalize`：将字符串字面类型的首字母转换为大写。'
- en: '`Uncapitalize`: Converts a first character of string literal type to lowercase.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Uncapitalize`：将字符串字面类型的首字母转换为小写。'
- en: 'Each of these can be used as a generic type that takes in a string. For example,
    using `Capitalize` to capitalize the first letter in a string:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都可以作为接受字符串的泛型类型使用。例如，使用 `Capitalize` 来将字符串的第一个字母大写：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: These intrinsic string manipulation types can be quite useful for manipulating
    property keys on object types.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这些内置字符串操作类型在操作对象类型的属性键时非常有用。
- en: Template Literal Keys
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板文字键
- en: Template literal types are a half-way point between the primitive `string` and
    string literals, which means they’re still strings. They can be used in any other
    place where you’d be able to use string literals.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 模板文字类型介于原始的 `string` 和字符串文字之间，这意味着它们仍然是字符串。它们可以在任何其他可以使用字符串文字的地方使用。
- en: 'For example, you can use them as the index signature in a mapped type. This
    `ExistenceChecks` type has a key for every string in `DataKey`, mapped with `check${Capitalize<DataKey>}`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以将它们用作映射类型中的索引签名。此 `ExistenceChecks` 类型在 `DataKey` 中的每个字符串都有一个键，使用 `check${Capitalize<DataKey>}`
    进行映射：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Remapping Mapped Type Keys
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重映射映射类型键
- en: TypeScript allows you to create new keys for members of mapped types based on
    the original members using template literal types. Placing the `as` keyword followed
    by a template literal type for the index signature in a mapped typed changes the
    resultant type’s keys to match the template literal type. Doing so allows the
    mapped type to have a different key for each mapped property while still referring
    to the original value.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 允许您基于原始成员使用模板文字类型为映射类型的成员创建新的键。在映射类型中使用 `as` 关键字，后跟模板文字类型作为索引签名，可以将结果类型的键修改为与模板文字类型匹配。这样做允许映射类型为每个映射属性具有不同的键，同时仍然引用原始值。
- en: 'Here, `DataEntryGetters` is a mapped type whose keys are `getLocation`, `getName`,
    and `getYear`. Each key is mapped to a new key with a template literal type. Each
    mapped value is a function whose return type is a `DataEntry` using the original
    `K` key as a type argument:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`DataEntryGetters` 是一种映射类型，其键是 `getLocation`、`getName` 和 `getYear`。每个键都映射到一个具有模板文字类型的新键。每个映射值是一个函数，其返回类型是使用原始
    `K` 键作为类型参数的 `DataEntry`：
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Key remappings can be combined with other type operations to create mapped types
    that are based on existing type shapes. One fun combination is using `keyof typeof`
    on an existing object to make a mapped type off that object’s type.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 键重映可以与其他类型操作结合使用，以创建基于现有类型形状的映射类型。一个有趣的组合是在现有对象上使用 `keyof typeof` 来创建该对象类型的映射类型。
- en: 'This `ConfigGetter` type is based on the `config` type, but each field is a
    function that returns the original config, and the keys are modified from the
    original key:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 此 `ConfigGetter` 类型基于 `config` 类型，但每个字段都是返回原始配置的函数，并且键已从原始键修改：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Note that in JavaScript, object keys may be type `string` or `Symbol`—and `Symbol`
    keys aren’t usable as template literal types because they’re not primitives. If
    you try to use a remapped template literal type key in a generic type, TypeScript
    will issue a complaint that `symbol` can’t be used in a template literal type:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在 JavaScript 中，对象键可以是 `string` 或 `Symbol` 类型——而 `Symbol` 键不能用作模板文字类型，因为它们不是原始类型。如果尝试在泛型类型中使用重映模板文字类型键，TypeScript
    将会抱怨 `symbol` 不能用作模板文字类型：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To get around that restriction, you can use a `string &` intersection type
    to enforce that only types that can be strings are used. Because `string & symbol`
    results in `never`, the whole template string will reduce to `never` and TypeScript
    will ignore it:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个限制，您可以使用 `string &` 交集类型来强制只使用可以是字符串的类型。因为 `string & symbol` 的结果是 `never`，整个模板字符串将减少到
    `never`，TypeScript 将忽略它：
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: TypeScript’s behavior of filtering out `never` types from unions is proving
    itself useful yet again!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 从联合类型中过滤出 `never` 类型的行为再次证明其非常有用！
- en: Type Operations and Complexity
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型操作与复杂性
- en: Debugging is twice as hard as writing the code in the first place. Therefore,
    if you write the code as cleverly as possible, you are, by definition, not smart
    enough to debug it.
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 调试比一开始编写代码要难两倍。因此，如果您尽可能聪明地编写代码，那么您在定义上就不够聪明来调试它。
- en: ''
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Brian Kernighan
  id: totrans-159
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Brian Kernighan
- en: The type operations described in this chapter are among the most powerful, cutting-edge
    type system features in any programming language today. Most developers are not
    yet familiar enough with them to be able to debug errors in significantly complex
    uses of them. Industry-standard development tools such as IDE features I cover
    in [Chapter 12, “Using IDE Features”](ch12.xhtml#using_ide_features) aren’t generally
    made for visualizing multilayered type operations used with each other.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述的类型操作是当今任何编程语言中最强大、尖端的类型系统特性之一。大多数开发者对它们还不够熟悉，无法调试其复杂用法中的错误。像我在[第12章，“使用IDE功能”](ch12.xhtml#using_ide_features)中介绍的行业标准开发工具通常并不适用于可视化多层次的相互使用的类型操作。
- en: If you do find a need to use type operations, please—for the sake of any developer
    who has to read your code, including a future you—try to keep them to a minimum
    if possible. Use readable names that help readers understand the code as they
    read it. Leave descriptive comments for anything you think future readers might
    struggle with.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实需要使用类型操作，请为了任何阅读你代码的开发者（包括未来的你），尽量保持最少的使用。使用可读的名称帮助读者在阅读代码时理解。对于任何你认为未来的读者可能会遇到困难的地方，请留下描述性的注释。
- en: Summary
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, you unlocked the true power of TypeScript by operating on
    types in its type system:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，通过在其类型系统中操作类型，你揭示了 TypeScript 的真正力量：
- en: Using mapped types to transform existing types into new ones
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用映射类型将现有类型转换为新类型
- en: Introducing logic into type operations with conditional types
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类型操作中引入逻辑，使用条件类型
- en: Learning how `never` interacts with intersections, unions, conditional types,
    and mapped types
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习`never`如何与交集、并集、条件类型和映射类型相互作用
- en: Representing patterns of string types using template literal types
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模板字面类型表示字符串类型的模式
- en: Combining template literal types and mapped types to modify type keys
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合模板字面类型和映射类型来修改类型键
- en: Tip
  id: totrans-169
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Now that you’ve finished reading this chapter, practice what you’ve learned
    on [*https://learningtypescript.com/type-operations*](https://learningtypescript.com/type-operations).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完成了本章的阅读，请在[*https://learningtypescript.com/type-operations*](https://learningtypescript.com/type-operations)上练习你所学到的内容。
- en: When you’re lost in the type system, what do you use?
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当你在类型系统中迷失时，你会使用什么？
- en: ''
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A mapped type!
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个映射类型！
