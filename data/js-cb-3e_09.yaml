- en: Chapter 8\. Classes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 类
- en: Is JavaScript an object-oriented programming language? The answer depends on
    who you ask (and how you phrase the question). But the general consensus is *yes*,
    with some caveats.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是一种面向对象编程语言吗？答案取决于你问的是谁（以及你如何提问）。但一般的共识是*是*，尽管有些限制条件。
- en: Outside of academic circles, object-oriented programming languages usually revolve
    around concepts like classes, interfaces, and inheritance. But until recently,
    JavaScript was an outlier—an object-oriented programming language built on functions
    and *prototypes*. Then, along came ES6, and all of sudden classes were available
    as a native language construct, muddying the waters. Was it just syntactic sugar
    or a major language evolution?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在学术界之外，面向对象编程语言通常围绕类、接口和继承等概念展开。但直到最近，JavaScript一直是一个特例——一个建立在函数和*原型*上的面向对象编程语言。然后，ES6出现了，突然之间类作为一种本地语言结构就出现了，使情况变得复杂起来。它只是语法糖还是一次重大的语言演进呢？
- en: The answer lies somewhere in between. Overall, ES6 classes are a higher-level
    language feature built on the familiar foundation of JavaScript prototypes. But
    the mapping isn’t exact, and the class model introduces some new subtleties that
    aren’t completely captured in the prototype model. Furthermore, it’s likely that
    classes will support new object-oriented features in the future, pushing the two
    overlapping models farther apart.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 答案介于两者之间。总体而言，ES6类是建立在JavaScript原型的熟悉基础上的一种更高级的语言特性。但映射并非完全一致，类模型引入了一些新的细微差别，这些差别在原型模型中并没有完全体现出来。此外，很可能未来的类将支持新的面向对象特性，进一步拉开这两种重叠模型的差距。
- en: 'The bottom line is this: today new development favors using classes, but prototype-based
    code is still common (and far from obsolete). This chapter focuses on common patterns
    using classes, but also explores prototypes.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 底线是：如今，新的开发倾向于使用类，但基于原型的代码仍然普遍存在（远非过时）。本章重点介绍使用类的常见模式，同时也探讨了原型。
- en: Creating a Reusable Class
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建可重复使用的类
- en: Problem
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to create a reusable template for custom objects.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望为自定义对象创建一个可重复使用的模板。
- en: Solution
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use the `class` keyword, and give your class a name. Inside, add a constructor
    function that initializes your object. Here’s a complete `Person` class example:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`class`关键字，并为你的类取一个名字。在内部，添加一个构造函数来初始化你的对象。以下是一个完整的`Person`类示例：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this example, the `Person` class is a simple package that bundles together
    two public fields (`firstName` and `lastName`). But it’s easy enough to add methods
    to your class, which work like functions but don’t include the `function` keyword.
    Here’s how you would code a `Person.swapNames()` method:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，`Person`类是一个简单的包装，将两个公共字段（`firstName`和`lastName`）捆绑在一起。但是，很容易向你的类添加方法，这些方法像函数一样工作，但不包括`function`关键字。以下是如何编写`Person.swapNames()`方法的代码示例：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Discussion
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: In essence of a JavaScript class is the constructor function. In fact, behind
    the scenes a JavaScript class *is* a constructor function, and all methods are
    attached to that function’s *prototype*. That means that a method like `Person.swapNames()`
    is shared between all the instances of the `Person` class, because they share
    the same prototype. (To dig deeper into this behind-the-scenes reality, check
    out the constructor pattern in [“Using the Constructor Pattern to Make a Custom
    Class”](#constructor_pattern).)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript类的本质是构造函数。事实上，在幕后，JavaScript类*是*一个构造函数，并且所有方法都附加到该函数的*原型*上。这意味着像`Person.swapNames()`这样的方法在`Person`类的所有实例之间是共享的，因为它们共享同一个原型。（要深入了解这个幕后实现，请查看[“使用构造函数模式制作自定义类”](#constructor_pattern)中的构造函数模式。）
- en: 'Classes have their own syntax requirements that you must follow:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 类有其自己的语法要求，你必须遵循这些要求：
- en: Constructor functions are always named `constructor`.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数总是命名为`constructor`。
- en: Neither constructors nor methods use the keyword `function`, although they are
    declared like functions in every other respect.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论构造函数还是方法，都不使用关键字`function`，尽管在其他方面声明方式与函数相同。
- en: When you write a constructor, you use `this` to create new public fields on
    the current object. You can then refer to these fields wherever you need them
    in your class methods, as long as you remember to always prefix the variable name
    with `this`. You can also access these fields outside of the class code, using
    the familiar dot syntax.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写一个构造函数时，你使用`this`来在当前对象上创建新的公共字段。然后，在你的类方法中，无论何时需要，都可以引用这些字段，只要记得始终在变量名前加上`this`前缀。你还可以在类代码外部访问这些字段，使用熟悉的点语法。
- en: You might wonder how you can change this accessibility—say, make your fields
    private and wrap them with public properties. The answer is that currently you
    can’t—at least, not without a home brew solution that introduces complications
    of its own. For a full discussion of the subject, see [“Adding Properties to a
    Class”](#custom_class_properties).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道如何更改此可访问性——例如，使字段私有并用公共属性包装它们。答案是目前您无法做到这一点——至少不会引入自己的自制解决方案而带来其它复杂性。有关完整讨论，请参阅[“向类添加属性”](#custom_class_properties)。
- en: 'As with functions, JavaScript allows you to create classes in an *expression*.
    Here’s an example:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 与函数类似，JavaScript允许您在*表达式*中创建类。以下是一个示例：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is a specialized—but not rare—technique. It allows you to avoid adding
    a class to the current scope. For example, that might be useful in this example
    if you were worried that there might already be a definition for another `Person`
    class. (Another way to solve the problem of name collisions is by using modules,
    as described in [“Organizing Your JavaScript Classes with Modules”](#using_es6_modules).)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种专业的——但并非罕见的——技术。它允许您避免将类添加到当前作用域中。例如，在这个例子中，如果您担心可能已经有另一个`Person`类的定义，这可能会很有用。（解决名称冲突问题的另一种方法是使用模块，如[“使用ES6模块组织您的JavaScript类”](#using_es6_modules)所述。）
- en: See Also
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For the old-fashioned constructor pattern for object creation, see [“Using the
    Constructor Pattern to Make a Custom Class”](#constructor_pattern). To see how
    to create class properties, refer to [“Adding Properties to a Class”](#custom_class_properties).
    To learn how to connect classes in an inheritance relationship, see [“Inheriting
    Functionality from Another Class”](#custom_class_inheritance).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于老式的构造函数模式用于对象创建，请参阅[“使用构造函数模式创建自定义类”](#constructor_pattern)。要了解如何创建类属性，请参考[“向类添加属性”](#custom_class_properties)。要学习如何在继承关系中连接类，请参阅[“从另一个类继承功能”](#custom_class_inheritance)。
- en: 'Extra: Multiple Constructors'
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 额外内容：多个构造函数
- en: In most object-oriented languages it’s possible to create multiple constructors,
    so the code that creates the class has a choice of what parameters to specify.
    But JavaScript doesn’t support constructor overloading or method overloading.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数面向对象的语言中，可以创建多个构造函数，因此创建类的代码可以选择指定哪些参数。但JavaScript不支持构造函数重载或方法重载。
- en: 'This isn’t quite as limiting as it seems, because JavaScript is notoriously
    loose with function arguments and never forces you to supply them. So even though
    `Person` has a single three-argument constructor, these are all valid ways to
    create an instance without supplying every argument:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不像看起来的那样有限，因为JavaScript在处理函数参数时非常宽松，并且从不强制您提供它们。因此，即使`Person`有一个单独的三参数构造函数，以下都是创建实例的有效方法，而不必提供每个参数：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Every class has exactly one constructor, and it always runs. Even if you don’t
    specify any arguments when you create a `Person` object, the three-argument constructor
    still runs and sets `this.firstName`, `this.lastName`, and `this.birthDate` (all
    of which will be set to `undefined`). If this isn’t acceptable, you can set default
    parameter values, just as you do with ordinary functions (see [“Providing a Default
    Parameter Value”](ch06.html#provide_default_parameter)).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类都有且只有一个构造函数，并且它总是运行的。即使在创建`Person`对象时没有指定任何参数，三参数构造函数仍然会运行并设置`this.firstName`、`this.lastName`和`this.birthDate`（这些都将被设置为`undefined`）。如果这样不可接受，您可以设置默认参数值，就像在普通函数中一样（参见[“提供默认参数值”](ch06.html#provide_default_parameter)）。
- en: Note
  id: totrans-30
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you create a class without a constructor, JavaScript automatically gives
    it a blank no-argument constructor. This detail becomes significant if you decide
    to use class inheritance ([“Inheriting Functionality from Another Class”](#custom_class_inheritance)).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您创建一个没有构造函数的类，JavaScript会自动给它一个空的无参数构造函数。如果您决定使用类继承，这个细节将变得重要（参见[“从另一个类继承功能”](#custom_class_inheritance)）。
- en: 'Another way to deal with optional arguments is using an object literal that
    gets passed to the constructor. That way the caller can choose to set only the
    named properties they want to use:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 处理可选参数的另一种方法是使用传递给构造函数的对象字面量。这样调用者可以选择设置他们想要使用的命名属性：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is a common JavaScript design pattern that’s described in detail in [“Using
    Named Function Parameters”](ch06.html#named_parameters). One advantage it provides
    is that you don’t need to worry about the order of properties in the object literal.
    A disadvantage is that there’s nothing to prevent you from accidentally creating
    incorrectly named parameters that will be silently ignored:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种常见的JavaScript设计模式，详细描述在 [“使用命名函数参数”](ch06.html#named_parameters) 中。它提供的一个优点是你不需要担心对象字面量中属性的顺序。一个缺点是，没有任何东西可以防止你意外地创建错误命名的参数，这些参数将会被静默地忽略：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Another possible approach is to create a single constructor for your class,
    but add static methods that create differently configured instances of the object.
    Depending on the implementation, this is sometimes called the *builder pattern*
    or *factory pattern*. It’s described in [“Using a Static Method to Create Objects”](#factory_method).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能的方法是为您的类创建一个单一的构造函数，但添加静态方法来创建不同配置的对象实例。根据实现的不同，这有时被称为 *建造者模式* 或 *工厂模式*。它在
    [“使用静态方法创建对象”](#factory_method) 中有描述。
- en: Adding Properties to a Class
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加类属性
- en: Problem
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to add property getters and setters to wrap your class data.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望添加属性的获取器和设置器以包装类数据。
- en: Solution
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'First, consider if properties are the best solution for your use case. (As
    explained in the discussion, they have well-known limitations and are slightly
    controversial.) If you decide to use properties, you can create `get` and `set`
    methods for each one. Here’s an example with a computed property, called `age`,
    which is calculated from the date stored in `this.dateOfBirth`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，考虑属性是否是您用例的最佳解决方案。（正如讨论中所解释的那样，它们有众所周知的局限性，并且稍微有争议。）如果决定使用属性，可以为每个属性创建 `get`
    和 `set` 方法。这里有一个计算属性 `age` 的示例，它是从存储在 `this.dateOfBirth` 中的日期计算出来的：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It’s up to you whether you include only a getter, only a setter, or both. Here’s
    an example that uses the property pattern to apply basic validation to the date
    of birth:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由您决定是否仅包含获取器、仅包含设置器，或者两者都包含。这里有一个使用属性模式应用基本验证到出生日期的示例：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-45
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This example throws an exception ([“Throwing a Standard Error”](ch10.html#throwing_errors))
    to notify the caller when they attempt to set an invalid value. This is a reasonable
    design decision, but it’s not always the best choice. Having an error occur when
    setting a property (or even worse, when attempting to create a `Person` with an
    invalid date) is not expected behavior in JavaScript, and the potential error
    may not be anticipated by the calling code. (The alternative—silently ignoring
    the offending error—is also risky.) In the end, a better approach may be to use
    methods to supply potentially problematic data instead of properties.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例在试图设置无效值时抛出异常（[“抛出标准错误”](ch10.html#throwing_errors)），以通知调用者。这是一个合理的设计决策，但在JavaScript中，当尝试设置属性（甚至更糟的是，尝试使用无效日期创建
    `Person` 时）时发生错误不是预期的行为，并且调用代码可能未预料到可能的错误。（另一种选择——在设置属性时静默地忽略有问题的错误——也是有风险的。）最终，使用方法来提供潜在问题数据而不是属性可能是更好的方法。
- en: Discussion
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'There are many reasons you might consider creating property procedures. Some
    examples include:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多原因可能导致您考虑创建属性过程。一些例子包括：
- en: To calculate a value (like `Person.age`)
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算一个值（如 `Person.age`）
- en: To transform a field into another representation
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个字段转换为另一种表示形式
- en: To perform validation before updating a field
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在更新字段之前执行验证
- en: To add hooks for some other service (like logging or testing) that should happen
    every time a field is read or set
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为某些其他服务（如日志记录或测试）添加钩子，这些服务应在每次读取或设置字段时发生
- en: To use some kind of lazy initialization, which only creates or calculates a
    property value when it’s needed
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用某种惰性初始化，只有在需要时才创建或计算属性值
- en: To expose a single property of an object that’s stored in a field
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公开存储在字段中的对象的单个属性
- en: This recipe presents two examples. The `Person.age` property is a read-only
    computed property. The `Person.dateOfBirth` property is a settable property with
    validation.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 本篇介绍两个示例。`Person.age` 属性是只读的计算属性。`Person.dateOfBirth` 属性是带有验证的可设置属性。
- en: 'When you use properties, you must be careful to avoid name collisions. The
    field that stores the value cannot have the same name as the property or the constructor
    parameter. To understand why, let’s take a closer look at the `dateOfBirth` example.
    The constructor accepts a `date` parameter, which it sets like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用属性时，必须小心避免名称冲突。存储值的字段不能与属性或构造函数参数具有相同的名称。为了理解原因，让我们更仔细地看看`dateOfBirth`的例子。构造函数接受一个`date`参数，并像这样设置它：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'At first glance, you might assume this statement stores the date in a public
    field named `this.dateOfBirth` (which is the usual pattern). But in this case,
    `this.dateOfBirth` refers to the `dateOfBirth` property. Its setter takes over:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，您可能会认为此语句将日期存储在名为`this.dateOfBirth`的公共字段中（这是通常的模式）。但在这种情况下，`this.dateOfBirth`指的是`dateOfBirth`属性。其setter接管了：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If the new value passes the test, it’s stored in a public field named `this._dateOfBirth`.
    The awkward naming is necessary, because both `this.dateOfBirth` (the property)
    and `this._dateOfBirth` (the field) have the same scope. If you use the same name
    for both, you’ll end up calling the wrong one (and triggering an infinite sequences
    of calls that will eventually overflow the stack).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果新值通过测试，它将存储在名为`this._dateOfBirth`的公共字段中。这种笨拙的命名是必要的，因为`this.dateOfBirth`（属性）和`this._dateOfBirth`（字段）具有相同的作用域。如果两者使用相同的名称，您将会调用错误的那个（并触发无限调用序列，最终导致堆栈溢出）。
- en: The leading underscore in a variable name like `_dateOfBirth` has another purpose.
    Currently, JavaScript doesn’t have any way to create private fields. But the underscore
    signals that a field is *supposed* to be private to the class. Then, you trust
    that the calling code will avoid using this field. If you don’t follow this convention,
    you’re almost certain to run into a problem where the calling code accidentally
    uses the field instead of the property. And even if you *do* observe this pattern,
    there’s no guarantee that the calling code will follow it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 类似`_dateOfBirth`这样的变量名中的前导下划线还有另一个目的。目前，JavaScript没有任何创建私有字段的方法。但下划线表示该字段应该是类的私有字段。然后，您可以信任调用代码会避免使用这个字段。如果不遵循这种约定，几乎肯定会遇到问题，即调用代码意外使用字段而不是属性。即使遵循了这种模式，也不能保证调用代码会遵循它。
- en: 'Many JavaScript developers argue that a more natural pattern in JavaScript
    is to use `setXxx()` and `getXxx()` methods:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 许多JavaScript开发人员认为，在JavaScript中更自然的模式是使用`setXxx()`和`getXxx()`方法：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This approach is a bit more cumbersome, but it has some advantages. It makes
    it obvious that you’re calling a method and running code, not simply setting a
    variable. As a result, the calling code can expect exceptions from type-checking
    or other side effects. Methods also prevent problems like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有点繁琐，但有一些优点。它明确表明您正在调用方法并运行代码，而不仅仅是设置变量。因此，调用代码可以期望来自类型检查或其他副作用的异常。方法还可以防止这样的问题：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-66
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Both the [Google JavaScript Style Guide](https://google.github.io/styleguide/jsguide.html)
    and the often-consulted [Airbnb JavaScript Style Guide](https://github.com/airbnb/javascript)
    discourage the usage of property getters and setters but allow `setXxx()` and
    `getXxx()` methods.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[Google JavaScript Style Guide](https://google.github.io/styleguide/jsguide.html)和经常查阅的[Airbnb
    JavaScript Style Guide](https://github.com/airbnb/javascript)都不鼓励使用属性的getter和setter，但允许使用`setXxx()`和`getXxx()`方法。'
- en: There’s one more wrinkle to consider with properties. Behind the scenes, JavaScript
    uses the `Object.defineProperty()` method to implement your property getters and
    setters. Most of the time, that works perfectly well. However, there are specialized
    cases when you may decide to use `defineProperty()` because it allows you to configure
    metadata details you can’t otherwise set. For example, if you want to make a property
    nonconfigurable (so its implementation can’t be altered) or nonenumerable (so
    it won’t show up in a `for...in` loop), you need to explicitly call `defineProperty()`.
    In this situation, the usual approach is to call `defineProperty` in the constructor.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用属性时，还有一个要考虑的细微之处。在JavaScript内部，使用`Object.defineProperty()`方法来实现您的属性getter和setter。大多数情况下，这样做完全正常。但在特定情况下，您可能决定使用`defineProperty()`，因为它允许您配置无法以其他方式设置的元数据细节。例如，如果您想使属性不可配置（因此其实现不能被更改）或不可枚举（因此它不会在`for...in`循环中显示），您需要显式调用`defineProperty()`。在这种情况下，通常的做法是在构造函数中调用`defineProperty`。
- en: See Also
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: If you want to use property procedures to react to property changes and trigger
    other actions (like logging), consider using proxies instead ([“Intercepting and
    Changing Actions on an Object with a Proxy”](ch07.html#modifications_with_proxies)).
    For more about creating properties with `Object.defineProperty()`, see [“Customizing
    the Way a Property Is Defined”](ch07.html#creating_properties_with_define_property).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望使用属性程序来响应属性变化并触发其他操作（比如日志记录），考虑使用代理而不是（[“使用代理拦截和修改对象上的操作”](ch07.html#modifications_with_proxies)）。有关使用
    `Object.defineProperty()` 创建属性的更多信息，请参阅[“自定义属性定义方式”](ch07.html#creating_properties_with_define_property)。
- en: 'Extra: Private Fields'
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 额外：私有字段
- en: Currently, JavaScript does not have a way to make member variables (those created
    with `this`) private. Many workarounds are used, and many of them are dangerously
    creative. The most popular implementation uses a `WeakMap` to store internal data.
    It works, but it adds a dangerous layer of extra homemade complexity.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，JavaScript 没有办法使成员变量（使用 `this` 创建的变量）私有化。许多解决方案都在使用，并且其中许多都是非常有创意且危险的。最流行的实现使用
    `WeakMap` 来存储内部数据。它确实有效，但也增加了一层危险的自制复杂性。
- en: 'A better approach is to use the underscore convention (like `_firstName`) to
    name fields that should not be accessed outside a class. In the future, JavaScript
    will patch this gap and adopt some version of the [*private class fields* proposal](https://github.com/tc39/proposal-class-fields).
    Right now, the private field syntax uses a `#` to identify private fields, which
    can be declared at the beginning of your class block, making your class self documenting.
    Here’s what that looks like:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是使用下划线约定（如 `_firstName`）来命名那些不应在类外部访问的字段。未来，JavaScript 将弥补这一空缺并采纳某种版本的[*私有类字段*提案](https://github.com/tc39/proposal-class-fields)。目前，私有字段语法使用
    `#` 来标识私有字段，可以在类块的开头声明，使得你的类自说明性更强。具体如下所示：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you want to experiment with these features today, you can use [Babel](https://babeljs.io)
    to transpile your code, although be aware that the syntax may change.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要立即尝试这些功能，可以使用[Babel](https://babeljs.io)来转译你的代码，尽管请注意语法可能会发生变化。
- en: Interestingly, this is one case where JavaScript classes have *less* functionality
    than the old-fashioned constructor pattern ([“Using the Constructor Pattern to
    Make a Custom Class”](#constructor_pattern)). That’s because the constructor pattern
    can use closures to store private variables, as explained in [“Creating a Function
    That Stores its State with a Closure”](ch06.html#create_a_function_that_remembers_its_sta).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，在这种情况下，JavaScript 类的功能比老式的构造函数模式*更少*（[“使用构造函数模式创建自定义类”](#constructor_pattern)）。因为构造函数模式可以使用闭包来存储私有变量，如[“使用闭包存储其状态的函数”](ch06.html#create_a_function_that_remembers_its_sta)中所解释的。
- en: Giving a Class a Better String Representation
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 给类一个更好的字符串表示
- en: Problem
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to choose a suitable text representation that will be used for your
    object when it’s converted to a string.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当将对象转换为字符串时，你想选择一个合适的文本表示方式。
- en: Solution
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Add a method named `toString()` to your class and return the string you want
    to use:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的类中添加一个名为 `toString()` 的方法，并返回你想要使用的字符串：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Discussion
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The default implementation of `toString()` for all objects displays the unhelpful
    text `[object Object]`. You can set your own text by adding a `toString()` method.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 所有对象的默认 `toString()` 实现显示不太有帮助的文本 `[object Object]`。你可以通过添加 `toString()` 方法来设置自己的文本。
- en: 'The `toString()` method can be called explicitly (as in this example), or it
    can be called implicitly when your object is converted to a string. For example,
    if you concatenate your object with a string, `toString()` is called automatically:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`toString()` 方法可以显式调用（就像这个例子中一样），或者当你的对象转换为字符串时可以隐式调用。例如，如果你将你的对象与一个字符串连接，`toString()`
    就会自动调用：'
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'However, calling `console.log()` on an object, on its own, does not trigger
    your `toString()`. That’s because `console.log()` has an extra bit of logic that
    iterates over the properties of your object and uses that to build its own custom
    string. You can get around this by calling `toString()` yourself, or using a template
    literal ([“Using Template Literals for Clearer String Concatenation”](ch02.html#using_template_literals)).
    Here’s a comparison:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，仅对对象调用 `console.log()` 并不会触发你的 `toString()`。这是因为 `console.log()` 有额外的逻辑，遍历对象的属性并用其构建自定义字符串。你可以通过手动调用
    `toString()` 或使用模板字面量（[“使用模板字面量进行更清晰的字符串拼接”](ch02.html#using_template_literals)）来解决这个问题。下面是一个比较：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Using the Constructor Pattern to Make a Custom Class
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用构造函数模式创建自定义类
- en: Problem
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to create a reusable, class-like entity in your code. You want to use
    the traditional constructor pattern because it matches your existing code.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望在您的代码中创建一个可重用的类似类的实体。您希望使用传统的构造函数模式，因为它与您现有的代码匹配。
- en: Solution
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: The constructor pattern is a slightly dated but still acceptable pattern for
    object creation. Even if you plan to use formal classes ([“Creating a Reusable
    Class”](#using_es6_classes)), it’s worth knowing the constructor pattern, because
    you’re likely to encounter it out in the wild. It can also help you understand
    how JavaScript classes work.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数模式是一种稍微过时但仍然可接受的对象创建模式。即使您打算使用正式类（[“创建可重用类”](#using_es6_classes)），了解构造函数模式也很重要，因为您可能会在野外遇到它。它还可以帮助您理解JavaScript类的工作原理。
- en: 'Here’s one of the `Person` class examples from [“Creating a Reusable Class”](#using_es6_classes),
    but written as a function with the constructor pattern:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个来自[“使用ES6类”](#using_es6_classes)的`Person`类的示例，但按照构造函数模式编写：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice that the code for using a function-based object is the same as the code
    for using a class-based with an identical constructor. As a result, you can usually
    migrate code from the constructor pattern to formal classes without disrupting
    the rest of your application.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用基于函数的对象的代码与使用具有相同构造函数的基于类的代码相同。因此，通常可以将代码从构造函数模式迁移到正式类而不会破坏应用程序的其他部分。
- en: Discussion
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Classes were a relative latecomer to the JavaScript language. Before they existed,
    developers used functions in their place. This works because JavaScript allows
    you to create new *instances* of a function (function objects) using the `new`
    keyword. Every function gets its own scope, with its own local data.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 类是JavaScript语言的一个相对晚期的引入者。在类存在之前，开发人员使用函数来代替。这是因为JavaScript允许您使用`new`关键字创建函数的新*实例*（函数对象）。每个函数都有自己的作用域，具有自己的局部数据。
- en: The constructor pattern exists in several variants. The most common approach
    is to create a function with the name of your “class” and accept all the constructor
    parameters you need to create an instance. Inside your function, you use `this`
    to create public fields. You can also create ordinary variables, which won’t be
    visible to outside code, and are only usable by the constructor and any nested
    functions.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数模式存在多种变体。最常见的方法是创建一个函数，函数名为您的“类”的名称，并接受创建实例所需的所有构造函数参数。在函数内部，使用`this`来创建公共字段。您还可以创建普通变量，这些变量对外部代码不可见，仅由构造函数和任何嵌套函数使用。
- en: There are two common ways to create method-like functions. The approach shown
    here creates each method using a function expression, and makes them publicly
    accessible with `this`. Because the method functions are wrapped inside the constructor
    function, they have the same scope as the constructor, and they have access to
    all the same variables and local variables. (Technically, the constructor function
    creates a closure, as explained in [“Creating a Function That Stores its State
    with a Closure”](ch06.html#create_a_function_that_remembers_its_sta).)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种常见的方法来创建类似方法的函数。这里展示的方法使用函数表达式创建每个方法，并使用`this`使它们公开可访问。因为方法函数被包裹在构造函数内部，它们具有与构造函数相同的作用域，并且可以访问所有相同的变量和局部变量。
    （从技术上讲，构造函数创建了一个闭包，如在[“创建一个使用闭包存储其状态的函数”](ch06.html#create_a_function_that_remembers_its_sta)中所解释的。）
- en: The other way to create methods is to explicitly add them to the *prototype*
    of your constructor function. If you haven’t encountered prototypes yet, they’re
    a basic (but mostly hidden) ingredient that allows objects to share functionality.
    When you attempt to call a method (like `Person.swapNames()`), JavaScript looks
    for the `swapNames()` function in the `Person` constructor. If it doesn’t find
    it, JavaScript looks for a `swapNames()` function in the prototype. The process
    gets a bit more involved when inheritance is involved, because JavaScript will
    search an entire *prototype chain* looking for a function, as explained in [“Inheriting
    Functionality from Another Class”](#custom_class_inheritance).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 创建方法的另一种方式是将它们显式添加到构造函数的*原型*中。如果您尚未遇到原型，它们是一种基本（但大多数情况下隐藏的）组成部分，允许对象共享功能。当您尝试调用方法（如`Person.swapNames()`）时，JavaScript会查找`Person`构造函数中的`swapNames()`函数。如果找不到它，JavaScript会在原型中查找`swapNames()`函数。当涉及继承时，这个过程会变得更复杂，因为JavaScript会在整个*原型链*中搜索函数，如[“从另一个类继承功能”](#custom_class_inheritance)中所解释的。
- en: 'So how do you add a function to a prototype? You can do it directly, using
    the `prototype` property:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如何向原型添加函数呢？您可以直接使用`prototype`属性：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This example behaves mostly the same as the version with the nested constructor
    functions. But there is a difference. Before, the `swapNames()` existed independently
    in each `Person` object. Now, there is a single `swapNames()` function set in
    the prototype and shared among all `Person` instances. This is important if you
    plan to create an inheritance relationship linking prototypes together (see [“Extra:
    Prototype Chains”](#prototype_chains)). It’s also significant if you attempt to
    use private variables with a closure ([“Creating a Function That Stores its State
    with a Closure”](ch06.html#create_a_function_that_remembers_its_sta)), because
    functions attached to the prototype don’t exist in the same context as the constructor
    function, and won’t have access to private variables defined in the constructor.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的行为与嵌套构造函数版本基本相同。但是有一个区别。以前，`swapNames()`在每个`Person`对象中独立存在。现在，在原型中设置了一个单独的`swapNames()`函数，并在所有`Person`实例之间共享。如果您计划创建将原型链接在一起的继承关系（参见[“额外：原型链”](#prototype_chains)），这一点很重要。如果您尝试使用闭包与私有变量（[“使用闭包存储其状态的函数”](ch06.html#create_a_function_that_remembers_its_sta)）函数，因为附加到原型的函数不存在于构造函数的相同上下文中，并且无法访问在构造函数中定义的私有变量。
- en: Caution
  id: totrans-105
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Using prototypes, you can alter the behavior of built-in JavaScript objects.
    For example, you can add functionality to the base `Array` or `String` types.
    This sounds like a nifty feature, but it’s rife with complications and is strongly
    discouraged (except perhaps for building frameworks). Blurring the distinction
    between standard and custom code invites confusion, and creates the possibility
    for nonstandard patterns, poorly optimized code, and hidden mistakes. It can also
    fail outright if more than one person attempts to extend a built-in object with
    the same name.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用原型，您可以改变内置JavaScript对象的行为。例如，您可以为基本的`Array`或`String`类型添加功能。这听起来像一个很棒的功能，但它充满了复杂性，并且强烈不建议使用（除非用于构建框架）。模糊标准代码和自定义代码之间的区别会引起混淆，并且可能导致非标准模式、性能不佳的代码和隐藏的错误。如果有多个人尝试使用相同名称扩展内置对象，它也可能完全失败。
- en: 'It’s interesting to compare the constructor pattern to the `class` keyword
    shown in [“Creating a Reusable Class”](#using_es6_classes). Most of the code is
    exactly the same in both examples:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 将构造函数模式与[“创建可重用类”](#using_es6_classes)中显示的`class`关键字进行比较是很有趣的。在这两个示例中，大部分代码都是完全相同的：
- en: You write a constructor function that accepts parameters and initializes your
    object.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您编写一个接受参数并初始化对象的构造函数。
- en: You use the `this` keyword to create publicly accessible fields.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您使用`this`关键字创建公开可访问的字段。
- en: You use the `new` keyword when creating the object (only now it’s technically
    an instance of a function, not a class).
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建对象时使用`new`关键字（现在技术上是一个函数的实例，而不是一个类）。
- en: But there are also some subtle differences, most obviously in syntax. In the
    constructor pattern there are no dedicated properties, and methods are declared
    separately, not nested in the constructor or explicitly attached to the constructor’s
    prototype (although that’s exactly what happens at runtime).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 但是也有一些细微的差异，最明显的是语法。在构造函数模式中没有专用属性，并且方法是单独声明的，而不是嵌套在构造函数中或显式附加到构造函数的原型（尽管在运行时确实是这样）。
- en: See Also
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[“Creating a Reusable Class”](#using_es6_classes) demonstrates the preferred
    way to create a custom object template in modern JavaScript, which is using the
    `class` keyword.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[“使用es6类”](#using_es6_classes)演示了在现代JavaScript中创建自定义对象模板的首选方法，即使用`class`关键字。'
- en: Supporting Method Chaining in Your Class
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在您的类中支持方法链
- en: Problem
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to define your class methods in such a way that several methods can
    be called in quick succession, in a single statement.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望以一种使得多个方法可以快速连续调用的方式定义类方法。
- en: Solution
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Make sure to return the current object at the end of each method that should
    support method chaining. In a custom class, this is usually as simple as adding
    a `return this` statement.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在支持方法链的每个方法的末尾返回当前对象。在自定义类中，通常只需添加`return this`语句即可。
- en: 'Here’s an example of a custom `Book` object with two methods, `raisePrice()`
    and `releaseNewEdition()`, both of which use method chaining:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个自定义的`Book`对象的示例，其中包含两个方法，`raisePrice()`和`releaseNewEdition()`，两者都使用方法链：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Discussion
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'The ability to directly call one method on the result of another method, in
    a single code statement, is known as *method chaining*. Here’s an example with
    a string and the `replaceAll()` method. Because `replaceAll()` returns a new string,
    you can call `replaceAll()` again on that string, and get a *third* string:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 直接在另一个方法的结果上调用一个方法，形成单一的代码语句，被称为 *方法链*。以下是一个使用字符串和 `replaceAll()` 方法的示例。因为 `replaceAll()`
    返回一个新字符串，您可以在该字符串上再次调用 `replaceAll()`，并得到一个 *第三个* 字符串：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Method chaining doesn’t have to be with the same method. It works with any
    method that returns an object. Consider how this code joins two arrays and then
    sorts the resulting array by chaining a call to `concat()` with one to `sort()`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 方法链不一定要使用相同的方法。它可以与返回对象的任何方法一起工作。考虑以下代码如何通过将 `concat()` 和 `sort()` 的调用链接来连接两个数组，然后对结果数组进行排序：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Chaining is used extensively in built-in JavaScript objects and in many JavaScript
    libraries and frameworks. To use this pattern in your own classes, you simply
    return a reference to `this` at the end of your method. The calling code can then
    ignore this reference, or use it to perform method chaining.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在内置的 JavaScript 对象和许多 JavaScript 库和框架中广泛使用链式调用。要在自己的类中使用此模式，您只需在方法末尾返回对 `this`
    的引用即可。调用代码可以忽略此引用，或者使用它执行方法链。
- en: 'In the current example, calling a method on `Book` changes the object and returns
    a reference to the changed object. The caller can ignore the return value, because
    they already have a reference to the `Book` object. However, many functional programming
    purists do something different. They write methods that return a changed object
    *copy*, while keeping the original object unchanged. Here’s how you’d implement
    this pattern:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前示例中，调用 `Book` 上的方法会更改对象并返回对更改后对象的引用。调用者可以忽略返回值，因为他们已经有了对 `Book` 对象的引用。但是，许多函数式编程纯粹主义者会做一些不同的事情。他们编写返回更改后对象
    *副本* 的方法，同时保持原始对象不变。以下是如何实现此模式的示例：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This pattern doesn’t affect the way method chaining works, but it does mean
    the caller needs to take the return value, or they won’t see the changes.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式不影响方法链工作的方式，但确实意味着调用者需要接受返回值，否则他们将看不到变化。
- en: Adding Static Methods to a Class
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向类添加静态方法
- en: Problem
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to create a utility method that’s tied to your class, but can be called
    without creating an object.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望创建一个与类相关但可以在不创建对象的情况下调用的实用方法。
- en: Solution
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Place the `static` keyword before the method. Make sure your method doesn’t
    attempt to use any instance fields, properties, or methods. Here’s an example
    with a static method named `Book.isEqual()`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法前加上 `static` 关键字。确保您的方法不尝试使用任何实例字段、属性或方法。这里有一个名为 `Book.isEqual()` 的静态方法示例：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You access a static method through the class name (as in `Book.isEqual()`).
    You can’t access it through an object variable.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您通过类名访问静态方法（如 `Book.isEqual()`）。不能通过对象变量访问它。
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Discussion
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Static methods have functionality that’s logically related to a class, but not
    tied to a specific instance. The `Array.isArray()` method is a good example—it
    lets you test whether any object is an array, without forcing you to create an
    array object first. Occasionally, classes are made up entirely of static methods.
    JavaScript’s `Math` class is a good example.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法具有与类逻辑相关但不绑定于特定实例的功能。`Array.isArray()` 方法是一个很好的例子 —— 它允许您测试任何对象是否为数组，而无需首先创建数组对象。偶尔，类完全由静态方法组成。JavaScript
    的 `Math` 类就是一个很好的例子。
- en: In the current example, you might want to give the `Book` class static methods
    related to processing or verifying ISBNs. You can also use static methods to make
    decisions about how objects of a certain class should be copied or compared. The
    solution demonstrates this principle with a static `isEqual()` method. You could
    also add a `compare()` method that would let you sort your objects in array (as
    shown in [“Sorting an Array of Objects by a Property Value”](ch05.html#sorting_array)).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前示例中，您可能希望为 `Book` 类提供与处理或验证 ISBN 相关的静态方法。您还可以使用静态方法来决定如何复制或比较某个类的对象。解决方案通过静态
    `isEqual()` 方法演示了这一原则。您还可以添加一个 `compare()` 方法，使您能够对数组中的对象进行排序（如 [“按属性值排序对象数组”](ch05.html#sorting_array)
    中所示）。
- en: In a static method, `this` refers to the current class, not an object instance.
    This can lead to problems, because your code will still be allowed to store data
    in `this` (or retrieve it). It just might not have the effect you expect. Essentially,
    everything in the static `this` acts like a class-scoped global variable, which
    is best avoided.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在静态方法中，`this`指的是当前类，而不是对象实例。这可能会导致问题，因为您的代码仍然允许在`this`中存储数据（或检索数据）。它只是可能没有您期望的效果。本质上，静态`this`中的所有内容都像一个类范围的全局变量，最好避免使用。
- en: Tip
  id: totrans-142
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If you want one static method to call another static method, you can use the
    `this` keyword. For example, if you want to call the static `isEqual()` from another
    static method in the `Book` class, you can refer to it as `Book.isEqual()` or
    `this.isEqual()`, which may be clearer.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要一个静态方法调用另一个静态方法，可以使用`this`关键字。例如，如果你想要在`Book`类的另一个静态方法中调用静态方法`isEqual()`，你可以使用`Book.isEqual()`或`this.isEqual()`，这可能更清晰。
- en: 'Property `set` and `get` methods can also be static, although their usage is
    sometimes controversial. For example, you can use a static getter to store a constant,
    like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 属性的`set`和`get`方法也可以是静态的，尽管它们的使用有时是有争议的。例如，您可以使用静态getter来存储常量，就像这样：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You can write a static setter, which acts like a global variable in your application.
    However, because there’s no static constructor, you’ll be forced to run code somewhere
    to assign the initial value. This isn’t particularly clear, so a [new static property
    syntax is under development](https://oreil.ly/7O28H), and currently supported
    by more modern browser versions. It allows you to set a public static property
    using a variable-like syntax:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以编写一个静态setter，它在您的应用程序中类似于全局变量。然而，由于没有静态构造函数，您将被迫在某个地方运行代码以分配初始值。这并不特别清晰，因此正在开发一种[new
    static property syntax](https://oreil.ly/7O28H)，目前更现代的浏览器版本已经支持。它允许您使用类似变量的语法设置公共静态属性：
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: However, it’s best to avoid this language feature altogether—or at least until
    some future data when its use in JavaScript is more normative.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最好完全避免这种语言特性——或者至少在JavaScript中的使用更为规范的未来数据时再考虑使用。
- en: Using a Static Method to Create Objects
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用静态方法创建对象
- en: Problem
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to create a method that generates a preconfigured object, possibly
    to get around JavaScript’s single-constructor limitation.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要创建一个生成预配置对象的方法，可能是为了绕过JavaScript的单构造函数限制。
- en: Solution
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Add a static method to your class that creates and returns the object you want.
    Here’s an example with a `Book` class that you can create through the constructor
    or through the static `Book.createSequel()` method:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的类中添加一个静态方法，创建并返回您想要的对象。以下是一个`Book`类的示例，您可以通过构造函数或通过静态方法`Book.createSequel()`创建它：
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here’s how you use the static method:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何使用静态方法：
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Discussion
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Using static methods, you can implement different types of *creational* patterns—basically,
    patterns that help you create preconfigured instances of a class. For example,
    the JavaScript `Date` class has a `now()` property that returns a new `Date` object
    that’s automatically set to the current date and time.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用静态方法，您可以实现不同类型的*创建型*模式——基本上是帮助您创建类的预配置实例的模式。例如，JavaScript的`Date`类有一个`now()`属性，返回一个新的`Date`对象，自动设置为当前日期和时间。
- en: 'This approach is particularly suited to creating more complex combinations
    of objects. For example, you could extend the previous example with a `Book.createTrilogy()`
    method to get an array of three `Book` objects. In this example, the `Book` objects
    share a single `Author` object, which means that if you update the `Author` object,
    all the `Book` instances that link to it see the change:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法特别适用于创建更复杂的对象组合。例如，您可以通过`Book.createTrilogy()`方法扩展前面的示例，以获取一个包含三个`Book`对象的数组。在这个示例中，`Book`对象共享一个`Author`对象，这意味着如果您更新`Author`对象，所有链接到它的`Book`实例都会看到这个变化：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Unlike constructors, there’s no limit to how many static methods you can add
    to support different object-creation scenarios.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 与构造函数不同，您可以添加多少个静态方法来支持不同的对象创建场景。
- en: Note
  id: totrans-162
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Sometimes these static methods are called *factory methods*, although that description
    isn’t technically precise. In object-oriented design theory, the factory pattern
    is used when you don’t know the exact type of object you’re creating. For example,
    you might write a `createBook()` method that examines the arguments you supply
    and returns an instance of either the `TechBook` class or the `FictionBook` class,
    both of which inherit from a base `Book` class. It’s possible to implement this
    design in JavaScript, too, but opinions are mixed about how well the language
    handles the heavier weight of this sort of classical OOP abstraction.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 有时这些静态方法被称为*工厂方法*，尽管这个描述在技术上并不精确。在面向对象设计理论中，当你不知道正在创建的对象的确切类型时，会使用工厂模式。例如，你可以编写一个`createBook()`方法，检查你提供的参数并返回`TechBook`类或`FictionBook`类的实例，它们都继承自基类`Book`。在JavaScript中也可以实现这种设计，但人们对语言如何处理这种更重的经典面向对象抽象的看法不一。
- en: Inheriting Functionality from Another Class
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从另一个类继承功能
- en: Problem
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to create a custom class that inherits the functionality of another
    class.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你想创建一个自定义类，继承另一个类的功能。
- en: Solution
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'With inheritance, one or more *child* classes derive from a *parent* class.
    To model this in code, you use the `extends` keyword when you declare the child
    class:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用继承，一个或多个*子*类从*父*类派生。在代码中建模这一点时，声明子类时使用`extends`关键字：
- en: '[PRE29]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here’s an example with a `Triangle` class that inherits from a more basic parent
    class named `Shape`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子，展示了一个从名为`Shape`的基础父类继承的`Triangle`类：
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this example, the parent class (`Shape`) doesn’t have any useful functionality.
    The `getArea()` method is only there as a placeholder. But in other cases, base
    classes may be useful on their own. For example, you could use inheritance with
    the `Book` class to create an `EBook` child or with the `Person` class to create
    a `Customer`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，父类（`Shape`）没有任何有用的功能。`getArea()`方法只是一个占位符。但在其他情况下，基类本身可能会有用。例如，你可以使用`Book`类的继承来创建`EBook`子类或`Person`类的`Customer`。
- en: 'It may seem that there’s no point to build a `Triangle` that derives from a
    `Shape` if you only plan to use the `Triangle`. And in a loosely typed language
    like JavaScript, this is often true! But the potential value appears when you
    use a single parent class to standardize more child classes:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript这样的弱类型语言中，如果你只打算使用`Triangle`，似乎没有必要构建一个从`Shape`继承的`Triangle`。而且在这种情况下，通常确实如此！但是当你使用单个父类来标准化更多子类时，潜在的价值就显现出来：
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now it becomes possible to write code like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以这样编写代码：
- en: '[PRE32]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Of course, JavaScript is a loosely typed language, and you could call `getArea()`
    on `Triangle` and `Circle` and `Square` objects even if they didn’t share a parent
    class that defined the method. But formalizing this interface with inheritance
    can help make these requirements explicit. It’s also important if you need to
    test objects using `instan⁠ce​of` ([“Checking if an Object Is a Certain Type”](ch07.html#check_object_type)):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，JavaScript是一种弱类型语言，即使它们没有共享定义该方法的父类，你也可以在`Triangle`、`Circle`和`Square`对象上调用`getArea()`。但是使用继承来规范这种接口可以帮助明确这些要求。如果你需要使用`instan⁠ce​of`来测试对象是否是某种类型，这也很重要（“检查对象类型”）：
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Discussion
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: If you don’t write a constructor for a child class, JavaScript creates one automatically.
    That constructor calls the base class constructor (but provides no arguments).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不为子类编写构造函数，JavaScript会自动创建一个。该构造函数调用基类构造函数（但不提供参数）。
- en: 'If you write a constructor for your child class, you *must* call the parent
    class constructor. Otherwise, you’ll receive a `ReferenceError` when you try to
    create an instance. To call the parent class constructor, you use the `super()`
    keyword:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果为子类编写了构造函数，*必须*调用父类构造函数。否则，在尝试创建实例时会收到`ReferenceError`。要调用父类构造函数，使用`super()`关键字：
- en: '[PRE34]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If the parent class constructor accepts arguments, you should pass them to
    `super()` like you would when creating the object. Here’s an example with an `EBook`
    class that extends `Book`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果父类构造函数接受参数，你应该像创建对象时那样将它们传递给`super()`。以下是一个扩展`Book`的`EBook`类的示例：
- en: '[PRE35]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You can also use `super()` to call other methods or properties in the parent
    class. For example, if a child class wants to call the parent class implementation
    of `formatString()`, it would call `super.formatString()`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`super()`调用父类中的其他方法或属性。例如，如果一个子类想调用父类`formatString()`的实现，它会调用`super.formatString()`。
- en: Classes are a relatively late introduction to JavaScript. Although they support
    inheritance, many of the other tools you might be used to in traditional object-oriented
    languages, like abstract base classes, virtual methods, and interfaces, have no
    analog in JavaScript. Some developers enjoy the lightweight nature of JavaScript
    and its emphasis on prototypes, while others feel they are missing vital tools
    for building large, complex applications. (If you’re in the latter camp, your
    best better is to consider TypeScript, a more rigorous superset of JavaScript.)
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 类是JavaScript相对较晚引入的功能。虽然它们支持继承，但你在传统面向对象语言中可能习惯的许多其他工具，如抽象基类、虚方法和接口，在JavaScript中都没有对应的概念。一些开发者喜欢JavaScript轻量级的特性和原型的重视，而另一些则觉得缺少构建大型复杂应用程序的重要工具。如果你属于后者，最好考虑使用TypeScript，这是JavaScript的一个更严格的超集。
- en: 'But inheritance isn’t without its own tradeoffs. It can encourage you to write
    tightly coupled classes that are dependent on one another and difficult to adapt
    to future changes. Even worse, it’s often difficult to identify these dependencies,
    and developers become reluctant to make changes to the parent class (a situation
    called the *fragile base class* problem). Because of problems like these, modern
    development often prefers aggregating groups of objects instead of using inheritance
    relationships. For example, instead of building an `Employee` class that extends
    `Person`, you might create an `Employee` object that includes a `Person` property,
    along with all the other details it needs. This pattern is called *composition*:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 但继承并非没有其缺点。它可能会促使你编写紧密耦合的类，这些类相互依赖并且难以适应未来的变更。更糟糕的是，往往很难识别这些依赖关系，开发者变得不愿意对父类进行更改（这种情况被称为*脆弱基类*问题）。正因为这些问题，现代开发往往更喜欢聚合对象组而不是使用继承关系。例如，不是建立一个扩展`Person`的`Employee`类，而是创建一个包含`Person`属性及其它所需细节的`Employee`对象。这种模式称为*组合*：
- en: '[PRE36]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Extra: Prototype Chains'
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 补充：原型链
- en: You may remember that the JavaScript class feature creates a prototype for an
    object. This prototype holds the implementation of all its methods and properties,
    and is shared between all instances of that class. Prototypes are also the secret
    to inheritance. When one class extends another, they are linked in a *prototype
    chain*.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得JavaScript类功能创建对象的原型。这个原型包含了所有方法和属性的实现，并在该类的所有实例之间共享。原型也是实现继承的秘诀。当一个类扩展另一个类时，它们被链接在一个*原型链*中。
- en: 'For example, consider the relationship of `Shape` and `Triangle`. The `Triangle`
    class has a prototype that holds whatever you’ve defined for the child class.
    However, that prototype has *its own* prototype, which is the prototype for `Shape`
    class, with all its members. The `Shape` prototype has its own prototype, too:
    the base `Object.prototype`, which ends the prototype chain.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑`Shape`和`Triangle`之间的关系。`Triangle`类有一个原型，其中保存了你为子类定义的任何内容。然而，该原型还有*它自己*的原型，即`Shape`类的原型，其中包含所有其成员。`Shape`原型也有它自己的原型：基础的`Object.prototype`，这样便形成了原型链。
- en: Inheritance can go as many levels deep as you want, so a prototype chain can
    become much longer. When you call a method like `Triangle.getArea()`, JavaScript
    searches the prototype chain. It looks for a method in the `Triangle` prototype,
    then the `Shape` prototype, and then the `Object` prototype (at which point it
    fails with an error if it can’t find a matching method).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 继承可以无限层级地延伸，因此原型链可以变得非常长。当你调用像`Triangle.getArea()`这样的方法时，JavaScript会搜索原型链。它首先在`Triangle`原型中查找方法，然后是`Shape`原型，最后是`Object`原型（如果找不到匹配的方法，则会报错）。
- en: 'Of course, JavaScript classes are relatively new, and prototypes have been
    around since the first version of the language. So it’s no surprise that you can
    create inheritance-like relationships using prototypes even if you aren’t using
    JavaScript classes. Sometimes this is paired with the old-fashioned constructor
    pattern ([“Using the Constructor Pattern to Make a Custom Class”](#constructor_pattern)),
    which results in some decidedly inelegant code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，JavaScript类是相对较新的，而原型自从语言的第一个版本以来就存在。因此，即使不使用JavaScript类，你也可以创建类似继承的关系。有时这与老式的构造函数模式（[“使用构造函数模式创建自定义类”](#constructor_pattern)）结合使用，结果是一些相当不优雅的代码。
- en: '[PRE37]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This pattern *should* be mostly obsolete now, because classes give you a cleaner
    method to create inheritance relationships. But it still lingers in plenty of
    long-lived codebases.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式现在*应该*大部分已经过时了，因为类给你提供了一个更清晰的方法来创建继承关系。但它仍然存在于许多长期存在的代码库中。
- en: Organizing Your JavaScript Classes with Modules
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模块组织你的 JavaScript 类
- en: Problem
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to encapsulate your classes in a separate namespace to facilitate reuse
    and prevent naming conflicts with other libraries.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要将你的类封装在一个单独的命名空间中，以便于重用并防止与其他库的命名冲突。
- en: Solution
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use the module system introduced with ES6\. There are three steps:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ES6 引入的模块系统。有三个步骤：
- en: Decide which functionality represents a complete module. Put the code for those
    classes, functions, and global variables in a separate script file.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 决定哪些功能代表一个完整的模块。将那些类、函数和全局变量的代码放在一个单独的脚本文件中。
- en: Choose which code details you want to *export* (make available to other scripts
    in other files).
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你想要*导出*（在其他文件的其他脚本中可用）的代码细节。
- en: In another script, *import* the features you want to use.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在另一个脚本中，*导入*你想要使用的功能。
- en: 'Here’s an example of a module; we’ll store it in a file named *lengthConverterModule.js*:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个模块的示例；我们将其存储在名为 *lengthConverterModule.js* 的文件中：
- en: '[PRE38]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The important line is the `export` statement at the end. It lists all the functions,
    variables, and classes that will be made accessible to other code files. In this
    example, the `Units` constant (really just an enum) and the `LengthConverter`
    class are made available, while the `InvisibleLogger` class is not.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是末尾的 `export` 语句。它列出了所有将被其他代码文件访问的函数、变量和类。在这个例子中，`Units` 常量（实际上只是一个枚举）和
    `LengthConverter` 类是可用的，而 `InvisibleLogger` 类则不是。
- en: Note
  id: totrans-207
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When you create module files, the extension *.mjs* is sometimes recommended.
    The *.mjs* extension clearly signals that you’re using an ES6 module, and it helps
    tools like Node and Babel recognize these files automatically. However, the *.mjs*
    extension can also cause problems if your web server isn’t configured to serve
    *.mjs* files with the right MIME type (`text/javascript`), like ordinary *.js*
    files. For that reason, we don’t use it in this example.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建模块文件时，有时建议使用扩展名为 *.mjs*。 *.mjs* 扩展名清楚地表明你在使用 ES6 模块，它有助于 Node 和 Babel 等工具自动识别这些文件。但是，如果你的
    web 服务器没有正确配置为使用正确的 MIME 类型（`text/javascript`）提供 *.mjs* 文件，那么 *.mjs* 扩展名也可能会引起问题，就像普通的
    *.js* 文件一样。因此，在这个例子中我们不使用它。
- en: Now you can import the functionality you need into another module. You can write
    this module as a separate file, or use a `<script>` block in a web page as we
    do here. But either way, your `<script>` tag must include the `type="module"`
    attribute.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以将需要的功能导入到另一个模块中。你可以将这个模块写成一个单独的文件，或者像我们在这里做的那样在网页中使用一个 `<script>` 块。但无论哪种方式，你的
    `<script>` 标签必须包含 `type="module"` 属性。
- en: 'Here’s the complete page, including a button that triggers a `doSampleConversion()`
    test:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完整的页面，包括触发 `doSampleConversion()` 测试的按钮：
- en: '[PRE39]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Discussion
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: JavaScript has used a number of module systems over the years, most notably
    with Node and npm. But since ES6, JavaScript has had its own module standard,
    which is supported natively in all modern browsers.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，JavaScript 使用了许多模块系统，最显著的是 Node 和 npm。但自 ES6 以来，JavaScript 已经有了自己的模块标准，所有现代浏览器都原生支持。
- en: 'Before you create a solution with modules, there are a few considerations you
    should know:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建带有模块的解决方案之前，有几个你应该了解的考虑因素：
- en: Browser security restrictions mean that you can’t run a module example from
    the local filesystem. Instead, you need to host your example on a development
    web server (as described in [“Setting Up a Local Test Server”](ch01.html#setting_up_test_server)).
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器安全限制意味着你不能从本地文件系统运行模块示例。相反，你需要将你的示例托管在开发 Web 服务器上（如 [“设置本地测试服务器”](ch01.html#setting_up_test_server)
    中描述的）。
- en: Modules are locked into their own distinct “module” scope. You can’t access
    a module from a normal nonmodule script. Similarly, you can’t access modules from
    the developer console.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块被锁定在它们自己独特的“模块”作用域中。你无法从普通的非模块脚本访问模块。同样，你也无法从开发者控制台访问模块。
- en: You can’t access modules from the HTML of your page. That means you can’t wire
    up an event handler using an HTML attribute like `onclick`, for example, because
    the page won’t be able to access an event handler that’s inside a module. Instead,
    your module code needs to reach *out* to the surrounding browser context using
    `window` or `document`.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你无法从页面的HTML中访问模块。这意味着你不能使用像`onclick`这样的HTML属性来连接事件处理程序，因为页面无法访问模块内部的事件处理程序。相反，你的模块代码需要通过`window`或`document`来访问周围的浏览器上下文。
- en: Modules are automatically executed in strict mode ([“Using Strict Mode to Catch
    Common Mistakes”](ch01.html#using_strict_mode)).
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块会自动以严格模式执行（[“使用严格模式捕捉常见错误”](ch01.html#using_strict_mode)）。
- en: 'Module features can only be imported into another module. If you want to create
    a `<script>` block for a module in a web page, make sure you set the `type` attribute
    to `module`, or the module importing feature won’t work:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 模块功能只能被导入到另一个模块中。如果你想在网页中为一个模块创建一个`<script>`块，确保将`type`属性设置为`module`，否则模块导入功能将无法工作：
- en: '[PRE40]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'When you import functionality from a module, you must specify the file path
    of the module in the `from` part of the `import` statement. Modules support a
    convenient shortcut that lets you start relative paths with `./`, so `./lengthConverterModule.js`
    points to the *lengthConverterModule.js* file in the current folder:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从一个模块导入功能时，你必须在`import`语句的`from`部分指定模块的文件路径。模块支持一种方便的快捷方式，允许你以`./`开头的相对路径，因此`./lengthConverterModule.js`指向当前文件夹中的*lengthConverterModule.js*文件：
- en: '[PRE41]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'There’s quite a bit of flexibility in the naming you use when you import module
    features. You can wrap your imports in a *module object*, which is a special sort
    of container that namespaces everything. Here’s an example that imports every
    exported type into a module object named `LConvert`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入模块功能时，你使用的命名具有相当大的灵活性。你可以将你的导入包装在一个*模块对象*中，这是一种特殊的容器，用于对所有内容进行命名空间管理。下面是一个将每种导出类型导入到名为`LConvert`的模块对象中的示例：
- en: '[PRE42]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Notice that no curly brackets are required when using module objects.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在使用模块对象时不需要大括号。
- en: 'You can also set a *default* export in your module:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在你的模块中设置一个*默认*导出：
- en: '[PRE43]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'And then you can import it using any name:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以使用任何名称进行导入：
- en: '[PRE44]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The default export feature matches similar functionality in other module systems.
    That makes it easier for those modules to be migrated into the ES6 modules standard.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 默认导出功能与其他模块系统中的类似功能匹配。这使得那些模块更容易迁移到ES6模块标准中。
- en: 'It’s likely that ES6 modules will eventually become the dominant module standard
    in JavaScript. But today, the implementation of ES modules in npm is still a bit
    rough around the edges. For the foreseeable future, that means developers will
    be juggling at least two module standards: the ES6 standard that’s recognized
    natively by modern browsers, and the older CommonJS standard that’s mature and
    well-established in the Node and npm ecosystem.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ES6模块很可能最终会成为JavaScript中主导的模块标准。但是今天，在npm中实现ES模块仍然存在一些问题。在可预见的未来，这意味着开发人员将至少需要处理两种模块标准：ES6标准，这是现代浏览器本地识别的，以及较老的CommonJS标准，在Node和npm生态系统中成熟和广泛使用。
- en: See Also
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: For information on using CommonJS modules with Node and npm, see ​[Chapter 18](ch18.html#ch18).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何在Node和npm中使用CommonJS模块的信息，请参见[第18章](ch18.html#ch18)。
