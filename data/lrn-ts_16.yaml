- en: Chapter 13\. Configuration Options
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 13 章\. 配置选项
- en: 'Compiler options:'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编译器选项：
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Types and modules and oh my!
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 类型和模块，还有更多！
- en: ''
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`tsc` your way.'
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`tsc` 你的方式。'
- en: TypeScript is highly configurable and made to adapt to all common JavaScript
    usage patterns. It can work for projects ranging from legacy browser code to the
    most modern server environments.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 高度可配置，并且设计适应所有常见的 JavaScript 使用模式。它可以用于从传统浏览器代码到最现代的服务器环境的项目。
- en: 'Much of TypeScript’s configurability comes from its cornucopia of over 100
    configuration options that can be provided via either:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 的大部分可配置性来自于其多达 100 多个配置选项，可以通过以下方式之一提供：
- en: Command-line (CLI) flags passed to `tsc`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递给`tsc`的命令行（CLI）标志
- en: “TSConfig” TypeScript configuration files
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “TSConfig” TypeScript 配置文件
- en: This chapter is not intended as a full reference for all TypeScript configuration
    options. Instead, I’d suggest treating this chapter as a tour of the most common
    options you’ll find yourself using. I’ve included just the ones that tend to be
    more useful and widely used for most TypeScript project setups. See [aka.ms/tsc](https://aka.ms/tsc)
    for a full reference on each of these options and more.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不旨在作为所有 TypeScript 配置选项的完整参考。相反，我建议将本章视为您将经常使用的最常见选项的导览。我仅包含那些对大多数 TypeScript
    项目设置更有用和广泛使用的选项。有关每个选项和更多信息，请参见[aka.ms/tsc](https://aka.ms/tsc)。
- en: tsc Options
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: tsc 选项
- en: Back in [Chapter 1, “From JavaScript to TypeScript”](ch01.xhtml#from_javascript_to_typescript),
    you used `tsc index.ts` to compile an *index.ts* file. The `tsc` command can take
    in most of TypeScript’s configuration options as `--` flags.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 回到[第 1 章，“从 JavaScript 到 TypeScript”](ch01.xhtml#from_javascript_to_typescript)，您使用`tsc
    index.ts`编译了一个*index.ts*文件。`tsc`命令可以将大多数 TypeScript 配置选项作为`--`标志传递。
- en: 'For example, to run `tsc` on an *index.ts* file and skip emitting an *index.js*
    file (so, only run type checking), pass the `--noEmit` flag:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要在*index.ts*文件上运行`tsc`并跳过发出*index.js*文件（因此，只运行类型检查），请传递`--noEmit`标志：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can run `tsc --help` to get a list of commonly used CLI flags. The full
    list of `tsc` configuration options from [aka.ms/tsc](https://aka.ms/tsc) is viewable
    with `tsc --all`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以运行`tsc --help`来获取常用的 CLI 标志列表。从[aka.ms/tsc](https://aka.ms/tsc)查看所有`tsc`配置选项的完整列表，使用`tsc
    --all`。
- en: Pretty Mode
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 漂亮模式
- en: 'The `tsc` CLI has the ability to output in a “pretty” mode: stylized with colors
    and spacing to make them easier to read. It defaults to pretty mode if it detects
    that the output terminal supports colorful text.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`tsc` CLI 具有“漂亮”模式的输出能力：使用颜色和间距进行样式化，使其更易于阅读。如果检测到输出终端支持彩色文本，则默认为漂亮模式。'
- en: Here’s an example of what `tsc` looks like printing two type errors from a file
    ([Figure 13-1](#tsc_pretty_errors)).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了一个从文件中打印两个类型错误的`tsc`的示例（见[图 13-1](#tsc_pretty_errors)）。
- en: '![tsc reporting two errors with blue file names, yellow line and column numbers,
    and red squigglies.](Images/lets_1301.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![tsc 报告两个错误，包含蓝色文件名、黄色行号和列号，以及红色波浪线。](Images/lets_1301.png)'
- en: Figure 13-1\. `tsc` reporting two errors with blue file names, yellow line and
    column numbers, and red squigglies
  id: totrans-20
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 13-1\. `tsc` 报告两个错误，包含蓝色文件名、黄色行号和列号，以及红色波浪线
- en: If you’d prefer CLI output that is more condensed and/or doesn’t have different
    colors, you can explicitly provide `--pretty false` to tell TypeScript to use
    a more terse, uncolored format ([Figure 13-2](#tsc_pretty_false_errors)).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望 CLI 输出更加简洁和/或不具有不同的颜色，可以显式提供`--pretty false`，告诉 TypeScript 使用更简洁、无颜色的格式（见[图 13-2](#tsc_pretty_false_errors)）。
- en: '![tsc reporting two errors in plain text.](Images/lets_1302.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![tsc 报告两个错误的普通文本模式。](Images/lets_1302.png)'
- en: Figure 13-2\. `tsc` reporting two errors in plain text
  id: totrans-23
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 13-2\. `tsc` 报告两个错误的普通文本模式
- en: Watch Mode
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 观察模式
- en: My favorite way to use the `tsc` CLI is with its `-w`/`--watch` mode. Instead
    of exiting once completed, watch mode will keep TypeScript running indefinitely
    and continuously updates your terminal with a real-time list of all the errors
    it sees.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢使用`tsc` CLI 的一种方式是使用其`-w`/`--watch`模式。在完成后不会退出，观察模式将持续运行 TypeScript，并实时更新终端中看到的所有错误列表。
- en: Running in watch mode on a file that contains two errors is shown in [Figure 13-3](#tsc_watch_errors).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含两个错误的文件上运行观察模式，见[图 13-3](#tsc_watch_errors)。
- en: '![tsc reporting two errors in watch mode.](Images/lets_1303.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![tsc 在观察模式下报告两个错误。](Images/lets_1303.png)'
- en: Figure 13-3\. `tsc` reporting two errors in watch mode
  id: totrans-28
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 13-3\. `tsc` 在观察模式下报告两个错误
- en: '[Figure 13-4](#tsc_watch_fixed) shows `tsc` updating console output to indicate
    that the file was changed in a way to fix all errors.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13-4](#tsc_watch_fixed)展示了`tsc`更新控制台输出以指示文件已更改以修复所有错误。'
- en: '![tsc reporting no errors in watch mode.](Images/lets_1304.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![tsc在监视模式下报告没有错误。](Images/lets_1304.png)'
- en: Figure 13-4\. `tsc` reporting no errors in watch mode
  id: totrans-31
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 13-4\. `tsc`在监视模式下报告没有错误
- en: Watch mode is particularly useful when you’re working on large changes such
    as refactors across many files. You can use TypeScript’s type errors as a checklist
    of sorts to see what still needs to be cleaned up.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当您正在进行跨多个文件的大规模更改（如重构）时，监视模式特别有用。您可以使用TypeScript的类型错误作为一种清单，查看仍需清理的内容。
- en: TSConfig Files
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TSConfig文件
- en: Instead of always providing all file names and configuration options to `tsc`,
    most configuration options may be specified in a *tsconfig.json* (“TSConfig”)
    file in a directory.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将大多数配置选项指定在一个目录中的*tsconfig.json*（“TSConfig”）文件中，而不是始终提供所有文件名和配置选项给`tsc`。
- en: The existence of a *tsconfig.json* indicates that the directory is the root
    of a TypeScript project. Running `tsc` in a directory will read in any configuration
    options in that *tsconfig.json* file.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*tsconfig.json*的存在表明该目录是一个TypeScript项目的根目录。在目录中运行`tsc`将读取该*tsconfig.json*文件中的任何配置选项。'
- en: 'You can also pass `-p`/`--project` to `tsc` with a path to a directory containing
    a *tsconfig.json* or any file to have `tsc` use that instead:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将`-p`/`--project`传递给`tsc`，并指定一个包含*tsconfig.json*或任何文件的目录路径，以便`tsc`使用该文件：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: TSConfig files are generally strongly recommended to be used for TypeScript
    projects whenever possible. IDEs such as VS Code will respect their configuration
    when giving you IntelliSense features.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，强烈建议使用TSConfig文件来进行TypeScript项目。像VS Code这样的IDE将在给您提供IntelliSense功能时尊重它们的配置。
- en: See [aka.ms/tsconfig.json](https://aka.ms/tsconfig.json) for the full list of
    configuration options available in TSConfig files.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[aka.ms/tsconfig.json](https://aka.ms/tsconfig.json)获取TSConfig文件中可用配置选项的完整列表。
- en: Note
  id: totrans-40
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you don’t set an option in your *tsconfig.json*, don’t worry that TypeScript’s
    default setting for it may change and interfere with your project’s compilation
    settings. This almost never happens and if it did, it would require a major version
    update to TypeScript and be called out in the release notes.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在你的*tsconfig.json*中没有设置选项，不用担心TypeScript的默认设置可能会改变并影响到你的项目编译设置。这几乎不会发生，即使发生了，也需要对TypeScript进行主要版本更新，并在发布说明中明确说明。
- en: tsc --init
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: tsc --init
- en: The `tsc` command line includes an `--init` command to create a new *tsconfig.json*
    file. That newly created TSConfig file will contain a link to the configuration
    docs as well as most of the allowed TypeScript configuration options with one-line
    comments briefly describing their use.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行中的`tsc`命令包括一个`--init`命令，用于创建一个新的*tsconfig.json*文件。这个新创建的TSConfig文件将包含一个链接到配置文档以及大多数允许的TypeScript配置选项，每个选项都有一行简短的注释描述其用途。
- en: 'Running this command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'will generate a fully commented *tsconfig.json* file:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 将生成一个完全注释的*tsconfig.json*文件：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: I recommend using `tsc --init` to create your configuration file on your first
    few TypeScript projects. Its default values are applicable to most projects, and
    its documentation comments are helpful in understanding them.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议在您的前几个TypeScript项目中使用`tsc --init`来创建您的配置文件。其默认值适用于大多数项目，并且其文档注释有助于理解它们。
- en: CLI Versus Configuration
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CLI与配置
- en: 'Looking through the TSConfig file created by `tsc --init`, you may notice that
    configuration options in that file are within a `"compilerOptions"` object. Most
    options available in both the CLI and in TSConfig files fall into one of two categories:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`tsc --init`创建的TSConfig文件中的配置选项可能会注意到，这些选项位于一个`"compilerOptions"`对象内。大多数同时适用于CLI和TSConfig文件的选项属于以下两个类别之一：
- en: Compiler
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器
- en: How each included file is compiled and/or type checked by TypeScript
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript如何编译和/或类型检查每个包含的文件
- en: File
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 文件
- en: Which files will or will not have TypeScript run on them
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 哪些文件将或不将在其上运行TypeScript
- en: Other settings that we’ll talk about after those two categories, such as project
    references, generally are only available in TSConfig files.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这两个类别之后讨论其他设置，比如项目引用，通常只能在TSConfig文件中使用。
- en: Tip
  id: totrans-56
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If a setting is provided to the `tsc` CLI, such as a one-off change for a CI
    or production build, it will generally override any value specified in a TSConfig
    file. Because IDEs generally read from the *tsconfig.json* in a directory for
    TypeScript settings, it’s recommended to put most configuration options in a *tsconfig.json*
    file.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果向 `tsc` CLI 提供了设置（例如为 CI 或生产构建提供的一次性更改），它通常会覆盖 TSConfig 文件中指定的任何值。因为 IDE 通常从目录中的
    *tsconfig.json* 读取 TypeScript 设置，建议将大多数配置选项放在 *tsconfig.json* 文件中。
- en: File Inclusions
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件包含
- en: By default, `tsc` will run on all nonhidden *.ts* files (those whose names do
    not start with a `.`) in the current directory and any child directories, ignoring
    hidden directories and directories named *node_modules*. TypeScript configurations
    can change that list of files to run on.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`tsc` 将运行当前目录及其子目录中所有非隐藏的 *.ts* 文件（即文件名不以 `.` 开头的文件），忽略隐藏目录和名为 *node_modules*
    的目录。TypeScript 配置可以修改要运行的文件列表。
- en: include
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: include
- en: The most common way to include files is with a top-level `"include"` property
    in a *tsconfig.json*. It allows an array of strings that describes what directories
    and/or files to include in TypeScript compilation.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 包含文件的最常见方式是在 *tsconfig.json* 中的顶级 `"include"` 属性中。它允许一个描述要在 TypeScript 编译中包含的目录和/或文件的字符串数组。
- en: 'For example, this configuration file recursively includes all TypeScript source
    files in a *src/* directory relative to the *tsconfig.json*:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，此配置文件递归包含与 *tsconfig.json* 相对于 *src/* 目录中的所有 TypeScript 源文件：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Glob wildcards are allowed in `include` strings for more fine-grained control
    of files to include:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`include` 字符串中允许使用全局通配符以更精细地控制要包含的文件：'
- en: '`*` matches zero or more characters (excluding directory separators).'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*` 匹配零个或多个字符（不包括目录分隔符）。'
- en: '`?` matches any one character (excluding directory separators).'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`?` 匹配任意一个字符（不包括目录分隔符）。'
- en: '`**/` matches any directory nested to any levels.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**/` 匹配任意级别的任何目录。'
- en: 'This configuration file allows only *.d.ts* files nested in a *typings/* directory
    and *src/* files with at least two characters in their name before an extension:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置文件仅允许在 *typings/* 目录中嵌套的 *.d.ts* 文件和在其名称前至少具有两个字符的 *src/* 文件的扩展名：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: For most projects, a simple `include` compiler option such as `["src"]` is generally
    sufficient.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数项目来说，简单的 `include` 编译选项，比如 `["src"]`，通常已经足够了。
- en: exclude
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: exclude
- en: The `include` list of files for a project sometimes includes files not meant
    for compilation by TypeScript. TypeScript allows a TSConfig file to omit paths
    from `include` by specifying them in a top-level `"exclude"` property. Similar
    to `include`, it allows an array of strings that describes what directories and/or
    files to exclude from TypeScript compilation.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 项目的 `include` 文件列表有时会包括 TypeScript 不需要编译的文件。TypeScript 允许 TSConfig 文件通过在顶层 `"exclude"`
    属性中指定来从 `include` 中省略路径。与 `include` 类似，它允许一个描述要从 TypeScript 编译中排除的目录和/或文件的字符串数组。
- en: 'The following configuration includes all files in *src/* except for those within
    any nested *external/* directory and a *node_modules* directory:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下配置包含 *src/* 中所有文件，但不包括任何嵌套 *external/* 目录和 *node_modules* 目录中的文件：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: By default, `exclude` contains `["node_modules", "bower_components", "jspm_packages"]`
    to avoid running the TypeScript compiler on compiled third-party library files.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`exclude` 包含 `["node_modules", "bower_components", "jspm_packages"]`，以避免在编译的第三方库文件上运行
    TypeScript 编译器。
- en: Tip
  id: totrans-76
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If you’re writing your own `exclude` list, you typically won’t need to re-add
    `"bower_components"` or `"jspm_packages"`. Most JavaScript projects that install
    node modules to a folder within the project only install to `"node_modules"`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您编写自己的 `exclude` 列表，通常不需要重新添加 `"bower_components"` 或 `"jspm_packages"`。大多数
    JavaScript 项目将 node 模块安装到项目内的一个文件夹中，只安装到 `"node_modules"`。
- en: Keep in mind, `exclude` only acts to remove files from the starting list in
    `include`. TypeScript will run on any file imported by any included file, even
    if the imported file is explicitly listed in `exclude`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`exclude` 仅用于从 `include` 的起始列表中移除文件。TypeScript 将运行任何被任何包含的文件导入的文件，即使导入的文件明确列在
    `exclude` 中。
- en: Alternative Extensions
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替代扩展名
- en: TypeScript is by default able to read in any file whose extension is *.ts*.
    However, some projects require being able to read in files with different extensions,
    such as JSON modules or JSX syntax for UI libraries such as React.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 默认可以读取任何扩展名为 *.ts* 的文件。然而，某些项目需要能够读取具有不同扩展名的文件，例如用于 UI 库（如 React）的
    JSON 模块或 JSX 语法。
- en: JSX Syntax
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSX 语法
- en: 'JSX syntax like `<Component />` is often used in UI libraries such as Preact
    and React. JSX syntax is not technically JavaScript. Like TypeScript’s type definitions,
    it’s an extension to JavaScript syntax that compiles down to regular JavaScript:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 像`<Component />`这样的JSX语法通常在UI库（如Preact和React）中使用。JSX语法并不是JavaScript的技术规范。与TypeScript的类型定义一样，它是JavaScript语法的扩展，可以编译成普通的JavaScript：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In order to use JSX syntax in a file, you must do two things:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要在文件中使用JSX语法，您必须完成以下两项操作：
- en: Enable the `"jsx"` compiler option in your configuration options
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在配置选项中启用`"jsx"`编译选项
- en: Name that file with a *.tsx* extension
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将文件命名为*.tsx*扩展名
- en: jsx
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: jsx
- en: The value used for the `"jsx"` compiler option determines how TypeScript emits
    JavaScript code for *.tsx* files. Projects generally use one of these three values
    ([Table 13-1](#jsx_compiler_option_inputs_and_outputs)).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 用于`"jsx"`编译选项的值决定了TypeScript为*.tsx*文件生成JavaScript代码的方式。项目通常使用以下三个值之一（[Table 13-1](#jsx_compiler_option_inputs_and_outputs)）。
- en: Table 13-1\. JSX compiler option inputs and outputs
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Table 13-1\. JSX编译选项输入和输出
- en: '| Value | Input code | Output code | Output file extension |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| Value | Input code | Output code | Output file extension |'
- en: '| --- | --- | --- | --- |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| “preserve” | `<div />` | `<div />` | .jsx |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| “preserve” | `<div />` | `<div />` | .jsx |'
- en: '| “react” | `<div />` | `React.createElement("div")` | .js |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| “react” | `<div />` | `React.createElement("div")` | .js |'
- en: '| “react-native” | `<div />` | `<div />` | .js |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| “react-native” | `<div />` | `<div />` | .js |'
- en: Values for `jsx` may be provided to the `tsc` CLI and/or in a TSConfig file.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 可以向`tsc` CLI或TSConfig文件提供`jsx`的值。
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you’re not directly using TypeScript’s built-in transpiler, which is the
    case when you’re transpiling code with a separate tool such as Babel, you most
    likely can use any of the allowed values for `"jsx"`. Most web apps built on modern
    frameworks such as Next.js or Remix handle React configuration and compiling syntax.
    If you’re using one of those frameworks you probably won’t have to directly configure
    TypeScript’s built-in transpiler.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有直接使用TypeScript的内置转换器进行转译，而是使用像Babel这样的单独工具进行代码转译，您很可能可以使用允许的任何`"jsx"`值。大多数基于现代框架（如Next.js或Remix）构建的Web应用程序处理React配置和编译语法。如果您使用这些框架之一，您可能不必直接配置TypeScript的内置转译器。
- en: Generic arrow functions in .tsx files
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .tsx文件中的通用箭头函数
- en: '[Chapter 10, “Generics”](ch10.xhtml#generics_chapter) mentioned that the syntax
    for generic arrow functions conflicts with JSX syntax. Attempting to write a type
    argument `<T>` for an arrow function in a *.tsx* file will give a syntax error
    for there not being a closing tag for that opening `T` element:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[Chapter 10, “Generics”](ch10.xhtml#generics_chapter)提到了泛型箭头函数的语法与JSX语法冲突。在*.tsx*文件中为箭头函数写入类型参数`<T>`会导致语法错误，因为没有为该开放`T`元素的标签写入结束标记：'
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To work around this syntax ambiguity, you can add an `= unknown` constraint
    to the type argument. Type arguments default to the `unknown` type so this doesn’t
    change code behavior at all. It just indicates to TypeScript to read a type argument,
    not a JSX element:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决此语法歧义，可以在类型参数中添加一个`= unknown`约束。类型参数默认为`unknown`类型，因此这不会改变代码行为。这只是告诉TypeScript读取一个类型参数，而不是一个JSX元素：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: resolveJsonModule
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`resolveJsonModule`'
- en: TypeScript will allow reading in *.json* files if the `resolveJsonModule` compiler
    option is set to `true`. When it is, *.json* files may be imported from as if
    they were *.ts* files exporting an object. TypeScript will infer the type of that
    object as if it were a `const` variable.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将`resolveJsonModule`编译选项设置为`true`，TypeScript将允许读取*.json*文件。这样一来，*.json*文件就可以像导出对象的*.ts*文件那样进行导入。TypeScript将推断该对象的类型，就好像它是一个`const`变量。
- en: 'For JSON files that contain an object, destructuring imports may be used. This
    pair of files defines an `"activist"` string in an *activist.json* file and imports
    it into a *usesActivist.ts* file:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于包含对象的JSON文件，可以使用解构导入。以下是一个示例，其中*activist.json*文件定义了一个`"activist"`字符串，并将其导入到*usesActivist.ts*文件中：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Default imports may be used as well if the `esModuleInterop` compiler option—covered
    later in this chapter—is enabled:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果启用了`esModuleInterop`编译选项（稍后在本章中讨论），还可以使用默认导入：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'For JSON files that contain other literal types, such as arrays or numbers,
    you’ll have to use the `* as` import syntax. This pair of files defines an array
    of strings in an *activists.json* file that is then imported into a *useActivists.ts*
    file:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于包含其他文字类型（如数组或数字）的JSON文件，需要使用`* as`导入语法。以下是一个示例，其中*activists.json*文件定义了一个字符串数组，并将其导入到*useActivists.ts*文件中：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Emit
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Emit
- en: Although the rise of dedicated compiler tools such as Babel has reduced TypeScript’s
    role in some projects to solely type checking, many other projects still rely
    on TypeScript for compiling TypeScript syntax to JavaScript. It’s quite useful
    for projects to be able to take in a single dependency on `typescript` and use
    its `tsc` command to output the equivalent JavaScript.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管专用编译工具（如Babel）的兴起已经使得 TypeScript 在某些项目中的角色仅限于类型检查，但许多其他项目仍然依赖 TypeScript 将
    TypeScript 语法编译为 JavaScript。对于项目来说，能够依赖于 `typescript` 并使用其 `tsc` 命令输出等效的 JavaScript
    是非常有用的。
- en: outDir
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: outDir
- en: 'By default, TypeScript places output files alongside their corresponding source
    files. For example, running `tsc` on a directory containing *fruits/apple.ts*
    and *vegetables/zucchini.ts* would result with output files *fruits/apple.js*
    and *vegetables/zucchini.js*:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，TypeScript 将输出文件放置在其对应的源文件旁边。例如，在包含 *fruits/apple.ts* 和 *vegetables/zucchini.ts*
    的目录上运行 `tsc` 将导致 *fruits/apple.js* 和 *vegetables/zucchini.js* 的输出文件：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Sometimes it may be preferable to place output files in a different folder.
    Many Node projects, for example, put transformed outputs in a *dist* or *lib*
    directory.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有时将输出文件放置在不同的文件夹中可能更可取。例如，许多 Node 项目将转换后的输出放置在 *dist* 或 *lib* 目录中。
- en: TypeScript’s `outDir` compiler option allows specifying a different root directory
    for outputs. Output files are kept in the same relative directory structure as
    input files.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 的 `outDir` 编译选项允许指定输出的不同根目录。输出文件的相对目录结构与输入文件相同。
- en: 'For example, running `tsc --outDir dist` on the previous directory would place
    outputs within a *dist/* folder:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在前述目录上运行 `tsc --outDir dist` 将会在 *dist/* 文件夹中放置输出：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: TypeScript calculates the root directory to place output files into by finding
    the longest common subpath of all input files (excluding *.d.ts* declaration files).
    That means that projects that place all input source files in a single directory
    will have that directory treated as the root.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 通过查找所有输入文件（排除 *.d.ts* 声明文件）的最长公共子路径来计算放置输出文件的根目录。这意味着将所有输入源文件放在单个目录中的项目将该目录视为根目录。
- en: 'For example, if the above example put all inputs in a *src/* directory and
    compiled with `--outDir lib`, *lib/fruits/apple.js* would be created instead of
    *lib/src/fruits/apple.js*:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果上述示例将所有输入放置在 *src/* 目录中，并使用 `--outDir lib` 进行编译，则会创建 *lib/fruits/apple.js*
    而不是 *lib/src/fruits/apple.js*：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: A `rootDir` compiler option does exist to explicitly specify that root directory,
    but it’s rarely necessary or used with values other than `.` or `src`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 确实有一个 `rootDir` 编译选项，用于显式指定根目录，但除了 `.` 或 `src` 之外，很少需要或使用其他值。
- en: target
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: target
- en: TypeScript is able to produce output JavaScript that can run in environments
    as old as ES3 (circa 1999!). Most environments are able to support syntax features
    from much newer versions of JavaScript.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 能够生成可以在 ES3（大约 1999 年）等旧环境中运行的 JavaScript 输出。大多数环境都能够支持来自较新 JavaScript
    版本的语法特性。
- en: TypeScript includes a `target` compiler option to specify how far back in syntax
    support JavaScript code needs to be transpiled. Although `target` defaults to
    `"es3"` for backward compatibility reasons when not specified and `tsc --init`
    defaults to specifying `"es2016"`, it’s generally advisable to use the newest
    JavaScript syntax possible per your target platform(s). Supporting newer JavaScript
    features in older environments necessitates creating more JavaScript code, which
    causes slightly larger file sizes and slightly worse runtime performance.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 包含一个 `target` 编译选项，用于指定需要将 JavaScript 代码转译到多老的语法支持。当未指定时，默认情况下 `target`
    为 `"es3"`，而 `tsc --init` 的默认设置为 `"es2016"`。通常建议根据目标平台使用尽可能新的 JavaScript 语法。在旧环境中支持新的
    JavaScript 特性会导致生成更多的 JavaScript 代码，这会稍微增加文件大小并略微降低运行时性能。
- en: Tip
  id: totrans-130
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: As of 2022, all releases within the last year of browsers serving > 0.1% of
    worldwide users support at least all of ECMAScript 2019 and nearly all of ECMAScript
    2020–2021, while the LTS-supported versions of Node.js support all of ECMAScript
    2021. There’s very little reason not to have a `target` at least as high as `"es2019"`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 2022 年，全球 > 0.1% 用户使用的浏览器的所有最新版本都至少支持 ECMAScript 2019，并且几乎所有版本支持 ECMAScript
    2020–2021，而 Node.js 的 LTS 支持版本则支持 ECMAScript 2021 的全部特性。因此，至少将 `target` 设置为 `"es2019"`
    是非常合理的。
- en: 'For example, take this TypeScript source containing ES2015 `const`s and ES2020
    `??` nullish coalescing:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑这个包含 ES2015 `const` 和 ES2020 `??` 空值合并的 TypeScript 源码：
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'With `tsc --target es2020` or newer, both `const` and `??` are supported syntax
    features, so TypeScript would only need to remove the `: string | undefined` from
    that snippet:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '使用 `tsc --target es2020` 或更新版本，`const` 和 `??` 都是支持的语法特性，因此 TypeScript 只需从片段中移除
    `: string | undefined`：'
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'With `tsc --target es2015` through `es2019`, the `??` syntax sugar would be
    compiled down to its equivalent in older versions of JavaScript:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `tsc --target es2015` 到 `es2019`，`??` 语法糖将编译为较旧版本 JavaScript 中的等效语法：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With `tsc --target es3` or `es5`, the `const` would additionally need to be
    converted to its equivalent `var`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `tsc --target es3` 或 `es5`，`const` 还需要额外转换为其等效的 `var`：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Specifying the `target` compiler option to a value that matches the oldest environment
    your code runs will ensure code is emitted as modern, terse syntax that can still
    run without syntax errors.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `target` 编译器选项指定为与代码运行的最旧环境相匹配的值，将确保代码以现代、简洁的语法形式输出，仍然可以在没有语法错误的情况下运行。
- en: Emitting Declarations
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发出声明
- en: '[Chapter 11, “Declaration Files”](ch11.xhtml#declaration_files) covered how
    *.d.ts* declaration files may be distributed in a package to indicate code types
    to consumers. Most packages use TypeScript’s `declaration` compiler option to
    emit *.d.ts* output files from source files:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 11 章，“声明文件”](ch11.xhtml#declaration_files) 讲述了如何在包中分发 *.d.ts* 声明文件以向消费者指示代码类型。大多数包使用
    TypeScript 的 `declaration` 编译器选项从源文件中发出 *.d.ts* 输出文件：'
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*.d.ts* output files are emitted under the same output rules as *.js* files,
    including respecting `outDir`.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*.d.ts* 输出文件遵循与 *.js* 文件相同的输出规则，包括遵守 `outDir`。'
- en: 'For example, running `tsc --declaration` on a directory containing *fruits/apple.ts*
    and *vegetables/zucchini.ts* would result in output declaration files *fruits/apple.d.ts*
    and *vegetables/zucchini.d.ts* alongside output *.js* files:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在包含 *fruits/apple.ts* 和 *vegetables/zucchini.ts* 的目录上运行 `tsc --declaration`
    将导致输出声明文件 *fruits/apple.d.ts* 和 *vegetables/zucchini.d.ts* 以及输出的 *.js* 文件：
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: emitDeclarationOnly
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: emitDeclarationOnly
- en: 'An `emitDeclarationOnly` compiler option exists, as a specialized addition
    to the `declaration` compiler option, that directs TypeScript to only emit declaration
    files: no *.js*/*.jsx* files at all. This is useful for projects that use an external
    tool to generate output JavaScript but still want to use TypeScript to generate
    output definition files:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一个 `emitDeclarationOnly` 编译器选项，作为 `declaration` 编译器选项的专门补充，指示 TypeScript 只发出声明文件：完全没有
    *.js*/*.jsx* 文件输出。这对于使用外部工具生成输出 JavaScript 但仍希望使用 TypeScript 生成输出定义文件的项目非常有用：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If `emitDeclarationOnly` is enabled, either `declaration` or the `composite`
    compiler option covered later in this chapter must be enabled.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果启用了 `emitDeclarationOnly`，则必须启用 `declaration` 或本章后面介绍的 `composite` 编译器选项之一。
- en: 'For example, running `tsc --declaration --emitDeclarationOnly` on a directory
    containing *fruits/apple.ts* and *vegetables/zucchini.ts* would result with output
    declaration files *fruits/apple.d.ts* and *vegetables/zucchini.d.ts* without any
    output *.js* files:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在包含 *fruits/apple.ts* 和 *vegetables/zucchini.ts* 的目录上运行 `tsc --declaration
    --emitDeclarationOnly` 将导致输出声明文件 *fruits/apple.d.ts* 和 *vegetables/zucchini.d.ts*，而没有任何
    *.js* 文件输出：
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Source Maps
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 源映射
- en: Source maps are descriptions of how the contents of output files match up to
    original source files. They allow developer tools such as debuggers to display
    original source code when navigating through the output file. They’re particularly
    useful for visual debuggers such as those used in browser developer tools and
    IDEs to let you see original source file contents while debugging. TypeScript
    includes the ability to output source maps alongside output files.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 源映射描述了输出文件的内容如何与原始源文件匹配。它们允许开发者工具（如调试器）在浏览输出文件时显示原始源代码。对于视觉调试器特别有用，比如浏览器开发者工具和集成开发环境（IDE），以便在调试时查看原始源文件内容。TypeScript
    包括在输出文件旁边输出源映射的能力。
- en: sourceMap
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: sourceMap
- en: TypeScript’s `sourceMap` compiler option enables outputting *.js.map* or *.jsx.map*
    sourcemaps alongside *.js* or *.jsx* output files. Sourcemap files are otherwise
    given the same name as their corresponding output JavaScript file and placed in
    the same directory.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 的 `sourceMap` 编译器选项使得可以在 *.js* 或 *.jsx* 输出文件旁边输出 *.js.map* 或 *.jsx.map*
    源映射文件。否则，源映射文件将与相应的输出 JavaScript 文件同名并放置在相同目录中。
- en: 'For example, running `tsc --sourceMap` on a directory containing *fruits/apple.ts*
    and *vegetables/zucchini.ts* would result with output sourcemap files *fruits/apple.js.map*
    and *vegetables/zucchini.js.map* alongside output *.js* files:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在包含 *fruits/apple.ts* 和 *vegetables/zucchini.ts* 的目录上运行 `tsc --sourceMap`
    将生成输出源映射文件 *fruits/apple.js.map* 和 *vegetables/zucchini.js.map*，以及输出的 *.js* 文件：
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: declarationMap
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: declarationMap
- en: TypeScript is also able to generate source maps for *.d.ts* declaration files.
    Its `declarationMap` compiler option directs it to generate a *.d.ts.map* source
    map for each *.d.ts* that maps back to the original source file. Declaration maps
    enable IDEs such as VS Code to go to the original source file when using editor
    features such as Go to Definition.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 还能够为 *.d.ts* 声明文件生成源映射。其 `declarationMap` 编译选项指示为每个 *.d.ts* 生成一个
    *.d.ts.map* 源映射文件，该文件将原始源文件映射回去。声明映射使得诸如 VS Code 这样的 IDE 在使用编辑器功能如跳转到定义时能够到达原始源文件。
- en: Tip
  id: totrans-163
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: '`declarationMap` is particularly useful when working with project references,
    covered toward the end of this chapter.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当与项目引用一起使用时，`declarationMap` 特别有用。
- en: 'For example, running `tsc --declaration --declarationMap` on a directory containing
    *fruits/apple.ts* and *vegetables/zucchini.ts* would result in output declaration
    sourcemap files *fruits/apple.d.ts.map* and *vegetables/zucchini.d.ts.map* alongside
    output *.d.ts* and *.js* files:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在包含 *fruits/apple.ts* 和 *vegetables/zucchini.ts* 的目录上运行 `tsc --declaration
    --declarationMap` 将生成输出声明源映射文件 *fruits/apple.d.ts.map* 和 *vegetables/zucchini.d.ts.map*，以及输出的
    *.d.ts* 和 *.js* 文件：
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: noEmit
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: noEmit
- en: For projects that completely rely on other tools to compile source files to
    output JavaScript, TypeScript can be told to skip emitting files altogether. Enabling
    the `noEmit` compiler option directs TypeScript to act purely as a type checker.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 对于完全依赖其他工具将源文件编译为输出 JavaScript 的项目，可以告诉 TypeScript 完全跳过生成文件。启用 `noEmit` 编译选项将使
    TypeScript 纯粹作为类型检查器。
- en: Running `tsc --noEmit` on any of the previous examples would result in no new
    files created. TypeScript would only report any syntax or type errors it finds.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何先前示例上运行 `tsc --noEmit` 将导致不生成新文件。TypeScript 仅报告找到的任何语法或类型错误。
- en: Type Checking
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型检查
- en: Most of TypeScript’s configuration options control its type checker. You can
    configure it to be gentle and forgiving, only emitting type-checking complaints
    when it’s completely certain of an error, or harsh and strict, requiring nearly
    all code be well typed.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 TypeScript 的配置选项控制其类型检查器。您可以配置它以温和和宽容的方式工作，只有在完全确定错误时才会发出类型检查投诉，或者以严格和严厉的方式要求几乎所有代码都要有良好的类型。
- en: lib
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: lib
- en: To start, which global APIs TypeScript assumes to be present in the runtime
    environment is configurable with the `lib` compiler option. It takes in an array
    of strings that defaults to your `target` compiler option, as well as `dom` to
    indicate including browser types.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，TypeScript 假设在运行时环境中存在的全局 API 可以通过 `lib` 编译选项进行配置。它接受一个字符串数组，默认为您的 `target`
    编译选项，以及 `dom` 表示包括浏览器类型。
- en: 'Most of the time, the only reason to customize `lib` would be to remove the
    `dom` inclusion for a project that doesn’t run in the browser:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，自定义 `lib` 的唯一理由是为了删除不在浏览器中运行的项目中的 `dom` 包含：
- en: '[PRE32]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Alternately, for a project that uses polyfills to support newer JavaScript
    APIs, `lib` can include `dom` and any ECMAScript version:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，对于使用 polyfill 支持更新的 JavaScript API 的项目，`lib` 可以包括 `dom` 和任何 ECMAScript 版本：
- en: '[PRE34]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Be wary of modifying `lib` without providing all the right runtime polyfills.
    A project with a `lib` set to `"es2021"` running on a platform that only supports
    up through ES2020 might have no type-checking errors but still experience runtime
    errors attempting to use APIs defined in ES2021 or later, such as `String.replaceAll`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 谨慎修改 `lib`，如果没有提供所有正确的运行时 polyfill，可能会导致问题。例如，项目中将 `lib` 设置为 `"es2021"`，但在只支持到
    ES2020 的平台上运行，可能不会出现类型检查错误，但尝试使用 ES2021 或更新定义的 API（如 `String.replaceAll`）时可能会出现运行时错误：
- en: '[PRE36]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Tip
  id: totrans-182
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Think of the `lib` compiler option as indicating what built-in language APIs
    are available, whereas the `target` compiler option indicates what syntax features
    exist.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `lib` 编译选项视为指示可用的内置语言 API，而 `target` 编译选项则指示存在的语法特性。
- en: skipLibCheck
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: skipLibCheck
- en: 'TypeScript provides a `skipLibCheck` compiler option that indicates to skip
    type checking in declaration files not explicitly included in your source code.
    This can be useful for applications that rely on many dependencies that may rely
    on different, conflicting definitions of shared libraries:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript提供了一个`skipLibCheck`编译选项，指示在未显式包含在您的源代码中的声明文件中跳过类型检查。这对依赖许多可能依赖不同、冲突的共享库定义的应用程序非常有用：
- en: '[PRE37]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`skipLibCheck` speeds up TypeScript performance by allowing it to skip some
    type checking. For this reason, it is generally a good idea to enable it on most
    projects.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`skipLibCheck`通过允许跳过一些类型检查来加速TypeScript性能。因此，通常建议在大多数项目中启用它。'
- en: Strict Mode
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 严格模式
- en: Most of TypeScript’s type-checking compiler options are grouped into what TypeScript
    refers to as *strict mode*. Each strictness compiler option defaults to `false`,
    and when enabled, directs the type checker to turn on some additional checks.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript的大多数类型检查编译选项都被分组到所谓的*严格模式*中。每个严格性编译选项默认为`false`，启用时，指示类型检查器打开一些额外的检查。
- en: I’ll cover the most commonly used strict options in alphabetical order later
    in this chapter. From those options, `noImplicitAny` and `strictNullChecks` are
    particularly useful and impactful in enforcing type-safe code.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在本章后面按字母顺序介绍最常用的严格选项。从这些选项中，`noImplicitAny`和`strictNullChecks`在强制执行类型安全代码方面特别有用和有影响。
- en: 'You can enable all strict mode checks by enabling the `strict` compiler option:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过启用`strict`编译选项来启用所有严格模式检查：
- en: '[PRE39]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If you want to enable all strict mode checks except for certain ones, you can
    both enable `strict` and explicitly disable certain checks. For example, this
    configuration enables all strict modes except for `noImplicitAny`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想启用除了某些检查外的所有严格模式检查，可以同时启用`strict`并显式禁用某些检查。例如，此配置启用了除了`noImplicitAny`之外的所有严格模式：
- en: '[PRE41]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Warning
  id: totrans-198
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Future versions of TypeScript may introduce new strict type-checking compiler
    options under `strict`. Using `strict` may therefore cause new type-checking complaints
    when you update TypeScript versions. You can always opt out of specific settings
    in your TSConfig.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 未来的TypeScript版本可能在`strict`下引入新的严格类型检查编译选项。因此，在更新TypeScript版本时，使用`strict`可能会导致新的类型检查投诉。您始终可以在您的TSConfig中选择退出特定设置。
- en: noImplicitAny
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: noImplicitAny
- en: If TypeScript cannot infer the type of a parameter or property, then it will
    fall back to assuming the `any` type. It is generally best practice to not allow
    these implicit `any` types in code as the `any` type is allowed to bypass much
    of TypeScript’s type checking.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果TypeScript无法推断参数或属性的类型，那么它将回退到假定的`any`类型。通常最佳实践是不允许这些隐式的`any`类型存在于代码中，因为`any`类型允许绕过TypeScript的大部分类型检查。
- en: The `noImplicitAny` compiler option directs TypeScript to issue a type-checking
    complaint when it has to fall back to an implicit `any`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`noImplicitAny`编译选项指示TypeScript在必须回退到隐式`any`时发出类型检查投诉。'
- en: 'For example, writing the following function parameter without a type declaration
    would cause a type error under `noImplicitAny`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，不带类型声明编写以下函数参数将在`noImplicitAny`下引发类型错误：
- en: '[PRE43]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Most of the time, a `noImplicitAny` complaint can be resolved either by adding
    a type annotation on the complaining location:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，可以通过在投诉位置添加类型注释来解决`noImplicitAny`投诉：
- en: '[PRE44]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Or, in the case of function parameters, putting the parent function in a location
    that indicates the type of the function:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在函数参数的情况下，将父函数放在指示函数类型的位置：
- en: '[PRE45]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Tip
  id: totrans-209
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: '`noImplicitAny` is an excellent flag for ensuring type safety across a project.
    I highly recommend striving to turn it on in projects written completely in TypeScript.
    However, if a project is still transitioning from JavaScript to TypeScript, it
    may be easier to finish converting all files to TypeScript first.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`noImplicitAny`是确保项目中类型安全的一个很好的标志。我强烈建议在完全使用TypeScript编写的项目中努力将其打开。然而，如果项目仍在从JavaScript过渡到TypeScript阶段，可能更容易先完成所有文件的转换到TypeScript。'
- en: strictBindCallApply
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: strictBindCallApply
- en: When TypeScript was first released, it didn’t have rich enough type system features
    to be able to represent the built-in `Function.apply`, `Function.bind`, or `Function.call`
    function utilities. Those functions by default had to take in `any` for their
    list of arguments. That’s not very type safe!
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当TypeScript首次发布时，它没有足够丰富的类型系统功能来表示内置的`Function.apply`、`Function.bind`或`Function.call`函数实用程序。那些函数默认情况下必须接受`any`作为其参数列表。这不太类型安全！
- en: 'As an example, without `strictBindCallApply`, the following variations on `getLength`
    all include `any` in their types:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在没有`strictBindCallApply`的情况下，以下`getLength`变体的所有类型都包含`any`：
- en: '[PRE46]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now that TypeScript’s type system features are powerful enough to represent
    those functions’ generic rest arguments, TypeScript allows opting in to using
    more restrictive types for the functions.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，TypeScript的类型系统功能足以表示那些函数的泛型剩余参数，TypeScript允许选择使用更严格的类型来进行函数。
- en: 'Enabling `strictBindCallApply` enables much more precise types for the `getLength`
    variations:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 启用`strictBindCallApply`可以为`getLength`变体提供更精确的类型：
- en: '[PRE47]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: TypeScript best practice is to enable `strictBindCallApply`. Its improved type
    checking for built-in function utilities helps improve type safety for projects
    that utilize them.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript的最佳实践是启用`strictBindCallApply`。它改进了内置函数工具的类型检查，有助于提高项目中使用它们的类型安全性。
- en: strictFunctionTypes
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: strictFunctionTypes
- en: The `strictFunctionTypes` compiler option causes function parameter types to
    be checked slightly more strictly. A function type is no longer considered assignable
    to another function type if its parameters are subtypes of that other type’s parameters.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`strictFunctionTypes`编译器选项导致函数参数类型检查更严格。如果函数类型的参数是该类型参数的子类型，则不再被认为可分配给另一个函数类型。'
- en: 'As a concrete example, the `checkOnNumber` function here takes in a function
    that should be able to receive a `number | string`, but is provided with a `stringContainsA`
    function that expects to take in a parameter only of type `string`. TypeScript’s
    default type checking would allow it—and the program would crash from trying to
    call `.match()` on a `number`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个具体例子，在这里`checkOnNumber`函数接收一个应该能接收`number | string`的函数，但提供了一个期望只接收`string`类型参数的`stringContainsA`函数。
    TypeScript的默认类型检查会允许这种情况发生，并且程序将因尝试在`number`上调用`.match()`而崩溃：
- en: '[PRE48]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Under `strictFunctionTypes`, `checkOnNumber(stringContainsA)` would cause a
    type-checking error:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在`strictFunctionTypes`下，`checkOnNumber(stringContainsA)`将导致类型检查错误：
- en: '[PRE49]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note
  id: totrans-225
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In technical terms, function parameters switch from being *bivariant* to *contravariant*.
    You can read more about the difference in the [TypeScript 2.6 release notes](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-6.html).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在技术术语上，函数参数从*bivariant*变为*contravariant*。您可以在[TypeScript 2.6发布说明](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-6.html)中了解更多关于这两者差异的信息。
- en: strictNullChecks
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: strictNullChecks
- en: 'Back in [Chapter 3, “Unions and Literals”](ch03.xhtml#unions_and_literals),
    I discussed the billion-dollar mistake of languages: allowing empty types such
    as `null` and `undefined` to be assignable to nonempty types. Disabling TypeScript’s
    `strictNullChecks` flag roughly adds `null | undefined` to every type in your
    code, thereby allowing any variable to receive `null` or `undefined`.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下[第3章，“联合类型和字面量”](ch03.xhtml#unions_and_literals)，我讨论了语言的十亿美元错误：允许空类型（如`null`和`undefined`）可分配给非空类型。禁用TypeScript的`strictNullChecks`标志大致会将`null
    | undefined`添加到代码中的每种类型中，从而允许任何变量接收`null`或`undefined`。
- en: 'This code snippet would cause a type error for assigning `null` to a `string`
    typed value only when `strictNullChecks` is enabled:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段只有在启用`strictNullChecks`时，将`null`赋给`string`类型的值才会引发类型错误：
- en: '[PRE50]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: TypeScript best practice is to enable `strictNullChecks`. Doing so helps prevent
    crashes and eliminates the billion-dollar mistake.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript的最佳实践是启用`strictNullChecks`。这样做有助于防止崩溃并消除十亿美元的错误。
- en: Refer to [Chapter 3, “Unions and Literals”](ch03.xhtml#unions_and_literals)
    for more details.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多详细信息，请参阅[第3章，“联合类型和字面量”](ch03.xhtml#unions_and_literals)。
- en: strictPropertyInitialization
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: strictPropertyInitialization
- en: 'Back in [Chapter 8, “Classes”](ch08.xhtml#classes), I discussed strict initialization
    checking in classes: making sure that each property on a class is definitely assigned
    in the class constructor. TypeScript’s `strictPropertyInitialization` flag causes
    a type error to be issued on class properties that have no initializer and are
    not definitely assigned in the constructor.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下[第8章，“类”](ch08.xhtml#classes)，我讨论了类中的严格初始化检查：确保类上的每个属性在类构造函数中确实被分配。 TypeScript的`strictPropertyInitialization`标志会导致对类属性发出类型错误，这些属性没有初始化程序并且在构造函数中也没有明确分配。
- en: TypeScript best practice is generally to enable `strictPropertyInitialization`.
    Doing so helps prevent crashes from mistakes in class initialization logic.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript的最佳实践通常是启用`strictPropertyInitialization`。这样做有助于防止由于类初始化逻辑中的错误而导致的崩溃。
- en: Refer to [Chapter 8, “Classes”](ch08.xhtml#classes) for more details.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多详细信息，请参阅[第8章，“类”](ch08.xhtml#classes)。
- en: useUnknownInCatchVariables
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: useUnknownInCatchVariables
- en: 'Error handling in any language is an inherently unsafe concept. Any function
    can in theory throw any number of errors from edge cases such as reading properties
    on `undefined` or user-written `throw` statements. In fact, there’s no guarantee
    a thrown error is even an instance of the `Error` class: code can always `throw
    "something-else"`.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 任何语言中的错误处理都是一个本质上不安全的概念。理论上，任何函数都可以抛出许多错误，例如在`undefined`上读取属性或用户编写的`throw`语句。事实上，并没有保证抛出的错误是`Error`类的实例：代码总是可以`throw
    "something-else"`。
- en: As a result, TypeScript’s default behavior for errors is to give them type `any`,
    as they could be anything. That allows flexibility in error handling at the cost
    of relying on the not-very-type-safe `any` by default.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，TypeScript 对于错误的默认行为是将它们视为`any`类型，因为它们可能是任何类型。这允许在错误处理时灵活处理，但以默认情况下依赖不太类型安全的`any`。
- en: 'The following snippet’s `error` is typed `any` because there’s no way for TypeScript
    to know what all the possible errors thrown by `someExternalFunction()` could
    be:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 TypeScript 无法知道`someExternalFunction()`抛出的所有可能错误，因此以下片段的`error`被标记为`any`：
- en: '[PRE51]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: As with most `any` uses, it would be more technically sound—at the cost of often
    necessitating explicit type assertions or narrowing—to treat errors as `unknown`
    instead. Catch clause errors are allowed to be annotated as the `any` or `unknown`
    types.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数`any`用法一样，将错误视为`unknown`类型在技术上更加合理，但往往需要明确的类型断言或缩小范围。捕获子句错误允许注释为`any`或`unknown`类型。
- en: 'This snippet correction adds an explicit `: unknown` to `error` to switch it
    to the `unknown` type:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '此片段修正了将`error`显式改为`: unknown`以将其切换为`unknown`类型：'
- en: '[PRE52]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The strict area flag `useUnknownInCatchVariables` changes TypeScript’s default
    catch clause error type to `unknown`. With `useUnknownInCatchVariables` enabled,
    both snippets would have type of `error` set to be `unknown`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 严格的区域标志`useUnknownInCatchVariables`将 TypeScript 的默认捕获子句错误类型更改为`unknown`。启用`useUnknownInCatchVariables`后，两个片段的类型都将设置为`unknown`，并且会显示`error`。
- en: TypeScript best practice is generally to enable `useUnknownInCatchVariables`,
    as it’s not always safe to assume errors will be any particular type.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 的最佳实践通常是启用`useUnknownInCatchVariables`，因为不能总是安全地假设错误将是特定类型。
- en: Modules
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块
- en: JavaScript’s various systems for exporting and importing module contents—AMD,
    CommonJS, ECMAScript, and so on—are one of the most convoluted module systems
    in any modern programming language. JavaScript is relatively unusual in that the
    way files import each other’s contents is often driven by user-written frameworks
    such as Webpack. TypeScript does its best to provide configuration options that
    represent most reasonable user-land module configurations.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的各种导出和导入模块内容的系统 —— AMD、CommonJS、ECMAScript 等 —— 是任何现代编程语言中最复杂的模块系统之一。JavaScript
    相对不寻常的是文件之间如何导入对方内容通常由用户编写的框架（如 Webpack）驱动。TypeScript 尽最大努力提供配置选项，以表示大多数合理的用户模块配置。
- en: 'Most new TypeScript projects are written with the standardized ECMAScript modules
    syntax. To recap, here is how ECMAScript modules import a value (`value`) from
    another module `("my-example-lib")` and export their own value (`logValue`):'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数新的 TypeScript 项目都使用标准化的 ECMAScript 模块语法进行编写。总结一下，这里是 ECMAScript 模块如何从另一个模块`("my-example-lib")`导入值（`value`）并导出它们自己的值（`logValue`）：
- en: '[PRE53]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: module
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块
- en: TypeScript provides a `module` compiler option to direct which module system
    transpiled code will use. When writing source code with ECMAScript modules, TypeScript
    may transpile the `export` and `import` statements to a different module system
    based on the `module` value.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 提供了一个`module`编译器选项来指定转译后的代码将使用哪个模块系统。当使用 ECMAScript 模块编写源代码时，TypeScript
    可能会将`export`和`import`语句转译为基于`module`值的不同模块系统。
- en: 'For example, directing that a project written in ECMAScript be output as CommonJS
    modules in either the command line:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，命令行中指定 ECMAScript 编写的项目输出为 CommonJS 模块：
- en: '[PRE54]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'or in a TSConfig:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 或在 TSConfig 中：
- en: '[PRE55]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The previous code snippet would roughly be output as:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段大致输出为：
- en: '[PRE56]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: If your `target` compiler option is `"es3"` or `"es5"`, `module`’s default value
    will be `"commonjs"`. Otherwise, `module` will default to `"es2015"` to specify
    outputting ECMAScript modules.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的`target`编译器选项是`"es3"`或`"es5"`，则`module`的默认值将为`"commonjs"`。否则，`module`将默认为`"es2015"`，以指定输出
    ECMAScript 模块。
- en: moduleResolution
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块解析
- en: '*Module resolution* is the process by which the imported path in an import
    is mapped to a module. TypeScript provides a `moduleResolution` option that you
    can use to specify the logic for that process. You’ll typically want to provide
    it one of two logic strategies:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '*模块解析* 是指导入语句中导入路径如何映射到模块的过程。TypeScript 提供了一个 `moduleResolution` 选项，您可以使用它来指定这一过程的逻辑。通常情况下，您会希望为它提供两种逻辑策略之一：'
- en: '`node`: The behavior used by CommonJS resolvers such as traditional Node.js'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`node`: 类似传统 Node.js 的 CommonJS 解析器所使用的行为'
- en: '`nodenext`: Aligning to the behavior specified for ECMAScript modules'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nodenext`: 与 ECMAScript 模块指定的行为对齐'
- en: The two strategies are similar. Most projects could use either of them and not
    notice a difference. You can read more on the intricacies behind the scenes of
    module resolution on [*https://www.typescriptlang.org/docs/handbook/module-resolution.html*](https://www.typescriptlang.org/docs/handbook/module-resolution.html).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种策略相似。大多数项目可以使用其中任何一种而不会注意到差异。您可以在[*https://www.typescriptlang.org/docs/handbook/module-resolution.html*](https://www.typescriptlang.org/docs/handbook/module-resolution.html)上详细了解模块解析背后的复杂性。
- en: Note
  id: totrans-265
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`moduleResolution` does not change how TypeScript emits code at all. It’s only
    used to describe the runtime environment your code is meant to be run in.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`moduleResolution` 完全不影响 TypeScript 如何生成代码。它仅用于描述代码运行时所需的环境。'
- en: 'Both the following CLI snippet and JSON file snippet would work to specify
    the `moduleResolution` compiler option:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的 CLI 片段和 JSON 文件片段都可以用来指定 `moduleResolution` 编译器选项：
- en: '[PRE57]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Tip
  id: totrans-270
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: For backward compatibility reasons, TypeScript keeps the default `moduleResolution`
    value to a `classic` value that was used for projects years ago. You almost certainly
    do not want the `classic` strategy in any modern project.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 由于向后兼容的原因，TypeScript 保持了默认的 `moduleResolution` 值为一个 `classic` 值，这个值在多年前的项目中使用过。在任何现代项目中，几乎肯定不希望使用
    `classic` 策略。
- en: Interoperability with CommonJS
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与 CommonJS 的互操作性
- en: When working with JavaScript modules, there is a difference between the “default”
    export of a module and its “namespace” output. The *default* export of a module
    is the `.default` property on its exported object. The *namespace* export of a
    module is the exported object itself.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理 JavaScript 模块时，“默认”导出和“命名空间”输出之间存在差异。模块的 *默认* 导出是其导出对象的 `.default` 属性。模块的
    *命名空间* 导出是导出对象本身。
- en: '[Table 13-2](#CommonJs_ECMAScript) recaps the differences between default and
    namespace exports and imports.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '[表格 13-2](#CommonJs_ECMAScript) 总结了默认和命名空间导出和导入之间的差异。'
- en: Table 13-2\. CommonJS and ECMAScript module export and import forms
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 13-2. CommonJS 和 ECMAScript 模块的导出和导入形式
- en: '| Area of syntax | CommonJS | ECMAScript modules |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| 语法区域 | CommonJS | ECMAScript 模块 |'
- en: '| --- | --- | --- |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Default export | `module.exports.default = value;` | `export default value;`
    |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| 默认导出 | `module.exports.default = value;` | `export default value;` |'
- en: '| Default import | `const { default: value } = require("...");` | `import value
    from "...";` |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| 默认导入 | `const { default: value } = require("...");` | `import value from
    "...";` |'
- en: '| Namespace export | `module.exports = value;` | Not supported |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| 命名空间导出 | `module.exports = value;` | 不支持 |'
- en: '| Namespace import | `const value = require("...");` | `import * as value from
    "...";` |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| 命名空间导入 | `const value = require("...");` | `import * as value from "...";`
    |'
- en: TypeScript’s type system builds its understanding of file imports and exports
    in terms of ECMAScript modules. If your project depends on npm packages as most
    do, however, it’s likely some of those dependencies are still published as CommonJS
    modules. Furthermore, although some packages that comply with ECMAScript modules
    rules avoid including a default export, many developers prefer the more succinct
    default-style imports over namespace-style imports. TypeScript includes a few
    compiler options that improve interoperability between module formats.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 的类型系统根据 ECMAScript 模块的文件导入和导出构建其理解。然而，如果您的项目依赖于大多数情况下都会依赖于 npm 包，很可能其中一些依赖项仍以
    CommonJS 模块的形式发布。此外，尽管一些符合 ECMAScript 模块规则的包避免包含默认导出，但许多开发人员更喜欢更简洁的默认样式导入而不是命名空间样式导入。TypeScript
    包括一些编译器选项，可以改善模块格式之间的互操作性。
- en: esModuleInterop
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: esModuleInterop
- en: The `esModuleInterop` configuration option adds a small amount of logic to JavaScript
    code emitted by TypeScript when `module` is not an ECMAScript module format such
    as `"es2015"` or `"esnext"`. That logic allows ECMAScript modules to import from
    modules even if they don’t happen to adhere to ECMAScript modules’ rules around
    default or namespace imports.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 当`module`不是诸如`"es2015"`或`"esnext"`之类的 ECMAScript 模块格式时，`esModuleInterop`配置选项会在
    TypeScript 生成的 JavaScript 代码中添加一小部分逻辑。该逻辑允许 ECMAScript 模块从模块导入，即使它们未必遵循 ECMAScript
    模块的默认或命名空间导入规则。
- en: 'One common reason to enable `esModuleInterop` is for packages such as `"react"`
    that do not ship a default export. If a module attempts to use a default-style
    import from the `"react"` package, TypeScript would report a type error without
    `esModuleInterop` enabled:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 启用`esModuleInterop`的一个常见原因是对于诸如`"react"`等不提供默认导出的包。如果模块尝试从`"react"`包中使用默认样式导入，则在未启用`esModuleInterop`的情况下，TypeScript
    将报告类型错误：
- en: '[PRE59]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Note that `esModuleInterop` only directly changes how emitted JavaScript code
    works with imports. The following `allowSyntheticDefaultImports` configuration
    option is what informs the type system about import interoperability.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`esModuleInterop`仅直接更改与导入关系的生成 JavaScript 代码的方式。以下`allowSyntheticDefaultImports`配置选项告知类型系统有关导入互操作性的信息。
- en: allowSyntheticDefaultImports
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 允许`allowSyntheticDefaultImports`
- en: The `allowSyntheticDefaultImports` compiler option informs the type system that
    ECMAScript modules may default import from files that are otherwise incompatible
    CommonJS namespace exports.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`allowSyntheticDefaultImports`编译器选项告知类型系统，ECMAScript 模块可以从其他不兼容的 CommonJS 命名空间导出文件中默认导入。'
- en: 'It defaults to `true` only if either of the following is true:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 仅当以下条件之一为真时，默认为`true`：
- en: '`module` is `"system"` (an older, rarely used module format not covered in
    this book).'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`module`为`"system"`（一种较旧且很少使用的模块格式，在本书中未涵盖）。'
- en: '`esModuleInterop` is `true` and `module` is not an ECMAScript modules format
    such as `"es2015"` or `"esnext"`.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`esModuleInterop`为`true`且`module`不是诸如`"es2015"`或`"esnext"`之类的 ECMAScript 模块格式时。
- en: 'In other words, if `esModuleInterop` is `true` but `module` is `"esnext"`,
    TypeScript will assume output compiled JavaScript code is not using import interoperability
    helpers. It would report a type error for a default import from packages such
    as `"react"`:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果`esModuleInterop`为`true`但`module`为`"esnext"`，TypeScript 将假定输出的编译 JavaScript
    代码未使用导入互操作性助手。对于从 `"react"` 等包中的默认导入，它将报告类型错误：
- en: '[PRE60]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: isolatedModules
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`isolatedModules`'
- en: 'External transpilers such as Babel that only operate on one file at a time
    cannot use type system information to emit JavaScript. As a result, TypeScript
    syntax features that rely on type information to emit JavaScript aren’t generally
    supported in those transpilers. Enabling the `isolatedModules` compiler tells
    TypeScript to report an error on any instance of a syntax that is likely to cause
    issues in those transpilers:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如 Babel 等外部转换器一次只能处理一个文件，无法使用类型系统信息来生成 JavaScript。因此，依赖类型信息来生成 JavaScript 的
    TypeScript 语法特性通常不受这些转换器的支持。启用`isolatedModules`编译器选项告诉 TypeScript 在可能导致这些转换器出现问题的语法实例上报告错误：
- en: Const enums, covered in [Chapter 14, “Syntax Extensions”](ch14.xhtml#syntax_extensions)
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量枚举，在[第 14 章，“语法扩展”](ch14.xhtml#syntax_extensions)中涵盖
- en: Script (nonmodule) files
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本（非模块）文件
- en: Standalone type exports, covered in [Chapter 14, “Syntax Extensions”](ch14.xhtml#syntax_extensions)
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立类型导出，在[第 14 章，“语法扩展”](ch14.xhtml#syntax_extensions)中涵盖
- en: I generally recommend enabling `isolatedModules` if your project uses a tool
    other than TypeScript to transpile to JavaScript.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的项目使用 TypeScript 以外的工具来转译为 JavaScript，则通常建议启用`isolatedModules`。
- en: JavaScript
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript
- en: While TypeScript is lovely and I hope you want to always write code in it, you
    don’t have to write all your source files in TypeScript. Although TypeScript by
    default ignores files with a *.js* or *.jsx* extension, using its `allowJs` and/or
    `checkJs` compiler options will allow it to read from, compile, and even—in a
    limited capacity—type check JavaScript files.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 TypeScript 很可爱，我希望您总是想要用它来编写代码，但您不必将所有源文件都写成 TypeScript。尽管 TypeScript 默认会忽略带有
    *.js* 或 *.jsx* 扩展名的文件，使用`allowJs`和/或`checkJs`编译器选项将允许它从这些文件中读取、编译，甚至在有限的情况下进行类型检查。
- en: Tip
  id: totrans-303
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: A common strategy for converting an existing JavaScript project to TypeScript
    is to start off with only a few files initially converted to TypeScript. More
    files may be added over time until there are no more JavaScript files left. You
    don’t have to go all-in on TypeScript until you’re ready to!
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 将现有的JavaScript项目转换为TypeScript的常见策略是最初只转换少量文件为TypeScript。随着时间的推移，可以逐步添加更多文件，直到没有剩余的JavaScript文件为止。在你准备好时，你不必完全依赖于TypeScript！
- en: allowJs
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: allowJs
- en: The `allowJs` compiler option allows constructs declared in JavaScript files
    to factor into type checking TypeScript files When combined with the `jsx` compiler
    option, *.jsx* files are also allowed.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`allowJs`编译选项允许在类型检查TypeScript文件时考虑在JavaScript文件中声明的结构。与`jsx`编译选项结合使用时，也允许*.jsx*文件。'
- en: 'For example, take this *index.ts* importing a `value` declared in a *values.js*
    file:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看这个*index.ts*导入*values.js*文件中声明的`value`：
- en: '[PRE61]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Without `allowJs` enabled, the `import` statement would not have a known type.
    It would be implicitly `any` by default or trigger a type error like “Could not
    find a declaration file for module `"./values"`.”
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未启用`allowJs`，`import`语句将不会具有已知类型。默认情况下，它将隐式为`any`，或触发类似“找不到模块`"./values"`的声明文件”的类型错误。
- en: '`allowJs` also adds JavaScript files to the list of files compiled to the ECMAScript
    target and emitted as JavaScript. Source maps and declaration files will be produced
    as well if the options to do so are enabled:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`allowJs`还会将JavaScript文件添加到编译为ECMAScript目标并生成JavaScript的文件列表中。如果启用了相应选项，则还会生成源映射和声明文件：'
- en: '[PRE63]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: With `allowJs` enabled, the imported `value` would be type `string`. No type
    errors would be reported.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 当启用`allowJs`选项时，导入的`value`将被视为`string`类型。不会报告任何类型错误。
- en: checkJs
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: checkJs
- en: 'TypeScript can do more than just factor JavaScript files into type checking
    TypeScript files: it can type check JavaScript files too. The `checkJs` compiler
    option serves two purposes:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript不仅可以将JavaScript文件引入到类型检查TypeScript文件中，还可以对JavaScript文件进行类型检查。`checkJs`编译选项有两个用途：
- en: Defaulting `allowJs` to `true` if it wasn’t already
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果尚未设置，则将`allowJs`默认为`true`
- en: Enabling the type checker on *.js* and *.jsx* files
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*.js*和*.jsx*文件上启用类型检查器
- en: 'Enabling `checkJs` will make TypeScript treat JavaScript files as if they were
    TypeScript files that don’t have any TypeScript-specific syntax. Type mismatches,
    misspelled variable names, and so on will all cause type errors as they normally
    would in a TypeScript file:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 启用`checkJs`将使TypeScript将JavaScript文件视为没有任何特定于TypeScript的语法的TypeScript文件。类型不匹配、变量名拼写错误等问题都将像在TypeScript文件中一样导致类型错误：
- en: '[PRE65]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'With `checkJs` enabled, this JavaScript file would cause a type-checking complaint
    for an incorrect variable name:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 当启用`checkJs`时，这个JavaScript文件将因为变量名错误而导致类型检查投诉：
- en: '[PRE67]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Without `checkJs` enabled, TypeScript would not have reported a type error for
    that likely bug.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未启用`checkJs`，TypeScript将不会报告该可能的错误类型。
- en: '@ts-check'
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '@ts-check'
- en: 'Alternately, `checkJs` can be enabled on a file-by-file basis by including
    a `// @ts-check` comment on top of the file. Doing so enables the `checkJs` option
    for just that JavaScript file:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以通过在文件顶部包含`// @ts-check`注释来逐个文件启用`checkJs`。这样做仅为该JavaScript文件启用`checkJs`选项：
- en: '[PRE68]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: JSDoc Support
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSDoc 支持
- en: Because JavaScript doesn’t have TypeScript’s rich type syntax, the types of
    values declared in JavaScript files are often not as precise as those declared
    in TypeScript files. For example, while TypeScript can infer the value of an object
    declared as a variable in a JavaScript file, there’s no native JavaScript way
    to declare in that file that the value adheres to any particular interface.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 因为JavaScript没有TypeScript丰富的类型语法，因此在JavaScript文件中声明的值的类型通常不像在TypeScript文件中声明的那样精确。例如，虽然TypeScript可以推断在JavaScript文件中声明为变量的对象的值，但在该文件中没有本地的JavaScript方法来声明该值符合任何特定接口。
- en: I mentioned back in [Chapter 1, “From JavaScript to TypeScript”](ch01.xhtml#from_javascript_to_typescript)
    that the JSDoc community standard provides some ways to describe types using comments.
    When `allowJs` and/or `checkJs` are enabled, TypeScript will recognize any JSDoc
    definitions in code.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[第1章，“从JavaScript到TypeScript”](ch01.xhtml#from_javascript_to_typescript)中提到过，JSDoc社区标准提供了一些使用注释描述类型的方法。当启用`allowJs`和/或`checkJs`时，TypeScript将识别代码中的任何JSDoc定义。
- en: 'For example, this snippet declares in JSDoc that the `sentenceCase` function
    takes in a `string`. TypeScript can then infer that it returns a `string`. With
    `checkJs` enabled, TypeScript would know to report a type error for passing it
    a `string[]` later:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，此片段在 JSDoc 中声明 `sentenceCase` 函数接受一个 `string`。TypeScript 可以推断出它返回一个 `string`。启用
    `checkJs` 后，TypeScript 将知道后续传递 `string[]` 时报告类型错误：
- en: '[PRE69]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: TypeScript’s JSDoc support is useful for incrementally adding type checking
    for projects that don’t have the time or developer familiarity to convert to TypeScript.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 的 JSDoc 支持对于那些没有时间或者开发者不熟悉转换为 TypeScript 的项目逐步添加类型检查非常有用。
- en: Tip
  id: totrans-334
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The full list of supported JSDoc syntax is available on [*https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html*](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的完整 JSDoc 语法列表可在 [*https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html*](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html)
    上找到。
- en: Configuration Extensions
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置扩展
- en: As you write more and more TypeScript projects, you may find yourself writing
    the same project settings repeatedly. Although TypeScript doesn’t allow configuration
    files to be written in JavaScript and use `import` or `require`, it does offer
    a mechanism for a TSConfig file to opt into “extending,” or copying in configuration
    values, from another configuration file.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 随着编写越来越多的 TypeScript 项目，你可能会发现自己重复编写相同的项目设置。虽然 TypeScript 不允许使用 JavaScript 编写配置文件并使用
    `import` 或 `require`，但它提供了一种机制，即 TSConfig 文件可以选择“扩展”或从另一个配置文件复制配置值。
- en: extends
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: extends
- en: 'A TSConfig may extend from another TSConfig with the `extends` configuration
    option. `extends` takes in a path to another TSConfig file and indicates that
    all settings from that file should be copied over. It behaves similarly to the
    `extends` keyword on classes: any option declared on the derived, or child, configuration
    will override any option of the same name on the base, or parent, configuration.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: TSConfig 可以通过 `extends` 配置选项从另一个 TSConfig 扩展。`extends` 接受另一个 TSConfig 文件的路径，并指示应复制该文件中的所有设置。它的行为类似于类上的
    `extends` 关键字：派生配置上声明的任何选项将覆盖基础配置上相同名称的任何选项。
- en: 'For example, many repositories that have multiple TSConfigs, such as monorepos
    containing multiple *packages/** directories, by convention create a *tsconfig.base.json*
    file for *tsconfig.json* files to extend from:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，许多包含多个 TSConfig 的存储库（例如包含多个 *packages/** 目录的单体存储库），按照惯例创建了一个 *tsconfig.base.json*
    文件，供 *tsconfig.json* 文件扩展：
- en: '[PRE70]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Note that `compilerOptions` are factored in recursively. Each compiler option
    from a base TSConfig will copy over to a derived TSConfig unless the derived TSConfig
    overrides that specific option.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，编译器选项会递归地计算。每个基础 TSConfig 中的编译器选项将复制到派生 TSConfig 中，除非派生 TSConfig 覆盖了该特定选项。
- en: 'If the previous example were to add a TSConfig that adds the `allowJs` option,
    that new derived TSConfig would still have `compilerOptions.strict` set to `true`:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面的示例要添加一个 TSConfig，添加 `allowJs` 选项，那么新的派生 TSConfig 仍将具有设置 `compilerOptions.strict`
    为 `true`：
- en: '[PRE72]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Extending modules
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展模块
- en: 'The `extends` property may point to either kind of JavaScript import:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`extends` 属性可以指向任一种 JavaScript 导入：'
- en: Absolute
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 绝对路径
- en: Starting with `@` or an alphabetical letter
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `@` 或字母开头
- en: Relative
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 相对路径
- en: A local file path starting with `.`
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `.` 开头的本地文件路径
- en: When an `extends` value is an absolute path, it indicates to extend the TSConfig
    from an npm module. TypeScript will use the normal Node module resolution system
    to find a package matching the name. If that package’s `package.json` contains
    a `"tsconfig"` field containing a relative path string, the TSConfig file at that
    path will be used. Otherwise, the package’s *tsconfig.json* file will be used.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `extends` 值为绝对路径时，表示从 npm 模块扩展 TSConfig。TypeScript 将使用正常的 Node 模块解析系统来查找匹配名称的包。如果该包的
    `package.json` 包含一个包含相对路径字符串的 `"tsconfig"` 字段，则将使用该路径中的 TSConfig 文件。否则，将使用该包的
    *tsconfig.json* 文件。
- en: 'Many organizations use npm packages to standardize TypeScript compiler options
    across repositories and/or within monorepos. The following TSConfig files are
    what you might set up for a monorepo in a `@my-org` organization. `packages/js`
    needs to specify the `allowJs` compiler option, while `packages/ts` does not change
    any compiler options:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 许多组织使用 npm 包来规范在代码库或者单体存储库中跨仓库使用的 TypeScript 编译器选项。以下是在 `@my-org` 组织中为单体存储库设置的
    TSConfig 文件。`packages/js` 需要指定 `allowJs` 编译器选项，而 `packages/ts` 不需要更改任何编译器选项。
- en: '[PRE73]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Configuration Bases
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置基础
- en: Instead of creating your own configuration from scratch or the `--init` suggestions,
    you can start with a premade “base” TSConfig file tailored to a particular runtime
    environment. These premade configuration bases are available on the npm package
    registry under `@tsconfig/`, such as `@tsconfig/recommended` or `@tsconfig/node16`.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从头开始创建自己的配置，也可以从预制的针对特定运行时环境定制的“基础”TSConfig文件或`--init`建议开始。这些预制的配置基础可在npm包注册表中的`@tsconfig/`下找到，例如`@tsconfig/recommended`或`@tsconfig/node16`。
- en: 'For example, to install the recommended TSConfig base for `deno`:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要安装`deno`的推荐TSConfig基础：
- en: '[PRE76]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Once a configuration base package is installed, it can be referenced like any
    other npm package configuration extension:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 安装配置基础包后，可以像引用任何其他npm包配置扩展一样引用它：
- en: '[PRE77]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The full list of TSConfig bases is documented on [*https://github.com/tsconfig/bases*](https://github.com/tsconfig/bases).
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: TSConfig基础的完整列表在[*https://github.com/tsconfig/bases*](https://github.com/tsconfig/bases)上有文档记录。
- en: Tip
  id: totrans-364
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: It is generally a good idea to know what TypeScript configuration options your
    file is using, even if you aren’t changing them yourself.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 通常最好知道您的文件正在使用哪些TypeScript配置选项，即使您自己不在更改它们。
- en: Project References
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目引用
- en: 'Each of the TypeScript configuration files I’ve shown so far have assumed they
    manage all the source files of a project. It can be useful in larger projects
    to use different configuration files for different areas of a project. TypeScript
    allows defining a system of “project references” where multiple projects can be
    built together. Setting up project references is a little more work than using
    a single TSConfig file but comes with several key benefits:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我展示的每个TypeScript配置文件都假定它们管理项目的所有源文件。在较大的项目中，使用不同的配置文件管理项目的不同区域可能很有用。TypeScript允许定义一个“项目引用”系统，其中多个项目可以一起构建。设置项目引用比使用单个TSConfig文件要复杂一些，但带来了几个关键好处：
- en: You can specify different compiler options for certain areas of code.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以为某些代码区域指定不同的编译器选项。
- en: TypeScript will be able to cache build outputs for individual projects, often
    resulting in significantly faster build times for large projects.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript将能够为各个项目缓存构建输出，通常会显著加快大型项目的构建时间。
- en: Project references enforce a “dependency tree” (only allowing certain projects
    to import files from certain other projects), which can help structure discrete
    areas of code.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目引用强制执行“依赖树”（仅允许某些项目从某些其他项目导入文件），这有助于结构化代码的离散区域。
- en: Tip
  id: totrans-371
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Project references are generally used in larger projects that have multiple
    distinct areas of code, such as monorepos and modular component systems. You probably
    don’t want to use them for small projects that don’t have dozens or more files.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 项目引用通常用于具有多个不同代码区域的较大项目，例如monorepos和模块化组件系统。您可能不希望在没有几十个或更多文件的小型项目中使用它们。
- en: 'The following three sections show how to build up project settings to enable
    project references:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 以下三个部分展示了如何构建项目设置以启用项目引用：
- en: '`composite` mode on a TSConfig enforces that it works in ways suitable for
    multi-TSConfig build modes.'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在TSConfig上的`composite`模式强制它以适合多TSConfig构建模式的方式工作。
- en: '`references` in a TSConfig indicate which composite TSConfigs it relies on.'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TSConfig中的`references`指示它依赖于哪些复合TSConfigs。
- en: Build mode uses composite TSConfig references to orchestrate building their
    files.
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建模式使用复合TSConfig引用来编排构建它们的文件。
- en: composite
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: composite
- en: 'TypeScript allows a project to opt into the `composite` configuration option
    to indicate that its file system inputs and outputs obey constraints that make
    it easier for build tools to determine whether its build outputs are up-to-date
    compared to its build inputs. When `composite` is `true`:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript允许项目选择`composite`配置选项，以指示其文件系统的输入和输出遵守约束，使构建工具更容易确定其构建输出是否与构建输入保持最新。当`composite`为`true`时：
- en: The rootDir setting, if not already explicitly set, defaults to the directory
    containing the TSConfig file.
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果尚未明确设置`rootDir`设置，则默认为包含TSConfig文件的目录。
- en: All implementation files must be matched by an include pattern or listed in
    the `files` array.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有实现文件必须与包含模式匹配或列在`files`数组中。
- en: '`declaration` must be turned on.'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须打开`declaration`。
- en: 'This configuration snippet matches all conditions for enabling `composite`
    mode in a `core/` directory:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置片段匹配在`core/`目录中启用`composite`模式的所有条件：
- en: '[PRE78]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: These changes help TypeScript enforce that all input files to the project create
    a matching *.d.ts* file. `composite` is generally most useful in combination with
    the following `references` configuration option.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改有助于TypeScript强制所有项目输入文件创建匹配的 *.d.ts* 文件。 `composite` 通常与以下 `references`
    配置选项结合使用。
- en: references
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用
- en: A TypeScript project can indicate it relies on the outputs generated by a composite
    TypeScript project with a `references` setting in its TSConfig. Importing modules
    from a referenced project will be seen in the type system as importing from its
    output *.d.ts* declaration file(s).
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript项目可以通过其TSConfig中的 `references` 设置指示它依赖于由复合TypeScript项目生成的输出。从引用项目导入模块将在类型系统中视为从其输出的
    *.d.ts* 声明文件(s) 导入。
- en: 'This configuration snippet sets up a *shell/* directory to reference a *core/*
    directory as its inputs:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置片段设置一个 *shell/* 目录以引用一个 *core/* 目录作为其输入：
- en: '[PRE79]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Note
  id: totrans-389
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `references` configuration option will not be copied from base TSConfigs
    to derived TSConfigs via `extends`.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`references` 配置选项不会通过 `extends` 从基本TSConfigs复制到派生TSConfigs。'
- en: '`references` is generally most useful in combination with the following build
    mode.'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`references` 通常与以下构建模式结合使用，非常有用。'
- en: Build Mode
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建模式
- en: Once an area of code has been set up to use project references, it will be possible
    to use `tsc` in its alternate “build” mode via the `-b`/`--b` CLI flag. Build
    mode enhances `tsc` into something of a project build coordinator. It lets `tsc`
    rebuild only the projects that have been changed since the last build, based on
    when their contents and their file outputs were last generated.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦某个代码区域设置为使用项目引用，就可以通过 `-b`/`--b` CLI 标志在其备用的“构建”模式中使用 `tsc`。构建模式将 `tsc` 提升为项目构建协调器。它允许
    `tsc` 仅重新构建自上次构建以来发生更改的项目，根据它们的内容和文件输出的生成时间。
- en: 'More precisely, TypeScript’s build mode will do the following when given a
    TSConfig:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 更准确地说，给定TSConfig时，TypeScript的构建模式将执行以下操作：
- en: Find that TSConfig’s referenced projects.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到该TSConfig的引用项目。
- en: Detect if they are up-to-date.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检测它们是否最新。
- en: Build out-of-date projects in the correct order.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按正确顺序构建过时的项目。
- en: Build the provided TSConfig if it or any of its dependencies have changed.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果TSConfig或其任何依赖项已更改，则构建提供的TSConfig。
- en: The ability of TypeScript’s build mode to skip rebuilding up-to-date projects
    can significantly improve build performance.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript的构建模式跳过重建最新项目的能力可以显著提高构建性能。
- en: Coordinator configurations
  id: totrans-400
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 协调员配置
- en: A common handy pattern for setting up TypeScript project references in a repository
    is to set up a root-level `tsconfig.json` with an empty `files` array and references
    to all the project references in the repository. That root TSConfig won’t direct
    TypeScript to build any files itself. Instead it will act purely to tell TypeScript
    to build referenced projects as needed.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在仓库中设置TypeScript项目引用的常见便捷模式是在根级 `tsconfig.json` 中设置一个空的 `files` 数组，并引用仓库中所有项目的引用。该根
    TSConfig 不会指导TypeScript自身构建任何文件。相反，它纯粹告诉TypeScript根据需要构建引用的项目。
- en: 'This `tsconfig.json` indicates to build the `packages/core` and `packages/shell`
    projects in a repository:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 此 `tsconfig.json` 指示在仓库中构建 `packages/core` 和 `packages/shell` 项目：
- en: '[PRE80]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'I personally like to standardize having a script in my `package.json` named
    `build` or `compile` that calls to `tsc -b` as a shortcut:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人喜欢在 `package.json` 中标准化地添加一个名为 `build` 或 `compile` 的脚本，以调用 `tsc -b` 作为快捷方式：
- en: '[PRE81]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Build-mode options
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建模式选项
- en: 'Build mode supports a few build-specific CLI options:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 构建模式支持几个构建特定的CLI选项：
- en: '`--clean`: deletes the outputs of the specified projects (may be combined with
    `--dry`)'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--clean`: 删除指定项目的输出（可与 `--dry` 结合使用）'
- en: '`--dry`: shows what would be done but doesn’t actually build anything'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--dry`: 显示将要执行的操作，但实际上不构建任何东西'
- en: '`--force`: acts as if all projects are out of date'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--force`: 表示所有项目都已过时'
- en: '`-w`/`--watch`: similar to the typical TypeScript watch mode'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-w`/`--watch`: 类似于典型的TypeScript监视模式'
- en: Because build mode supports watch mode, running a command like `tsc -b -w` can
    be a fast way to get an up-to-date listing of all compiler errors in a large project.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 因为构建模式支持监视模式，运行像 `tsc -b -w` 这样的命令可以快速获取大型项目中所有编译器错误的最新列表。
- en: Summary
  id: totrans-413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: 'In this chapter, you went over many of the important configuration options
    provided by TypeScript:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经了解了TypeScript提供的许多重要配置选项：
- en: Using `tsc`, including its pretty and watch modes
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `tsc`，包括其pretty和watch模式
- en: Using TSConfig files, including creating one with `tsc --init`
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用TSConfig文件，包括使用 `tsc --init` 创建一个TSConfig文件。
- en: Changing which files will be included by the TypeScript compiler
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改TypeScript编译器将包含的文件
- en: Allowing JSX syntax in *.tsx* files and/or JSON syntax in *.json* files
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许在*.tsx*文件中使用JSX语法和/或在*.json*文件中使用JSON语法
- en: Changing the directory, ECMAScript version target, declaration file, and/or
    source map outputs with files
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`files`更改目录、ECMAScript版本目标、声明文件和/或源映射输出
- en: Changing the built-in library types used in compilation
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改编译中使用的内置库类型
- en: Strict mode and useful strict flags such as `noImplicitAny` and `strictNullChecks`
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 严格模式和有用的严格标志，如`noImplicitAny`和`strictNullChecks`
- en: Supporting different module systems and changing module resolution
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持不同的模块系统和更改模块解析方式
- en: Allowing including JavaScript files, and opting into type checking those files
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许包含JavaScript文件，并选择对这些文件进行类型检查
- en: Using `extends` to share configuration options between files
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`extends`来在文件之间共享配置选项
- en: Using project references and build mode to orchestrate multi-TSConfig builds
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用项目引用和构建模式来编排多个TSConfig构建
- en: Tip
  id: totrans-426
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Now that you’ve finished reading this chapter, practice what you’ve learned
    on [*https://learningtypescript.com/configuration-options*](https://learningtypescript.com/configuration-options).
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经完成阅读本章，可以在[*https://learningtypescript.com/configuration-options*](https://learningtypescript.com/configuration-options)上练习所学内容。
- en: What is a disciplinarian’s favorite TypeScript compiler option?
  id: totrans-428
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个纪律者最喜欢的TypeScript编译器选项是什么？
- en: ''
  id: totrans-429
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`strict`.'
  id: totrans-430
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`strict`。'
