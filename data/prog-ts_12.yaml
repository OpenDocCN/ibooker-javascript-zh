- en: Chapter 12\. Building and Running TypeScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 12 章\. 构建和运行 TypeScript
- en: 'If you’ve deployed and run a JavaScript application in production, then you
    know how to run a TypeScript application too—once you compile it to JavaScript,
    the two aren’t so different. This chapter is about productionizing and building
    TypeScript applications, but there isn’t much here that’s unique to TypeScript
    apps—it mostly applies to JavaScript applications too. We’ll divide it up into
    four sections, covering:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在生产环境中部署和运行 JavaScript 应用程序，那么您也知道如何运行 TypeScript 应用程序——一旦您将其编译为 JavaScript，这两者并没有太大的不同。本章讨论的是生产和构建
    TypeScript 应用程序，但在 TypeScript 应用程序中并没有太多独特的内容——它大部分也适用于 JavaScript 应用程序。我们将其分为四个部分，涵盖以下内容：
- en: The things you have to do to build any TypeScript application
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您必须做的事情来构建任何 TypeScript 应用程序
- en: Building and running TypeScript applications on the server
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器上构建和运行 TypeScript 应用程序
- en: Building and running TypeScript applications in the browser
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在浏览器中构建和运行 TypeScript 应用程序
- en: Building for and publishing your TypeScript application to NPM
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 TypeScript 应用程序构建和发布到 NPM
- en: Building Your TypeScript Project
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建您的 TypeScript 项目
- en: Building a TypeScript project is straightforward. In this section, we’ll cover
    the core ideas you’ll need to understand in order to build your project for whatever
    environment you plan to run it in.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 构建 TypeScript 项目非常简单。在本节中，我们将涵盖您需要理解的核心概念，以便为计划运行的任何环境构建项目。
- en: Project Layout
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目布局
- en: I suggest keeping your source TypeScript code in a top-level *src/* folder,
    and compiling it to a top-level *dist/* folder. This folder structure is a popular
    convention, and splitting your source code and generated code into two top-level
    folders can make your life easier down the line, when you’re integrating with
    other tooling. It also makes it easier to exclude generated artifacts from source
    control.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议将您的源 TypeScript 代码保存在顶级 *src/* 文件夹中，并将其编译为顶级 *dist/* 文件夹。这种文件结构是一种常见的约定，将源代码和生成的代码分为两个顶级文件夹可以在日后与其他工具集成时简化您的生活。它还使得可以更轻松地将生成的工件排除在源代码控制之外。
- en: 'Try to stick to this convention when you can:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量坚持这种约定：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Artifacts
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工件
- en: When you compile a TypeScript program to JavaScript, there are a few different
    artifacts that TSC can generate for you ([Table 12-1](#artifact-tsc-table)).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将 TypeScript 程序编译为 JavaScript 时，TSC 可以为您生成几种不同的工件（[表 12-1](#artifact-tsc-table)）。
- en: Table 12-1\. Artifacts that TSC can generate for you
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12-1\. TSC 可以为您生成的工件
- en: '| Type | File extension | tsconfig.json flag | Emitted by default? |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 文件扩展名 | tsconfig.json 标志 | 默认是否生成？ |'
- en: '| --- | --- | --- | --- |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| **JavaScript** | *.js* | `{"emitDeclarationOnly": false}` | Yes |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| **JavaScript** | *.js* | `{"emitDeclarationOnly": false}` | 是 |'
- en: '| **Source maps** | *.js.map* | `{"sourceMap": true}` | No |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| **源映射** | *.js.map* | `{"sourceMap": true}` | 否 |'
- en: '| **Type declarations** | *.d.ts* | `{"declaration": true}` | No |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| **类型声明** | *.d.ts* | `{"declaration": true}` | 否 |'
- en: '| **Declaration maps** | *.d.ts.map* | `{"declarationMap": true}` | No |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| **声明映射** | *.d.ts.map* | `{"declarationMap": true}` | 否 |'
- en: The first type of artifact—JavaScript files—should be familiar. TSC compiles
    your TypeScript code to JavaScript that you can then run using a JavaScript platform
    like NodeJS or Chrome. If you run `tsc yourfile.ts`, TSC will typecheck *yourfile.ts*
    and compile it to JavaScript.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种工件——JavaScript 文件——应该很熟悉。TSC 将您的 TypeScript 代码编译为 JavaScript，然后您可以使用类似 NodeJS
    或 Chrome 的 JavaScript 平台运行它。如果您运行 `tsc yourfile.ts`，TSC 将对 *yourfile.ts* 进行类型检查并将其编译为
    JavaScript。
- en: The second type of artifact—source maps—is special files that link each piece
    of your generated JavaScript back to the specific line and column of the TypeScript
    file that it was generated from. This is helpful for debugging your code (Chrome
    DevtTools will show your TypeScript code, instead of the generated JavaScript),
    and for mapping lines and columns in JavaScript exception stack traces back to
    TypeScript (tools like those mentioned in [“Error Monitoring”](#error-monitoring-sect)
    do this lookup automatically if you give them your source maps).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种类型的工件——源映射——是特殊文件，将生成的每个 JavaScript 片段链接回生成它的 TypeScript 文件的特定行和列。这对于调试代码很有帮助（Chrome
    DevtTools 将显示您的 TypeScript 代码，而不是生成的 JavaScript），并且可以将 JavaScript 异常堆栈跟踪的行和列映射回
    TypeScript（如果您提供了源映射，像[“错误监控”](#error-monitoring-sect)中提到的工具会自动执行此查找）。
- en: The third artifact—type declarations—lets other TypeScript projects take advantage
    of your generated types.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种工件——类型声明——允许其他 TypeScript 项目利用您生成的类型。
- en: Finally, declaration maps are used to speed up compilation times for your TypeScript
    projects. You’ll read more about them in [“Project References”](#improving-compile-times).
    We’ll spend the rest of this chapter talking about how and why to generate these
    artifacts.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，声明映射被用来加快 TypeScript 项目的编译时间。你将在[“项目引用”](#improving-compile-times)中详细了解它们。本章的其余部分将讨论如何以及为何生成这些工件。
- en: Dialing In Your Compile Target
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整你的编译目标
- en: 'JavaScript can be an unusual language to work with: not only does it have a
    quickly evolving specification with a yearly release cycle, but, as a programmer,
    you can’t always control which JavaScript version the platform you’re running
    your program on implements. On top of that, many JavaScript programs are *isomorphic*,
    meaning you can run them on either the server or the client. For example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 可能是一个不寻常的语言来处理：它不仅具有快速发展的规范，每年发布一个版本，而且作为程序员，你并不能总是控制你的程序运行的平台实现了哪个
    JavaScript 版本。此外，许多 JavaScript 程序是*同构*的，这意味着你可以在服务器或客户端上运行它们。例如：
- en: If you run your backend JavaScript program on a server that you control, then
    you can control exactly which JavaScript version it will run on.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你在你控制的服务器上运行后端 JavaScript 程序，那么你可以精确控制它将运行的 JavaScript 版本。
- en: If you then release your backend JavaScript program as an open source project,
    you don’t know which JavaScript version will be supported by your consumers’ JavaScript
    platforms. The best you can do in a NodeJS environment is declare a range of supported
    NodeJS versions, but in a browser environment you’re out of luck.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你将你的后端 JavaScript 程序作为开源项目发布，你不知道消费者的 JavaScript 平台将支持哪个 JavaScript 版本。在 NodeJS
    环境中，你能做的最好的是声明支持的 NodeJS 版本范围，但在浏览器环境中，你就没那么幸运了。
- en: If you run your JavaScript in a browser, you have no idea which browser people
    will use to run it—the latest Chrome, Firefox, or Edge that supports most modern
    JavaScript features, a slightly outdated version of one of those browsers that’s
    missing some bleeding-edge functionality, an antiquated browser like Internet
    Explorer 8, or an embedded browser like the one that runs on the PlayStation 4
    in your garage. The best you can do is define a minimum set of features that people’s
    browsers need to support to run your application, ship polyfills for as many of
    those features as you can, and try to detect when users are on really old browsers
    that your app won’t run on and show them a message saying that they need to upgrade.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你在浏览器中运行你的 JavaScript，你不知道人们将使用哪个浏览器来运行它——最新版本的 Chrome、Firefox 或支持大多数现代 JavaScript
    特性的 Edge，稍微过时的其中一个浏览器版本，可能缺少一些前沿功能的浏览器，像 Internet Explorer 8 这样的古老浏览器，或者在你车库里运行的
    PlayStation 4 上的嵌入式浏览器。你能做的最好的是定义人们的浏览器需要支持的最小功能集，为尽可能多的这些功能提供 polyfill，并尝试检测用户是否在真正旧的浏览器上，你的应用无法运行，并显示他们需要升级的消息。
- en: If you release an isomorphic JavaScript library (e.g., a logging library that
    runs on both browser and server), then you have to support both a minimum NodeJS
    version and a swath of browser JavaScript engines and versions.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你发布了一个同构的 JavaScript 库（例如，在浏览器和服务器上都能运行的日志库），那么你必须支持一个最低的 NodeJS 版本和一系列浏览器
    JavaScript 引擎和版本。
- en: 'Not every JavaScript environment supports every JavaScript feature out of the
    box, but you should still try to write code in the latest language version. There
    are two ways to do this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每个 JavaScript 环境都能在开箱即用时支持每个 JavaScript 特性，但你仍应该尝试用最新的语言版本编写代码。有两种方法可以做到这一点：
- en: '*Transpile* (i.e., automatically convert) applications from the latest version
    of JavaScript to the oldest JavaScript version that a platform you target supports.
    We do this for language features like `for..of` loops and `async`/`await`, which
    can be automatically converted to `for` loops and `.then` calls, respectively.'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*转译*（即自动转换）应用程序，从最新版本的 JavaScript 转换为目标平台支持的最老的 JavaScript 版本。我们为语言特性如`for..of`循环和`async`/`await`，可以自动转换为`for`循环和`.then`调用，做到这一点。'
- en: '*Polyfill* (i.e., provide implementations for) any modern features that are
    missing in the JavaScript runtime you’re running on. We do this for features provided
    by the JavaScript standard library (like `Promise`, `Map`, and `Set`) and for
    prototype methods (like `Array.prototype.includes` and `Function.prototype.bind`).'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*Polyfill*（即提供实现）任何现代特性，在你运行的 JavaScript 运行时中缺失。我们为 JavaScript 标准库（如`Promise`、`Map`和`Set`）以及原型方法（如`Array.prototype.includes`和`Function.prototype.bind`）提供这些功能。'
- en: 'TSC has built-in support for transpiling your code to older JavaScript versions,
    but it will not automatically polyfill your code. This is worth reiterating: TSC
    will transpile most JavaScript features for older environments, but it will not
    provide implementations for missing features.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: TSC 内置支持将你的代码转译为旧版本的 JavaScript，但不会自动为你提供 polyfill。这值得再强调一下：TSC 会为旧环境转译大多数 JavaScript
    特性，但不会提供缺失特性的实现。
- en: 'TSC gives you three settings to dial in which environments you want to target:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: TSC 提供了三个设置选项，帮助你调整目标环境：
- en: '`target` sets the JavaScript version you want to transpile to: `es5`, `es2015`,
    etc.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target` 设置你想要编译到的 JavaScript 版本：`es5`、`es2015` 等等。'
- en: '`module` sets the module system you want to target: `es2015` modules, `commonjs`
    modules, `systemjs` modules, etc.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`module` 设置你想要的模块系统：`es2015` 模块、`commonjs` 模块、`systemjs` 模块等等。'
- en: '`lib` tells TypeScript which JavaScript features are available in the environments
    you’re targeting: `es5` features, `es2015` features, the `dom`, etc. It doesn’t
    actually implement these features—that’s what polyfills are for—but it does tell
    TypeScript that the features are available (either natively or via a polyfill).'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lib` 告诉 TypeScript 目标环境中可用的 JavaScript 特性：`es5` 特性、`es2015` 特性、`dom` 等等。它并不实现这些特性——这就是
    polyfill 的作用——但它告诉 TypeScript 这些特性是可用的（无论是原生支持还是通过 polyfill）。'
- en: The environment you plan to run your application in dictates which JavaScript
    version you should transpile to with `target` and what to set `lib` to. If you’re
    not sure, `es5` is usually a safe default for both. What you set `module` to depends
    on whether you’re targeting a NodeJS or browser environment, and what module loader
    you’re using if the latter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你计划在哪个环境中运行应用程序决定了你应该用 `target` 编译到哪个 JavaScript 版本，以及应该设置哪些 `lib`。如果不确定，通常
    `es5` 对于两者都是一个安全的默认值。你设置 `module` 取决于你是在目标 NodeJS 还是浏览器环境，以及如果是后者，你使用的模块加载器是什么。
- en: Tip
  id: totrans-40
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If you need to support an unusual set of platforms, look up which JavaScript
    features your target platforms support natively in Juriy Zaytsev’s (aka Kangax’s)
    [compatibility tables](http://kangax.github.io/compat-table/es5/).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要支持一组不寻常的平台，请查阅 Juriy Zaytsev（又名 Kangax）的 [兼容性表格](http://kangax.github.io/compat-table/es5/)，了解你的目标平台原生支持哪些
    JavaScript 特性。
- en: Let’s dig a little deeper into `target` and `lib`; we’ll leave `module` to the
    sections on [“Running TypeScript on the Server”](#Running-TypeScript-on-the-Server)
    and [“Running TypeScript in the Browser”](#Running-TypeScript-in-the-Browser).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地了解 `target` 和 `lib`；关于 [“在服务器上运行 TypeScript”](#Running-TypeScript-on-the-Server)
    和 [“在浏览器中运行 TypeScript”](#Running-TypeScript-in-the-Browser)，我们将留给各自的章节。
- en: target
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: target
- en: TSC’s built-in transpiler supports converting most JavaScript features to older
    JavaScript versions, meaning you can write your code in the latest TypeScript
    version and transpile it down to whatever JavaScript version you need to support.
    Since TypeScript supports the latest JavaScript features (like `async`/`await`,
    which is not yet supported by all major JavaScript platforms at the time of writing),
    you’ll almost always find yourself taking advantage of this built-in transpiler
    to convert your code to something that NodeJS and browsers understand today.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: TSC 的内置转译器支持将大多数 JavaScript 特性转译为旧版本的 JavaScript，这意味着你可以使用最新的 TypeScript 版本编写代码，并将其转译为你需要支持的任何
    JavaScript 版本。由于 TypeScript 支持最新的 JavaScript 特性（例如 `async`/`await`，目前并非所有主要 JavaScript
    平台都支持），你几乎总是会利用这个内置转译器将你的代码转换为 NodeJS 和浏览器今天能理解的代码。
- en: Let’s take a look at which specific JavaScript features TSC does and does not
    transpile for older JavaScript versions ([Table 12-2](#tsc-does-transpile) and
    [Table 12-3](#tsc-does-not-transpile)).^([1](ch12.html#idm46304949773272))
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 TSC 在转译为旧版 JavaScript 时支持哪些具体的 JavaScript 特性，以及不支持哪些特性（[表 12-2](#tsc-does-transpile)
    和 [表 12-3](#tsc-does-not-transpile)）^([1](ch12.html#idm46304949773272))。
- en: Note
  id: totrans-46
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In the past, there was a new revision of the JavaScript language released every
    few years, with an incrementing language version (ES1, ES3, ES5, ES6). As of 2015,
    the JavaScript language now has a yearly release cycle, with each language version
    named after the year it’s released in (ES2015, ES2016, and so on). Some JavaScript
    features, however, get TypeScript support before they’re actually slated for a
    specific JavaScript version; we refer to these features as “ESNext” (as in, the
    next revision).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，JavaScript 语言每隔几年就会发布一个新版本，版本号逐步增加（ES1，ES3，ES5，ES6）。从2015年开始，JavaScript
    语言现在采用每年发布一次的周期，每个语言版本都以发布的年份命名（ES2015，ES2016等）。然而，一些 JavaScript 特性在实际进入特定 JavaScript
    版本之前就已经获得了 TypeScript 的支持；我们称这些特性为“ESNext”（即下一个修订版本）。
- en: Table 12-2\. TSC does transpile
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 表12-2\. TSC 进行了转译
- en: '| Version | Feature |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 版本 | 功能 |'
- en: '| --- | --- |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| ES2015 | `const`, `let`, `for..of` loops, array/object spread (`...`), tagged
    template strings, classes, generators, arrow functions, function default parameters,
    function rest parameters, destructuring declarations/assignments/parameters |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| ES2015 | `const`, `let`, `for..of` 循环, 数组/对象展开 (`...`), 带标签的模板字符串, 类, 生成器,
    箭头函数, 函数默认参数, 函数剩余参数, 解构声明/赋值/参数 |'
- en: '| ES2016 | Exponentiation operator (`**`) |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| ES2016 | 指数运算符 (`**`) |'
- en: '| ES2017 | `async` functions, `await`ing promises |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| ES2017 | `async` 函数，等待 promise |'
- en: '| ES2018 | `async` iterators |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| ES2018 | `async` 迭代器 |'
- en: '| ES2019 | Optional parameter in catch clause |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| ES2019 | catch 子句中的可选参数 |'
- en: '| ESNext | Numeric separators (`123_456`) |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| ESNext | 数字分隔符 (`123_456`) |'
- en: Table 12-3\. TSC does not transpile
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 表12-3\. TSC 不会进行转译
- en: '| Version | Feature |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 版本 | 功能 |'
- en: '| --- | --- |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| ES5 | Object getters/setters |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| ES5 | 对象的 getter/setter |'
- en: '| ES2015 | Regex `y` and `u` flags |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| ES2015 | 正则表达式 `y` 和 `u` 标志 |'
- en: '| ES2018 | Regex `s` flag |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| ES2018 | 正则表达式 `s` 标志 |'
- en: '| ESNext | BigInt (`123n`) |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| ESNext | BigInt (`123n`) |'
- en: 'To set the transpilation target, pop open your *tsconfig.json* and set the
    `target` field to:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置转译目标，请打开您的 *tsconfig.json* 并将 `target` 字段设置为：
- en: '`es3` for ECMAScript 3'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`es3` 代表 ECMAScript 3'
- en: '`es5` for ECMAScript 5 (this is a good default if you’re not sure what to use)'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`es5` 代表 ECMAScript 5（如果不确定使用什么版本，这是一个很好的默认值）'
- en: '`es6` or `es2015` for ECMAScript 2015'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`es6` 或 `es2015` 代表 ECMAScript 2015'
- en: '`es2016` for ECMAScript 2016'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`es2016` 代表 ECMAScript 2016'
- en: '`es2017` for ECMAScript 2017'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`es2017` 代表 ECMAScript 2017'
- en: '`es2018` for ECMAScript 2018'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`es2018` 代表 ECMAScript 2018'
- en: '`esnext` for whatever the most recent ECMAScript revision is'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`esnext` 代表最新的 ECMAScript 修订版本'
- en: 'For example, to compile to ES5:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要编译为 ES5：
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: lib
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: lib
- en: 'As I mentioned, there’s one hitch with transpiling your code to older JavaScript
    versions: while most language features can be safely transpiled (`let` to `var`,
    `class` to `function`), you still need to *polyfill* functionality yourself if
    your target environment doesn’t support a newer library feature. Some examples
    are utilities like `Promise` and `Reflect`, and data structures like `Map`, `Set`,
    and `Symbol`. When targeting a bleeding-edge environment like the latest Chrome,
    Firefox, or Edge, you usually won’t need any polyfills; but if you’re targeting
    browsers a few versions back—or most NodeJS environments—you will need to polyfill
    missing features.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我所提到的，将您的代码转译为较旧的 JavaScript 版本有一个小问题：虽然大多数语言特性可以安全地转译（`let` 转为 `var`，`class`
    转为 `function`），但是如果您的目标环境不支持较新的库特性，仍然需要自己 *polyfill* 功能。例如像 `Promise` 和 `Reflect`
    这样的实用工具，以及像 `Map`、`Set` 和 `Symbol` 这样的数据结构。如果您的目标是最新版本的 Chrome、Firefox 或 Edge
    等先进环境，通常不需要任何 polyfills；但是如果您的目标是几个版本之前的浏览器，或者大多数 NodeJS 环境，则需要 polyfill 遗漏的特性。
- en: Thankfully, you won’t need to write polyfills yourself. Instead, you can install
    them from a popular polyfill library like [`core-js`](https://www.npmjs.com/package/core-js),
    or add polyfills to your code automatically by running your typechecked TypeScript
    code through Babel with [`@babel/polyfill`](https://babeljs.io/docs/en/babel-polyfill).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，您不需要自己编写 polyfill。相反，您可以从流行的 polyfill 库如 [`core-js`](https://www.npmjs.com/package/core-js)
    安装它们，或者通过运行经过类型检查的 TypeScript 代码通过 [`@babel/polyfill`](https://babeljs.io/docs/en/babel-polyfill)
    自动将 polyfills 添加到您的代码中。
- en: Tip
  id: totrans-77
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If you plan to run your application in a browser, be careful not to bloat the
    size of your JavaScript bundle by including every single polyfill regardless of
    whether or not the browser you’re running your code in actually needs it—your
    target platform probably already supports some of the features you’re polyfilling.
    Instead, use a service like [Polyfill.io](https://polyfill.io/v2/docs/) to load
    just those polyfills that your user’s browser needs.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划在浏览器中运行你的应用程序，请注意不要通过包含每一个 polyfill 来使你的 JavaScript 捆绑包膨胀，无论你的代码运行的浏览器是否实际需要它们
    —— 你的目标平台可能已经支持一些你正在 polyfill 的功能。相反，使用像 [Polyfill.io](https://polyfill.io/v2/docs/)
    这样的服务，只加载你的用户浏览器需要的那些 polyfill。
- en: 'Once you’ve added polyfills to your code, it’s time to tell TSC that your environment
    is guaranteed to support the features you polyfilled—enter your *tsconfig.json*’s
    `lib` field. For example, you could use this configuration if you’ve polyfilled
    all ES2015 features plus ES2016’s `Array.prototype.includes`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在代码中添加了 polyfill，就需要告诉 TSC 你的环境已经支持了你 polyfill 的功能 —— 输入你的 *tsconfig.json*
    的 `lib` 字段。例如，如果你已经 polyfill 了所有 ES2015 特性以及 ES2016 的 `Array.prototype.includes`，你可以使用这个配置：
- en: '[PRE2]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you’re running your code in the browser, also enable DOM type declarations
    for things like `window`, `document`, and all the other APIs you get when running
    your JavaScript in the browser:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在浏览器中运行你的代码，还要为 DOM 类型声明启用，比如 `window`、`document`，以及在浏览器中运行 JavaScript 时获得的所有其他
    API：
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For a full list of supported libs run `tsc --help`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取支持的 libs 的完整列表，请运行 `tsc --help`。
- en: Enabling Source Maps
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用源映射
- en: Source maps are a way to link your transpiled code back to the source code it
    was generated from. Most developer tools (like Chrome DevTools), error reporting
    and logging frameworks, and build tools know about source maps. Since a typical
    build pipeline can produce code that’s very different from the code you started
    with (for example, your pipeline might compile TypeScript to ES5 JavaScript, tree-shake
    it with Rollup, preevaluate it with Prepack, then minify it with Uglify), using
    source maps throughout your build pipeline can make it a lot easier to debug the
    resulting JavaScript.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 源映射是一种将你的编译后代码与生成它的源代码进行关联的方法。大多数开发者工具（如 Chrome DevTools）、错误报告和日志框架以及构建工具都支持源映射。由于典型的构建流水线可能会生成与最初的代码非常不同的代码（例如，你的流水线可能会将
    TypeScript 编译为 ES5 JavaScript，使用 Rollup 进行树摇，使用 Prepack 进行预评估，然后使用 Uglify 进行压缩），在整个构建流水线中使用源映射可以大大简化调试生成的
    JavaScript 的过程。
- en: 'It’s generally a good idea to use source maps in development, and ship source
    maps to production in both browser and server environments. There’s one caveat,
    though: if you rely on some level of security through obscurity for your browser
    code, don’t ship source maps to browsers in production.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通常建议在开发中使用源映射，并在浏览器和服务器环境中将源映射发布到生产环境。不过，有一个注意事项：如果你依赖于某种程度上的安全性通过混淆来保护你的浏览器代码，那么不要在生产环境中将源映射发布到浏览器中。
- en: Project References
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目引用
- en: As your application grows, it will take longer and longer for TSC to typecheck
    and compile your code. This time grows roughly linearly with the size of your
    codebase. When developing locally, slow incremental compile times can seriously
    slow down your development, and make working with TypeScript painful.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的应用程序增长，TSC 对你的代码进行类型检查和编译所需的时间会越来越长。这个时间大致与你的代码库的大小成正比增长。在本地开发时，缓慢的增量编译时间会严重拖慢你的开发速度，并使得使用
    TypeScript 变得困难。
- en: To address this, TSC comes with a feature called *project references* that speeds
    up compilation times dramatically, including incremental compile times. For any
    project with a few hundred files or more, project references are a must-have.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，TSC 提供了一个名为 *项目引用* 的功能，大大加快了编译时间，包括增量编译时间。对于任何具有几百个或更多文件的项目，项目引用都是必不可少的。
- en: 'Use them like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样使用它们：
- en: Split your TypeScript project into multiple projects. A project is simply a
    folder that contains a *tsconfig.json* and some TypeScript code. Try to split
    your code in such a way that code that tends to be updated together lives in the
    same folder.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的 TypeScript 项目分割成多个项目。一个项目只是一个包含 *tsconfig.json* 和一些 TypeScript 代码的文件夹。尝试以这样一种方式分割你的代码，使得通常一起更新的代码位于同一个文件夹中。
- en: 'In each project folder, create a *tsconfig.json* that includes at least:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个项目文件夹中，创建一个 *tsconfig.json*，至少包括以下内容：
- en: '[PRE4]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The keys here are:'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关键在于：
- en: '`composite`, which tells TSC that this folder is a subproject of a larger TypeScript
    project.'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`composite` 表示这个文件夹是一个更大的 TypeScript 项目的子项目。'
- en: '`declaration`, which tells TSC to emit *.d.ts* declaration files for this project.
    The way project references work, projects have access to each other’s declaration
    files and emitted JavaScript, but not their source TypeScript files. This creates
    a boundary beyond which TSC won’t try to retypecheck or recompile your code: if
    you update a line of code in your subproject *A*, TSC doesn’t have to retypecheck
    your other subproject *B*; all TSC needs to check for a type error is *B*’s type
    declarations. This is the core behavior that makes project references so efficient
    at rebuilding big projects.'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`declaration`，告诉 TSC 为这个项目生成 *.d.ts* 声明文件。项目引用的工作方式是，项目可以访问彼此的声明文件和生成的 JavaScript，但不能访问它们的源
    TypeScript 文件。这创建了一个边界，超出这个边界 TSC 将不会尝试重新检查或重新编译你的代码：如果你在子项目 *A* 中更新了一行代码，TSC
    不必重新检查你的其他子项目 *B*；TSC 只需要检查 *B* 的类型声明以查找类型错误。这是使项目引用在重建大型项目时如此高效的核心行为。'
- en: '`declarationMap`, which tells TSC to build source maps for generated type declarations.'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`declarationMap`，告诉 TSC 为生成的类型声明构建源映射。'
- en: '`references`, which is an array of subprojects that your subproject depends
    on. Each reference’s `path` should point either to a folder that contains a *tsconfig.json*,
    or directly to a TSC configuration file (if your configuration file isn’t named
    *tsconfig.json*). `prepend` will concatenate the JavaScript and source maps generated
    by the subproject you’re referencing to the JavaScript and source maps generated
    by your subproject. Note that `prepend` is only useful when you’re using `outFile`—if
    you don’t use `outFile`, you can ditch the `prepend`.'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`references`，是一个包含你的子项目依赖的子项目数组。每个引用的 `path` 应该指向一个包含 *tsconfig.json* 文件的文件夹，或直接指向一个
    TSC 配置文件（如果你的配置文件不叫 *tsconfig.json*）。`prepend` 将连接由你引用的子项目生成的 JavaScript 和源映射到你的子项目生成的
    JavaScript 和源映射中。注意，只有当你使用 `outFile` 时，`prepend` 才有用处——如果你不使用 `outFile`，你可以放弃
    `prepend`。'
- en: '`rootDir`, which explicitly specifies that this subproject should be compiled
    relative to the root project (`.`). Alternatively, you can specify an `outDir`
    that’s a subfolder of the root project’s `outDir`.'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rootDir`，明确指定该子项目应该相对于根项目 (`.`) 进行编译。或者，你可以指定一个 `outDir`，作为根项目 `outDir` 的子文件夹。'
- en: 'Create a root *tsconfig.json* that references any subprojects that aren’t yet
    referenced by another subproject:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个根 *tsconfig.json*，引用任何尚未被其他子项目引用的子项目：
- en: '[PRE5]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now when you compile your project with TSC, use the `build` flag to tell TSC
    to take project references into account:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在当你使用 TSC 编译你的项目时，使用 `build` 标志告诉 TSC 考虑项目引用：
- en: '[PRE6]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Warning
  id: totrans-104
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'At the time of writing, project references are a new TypeScript feature with
    some rough edges. When using them, be careful to:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 目前项目引用是 TypeScript 的一个新功能，有些地方还不够成熟。在使用时，请务必注意以下几点：
- en: Rebuild the entire project (with `tsc -b`) after cloning or refetching it, in
    order to regenerate any missing or outdated *.d.ts* files. Alternatively, check
    in your generated *d.ts* files.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在克隆或重新获取后，重新构建整个项目（使用 `tsc -b`），以重新生成任何丢失或过时的 *.d.ts* 文件。或者，检查你生成的 *d.ts* 文件。
- en: 'Not use `noEmitOnError: false` with project references—TSC will always hardcode
    the option to `true`.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '不要在项目引用中使用 `noEmitOnError: false` —— TSC 将始终将选项硬编码为 `true`。'
- en: Manually make sure that a given subproject isn’t prepended by more than one
    other subproject. Otherwise, the doubly prepended subproject will show up twice
    in your compiled output. Note that if you’re just referencing and not prepending,
    you’re good to go.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动确保给定的子项目不被多于一个其他子项目预置。否则，双重预置的子项目将在你的编译输出中显示两次。注意，如果你只是引用而不是预置，那就没问题。
- en: Error Monitoring
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误监控
- en: TypeScript warns you about errors at compile time, but you also need a way to
    find out about exceptions that your users experience at runtime, so that you can
    try to prevent them at compile time (or at least fix the bug that caused the runtime
    error). Use an error monitoring tool like [Sentry](https://sentry.io) or [Bugsnag](https://bugsnag.com)
    to report and collate your runtime exceptions.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 在编译时会警告你有关错误，但你也需要一种方法来了解用户在运行时遇到的异常，以便你可以尝试在编译时防止它们（或者至少修复导致运行时错误的
    bug）。使用像 [Sentry](https://sentry.io) 或 [Bugsnag](https://bugsnag.com) 这样的错误监控工具来报告和整理你的运行时异常。
- en: Running TypeScript on the Server
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在服务器上运行 TypeScript
- en: 'To run your TypeScript code in a NodeJS environment, just compile your code
    to ES2015 JavaScript (or ES5, if you’re targeting a legacy NodeJS version) with
    your *tsconfig.json*’s module flag set to `commonjs`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要在NodeJS环境中运行你的TypeScript代码，只需将你的代码编译成ES2015 JavaScript（或者如果你的目标是旧版NodeJS，则编译成ES5），并且将你的*tsconfig.json*的module标志设置为`commonjs`：
- en: '[PRE7]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: That will compile your ES2015 `import` and `export` calls to `require` and `module.exports`,
    respectively, so your code will run on NodeJS with no further bundling needed.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把你的ES2015的`import`和`export`语句编译成`require`和`module.exports`，因此你的代码可以在NodeJS上运行，无需进一步打包。
- en: If you’re using source maps (you should be!), you’ll need to feed your source
    maps into your NodeJS process. Just grab the [`source-map-support`](https://www.npmjs.com/package/source-map-support)
    package from NPM, and follow the package’s setup instructions. Most process monitoring,
    logging, and error reporting tools like [PM2](https://www.npmjs.com/package/pm2),
    [Winston](https://www.npmjs.com/package/winston), and [Sentry](https://sentry.io)
    have built-in support for source maps.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用源映射（你应该！），你需要将你的源映射提供给你的NodeJS进程。只需从NPM获取[`source-map-support`](https://www.npmjs.com/package/source-map-support)包，并按照该包的设置说明进行设置。大多数进程监控、日志记录和错误报告工具（如[PM2](https://www.npmjs.com/package/pm2)，[Winston](https://www.npmjs.com/package/winston)和[Sentry](https://sentry.io)）都内置了对源映射的支持。
- en: Running TypeScript in the Browser
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在浏览器中运行TypeScript
- en: Compiling TypeScript to run in the browser involves a little more work than
    running TypeScript on the server.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 编译TypeScript以在浏览器中运行需要比在服务器上运行TypeScript多一些工作。
- en: First, pick a module system to compile to. A good rule of thumb is to stick
    to `umd` when publishing a library for others to use (e.g., on NPM) in order to
    maximize compatibility with various module bundlers that people might use in their
    projects.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，选择一个模块系统进行编译。一个很好的经验法则是，如果要发布供他人使用的库（例如在NPM上），最好使用`umd`以确保与各种项目中可能使用的模块打包工具兼容。
- en: 'If you just plan to use your code yourself without publishing it to NPM, which
    format you compile to depends on the module bundler you’re using. Check your bundler’s
    documentation—for example, Webpack and Rollup work best with ES2015 modules, while
    Browserify requires CommonJS modules. Here are a few guidelines:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只打算自己使用代码而不将其发布到NPM，请根据你正在使用的模块打包工具来决定编译到哪种格式。查看你的打包工具的文档——例如，Webpack和Rollup最适合ES2015模块，而Browserify需要CommonJS模块。以下是一些指南：
- en: If you’re using the [SystemJS](https://github.com/systemjs/systemjs) module
    loader, set `module` to `systemjs`.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在使用[SystemJS](https://github.com/systemjs/systemjs)模块加载器，请将`module`设置为`systemjs`。
- en: If you’re running your code through an ES2015-aware module bundler like [Webpack](https://webpack.js.org)
    or [Rollup](https://github.com/rollup/rollup), set `module` to `es2015` or higher.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你通过像[Webpack](https://webpack.js.org)或[Rollup](https://github.com/rollup/rollup)这样的ES2015模块感知的模块打包工具运行你的代码，请将`module`设置为`es2015`或更高版本。
- en: If you’re using an ES2015-aware module bundler and your code uses dynamic imports
    (see [“Dynamic Imports”](ch10.html#dynamic_imports)), set `module` to `esnext`.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在使用ES2015感知的模块打包工具，并且你的代码使用动态导入（参见[“动态导入”](ch10.html#dynamic_imports)），请将`module`设置为`esnext`。
- en: If you’re building a library for other projects to use, and aren’t running your
    code through any additional build steps after `tsc`, maximize compatibility with
    different loaders that people use by setting `module` to `umd`.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在为其他项目构建一个库，并且在`tsc`之后没有任何其他构建步骤，请通过将`module`设置为`umd`来最大化与人们使用的不同加载器的兼容性。
- en: If you’re bundling your module with a CommonJS bundler like [Browserify](https://github.com/browserify/browserify),
    set `module` to `commonjs`.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在使用像[Browserify](https://github.com/browserify/browserify)这样的CommonJS打包工具打包你的模块，请将`module`设置为`commonjs`。
- en: If you’re planning to load your code with [RequireJS](https://requirejs.org)
    or another AMD module loader, set `module` to `amd`.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你计划使用[RequireJS](https://requirejs.org)或其他AMD模块加载器加载你的代码，请将`module`设置为`amd`。
- en: If you want your top-level exports to be globally available on the `window`
    object (as you might if you’re Mussolini’s great-nephew), set `module` to `none`.
    Note that TSC will try to curb your enthusiasm for inflicting pain on other software
    engineers by compiling to `commonjs` anyway if your code is in module mode (see
    [“Module Mode Versus Script Mode”](ch10.html#module-mode)).
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你希望你的顶层导出在`window`对象上全局可用（例如，如果你是墨索里尼的侄孙），请将`module`设置为`none`。请注意，如果你的代码处于模块模式下，TSC将尝试通过编译成`commonjs`来遏制你对其他软件工程师施加痛苦的热情（参见[“模块模式与脚本模式”](ch10.html#module-mode)）。
- en: Next, configure your build pipeline to compile all your TypeScript to a single
    JavaScript file (usually called a “bundle”) or a set of JavaScript files. While
    TSC can do this for you for small projects with the `outFile` TSC flag, the flag
    is limited to generating SystemJS and AMD bundles. And since TSC doesn’t support
    build plugins and intelligent code splitting the same way that a dedicated build
    tool like Webpack does, you’ll soon find yourself wanting a more powerful bundler.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，配置你的构建流水线，将所有的 TypeScript 编译成单个 JavaScript 文件（通常称为“捆绑包”）或一组 JavaScript 文件。虽然
    TSC 可以通过 `outFile` TSC 标志为小型项目执行此操作，但该标志仅限于生成 SystemJS 和 AMD 捆绑包。由于 TSC 不支持构建插件和智能代码分割，就像
    Webpack 这样的专用构建工具一样，你很快就会发现自己需要一个更强大的打包工具。
- en: 'That’s why for frontend projects, you should use a more powerful build tool
    from the beginning. There are TypeScript plugins for whatever build tool you might
    be using, such as:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于前端项目，你应该从一开始就使用更强大的构建工具。无论你使用什么构建工具，都有适用于该工具的 TypeScript 插件，例如：
- en: '[`ts-loader`](http://bit.ly/2Gw3uH2) for [Webpack](https://webpack.js.org)'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`ts-loader`](http://bit.ly/2Gw3uH2) 适用于 [Webpack](https://webpack.js.org)'
- en: '[`tsify`](http://bit.ly/2KOaZgw) for [Browserify](http://bit.ly/2IDpfGe)'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`tsify`](http://bit.ly/2KOaZgw) 适用于 [Browserify](http://bit.ly/2IDpfGe)'
- en: '[`@babel/preset-typescript`](http://bit.ly/2vc2Sjy) for [Babel](https://babeljs.io)'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`@babel/preset-typescript`](http://bit.ly/2vc2Sjy) 适用于 [Babel](https://babeljs.io)'
- en: '[`gulp-typescript`](http://bit.ly/2vanubN) for [Gulp](https://gulpjs.com)'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`gulp-typescript`](http://bit.ly/2vanubN) 适用于 [Gulp](https://gulpjs.com)'
- en: '[`grunt-ts`](http://bit.ly/2PgUXuq) for [Grunt](https://gruntjs.com)'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`grunt-ts`](http://bit.ly/2PgUXuq) 适用于 [Grunt](https://gruntjs.com)'
- en: 'While a full discussion of optimizing your JavaScript bundle for fast loading
    is outside the scope of this book, some brief advice—not specific to TypeScript—is:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管详细讨论如何优化 JavaScript 捆绑包以实现快速加载超出了本书的范围，但一些简短的建议（不特定于 TypeScript）包括：
- en: Keep your code modular, and avoid implicit dependencies in your code (these
    can happen when you assign things to the `window` global, or to other globals),
    so that your build tool can more accurately analyze your project’s dependency
    graph.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持代码模块化，避免在代码中引入隐式依赖（当你将东西分配给 `window` 全局变量或其他全局变量时可能会发生这种情况），这样你的构建工具就能更准确地分析项目的依赖关系。
- en: Use dynamic imports to lazy-load code that you don’t need for your initial page
    load, so you don’t unnecessarily block your page from rendering.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用动态导入来延迟加载不需要在初始页面加载时就加载的代码，这样可以避免不必要地阻塞页面渲染。
- en: Take advantage of your build tool’s automatic code splitting functionality,
    so that you avoid loading too much JavaScript and slowing page load unnecessarily.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 充分利用构建工具的自动代码分割功能，以避免加载过多的 JavaScript 代码，从而不必要地减慢页面加载速度。
- en: Have a strategy for measuring page load time, either synthetically or, ideally,
    with real user data. As your app grows the initial load time can get slower and
    slower; you can only optimize that load time if you have a way to measure it.
    Tools like [New Relic](https://newrelic.com) and [Datadog](https://www.datadoghq.com)
    are invaluable here.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制定页面加载时间测量策略，可以是通过合成数据或理想情况下使用真实用户数据。随着应用程序的增长，初始加载时间可能会变得越来越慢；只有在能够测量加载时间的情况下，你才能优化它。像
    [New Relic](https://newrelic.com) 和 [Datadog](https://www.datadoghq.com) 这样的工具在这方面非常宝贵。
- en: Keep your production build as similar as possible to your development build.
    The more the two diverge, the more hard-to-fix bugs you’ll have that only show
    up in production.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量使生产构建与开发构建尽可能相似。两者差异越大，只会在生产环境中才会出现的难以修复的错误就越多。
- en: Finally, when shipping TypeScript to run in the browser, have a strategy for
    polyfilling missing browser features. This might be a standard set of polyfills
    you ship as part of every bundle, or it might be a dynamic set of polyfills based
    on what features the user’s browser supports.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，在将 TypeScript 部署到浏览器中运行时，需要制定一个策略来填充缺失的浏览器功能。这可以是一组标准的 polyfill，作为每个捆绑包的一部分进行发布，或者根据用户浏览器支持的功能动态选择
    polyfill。
- en: Publishing Your TypeScript Code to NPM
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将你的 TypeScript 代码发布到 NPM
- en: 'It’s easy to compile your TypeScript code so that other TypeScript and JavaScript
    projects can use it. There are a few best practices to keep in mind when compiling
    to JavaScript for external use:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 编译 TypeScript 代码以便其他 TypeScript 和 JavaScript 项目可以使用。在将 TypeScript 编译为供外部使用的
    JavaScript 时，有一些最佳实践需要牢记：
- en: Generate source maps, so you can debug your own code.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成源映射，这样你就可以调试自己的代码。
- en: Compile to ES5, so that others can easily build and run your code.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译为 ES5，以便其他人可以轻松地构建和运行你的代码。
- en: Be mindful about which module format you compile to (UMD, CommonJS, ES2015,
    etc.).
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在选择要编译到的模块格式时要注意（UMD、CommonJS、ES2015 等）。
- en: Generate type declarations, so that other TypeScript users have types for your
    code.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成类型声明，以便其他 TypeScript 用户可以为你的代码提供类型。
- en: 'Start by compiling your TypeScript to JavaScript with `tsc`, and generate corresponding
    type declarations. Be sure to configure your *tsconfig.json* to maximize compatibility
    with popular JavaScript environments and build systems (more on that in [“Building
    Your TypeScript Project”](#building)):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 首先用 `tsc` 将你的 TypeScript 编译为 JavaScript，并生成相应的类型声明。确保配置你的*tsconfig.json*以最大化与流行的
    JavaScript 环境和构建系统的兼容性（关于此更多信息，请参见[“构建您的 TypeScript 项目”](#building)）：
- en: '[PRE8]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, blacklist your TypeScript source code from getting published to NPM in
    your *.npmignore*, to avoid bloating the size of your package. And in your *.gitignore*,
    exclude generated artifacts from your Git repository to avoid polluting it:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在你的*.npmignore*中将你的 TypeScript 源代码列入黑名单，以避免将其发布到 NPM 时使包大小膨胀。并且在你的*.gitignore*中排除生成的工件，以避免污染你的
    Git 仓库：
- en: '[PRE9]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-152
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you stuck with the recommended project layout and kept your source files
    in *src/* and your generated files in *dist/*, your *.ignore* files will be even
    simpler:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你坚持推荐的项目布局，并将源文件保存在*src/*中，生成的文件保存在*dist/*中，你的*.ignore*文件将会更简单：
- en: '[PRE11]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, add a `"types"` field to your project’s *package.json* to indicate
    that it comes with type declarations (note that this isn’t mandatory, but it is
    a helpful hint to TSC for any consumers that use TypeScript), and add a script
    to build your package before publishing it, to make sure that your package’s JavaScript,
    type declarations, and source maps are always up to date and in sync with the
    TypeScript you compiled them from:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在你项目的*package.json*中添加一个 `"types"` 字段，指示它带有类型声明（注意这不是强制的，但对于使用 TypeScript
    的任何消费者，这是一个有用的提示），并添加一个脚本来在发布之前构建你的包，以确保你的包的 JavaScript、类型声明和源映射始终保持更新并与你编译它们的
    TypeScript 同步：
- en: '[PRE13]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: That’s it! Now when you `npm publish` your package to NPM, NPM will automatically
    compile your TypeScript to a format usable by both people that use TypeScript
    (with full type safety) and people that use JavaScript (with some type safety,
    if their code editor supports it).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！现在当你将你的包`npm publish`到 NPM 时，NPM 将自动将你的 TypeScript 编译为可供既使用 TypeScript 的人（具有完全的类型安全性）使用，也供使用
    JavaScript 的人（如果他们的代码编辑器支持的话，有一定的类型安全性）使用的格式。
- en: Triple-Slash Directives
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 三斜杠指令
- en: TypeScript comes with a little-known, rarely used, and mostly outdated feature
    called *triple-slash directives*. These directives are specially formatted TypeScript
    comments that serve as instructions to TSC.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 自带一个鲜为人知、使用稀少且大多已过时的特性，称为*三斜杠指令*。这些指令是特别格式化的 TypeScript 注释，用作给 TSC
    的指令。
- en: 'They come in a few flavors, and in this section, we’ll cover just two of them:
    `types`, for eliding type-only full-module imports, and `amd-module`, for naming
    generated AMD modules. For a full reference, see [Appendix E](app05.html#triple-slash-directives).'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 它们有几种不同的风格，在本节中，我们将只涵盖其中的两种：`types`，用于省略仅类型的完整模块导入，和`amd-module`，用于命名生成的 AMD
    模块。有关完整参考，请参见[附录 E](app05.html#triple-slash-directives)。
- en: The types Directive
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: types 指令
- en: When you import something from a module, depending on what you imported, TypeScript
    won’t always need to generate an `import` or `require` call when you compile your
    code to JavaScript. If you have an `import` statement whose export is only used
    in a type position in your module (i.e., you just imported a type from a module),
    TypeScript won’t generate any JavaScript code for that `import`—think of it as
    only existing at the type level. This feature is called *import elision*.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从模块导入东西时，根据你导入的内容，当你将代码编译为 JavaScript 时，TypeScript 不会总是需要生成 `import` 或 `require`
    调用。如果你有一个 `import` 语句，其导出仅在模块的类型位置中使用（即，你只是从一个模块中导入了一个类型），TypeScript 将不会为该 `import`
    生成任何 JavaScript 代码——可以将其视为仅存在于类型级别。这个特性称为*导入省略*。
- en: 'The exception to the rule is imports used for side effects: if you import an
    entire module (without importing a specific export or a wildcard from that module),
    that import will generate JavaScript code when you compile your TypeScript. You
    might do this, for instance, if you want to make sure that an ambient type defined
    in a script-mode module is available in your program (like we did in [“Safely
    Extending the Prototype”](ch06.html#extending-the-prototype)). For example:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的例外是用于副作用的导入：如果你导入整个模块（而不导入特定的导出或通配符），当你编译 TypeScript 时，该导入将生成 JavaScript
    代码。例如，你可能这样做，以确保脚本模式模块中定义的环境类型在你的程序中可用（就像我们在[“安全地扩展原型”](ch06.html#extending-the-prototype)中所做的那样）。例如：
- en: '[PRE14]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After compiling *app.ts* to JavaScript with `tsc app.ts`, you’ll notice that
    that the `./global` import wasn’t elided:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `tsc app.ts` 将 *app.ts* 编译为 JavaScript 后，你会注意到 `./global` 的导入并没有被省略：
- en: '[PRE15]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If you find yourself writing imports like this, you may want to start by making
    sure that your import really needs to use side effects, and that there isn’t some
    other way to rewrite your code to make it more explicit which value or type you’re
    importing (e.g., `import {MyType} from './global'`—which TypeScript will elide
    for you—instead of `import './global'`). Or, see if you can include your ambient
    type in your *tsconfig.json*’s `types`, `files`, or `include` field and avoid
    the import altogether.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己写了这样的导入语句，你可能需要首先确保你的导入确实需要使用副作用，并且没有其他方法可以重写你的代码，使得导入的值或类型更加明确（例如，`import
    {MyType} from './global'` — TypeScript 将会为你省略这部分 — 而不是 `import './global'`）。或者，看看是否可以在你的
    *tsconfig.json* 的 `types`、`files` 或 `include` 字段中包含你的环境类型，避免导入整个模块。
- en: 'If neither of those works for your use case, and you want to continue to use
    a full-module import but avoid generating a JavaScript `import` or `require` call
    for that import, use the `types` triple-slash directive. A triple-slash directive
    is three slashes `///` followed by one of a few possible XML tags, each with its
    own set of required attributes. For the `types` directive, it looks like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以上两种方式对你的使用场景都不适用，并且你希望继续使用完整的模块导入但又避免生成 JavaScript 的 `import` 或 `require`
    调用，可以使用 `types` 的三斜线指令。三斜线指令由三个斜线 `///` 开头，接着是几个可能的 XML 标签之一，每个标签有自己的一组必需属性。对于
    `types` 指令来说，它看起来像这样：
- en: 'Declare a dependency on an ambient type declaration:'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明对环境类型声明的依赖：
- en: '[PRE16]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Declare a dependency on *@types/jasmine/index.d.ts*:'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明对 *@types/jasmine/index.d.ts* 的依赖：
- en: '[PRE17]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You probably won’t find yourself using this directive often. And if you do,
    you may want to rethink how you’re using types in your project, and consider if
    there’s a way to rely less on ambient types.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不会经常使用这个指令。如果确实使用了，请重新考虑如何在项目中使用类型，并考虑是否有办法减少对环境类型的依赖。
- en: The amd-module Directive
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: amd-module 指令
- en: 'When compiling your TypeScript code to the AMD module format (indicated with
    `{"module": "amd"}` in your *tsconfig.json*), TypeScript will generate anonymous
    AMD modules by default. You can use the AMD triple-slash directive to give your
    emitted modules names.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '当将你的 TypeScript 代码编译为 AMD 模块格式（在你的 *tsconfig.json* 中指定为 `{"module": "amd"}`）时，默认情况下
    TypeScript 将生成匿名的 AMD 模块。你可以使用 AMD 的三斜线指令来为生成的模块指定名称。'
- en: 'Let’s say you have the following code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有以下代码：
- en: '[PRE18]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Compiling to the `amd` module format, TSC generates the following JavaScript
    code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 编译为 `amd` 模块格式时，TSC 生成了以下 JavaScript 代码：
- en: '[PRE19]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you’re familiar with the AMD module format, you might have noticed that
    this is an anonymous AMD module. To give your AMD module a name, use the `amd-module`
    triple-slash directive in your code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉 AMD 模块格式，你可能注意到这是一个匿名的 AMD 模块。要为你的 AMD 模块指定名称，可以在你的代码中使用 `amd-module`
    的三斜线指令：
- en: '[PRE20]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[![1](assets/1.png)](#co_building_and_running_typescript_CO1-1)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_building_and_running_typescript_CO1-1)'
- en: We use the `amd-module` directive, and set a `name` attribute on it.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `amd-module` 指令，并在其上设置了 `name` 属性。
- en: '[![2](assets/2.png)](#co_building_and_running_typescript_CO1-2)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_building_and_running_typescript_CO1-2)'
- en: The rest of our code is unchanged.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 其余代码保持不变。
- en: 'Recompiling to the AMD module format with TSC, we now get the following JavaScript:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 TSC 重新编译到 AMD 模块格式后，我们现在得到以下 JavaScript 代码：
- en: '[PRE21]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When compiling to AMD modules, use the `amd-module` directive to make your code
    easier to bundle and debug (or, switch to a more modern module format like ES2015
    modules if you can).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译为 AMD 模块时，使用 `amd-module` 指令可以使你的代码更易于捆绑和调试（或者，如果可能的话，切换到更现代的模块格式，如 ES2015
    模块）。
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: In this chapter we covered everything you need to know to build and run your
    TypeScript application in production, either in the browser or on the server.
    We discussed how to choose a JavaScript version to compile to, which libraries
    to mark as available in your environment (and how to polyfill libraries when they’re
    missing), and how to build and ship source maps with your application to make
    it easier to debug in production and develop locally. We then explored how to
    modularize your TypeScript project to keep compilation times fast. Finally, we
    finished up with how to run your TypeScript application on the server and in the
    browser, how to publish your TypeScript code to NPM for others to use, how import
    elision works, and—for AMD users—how to use triple-slash directives to name your
    modules.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们涵盖了构建和在生产环境中运行 TypeScript 应用程序所需的一切内容，无论是在浏览器还是服务器上。我们讨论了如何选择要编译的 JavaScript
    版本，如何标记环境中可用的库（以及如何在缺失时填充库），以及如何构建和发布带有源映射的应用程序，以便在生产中进行调试和在本地开发时更轻松。然后，我们探讨了如何将您的
    TypeScript 项目模块化以保持快速编译时间。最后，我们介绍了如何在服务器和浏览器上运行您的 TypeScript 应用程序，如何将您的 TypeScript
    代码发布到 NPM 供他人使用，import elision 的工作原理，以及对于 AMD 用户如何使用三斜杠指令命名您的模块。
- en: ^([1](ch12.html#idm46304949773272-marker)) If you use a language feature that
    TSC doesn’t transpile and your target environment doesn’t support it either, you
    can usually find a Babel plugin to transpile it for you. To find the most up-to-date
    plugin, search for “babel plugin <feature name>” in your favorite search engine.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch12.html#idm46304949773272-marker)) 如果您使用了 TSC 不会转译的语言特性，并且您的目标环境也不支持它，通常可以找到一个
    Babel 插件来为您转译它。要找到最新的插件，请在您喜欢的搜索引擎中搜索“babel plugin <feature name>”。
