- en: Chapter 2\. Strings and Regular Expressions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ç¬¬äºŒç« \. å­—ç¬¦ä¸²å’Œæ­£åˆ™è¡¨è¾¾å¼
- en: 'Hereâ€™s a trivia question for your next JavaScript party: how many data types
    are there in the worldâ€™s most popular language?'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸‹é¢æ˜¯ä¸€ä¸ªå…³äºä½ ä¸‹ä¸€ä¸ª JavaScript èšä¼šçš„è¶£å‘³é—®é¢˜ï¼šä¸–ç•Œä¸Šæœ€æµè¡Œçš„è¯­è¨€æœ‰å¤šå°‘ç§æ•°æ®ç±»å‹ï¼Ÿ
- en: 'The answer is *eight*, but they might not be what you expect. JavaScriptâ€™s
    eight data types are:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: ç­”æ¡ˆæ˜¯ *eight*ï¼Œä½†å®ƒä»¬å¯èƒ½ä¸æ˜¯ä½ æ‰€æœŸæœ›çš„ã€‚JavaScript çš„å…«ç§æ•°æ®ç±»å‹åŒ…æ‹¬ï¼š
- en: '`Number`'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Number`'
- en: '`String`'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String`'
- en: '`Boolean`'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boolean`'
- en: '`BigInt` (for very large integers)'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BigInt`ï¼ˆç”¨äºéå¸¸å¤§çš„æ•´æ•°ï¼‰'
- en: '`Symbol` (for unique identifiers)'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Symbol`ï¼ˆç”¨äºå”¯ä¸€æ ‡è¯†ç¬¦ï¼‰'
- en: '`Object` (the root of every other JavaScript type)'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object`ï¼ˆå…¶ä»–æ¯ç§ JavaScript ç±»å‹çš„æ ¹ï¼‰'
- en: '`undefined` (a variable that hasnâ€™t been assigned a value)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`undefined`ï¼ˆæœªåˆ†é…å€¼çš„å˜é‡ï¼‰'
- en: '`null` (a missing object)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`null`ï¼ˆä¸¢å¤±çš„å¯¹è±¡ï¼‰'
- en: The recipes in this book feature all of these ingredients. In this chapter,
    youâ€™ll turn your focus to the text-manipulating power of strings.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬ä¹¦ä¸­çš„é…æ–¹æ¶µç›–äº†æ‰€æœ‰è¿™äº›è¦ç‚¹ã€‚åœ¨æœ¬ç« ä¸­ï¼Œä½ å°†ä¸“æ³¨äºå­—ç¬¦ä¸²çš„æ–‡æœ¬å¤„ç†èƒ½åŠ›ã€‚
- en: Checking for an Existing, Nonempty String
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æ£€æŸ¥æ˜¯å¦å­˜åœ¨éç©ºå­—ç¬¦ä¸²
- en: Problem
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: é—®é¢˜
- en: You want to verify that a variable is defined, is a string, and is not empty
    before you use it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä½¿ç”¨ä¹‹å‰ï¼Œä½ éœ€è¦éªŒè¯å˜é‡æ˜¯å¦å·²å®šä¹‰ã€æ˜¯å¦ä¸ºå­—ç¬¦ä¸²ä»¥åŠæ˜¯å¦ä¸ä¸ºç©ºã€‚
- en: Solution
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: è§£å†³æ–¹æ¡ˆ
- en: Before you start working with a string, you often need to validate that itâ€™s
    safe to use. When you do, there are different questions you might ask.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å¼€å§‹å¤„ç†å­—ç¬¦ä¸²ä¹‹å‰ï¼Œé€šå¸¸éœ€è¦éªŒè¯å…¶æ˜¯å¦å®‰å…¨ä½¿ç”¨ã€‚åœ¨è¿™æ ·åšæ—¶ï¼Œå¯èƒ½ä¼šæœ‰ä¸åŒçš„é—®é¢˜ã€‚
- en: 'If you want to make sure that your variable is a string (not just a variable
    that can be *converted* to a string), you use this test:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœè¦ç¡®ä¿å˜é‡æ˜¯å­—ç¬¦ä¸²ï¼ˆè€Œä¸ä»…ä»…æ˜¯å¯*è½¬æ¢*ä¸ºå­—ç¬¦ä¸²çš„å˜é‡ï¼‰ï¼Œåˆ™ä½¿ç”¨æ­¤æµ‹è¯•ï¼š
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you want to check that you have a nonempty string (not the zero-length string
    `''''`), you can tighten your verification like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ æƒ³æ£€æŸ¥æ˜¯å¦æœ‰éç©ºå­—ç¬¦ä¸²ï¼ˆè€Œä¸æ˜¯é›¶é•¿åº¦å­—ç¬¦ä¸² `''`ï¼‰ï¼Œä½ å¯ä»¥åƒè¿™æ ·æ”¶ç´§ä½ çš„éªŒè¯ï¼š
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Optionally, you may want to reject strings that are made up of whitespace only,
    in which case you can use the `String.trim()` method:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: å¯é€‰åœ°ï¼Œä½ å¯èƒ½å¸Œæœ›æ‹’ç»ä»…ç”±ç©ºç™½å­—ç¬¦ç»„æˆçš„å­—ç¬¦ä¸²ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå¯ä»¥ä½¿ç”¨ `String.trim()` æ–¹æ³•ï¼š
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The order of your conditions is important. JavaScript uses *short-circuit evaluation*.
    That means it will only evaluate the second condition (the length check) if the
    first condition (the type check) succeeds. This is important because the length
    check will fail if `unknownVariable` is a different type of variable, like a number.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: æ¡ä»¶çš„é¡ºåºå¾ˆé‡è¦ã€‚JavaScript ä½¿ç”¨ *çŸ­è·¯æ±‚å€¼*ã€‚è¿™æ„å‘³ç€åªæœ‰åœ¨ç¬¬ä¸€ä¸ªæ¡ä»¶ï¼ˆç±»å‹æ£€æŸ¥ï¼‰æˆåŠŸæ—¶ï¼Œå®ƒæ‰ä¼šè¯„ä¼°ç¬¬äºŒä¸ªæ¡ä»¶ï¼ˆé•¿åº¦æ£€æŸ¥ï¼‰ã€‚è¿™å¾ˆé‡è¦ï¼Œå› ä¸ºå¦‚æœ
    `unknownVariable` æ˜¯ä¸åŒç±»å‹çš„å˜é‡ï¼ˆå¦‚æ•°å­—ï¼‰ï¼Œé•¿åº¦æ£€æŸ¥å°†å¤±è´¥ã€‚
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Thereâ€™s a potential gap when using the `typeof` operator. Itâ€™s possible to
    circumvent the string test by using a `String` object instead of a string literal:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨ `typeof` è¿ç®—ç¬¦æ—¶å­˜åœ¨æ½œåœ¨æ¼æ´ã€‚å¯ä»¥é€šè¿‡ä½¿ç”¨ `String` å¯¹è±¡è€Œä¸æ˜¯å­—ç¬¦ä¸²å­—é¢é‡æ¥ç»•è¿‡å­—ç¬¦ä¸²æµ‹è¯•ï¼š
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now the `typeof` operator will return `*object*` instead of `*string*`, because
    the string primitive is wrapped in a `String` object.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œ`typeof` è¿ç®—ç¬¦å°†è¿”å› `*object*` è€Œä¸æ˜¯ `*string*`ï¼Œå› ä¸ºå­—ç¬¦ä¸²åŸå§‹å€¼è¢«åŒ…è£…åœ¨ `String` å¯¹è±¡ä¸­ã€‚
- en: 'In modern JavaScript, creating a `String` object instance is discouraged for
    reasons like this. Youâ€™re better off removing this practice from any code you
    encounter than coding around it. However, if you need to accommodate possible
    `String` objects, you can use a more complex test like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ç°ä»£ JavaScript ä¸­ï¼Œä¸å»ºè®®åˆ›å»º `String` å¯¹è±¡å®ä¾‹ï¼ŒåŸå› å¦‚ä¸Šæ‰€è¿°ã€‚æœ€å¥½ä»ä»»ä½•ä½ é‡åˆ°çš„ä»£ç ä¸­åˆ é™¤è¿™ç§åšæ³•ï¼Œè€Œä¸æ˜¯åœ¨å…¶å‘¨å›´ç¼–ç ã€‚ç„¶è€Œï¼Œå¦‚æœéœ€è¦é€‚åº”å¯èƒ½çš„
    `String` å¯¹è±¡ï¼Œå¯ä»¥ä½¿ç”¨æ›´å¤æ‚çš„æµ‹è¯•ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This code checks that one of two conditions are met: either you have a string
    primitive or an object that has the same prototype as `String`.^([1](ch02.html#idm45475190104344))'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: æ­¤ä»£ç æ£€æŸ¥æ˜¯å¦æ»¡è¶³ä»¥ä¸‹ä¸¤ä¸ªæ¡ä»¶ä¹‹ä¸€ï¼šè¦ä¹ˆæ˜¯å­—ç¬¦ä¸²åŸå§‹å€¼ï¼Œè¦ä¹ˆæ˜¯å…·æœ‰ä¸ `String` ç›¸åŒåŸå‹çš„å¯¹è±¡ã€‚^([1](ch02.html#idm45475190104344))
- en: Discussion
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: è®¨è®º
- en: 'The type-checking test in this recipe uses the `typeof` operator. It returns
    the type name of the variable as a lowercase string. The possible values are:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: æ­¤é…æ–¹ä¸­çš„ç±»å‹æ£€æŸ¥æµ‹è¯•ä½¿ç”¨ `typeof` è¿ç®—ç¬¦ã€‚å®ƒè¿”å›å˜é‡çš„ç±»å‹åç§°ä½œä¸ºå°å†™å­—ç¬¦ä¸²ã€‚å¯èƒ½çš„å€¼åŒ…æ‹¬ï¼š
- en: '`undefined`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`undefined`'
- en: '`boolean`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean`'
- en: '`number`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`number`'
- en: '`bigint`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bigint`'
- en: '`string`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string`'
- en: '`symbol`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`symbol`'
- en: '`function`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`function`'
- en: '`object`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object`'
- en: These values match the list at the beginning of this chapter, but with two small
    differences. First, thereâ€™s no `*null*`, because null values return the string
    `*object*` instead. (This is considered a bug by many, but itâ€™s kept for historical
    reasons.) Second, thereâ€™s an added `*function*` data type, even though a function
    is technically a special case of object.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›å€¼ä¸æœ¬ç« å¼€å¤´çš„åˆ—è¡¨åŒ¹é…ï¼Œä½†æœ‰ä¸¤ä¸ªå°å·®å¼‚ã€‚é¦–å…ˆï¼Œæ²¡æœ‰`*null*`ï¼Œå› ä¸ºnullå€¼è¿”å›å­—ç¬¦ä¸²`*object*`è€Œä¸æ˜¯ã€‚è¿™è¢«è®¸å¤šäººè®¤ä¸ºæ˜¯ä¸€ä¸ªé”™è¯¯ï¼Œä½†å‡ºäºå†å²åŸå› è€Œä¿ç•™ã€‚å…¶æ¬¡ï¼Œæ·»åŠ äº†`*function*`æ•°æ®ç±»å‹ï¼Œå°½ç®¡å‡½æ•°åœ¨æŠ€æœ¯ä¸Šæ˜¯å¯¹è±¡çš„ç‰¹ä¾‹ã€‚
- en: Occasionally, youâ€™ll see the following old-fashioned string-validation technique.
    It doesnâ€™t require a variable to actually *be* a string. It simply verifies that
    your value can be treated as a string, and that it isnâ€™t the empty string.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: å¶å°”ï¼Œæ‚¨ä¼šçœ‹åˆ°ä»¥ä¸‹è€å¼çš„å­—ç¬¦ä¸²éªŒè¯æŠ€æœ¯ã€‚å®ƒä¸è¦æ±‚å˜é‡å®é™…ä¸Š*æ˜¯*ä¸€ä¸ªå­—ç¬¦ä¸²ã€‚å®ƒåªæ˜¯éªŒè¯æ‚¨çš„å€¼æ˜¯å¦å¯ä»¥è¢«è§†ä¸ºå­—ç¬¦ä¸²ï¼Œå¹¶ä¸”å®ƒä¸æ˜¯ç©ºå­—ç¬¦ä¸²ã€‚
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This works because `null` values, `undefined` values, and empty strings (`''`)
    are all *falsy* in JavaScript. If you evaluate any of them in a conditional expression,
    they are treated as false.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯å› ä¸ºåœ¨JavaScriptä¸­ï¼Œ`null`å€¼ã€`undefined`å€¼å’Œç©ºå­—ç¬¦ä¸²ï¼ˆ`''`ï¼‰éƒ½è¢«è§†ä¸º*å‡å€¼*ã€‚å¦‚æœåœ¨æ¡ä»¶è¡¨è¾¾å¼ä¸­è¯„ä¼°å®ƒä»¬ä¸­çš„ä»»ä½•ä¸€ä¸ªï¼Œå®ƒä»¬å°†è¢«è§†ä¸ºå‡ã€‚
- en: This approach has a potential blindspot with the number 0, which always evaluates
    to `false`, skipping the `if` block. To be safe, itâ€™s better to explicitly convert
    your numeric variables to strings, as described in [â€œConverting a Numeric Value
    to a Formatted Stringâ€](#converting_number_to_string).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§æ–¹æ³•åœ¨å¤„ç†æ•°å­—0æ—¶å­˜åœ¨æ½œåœ¨çš„ç›²ç‚¹ï¼Œå› ä¸º0å§‹ç»ˆè¯„ä¼°ä¸º`false`ï¼Œä»è€Œè·³è¿‡`if`å—ã€‚ä¸ºäº†å®‰å…¨èµ·è§ï¼Œæœ€å¥½æ˜¾å¼å°†æ‚¨çš„æ•°å­—å˜é‡è½¬æ¢ä¸ºå­—ç¬¦ä¸²ï¼Œå¦‚[â€œå°†æ•°å€¼è½¬æ¢ä¸ºæ ¼å¼åŒ–å­—ç¬¦ä¸²â€](#converting_number_to_string)ä¸­æ‰€è¿°ã€‚
- en: Converting a Numeric Value to a Formatted String
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: å°†æ•°å€¼è½¬æ¢ä¸ºæ ¼å¼åŒ–å­—ç¬¦ä¸²
- en: Problem
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: é—®é¢˜
- en: You want to create a string representation of a number.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: æ‚¨æƒ³è¦åˆ›å»ºä¸€ä¸ªæ•°å­—çš„å­—ç¬¦ä¸²è¡¨ç¤ºã€‚
- en: Solution
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: è§£å†³æ–¹æ¡ˆ
- en: 'JavaScript is a loosely typed language, and it will automatically convert any
    value to a string when it needs toâ€”for example, if you compare a number to a string
    or join a number to a string with the `+` operator. In fact, one of the easiest
    tricks that JavaScript developers use to convert numbers to strings is to simply
    concatenate an empty string on the beginning or end of the value:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScriptæ˜¯ä¸€ç§å¼±ç±»å‹è¯­è¨€ï¼Œå½“éœ€è¦æ—¶ä¼šè‡ªåŠ¨å°†ä»»ä½•å€¼è½¬æ¢ä¸ºå­—ç¬¦ä¸²ï¼Œä¾‹å¦‚ï¼Œå¦‚æœæ‚¨å°†æ•°å­—ä¸å­—ç¬¦ä¸²æ¯”è¾ƒæˆ–ä½¿ç”¨`+`è¿ç®—ç¬¦å°†æ•°å­—ä¸å­—ç¬¦ä¸²è¿æ¥èµ·æ¥ã€‚äº‹å®ä¸Šï¼ŒJavaScriptå¼€å‘äººå‘˜ç”¨æ¥å°†æ•°å­—è½¬æ¢ä¸ºå­—ç¬¦ä¸²çš„æœ€ç®€å•çš„æŠ€å·§ä¹‹ä¸€å°±æ˜¯ç®€å•åœ°åœ¨å€¼çš„å¼€å¤´æˆ–ç»“å°¾è¿æ¥ä¸€ä¸ªç©ºå­—ç¬¦ä¸²ï¼š
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'However, modern practice favors *explicit* variable conversions. Every JavaScript
    object has a built-in `toString()` method, including the `Number` object. You
    can call it like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œç°ä»£åšæ³•æ›´åå‘äº*æ˜¾å¼*å˜é‡è½¬æ¢ã€‚æ¯ä¸ªJavaScriptå¯¹è±¡éƒ½æœ‰ä¸€ä¸ªå†…ç½®çš„`toString()`æ–¹æ³•ï¼ŒåŒ…æ‹¬`Number`å¯¹è±¡ã€‚æ‚¨å¯ä»¥åƒè¿™æ ·è°ƒç”¨å®ƒï¼š
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Often, you need to customize the string representation of your number. For example,
    you might want a fixed number of decimal places (like 30.00 instead of 30). This
    might also involve rounding (for example, from 30.009 to 30.01).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ç»å¸¸éœ€è¦è‡ªå®šä¹‰æ•°å­—çš„å­—ç¬¦ä¸²è¡¨ç¤ºã€‚ä¾‹å¦‚ï¼Œæ‚¨å¯èƒ½å¸Œæœ›å›ºå®šå°æ•°ä½æ•°ï¼ˆå¦‚30.00è€Œä¸æ˜¯30ï¼‰ã€‚è¿™å¯èƒ½è¿˜æ¶‰åŠåˆ°å››èˆäº”å…¥ï¼ˆä¾‹å¦‚ï¼Œä»30.009åˆ°30.01ï¼‰ã€‚
- en: 'JavaScript has three utility methods built into the number data type that can
    help you. All of them create string representations of a number:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScriptæœ‰ä¸‰ä¸ªå†…ç½®äºæ•°å­—æ•°æ®ç±»å‹ä¸­çš„å®ç”¨æ–¹æ³•ï¼Œå¯ä»¥å¸®åŠ©æ‚¨ã€‚å®ƒä»¬éƒ½åˆ›å»ºæ•°å­—çš„å­—ç¬¦ä¸²è¡¨ç¤ºï¼š
- en: '`Number.toFixed()`'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`Number.toFixed()`'
- en: Lets you specify the number of digits to keep after the decimal point.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: å…è®¸æ‚¨æŒ‡å®šå°æ•°ç‚¹åè¦ä¿ç•™çš„ä½æ•°ã€‚
- en: '`Number.toExponential()`'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`Number.toExponential()`'
- en: Uses scientific notation, and lets you specify the number of digits to show
    after the decimal point.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨ç§‘å­¦è®¡æ•°æ³•ï¼Œå¹¶å…è®¸æ‚¨æŒ‡å®šå°æ•°ç‚¹åè¦æ˜¾ç¤ºçš„ä½æ•°ã€‚
- en: '`Number.toPrecision()`'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`Number.toPrecision()`'
- en: Lets you specify the number of significant digits to keep, without considering
    how large or small your number is.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: å…è®¸æ‚¨æŒ‡å®šè¦ä¿ç•™çš„æœ‰æ•ˆæ•°å­—ä½æ•°ï¼Œè€Œä¸è€ƒè™‘æ‚¨çš„æ•°å­—æ˜¯å¤šä¹ˆå¤§æˆ–å°ã€‚
- en: Note
  id: totrans-62
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: æ³¨æ„
- en: If you arenâ€™t familiar with *significant digits*, itâ€™s a scientific concept
    used to make sure calculations keep an appropriate degree of precision. It also
    helps to make sure a measurement is not represented in a way that implies more
    precision than it actually has. (For example, your average weight may be 162.5
    pounds, but itâ€™s probably not meaningful to say itâ€™s 162.503018 pounds, nor is
    it helpful to round it to 200 pounds.) Wikipedia explains the [concept in detail](https://oreil.ly/vrrPr).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ ä¸ç†Ÿæ‚‰*æœ‰æ•ˆæ•°å­—*ï¼Œè¿™æ˜¯ä¸€ä¸ªç§‘å­¦æ¦‚å¿µï¼Œç”¨äºç¡®ä¿è®¡ç®—å…·æœ‰é€‚å½“çš„ç²¾åº¦ã€‚å®ƒè¿˜æœ‰åŠ©äºç¡®ä¿æµ‹é‡ç»“æœä¸ä¼šä»¥æ¯”å®é™…ç²¾åº¦æ›´é«˜çš„æ–¹å¼è¡¨ç¤ºã€‚ï¼ˆä¾‹å¦‚ï¼Œä½ çš„å¹³å‡ä½“é‡å¯èƒ½æ˜¯162.5ç£…ï¼Œä½†è¯´å®ƒæ˜¯162.503018ç£…å¯èƒ½å¹¶æ²¡æœ‰å®é™…æ„ä¹‰ï¼Œå°†å…¶å››èˆäº”å…¥åˆ°200ç£…ä¹Ÿæ²¡æœ‰å¸®åŠ©ã€‚ï¼‰ç»´åŸºç™¾ç§‘è¯¦ç»†è§£é‡Šäº†[è¿™ä¸ªæ¦‚å¿µ](https://oreil.ly/vrrPr)ã€‚
- en: 'Hereâ€™s an example that demonstrates all three string conversion methods:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæœ‰ä¸€ä¸ªç¤ºä¾‹ï¼Œæ¼”ç¤ºäº†æ‰€æœ‰ä¸‰ç§å­—ç¬¦ä¸²è½¬æ¢æ–¹æ³•ï¼š
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you want to apply formatting like commas, a currency symbol, or some other
    locale-specific details, you need the help of the `Intl.NumberFormat` object.
    Once you create an instance and configure it appropriately, you can use the `Intl.NumberFormat`
    to perform your number-to-string conversion.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ æƒ³åº”ç”¨é€—å·ã€è´§å¸ç¬¦å·æˆ–å…¶ä»–åŒºåŸŸç‰¹å®šç»†èŠ‚çš„æ ¼å¼åŒ–ï¼Œä½ éœ€è¦`Intl.NumberFormat`å¯¹è±¡çš„å¸®åŠ©ã€‚ä¸€æ—¦ä½ åˆ›å»ºäº†ä¸€ä¸ªå®ä¾‹å¹¶é€‚å½“é…ç½®å®ƒï¼Œä½ å¯ä»¥ä½¿ç”¨`Intl.NumberFormat`æ‰§è¡Œä½ çš„æ•°å­—è½¬å­—ç¬¦ä¸²è½¬æ¢ã€‚
- en: 'For example, to format a number as a US currency string, you use code like
    this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ä¾‹å¦‚ï¼Œè¦å°†ä¸€ä¸ªæ•°å­—æ ¼å¼åŒ–ä¸ºç¾å…ƒè´§å¸å­—ç¬¦ä¸²ï¼Œä½ å¯ä»¥ä½¿ç”¨ä»¥ä¸‹ä»£ç ï¼š
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Discussion
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: è®¨è®º
- en: A *locale* represents a specific geographic or cultural region. Locale identifiers
    combine a language code and a region string. The locale *en-US* represents the
    English language in the United States of America. The local *en_CA* is English
    in Canada, *fr-CA* is French in Canada, *ja-JP* is Japanese in Japan, and so on.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*Locale*ä»£è¡¨ç‰¹å®šçš„åœ°ç†æˆ–æ–‡åŒ–åŒºåŸŸã€‚è¯­è¨€æ ‡è¯†ç¬¦ç»“åˆäº†è¯­è¨€ä»£ç å’ŒåŒºåŸŸå­—ç¬¦ä¸²ã€‚*en-US*ä»£è¡¨ç¾å›½çš„è‹±è¯­ï¼Œ*en_CA*æ˜¯åŠ æ‹¿å¤§çš„è‹±è¯­ï¼Œ*fr-CA*æ˜¯åŠ æ‹¿å¤§çš„æ³•è¯­ï¼Œ*ja-JP*æ˜¯æ—¥æœ¬çš„æ—¥è¯­ï¼Œç­‰ç­‰ã€‚'
- en: 'Depending on your locale, there are some standard number formatting rules that
    apply. For example, numbers in English language regions often use commas to separate
    thousands (as in *1,200.00*), while commas in French language regions often use
    commas instead of a decimal point (as in *1 200,00*). If you create a `Intl.NumberFormat`
    object without any constructor arguments, you get the locale settings of the current
    computer:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: æ ¹æ®ä½ çš„åŒºåŸŸè®¾ç½®ï¼Œæœ‰ä¸€äº›æ ‡å‡†çš„æ•°å­—æ ¼å¼åŒ–è§„åˆ™é€‚ç”¨ã€‚ä¾‹å¦‚ï¼Œè‹±è¯­è¯­è¨€åŒºåŸŸä¸­çš„æ•°å­—é€šå¸¸ä½¿ç”¨é€—å·æ¥åˆ†éš”åƒä½ï¼ˆå¦‚*1,200.00*ï¼‰ï¼Œè€Œæ³•è¯­è¯­è¨€åŒºåŸŸä¸­é€šå¸¸ä½¿ç”¨é€—å·è€Œä¸æ˜¯å°æ•°ç‚¹ï¼ˆå¦‚*1
    200,00*ï¼‰ã€‚å¦‚æœä½ åˆ›å»ºä¸€ä¸ªæ²¡æœ‰æ„é€ å‡½æ•°å‚æ•°çš„`Intl.NumberFormat`å¯¹è±¡ï¼Œä½ ä¼šå¾—åˆ°å½“å‰è®¡ç®—æœºçš„åŒºåŸŸè®¾ç½®ï¼š
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can also create an `Intl.NumberFormat` object for a specific locale, with
    no extra options:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ ä¹Ÿå¯ä»¥ä¸ºç‰¹å®šçš„åŒºåŸŸåˆ›å»ºä¸€ä¸ª`Intl.NumberFormat`å¯¹è±¡ï¼Œä¸éœ€è¦é¢å¤–çš„é€‰é¡¹ï¼š
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the *en-US* region, this object will add comma separators, but it wonâ€™t apply
    a fixed number of decimal points or add a currency symbol.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨*en-US*åŒºåŸŸï¼Œè¿™ä¸ªå¯¹è±¡ä¼šæ·»åŠ é€—å·åˆ†éš”ç¬¦ï¼Œä½†ä¸ä¼šåº”ç”¨å›ºå®šæ•°é‡çš„å°æ•°ç‚¹æˆ–æ·»åŠ è´§å¸ç¬¦å·ã€‚
- en: The `Intl.NumberFormat` object supports a number of options. You can change
    the way negative numbers are displayed, set minimum and maximum numbers of digits,
    show percentages, and choose different numbering systems in some languages. You
    can find comprehensive information in the [Mozilla Developer Network reference](https://oreil.ly/JEF4Q).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`Intl.NumberFormat`å¯¹è±¡æ”¯æŒå¤šç§é€‰é¡¹ã€‚ä½ å¯ä»¥æ›´æ”¹è´Ÿæ•°æ˜¾ç¤ºçš„æ–¹å¼ï¼Œè®¾ç½®æœ€å°å’Œæœ€å¤§æ•°å­—ä½æ•°ï¼Œæ˜¾ç¤ºç™¾åˆ†æ¯”ï¼Œå¹¶åœ¨æŸäº›è¯­è¨€ä¸­é€‰æ‹©ä¸åŒçš„ç¼–å·ç³»ç»Ÿã€‚ä½ å¯ä»¥åœ¨[Mozilla
    å¼€å‘è€…ç½‘ç»œå‚è€ƒæ–‡æ¡£](https://oreil.ly/JEF4Q)ä¸­æ‰¾åˆ°è¯¦ç»†ä¿¡æ¯ã€‚'
- en: 'You may see an older version of this technique that uses the `Number.toLocaleString()`
    method. Hereâ€™s an example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¯èƒ½ä¼šçœ‹åˆ°ä¸€ä¸ªä½¿ç”¨`Number.toLocaleString()`æ–¹æ³•çš„æ—§ç‰ˆæœ¬æŠ€æœ¯ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªç¤ºä¾‹ï¼š
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This approach is perfectly valid, although if you plan to format a long series
    of numbers, creating and reusing a single `Intl.NumberFormat` object will perform
    better.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§æ–¹æ³•æ˜¯å®Œå…¨æœ‰æ•ˆçš„ï¼Œå°½ç®¡å¦‚æœä½ æ‰“ç®—æ ¼å¼åŒ–ä¸€é•¿ä¸²æ•°å­—ï¼Œåˆ›å»ºå’Œé‡ç”¨ä¸€ä¸ªå•ä¸€çš„`Intl.NumberFormat`å¯¹è±¡ä¼šè¡¨ç°æ›´å¥½ã€‚
- en: See Also
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å‚è§
- en: If you need formatting support thatâ€™s more extensive than what `Intl.NumberFormat`
    provides, you can use a third-party library like [Numeral.js](https://github.com/adamwdraper/Numeral-js).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ éœ€è¦æ¯”`Intl.NumberFormat`æä¾›çš„æ ¼å¼æ”¯æŒæ›´å¤šçš„åŠŸèƒ½ï¼Œä½ å¯ä»¥ä½¿ç”¨ç¬¬ä¸‰æ–¹åº“ï¼Œæ¯”å¦‚[Numeral.js](https://github.com/adamwdraper/Numeral-js)ã€‚
- en: Inserting Special Characters
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æ’å…¥ç‰¹æ®Šå­—ç¬¦
- en: Problem
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: é—®é¢˜
- en: You want to insert a special character, such as a line break, into a string.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ æƒ³è¦æ’å…¥ç‰¹æ®Šå­—ç¬¦ï¼Œæ¯”å¦‚æ¢è¡Œç¬¦ï¼Œåˆ°ä¸€ä¸ªå­—ç¬¦ä¸²ä¸­ã€‚
- en: Solution
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: è§£å†³æ–¹æ¡ˆ
- en: 'The simplest approach with many special characters is simple: just paste the
    character you want into your editor. For example, if you need a copyright symbol
    (Â©), first find the character in a desktop utility like charmap (on a Windows
    computer) or just search for â€œcopyright symbolâ€ in Google. Select the symbol,
    copy it, and then paste it into your code.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: å¤„ç†å¸¦æœ‰è®¸å¤šç‰¹æ®Šå­—ç¬¦çš„æœ€ç®€å•æ–¹æ³•å¾ˆç®€å•ï¼šåªéœ€å°†æ‚¨éœ€è¦çš„å­—ç¬¦ç²˜è´´åˆ°æ‚¨çš„ç¼–è¾‘å™¨ä¸­ã€‚ä¾‹å¦‚ï¼Œå¦‚æœæ‚¨éœ€è¦ç‰ˆæƒç¬¦å·ï¼ˆÂ©ï¼‰ï¼Œé¦–å…ˆåœ¨æ¡Œé¢å®ç”¨ç¨‹åºï¼ˆå¦‚ Windows è®¡ç®—æœºä¸Šçš„
    charmapï¼‰ä¸­æ‰¾åˆ°è¯¥å­—ç¬¦ï¼Œæˆ–è€…åœ¨ Google ä¸­æœç´¢â€œç‰ˆæƒç¬¦å·â€ã€‚é€‰æ‹©ç¬¦å·ï¼Œå¤åˆ¶å®ƒï¼Œç„¶åç²˜è´´åˆ°æ‚¨çš„ä»£ç ä¸­ã€‚
- en: If you want to use a character that wouldnâ€™t normally be allowed in your code
    (according to the syntax rules of JavaScript), you need to use one of its *escape
    sequences*â€”special character code combinations that arenâ€™t interpreted literally.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæ‚¨æƒ³è¦åœ¨ä»£ç ä¸­ä½¿ç”¨é€šå¸¸ä¸å…è®¸çš„å­—ç¬¦ï¼ˆæ ¹æ® JavaScript çš„è¯­æ³•è§„åˆ™ï¼‰ï¼Œæ‚¨éœ€è¦ä½¿ç”¨å…¶ä¸­çš„ä¸€ç§*è½¬ä¹‰åºåˆ—*â€”ç‰¹æ®Šçš„å­—ç¬¦ä»£ç ç»„åˆï¼Œè¿™äº›ç»„åˆä¸ä¼šè¢«å­—é¢è§£é‡Šã€‚
- en: 'For example, if youâ€™re using apostrophes to delimit your strings, you canâ€™t
    put an apostrophe character directly *in* your string. Instead, you need to use
    the `\''` escape sequence, like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ä¾‹å¦‚ï¼Œå¦‚æœä½ åœ¨å­—ç¬¦ä¸²ä¸­ä½¿ç”¨æ’‡å·ä½œä¸ºå®šç•Œç¬¦ï¼Œå°±ä¸èƒ½ç›´æ¥åœ¨*å­—ç¬¦ä¸²å†…*æ”¾ç½®æ’‡å·å­—ç¬¦ã€‚ç›¸åï¼Œä½ éœ€è¦ä½¿ç”¨ `\'` è½¬ä¹‰åºåˆ—ï¼Œå°±åƒè¿™æ ·ï¼š
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now `favoriteMovie` holds the text *My favorite movie is â€˜The Seventh Sealâ€™.*
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ `favoriteMovie` åŒ…å«æ–‡æœ¬ *My favorite movie is â€˜The Seventh Sealâ€™.*ã€‚
- en: Discussion
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: è®¨è®º
- en: The escape sequences in JavaScript all begin with the *backslash character*
    (`\`). This character signals that what follows is a sequence of characters that
    needs special handling. [TableÂ 2-1](#escape_sequence_list) lists the other escape
    sequences that JavaScript recognizes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript ä¸­çš„è½¬ä¹‰åºåˆ—éƒ½ä»¥*åæ–œæ å­—ç¬¦*ï¼ˆ`\`ï¼‰å¼€å¤´ã€‚è¯¥å­—ç¬¦è¡¨ç¤ºåç»­çš„å­—ç¬¦åºåˆ—éœ€è¦ç‰¹æ®Šå¤„ç†ã€‚[è¡¨Â 2-1](#escape_sequence_list)
    åˆ—å‡ºäº† JavaScript æ‰€è¯†åˆ«çš„å…¶ä»–è½¬ä¹‰åºåˆ—ã€‚
- en: Table 2-1\. Escape sequences
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: è¡¨ 2-1\. è½¬ä¹‰åºåˆ—
- en: '| Sequence | Character |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| åºåˆ— | å­—ç¬¦ |'
- en: '| --- | --- |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `\''` | Single quote |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `\''` | å•å¼•å· |'
- en: '| `\"` | Double quote |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `\"` | åŒå¼•å· |'
- en: '| `\\` | Backslash |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `\\` | åæ–œæ  |'
- en: '| `\n` | Newline |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `\n` | æ¢è¡Œç¬¦ |'
- en: '| `\t` | Horizontal tab |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `\t` | æ°´å¹³åˆ¶è¡¨ç¬¦ |'
- en: '| `\b` | Nondestructive backspace* |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `\b` | éç ´åæ€§é€€æ ¼* |'
- en: '| `\f` | Form feed* |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `\f` | æ¢é¡µç¬¦* |'
- en: '| `\r` | Carriage return^([a](ch02.html#idm45475189621992)) |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `\r` | å›è½¦ç¬¦^([a](ch02.html#idm45475189621992)) |'
- en: '| `\ddd` | Octal sequence (3 digits: *`ddd`*) |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `\ddd` | å…«è¿›åˆ¶åºåˆ—ï¼ˆ3 ä½æ•°ï¼š*`ddd`*ï¼‰ |'
- en: '| `\xdd` | Hexadecimal sequence (2 digits: *`dd`*) |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `\xdd` | åå…­è¿›åˆ¶åºåˆ—ï¼ˆ2 ä½æ•°ï¼š*`dd`*ï¼‰ |'
- en: '| `\udddd` | Unicode sequence (4 hex digits: *`dddd`*) |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `\udddd` | Unicode åºåˆ—ï¼ˆ4 ä¸ªåå…­è¿›åˆ¶æ•°å­—ï¼š*`dddd`*ï¼‰ |'
- en: '| ^([a](ch02.html#idm45475189621992-marker)) Some escape sequences (like the
    ones used for backspaces and form feeds) are holdovers from the original ASCII
    character standard and C language. Unless youâ€™re dealing with a legacy scenario
    (like sending input to a terminal), these escape sequences arenâ€™t likely to be
    useful in JavaScript. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| ^([a](ch02.html#idm45475189621992-marker)) ä¸€äº›è½¬ä¹‰åºåˆ—ï¼ˆå¦‚ç”¨äºé€€æ ¼å’Œæ¢é¡µçš„åºåˆ—ï¼‰æ˜¯ä»åŸå§‹ ASCII
    å­—ç¬¦æ ‡å‡†å’Œ C è¯­è¨€ä¸­ä¿ç•™ä¸‹æ¥çš„ã€‚é™¤éæ‚¨å¤„ç†é—ç•™åœºæ™¯ï¼ˆå¦‚å°†è¾“å…¥å‘é€åˆ°ç»ˆç«¯ï¼‰ï¼Œå¦åˆ™è¿™äº›è½¬ä¹‰åºåˆ—åœ¨ JavaScript ä¸­ä¸å¤ªå¯èƒ½æœ‰ç”¨ã€‚'
- en: 'The last three escape sequences in [TableÂ 2-1](#escape_sequence_list) are patterns
    that require you to supply a numeric value. For example, if you donâ€™t want to
    use the copy-and-paste trick to add a copyright symbol, you can insert it by using
    the `\u` escape sequence and the copyright symbolâ€™s Unicode value:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[è¡¨Â 2-1](#escape_sequence_list) ä¸­çš„æœ€åä¸‰ä¸ªè½¬ä¹‰åºåˆ—æ˜¯éœ€è¦æä¾›æ•°å€¼çš„æ¨¡å¼ã€‚ä¾‹å¦‚ï¼Œå¦‚æœæ‚¨ä¸æƒ³ä½¿ç”¨å¤åˆ¶ç²˜è´´æŠ€å·§æ¥æ·»åŠ ç‰ˆæƒç¬¦å·ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨
    `\u` è½¬ä¹‰åºåˆ—å’Œç‰ˆæƒç¬¦å·çš„ Unicode å€¼æ¥æ’å…¥å®ƒï¼š'
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now the `copyrightNotice` string is set to *This page Â© Shelley Powers.*
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ `copyrightNotice` å­—ç¬¦ä¸²è®¾ç½®ä¸º *This page Â© Shelley Powers.*ã€‚
- en: See Also
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å¦è¯·å‚è§
- en: For information about inserting even more specialized characters in your strings,
    see [â€œInserting Emojisâ€](#inserting_emojis). For an alternate approach to dealing
    with line breaks without using `\n`, see [â€œUsing Template Literals for Clearer
    String Concatenationâ€](#using_template_literals).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰å…³åœ¨å­—ç¬¦ä¸²ä¸­æ’å…¥æ›´ä¸“ä¸šå­—ç¬¦çš„ä¿¡æ¯ï¼Œè¯·å‚é˜… [â€œæ’å…¥è¡¨æƒ…ç¬¦å·â€](#inserting_emojis)ã€‚æœ‰å…³å¤„ç†æ¢è¡Œè€Œä¸ä½¿ç”¨ `\n` çš„æ›¿ä»£æ–¹æ³•ï¼Œè¯·å‚é˜…
    [â€œä½¿ç”¨æ¨¡æ¿æ–‡å­—æ¸…æ™°åœ°è¿›è¡Œå­—ç¬¦ä¸²è¿æ¥â€](#using_template_literals)ã€‚
- en: Inserting Emojis
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æ’å…¥è¡¨æƒ…ç¬¦å·
- en: Problem
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: é—®é¢˜
- en: You want to insert an extended Unicode character that has a 4-byte encoding,
    like an emoji or certain types of accented non-English letters.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: æ‚¨æƒ³è¦æ’å…¥ä¸€ä¸ªå…·æœ‰ 4 å­—èŠ‚ç¼–ç çš„æ‰©å±• Unicode å­—ç¬¦ï¼Œå¦‚è¡¨æƒ…ç¬¦å·æˆ–æŸäº›ç±»å‹çš„é‡éŸ³éè‹±æ–‡å­—æ¯ã€‚
- en: Solution
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: è§£å†³æ–¹æ¡ˆ
- en: 'If you simply want to create a string with an emoji, the copy-and-paste trick
    from [â€œInserting Special Charactersâ€](#inserting_special_characters) usually works.
    In a modern code editor, you can write code like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæ‚¨åªæ˜¯æƒ³åˆ›å»ºä¸€ä¸ªå¸¦æœ‰è¡¨æƒ…ç¬¦å·çš„å­—ç¬¦ä¸²ï¼Œé€šå¸¸å¯ä»¥ä»[â€œæ’å…¥ç‰¹æ®Šå­—ç¬¦â€](#inserting_special_characters)çš„â€œå¤åˆ¶å¹¶ç²˜è´´æŠ€å·§â€ä¸­å·¥ä½œã€‚åœ¨ç°ä»£ä»£ç ç¼–è¾‘å™¨ä¸­ï¼Œæ‚¨å¯ä»¥åƒè¿™æ ·ç¼–å†™ä»£ç ï¼š
- en: '`const hamburger = ''`ğŸ”`'';`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const hamburger = ''`ğŸ”`'';`'
- en: '`const hamburgerStory = ''I like hamburgers'' + hamburger;`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const hamburgerStory = ''æˆ‘å–œæ¬¢æ±‰å ¡åŒ…'' + hamburger;`'
- en: Your code font doesnâ€™t even need to support emojis, because your code editor
    will fall back on the emoji support provided by your operating system. (Of course,
    issues can still occur. For example, you might see a square â€œmissing characterâ€
    icon on an older system where the emoji isnâ€™t available.)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äºä»£ç ç¼–è¾‘å™¨å°†ä½¿ç”¨æ“ä½œç³»ç»Ÿæä¾›çš„è¡¨æƒ…ç¬¦å·æ”¯æŒä½œä¸ºåå¤‡ï¼Œå› æ­¤æ‚¨çš„ä»£ç å­—ä½“ç”šè‡³æ— éœ€æ”¯æŒè¡¨æƒ…ç¬¦å·ã€‚ï¼ˆå½“ç„¶ï¼Œé—®é¢˜ä»å¯èƒ½å‘ç”Ÿã€‚ä¾‹å¦‚ï¼Œåœ¨æ—§ç³»ç»Ÿä¸Šï¼Œè¡¨æƒ…ç¬¦å·ä¸å¯ç”¨æ—¶ï¼Œæ‚¨å¯èƒ½ä¼šçœ‹åˆ°ä¸€ä¸ªæ–¹æ¡†â€œç¼ºå¤±å­—ç¬¦â€å›¾æ ‡ã€‚ï¼‰
- en: Another option is to use the Unicode value for the emoji. The problem is that
    you canâ€™t use a standard `\u` escape sequence to get an emoji, because every emoji
    is stored as a 4-byte value. (By comparison, the Unicode characters that map to
    the keys of your keyboard are usually encoded as 2-byte values.)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: å¦ä¸€ä¸ªé€‰é¡¹æ˜¯ä½¿ç”¨è¡¨æƒ…ç¬¦å·çš„Unicodeå€¼ã€‚é—®é¢˜æ˜¯ï¼Œæ‚¨ä¸èƒ½ä½¿ç”¨æ ‡å‡†çš„`\u`è½¬ä¹‰åºåˆ—æ¥è·å–è¡¨æƒ…ç¬¦å·ï¼Œå› ä¸ºæ¯ä¸ªè¡¨æƒ…ç¬¦å·éƒ½å­˜å‚¨ä¸º4å­—èŠ‚å€¼ã€‚ï¼ˆç›¸æ¯”ä¹‹ä¸‹ï¼Œæ˜ å°„åˆ°é”®ç›˜é”®çš„Unicodeå­—ç¬¦é€šå¸¸ç¼–ç ä¸º2å­—èŠ‚å€¼ã€‚ï¼‰
- en: 'The solution is to use the `String.fromCodePoint()` method:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: è§£å†³æ–¹æ¡ˆæ˜¯ä½¿ç”¨`String.fromCodePoint()`æ–¹æ³•ï¼š
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The hamburger emoji has the hexadecimal code U+1F354\. To use it with `fromCodePoint()`,
    replace the prefix *U+* with *0x*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: æ±‰å ¡åŒ…è¡¨æƒ…çš„åå…­è¿›åˆ¶ä»£ç æ˜¯U+1F354ã€‚è¦ä½¿ç”¨å®ƒä¸`fromCodePoint()`ï¼Œè¯·ç”¨*0x*æ›¿æ¢å‰ç¼€*U+*ã€‚
- en: Once youâ€™ve created an emoji-enhanced string, you can write it to the developer
    console or show it in a web page, just as you would with an ordinary string composed
    of ordinary characters.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ›å»ºäº†ä¸€ä¸ªå¯Œå«è¡¨æƒ…ç¬¦å·çš„å­—ç¬¦ä¸²åï¼Œæ‚¨å¯ä»¥åƒå¤„ç†ç”±æ™®é€šå­—ç¬¦ç»„æˆçš„æ™®é€šå­—ç¬¦ä¸²ä¸€æ ·å°†å…¶å†™å…¥å¼€å‘è€…æ§åˆ¶å°æˆ–æ˜¾ç¤ºåœ¨ç½‘é¡µä¸Šã€‚
- en: Discussion
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: è®¨è®º
- en: As of 2020, there are just over three thousand emojis in the world. You can
    see them, with their corresponding hexadecimal values [at the Full Emoji List](https://oreil.ly/IIguA).
    Just because an emoji exists doesnâ€™t mean it will be supported on the devices
    where you plan to use it, so test for compliance early.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: æˆªè‡³2020å¹´ï¼Œå…¨ä¸–ç•Œä»…æœ‰ä¸‰åƒå¤šä¸ªè¡¨æƒ…ç¬¦å·ã€‚æ‚¨å¯ä»¥åœ¨[å®Œæ•´è¡¨æƒ…åˆ—è¡¨](https://oreil.ly/IIguA)ä¸Šçœ‹åˆ°å®ƒä»¬åŠå…¶ç›¸åº”çš„åå…­è¿›åˆ¶å€¼ã€‚ä»…ä»…å› ä¸ºä¸€ä¸ªè¡¨æƒ…ç¬¦å·å­˜åœ¨å¹¶ä¸æ„å‘³ç€å®ƒå°†åœ¨æ‚¨è®¡åˆ’ä½¿ç”¨å®ƒçš„è®¾å¤‡ä¸Šå—æ”¯æŒï¼Œå› æ­¤è¯·å°½æ—©æµ‹è¯•å…¼å®¹æ€§ã€‚
- en: If you need to do string processing with strings that may include emojis, other
    issues can crawl out of the woodwork. For example, what do you expect this code
    will find?
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæ‚¨éœ€è¦å¤„ç†å¯èƒ½åŒ…å«è¡¨æƒ…ç¬¦å·çš„å­—ç¬¦ä¸²è¿›è¡Œå­—ç¬¦ä¸²å¤„ç†ï¼Œå¯èƒ½ä¼šé‡åˆ°å…¶ä»–é—®é¢˜ã€‚ä¾‹å¦‚ï¼Œæ‚¨è®¤ä¸ºä»¥ä¸‹ä»£ç å°†æ‰¾åˆ°ä»€ä¹ˆï¼Ÿ
- en: '`const hamburger = ''`ğŸ”`'';`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const hamburger = ''`ğŸ”`'';`'
- en: '`const hamburgerLength = hamburger.length;`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const hamburgerLength = hamburger.length;`'
- en: Even though the `hamburger` string is just one character, to your code the length
    appears to be 2 because the hamburger emoji takes twice as many bytes in memory.
    This is an unpleasant [*leaky abstraction*](https://oreil.ly/nlmvi) and a limitation
    of JavaScriptâ€™s support for Unicode.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: å°½ç®¡`hamburger`å­—ç¬¦ä¸²åªæœ‰ä¸€ä¸ªå­—ç¬¦ï¼Œä½†åœ¨ä½ çš„ä»£ç ä¸­ï¼Œé•¿åº¦çœ‹èµ·æ¥æ˜¯2ï¼Œå› ä¸ºæ±‰å ¡åŒ…è¡¨æƒ…åœ¨å†…å­˜ä¸­å ç”¨äº†ä¸¤å€çš„å­—èŠ‚ã€‚è¿™æ˜¯JavaScriptå¯¹Unicodeæ”¯æŒçš„ä¸€ä¸ªä¸æ„‰å¿«çš„[*æ³„æ¼æŠ½è±¡*](https://oreil.ly/nlmvi)å’Œé™åˆ¶ã€‚
- en: There are workarounds that people have invented to deal with emoji issues, like
    incorrect lengths and problems iterating over characters or slicing strings. But
    making a home brew solution is risky, because there are often strange edge cases.
    Instead, consider a JavaScript library with emoji support like [Grapheme Splitter](https://github.com/orling/grapheme-splitter)
    if you need to manipulate emoji-enriched text.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰äººå·²ç»å‘æ˜äº†ä¸€äº›è§£å†³è¡¨æƒ…ç¬¦å·é—®é¢˜çš„å˜é€šæ–¹æ³•ï¼Œä¾‹å¦‚ä¸æ­£ç¡®çš„é•¿åº¦å’Œåœ¨å­—ç¬¦ä¸Šè¿›è¡Œè¿­ä»£æˆ–åˆ‡ç‰‡çš„é—®é¢˜ã€‚ä½†æ˜¯è‡ªåˆ¶è§£å†³æ–¹æ¡ˆé£é™©å¾ˆå¤§ï¼Œå› ä¸ºé€šå¸¸å­˜åœ¨å¥‡æ€ªçš„è¾¹ç¼˜æƒ…å†µã€‚å¦‚æœéœ€è¦å¤„ç†å¯Œå«è¡¨æƒ…ç¬¦å·çš„æ–‡æœ¬ï¼Œå¯ä»¥è€ƒè™‘ä½¿ç”¨åƒ[Grapheme
    Splitter](https://github.com/orling/grapheme-splitter)è¿™æ ·æ”¯æŒè¡¨æƒ…ç¬¦å·çš„JavaScriptåº“ã€‚
- en: Using Template Literals for Clearer String Concatenation
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ä½¿ç”¨æ¨¡æ¿å­—é¢é‡æ¥è¿›è¡Œæ›´æ¸…æ™°çš„å­—ç¬¦ä¸²è¿æ¥
- en: Problem
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: é—®é¢˜
- en: You want a simpler, clearer way to write long string concatenation operations.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: æ‚¨å¸Œæœ›æœ‰ä¸€ä¸ªæ›´ç®€å•ã€æ›´æ¸…æ™°çš„æ–¹æ³•æ¥ç¼–å†™é•¿å­—ç¬¦ä¸²çš„è¿æ¥æ“ä½œã€‚
- en: Solution
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: è§£å†³æ–¹æ¡ˆ
- en: 'A common task in programming is to combine bits of static text with variables
    to create a single, longer string. The traditional way to assemble this kind of
    string is with the concatentation operator `+`, as shown here:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ç¼–ç¨‹ä¸­çš„ä¸€ä¸ªå¸¸è§ä»»åŠ¡æ˜¯å°†é™æ€æ–‡æœ¬çš„å„ä¸ªéƒ¨åˆ†ä¸å˜é‡ç»“åˆèµ·æ¥ï¼Œåˆ›å»ºä¸€ä¸ªæ›´é•¿çš„å­—ç¬¦ä¸²ã€‚ç»„è£…è¿™ç§ç±»å‹çš„å­—ç¬¦ä¸²çš„ä¼ ç»Ÿæ–¹å¼æ˜¯ä½¿ç”¨è¿æ¥è¿ç®—ç¬¦`+`ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Itâ€™s not awful, but it can get awkward, particularly as the fixed bits of text
    get longer. Itâ€™s also surprisingly easy to forget to add spaces around the variables.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: å®ƒå¹¶ä¸ç³Ÿç³•ï¼Œä½†åœ¨å›ºå®šæ–‡æœ¬å˜å¾—æ›´é•¿æ—¶å¯èƒ½ä¼šå˜å¾—å°´å°¬ã€‚è€Œä¸”å¾ˆå®¹æ˜“å¿˜è®°åœ¨å˜é‡å‘¨å›´æ·»åŠ ç©ºæ ¼ã€‚
- en: 'A different approach is to use *template literals*, a type of string literal
    that allows embedded expressions. To create a template literal, just replace your
    standard string delimeters (apostrophes or double quotes) with the backtick (`)
    character:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: å¦ä¸€ç§æ–¹æ³•æ˜¯ä½¿ç”¨*æ¨¡æ¿å­—é¢é‡*ï¼Œä¸€ç§å…è®¸åµŒå…¥è¡¨è¾¾å¼çš„å­—ç¬¦ä¸²å­—é¢é‡ã€‚è¦åˆ›å»ºæ¨¡æ¿å­—é¢é‡ï¼Œåªéœ€ç”¨åå¼•å·ï¼ˆ`ï¼‰æ›¿æ¢æ ‡å‡†å­—ç¬¦ä¸²å®šç•Œç¬¦ï¼ˆæ’‡å·æˆ–åŒå¼•å·ï¼‰å³å¯ï¼š
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now you can insert your variables directly into your template literal. All you
    need to do is wrap each variable in curly braces, preceded by a dollar sign, like
    `${firstName}`. This is called an *expression.*
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œæ‚¨å¯ä»¥ç›´æ¥å°†å˜é‡æ’å…¥åˆ°æ¨¡æ¿å­—é¢é‡ä¸­ã€‚æ‚¨åªéœ€å°†æ¯ä¸ªå˜é‡ç”¨èŠ±æ‹¬å·åŒ…è£¹èµ·æ¥ï¼Œå¹¶åœ¨å‰é¢åŠ ä¸Šä¸€ä¸ªç¾å…ƒç¬¦å·ï¼Œä¾‹å¦‚`${firstName}`ã€‚è¿™ç§°ä¸º*è¡¨è¾¾å¼*ã€‚
- en: 'The advantage of the template literal approach becomes clearer when you look
    at a full example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: æ¨¡æ¿å­—é¢é‡æ–¹æ³•çš„ä¼˜åŠ¿åœ¨äºå½“æ‚¨æŸ¥çœ‹å®Œæ•´ç¤ºä¾‹æ—¶å˜å¾—æ›´åŠ æ˜æ˜¾ï¼š
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Itâ€™s even clearer when you use a modern code editor that colorizes the curly
    brace expressions, making the variables stand out from the literal text.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: å½“æ‚¨åœ¨ç°ä»£ä»£ç ç¼–è¾‘å™¨ä¸­ä½¿ç”¨ç€è‰²èŠ±æ‹¬å·è¡¨è¾¾å¼æ—¶ï¼Œæƒ…å†µä¼šå˜å¾—æ›´æ¸…æ™°ï¼Œè¿™ä½¿å¾—å˜é‡ä»æ–‡å­—å­—é¢ä¸Šè„±é¢–è€Œå‡ºã€‚
- en: Template literals also preserve line breaks. In the examples shown here, you
    canâ€™t see this effect, because weâ€™ve wrapped the code to fit the page. But if
    you deliberately hit Enter to put hard line breaks in your template literal, those
    breaks will be preserved in the string, exactly as if youâ€™d used the `\n` newline
    escape sequence (see [â€œInserting Special Charactersâ€](#inserting_special_characters)).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: æ¨¡æ¿å­—é¢é‡è¿˜ä¿ç•™æ¢è¡Œç¬¦ã€‚åœ¨è¿™é‡Œæ˜¾ç¤ºçš„ç¤ºä¾‹ä¸­ï¼Œæ‚¨çœ‹ä¸åˆ°è¿™ç§æ•ˆæœï¼Œå› ä¸ºæˆ‘ä»¬å·²ç»æŠŠä»£ç æ¢è¡Œä»¥é€‚åº”é¡µé¢ã€‚ä½†æ˜¯ï¼Œå¦‚æœæ‚¨æ•…æ„æŒ‰Enteré”®åœ¨æ¨¡æ¿å­—é¢é‡ä¸­æ·»åŠ ç¡¬æ¢è¡Œï¼Œè¿™äº›æ¢è¡Œå°†ä¿ç•™åœ¨å­—ç¬¦ä¸²ä¸­ï¼Œå°±åƒä½¿ç”¨`\n`æ¢è¡Œè½¬ä¹‰åºåˆ—ä¸€æ ·ï¼ˆå‚è§[â€œæ’å…¥ç‰¹æ®Šå­—ç¬¦â€](#inserting_special_characters)ï¼‰ã€‚
- en: Note
  id: totrans-147
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: æ³¨æ„
- en: Many JavaScript styte guides, including [Airbnb](https://github.com/airbnb/javascript),
    have rules that discourage string concatenation and favor template literals. You
    can use a linter like ESLint ([â€œEnforcing Code Standards with a Linterâ€](ch01.html#using_eslint))
    to enforce this practice in your code.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: è®¸å¤šJavaScripté£æ ¼æŒ‡å—ï¼ŒåŒ…æ‹¬[Airbnb](https://github.com/airbnb/javascript)ï¼Œéƒ½æœ‰è§„åˆ™ä¸é¼“åŠ±å­—ç¬¦ä¸²è¿æ¥ï¼Œè€Œæ˜¯é’çä½¿ç”¨æ¨¡æ¿å­—é¢é‡ã€‚æ‚¨å¯ä»¥ä½¿ç”¨ç±»ä¼¼ESLintçš„ä»£ç æ£€æŸ¥å·¥å…·ï¼ˆ[â€œä½¿ç”¨ESLintæ‰§è¡Œä»£ç æ ‡å‡†â€](ch01.html#using_eslint)ï¼‰æ¥åœ¨æ‚¨çš„ä»£ç ä¸­å¼ºåˆ¶æ‰§è¡Œè¿™ä¸€å®è·µã€‚
- en: Discussion
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: è®¨è®º
- en: 'When you use expressions in a template literal, you arenâ€™t limited to inserting
    variables as they are. In fact, you can use any code expression that JavaScript
    can evaluate. For example, consider this code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æ¨¡æ¿å­—é¢é‡ä¸­ä½¿ç”¨è¡¨è¾¾å¼æ—¶ï¼Œä¸é™äºç›´æ¥æ’å…¥å˜é‡ã€‚äº‹å®ä¸Šï¼Œæ‚¨å¯ä»¥ä½¿ç”¨JavaScriptèƒ½è¯„ä¼°çš„ä»»ä½•ä»£ç è¡¨è¾¾å¼ã€‚ä¾‹å¦‚ï¼Œè¯·è€ƒè™‘ä»¥ä¸‹ä»£ç ï¼š
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, JavaScript executes the addition in the expression `{5+3}`, gets the result,
    and creates the string *The sum of 5 + 3 is 8*.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™é‡Œï¼ŒJavaScriptæ‰§è¡Œè¡¨è¾¾å¼`{5+3}`ä¸­çš„åŠ æ³•ï¼Œè·å–ç»“æœï¼Œå¹¶åˆ›å»ºå­—ç¬¦ä¸²*The sum of 5 + 3 is 8*ã€‚
- en: 'If you want to do something more complex, like format strings or manipulate
    objects, you can use an expression that calls a function. For example, if youâ€™ve
    created a `getDaysSince()` function for calculating the difference between dates
    (see [â€œCalculating the Time Elapsed Between Two Datesâ€](ch04.html#calculating_time_between_dates)),
    you can use it in a template literal like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæ‚¨æƒ³åšä¸€äº›æ›´å¤æ‚çš„äº‹æƒ…ï¼Œæ¯”å¦‚æ ¼å¼åŒ–å­—ç¬¦ä¸²æˆ–æ“ä½œå¯¹è±¡ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨è°ƒç”¨å‡½æ•°çš„è¡¨è¾¾å¼ã€‚ä¾‹å¦‚ï¼Œå¦‚æœæ‚¨åˆ›å»ºäº†ä¸€ä¸ªç”¨äºè®¡ç®—æ—¥æœŸé—´å·®å¼‚çš„`getDaysSince()`å‡½æ•°ï¼ˆå‚è§[â€œè®¡ç®—ä¸¤ä¸ªæ—¥æœŸé—´ç»è¿‡çš„æ—¶é—´â€](ch04.html#calculating_time_between_dates)ï¼‰ï¼Œæ‚¨å¯ä»¥åœ¨æ¨¡æ¿å­—é¢é‡ä¸­åƒè¿™æ ·ä½¿ç”¨å®ƒï¼š
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The only limit is practicalâ€”in other words donâ€™t make your expressions so complex
    that the resulting template literal is more difficult to read than code that uses
    the traditional string-concatenation approach.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: å”¯ä¸€çš„é™åˆ¶æ˜¯å®é™…æƒ…å†µâ€”â€”æ¢å¥è¯è¯´ï¼Œä¸è¦ä½¿æ‚¨çš„è¡¨è¾¾å¼è¿‡äºå¤æ‚ï¼Œä»¥è‡³äºç”Ÿæˆçš„æ¨¡æ¿å­—é¢é‡æ¯”ä½¿ç”¨ä¼ ç»Ÿå­—ç¬¦ä¸²è¿æ¥æ–¹æ³•çš„ä»£ç æ›´éš¾é˜…è¯»ã€‚
- en: Currently, JavaScript has no built-in way to format numbers, dates, and currency
    values inside template literal expressions. Plenty of people have speculated that
    future versions of JavaScript will add this capability. Thereâ€™s even a JavaScript
    library that uses an awkward extensibility feature called [*tagged templates*](https://github.com/skolmer/es2015-i18n-tag)
    to wedge it in.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å‰ï¼ŒJavaScriptæ²¡æœ‰å†…ç½®çš„æ–¹æ³•æ¥åœ¨æ¨¡æ¿å­—é¢é‡è¡¨è¾¾å¼å†…æ ¼å¼åŒ–æ•°å­—ã€æ—¥æœŸå’Œè´§å¸å€¼ã€‚è®¸å¤šäººçŒœæµ‹æœªæ¥ç‰ˆæœ¬çš„JavaScriptå°†æ·»åŠ æ­¤åŠŸèƒ½ã€‚ç”šè‡³æœ‰ä¸€ä¸ªJavaScriptåº“ï¼Œä½¿ç”¨äº†ä¸€ä¸ªå°´å°¬çš„å¯æ‰©å±•æ€§ç‰¹æ€§ç§°ä¸º[*æ ‡è®°æ¨¡æ¿*](https://github.com/skolmer/es2015-i18n-tag)æ¥æ·»åŠ å®ƒã€‚
- en: Performing a Case-Insensitive String Comparison
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æ‰§è¡Œä¸åŒºåˆ†å¤§å°å†™çš„å­—ç¬¦ä¸²æ¯”è¾ƒ
- en: Problem
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: é—®é¢˜
- en: You want to see if two strings match, while treating uppercase and lowercase
    letters as the same.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ æƒ³è¦æŸ¥çœ‹ä¸¤ä¸ªå­—ç¬¦ä¸²æ˜¯å¦åŒ¹é…ï¼ŒåŒæ—¶å°†å¤§å†™å’Œå°å†™å­—æ¯è§†ä¸ºç›¸åŒã€‚
- en: Solution
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: è§£å†³æ–¹æ³•
- en: 'The off-the-cuff approach is to use the `String.toLowerCase()` method on both
    strings, and compare the result, like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€ç§å³å…´çš„æ–¹æ³•æ˜¯å¯¹ä¸¤ä¸ªå­—ç¬¦ä¸²éƒ½ä½¿ç”¨ `String.toLowerCase()` æ–¹æ³•ï¼Œç„¶åæ¯”è¾ƒç»“æœï¼Œä¾‹å¦‚ï¼š
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This approach is fairly reliable, but it can suffer from edge cases with different
    languages, accents, and special characters. (For example, check out the [potential
    problems](https://oreil.ly/CiALB) with Turkish.)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§æ–¹æ³•ç›¸å½“å¯é ï¼Œä½†åœ¨å¤„ç†ä¸åŒè¯­è¨€ã€é‡éŸ³ç¬¦å·å’Œç‰¹æ®Šå­—ç¬¦æ—¶å¯èƒ½ä¼šå‡ºç°è¾¹ç¼˜æƒ…å†µã€‚ï¼ˆä¾‹å¦‚ï¼Œè¯·æŸ¥çœ‹ä¸åœŸè€³å…¶è¯­ç›¸å…³çš„ [æ½œåœ¨é—®é¢˜](https://oreil.ly/CiALB)ã€‚ï¼‰
- en: 'An alternate, bulletproof approach is to use the `String.localeCompare()` method
    with `sensitivity` set to `*accent*`, as shown here:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: å¦ä¸€ç§å¥å£®çš„æ–¹æ³•æ˜¯ä½¿ç”¨ `String.localeCompare()` æ–¹æ³•ï¼Œå¹¶å°† `sensitivity` è®¾ç½®ä¸º `*accent*`ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Discussion
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: è®¨è®º
- en: If `localeCompare()` deems that two strings match, it returns 0\. Otherwise
    it returns a positive or negative integer indicating whether the compared string
    falls before or after the referenced string in the sort order. (Because weâ€™re
    using `localeCompare()` to test for equality, the sort order isnâ€™t important,
    and you can ignore it.)
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœ `localeCompare()` åˆ¤å®šä¸¤ä¸ªå­—ç¬¦ä¸²åŒ¹é…ï¼Œåˆ™è¿”å› 0ã€‚å¦åˆ™ï¼Œè¿”å›ä¸€ä¸ªæ­£æ•°æˆ–è´Ÿæ•°ï¼ŒæŒ‡ç¤ºæ¯”è¾ƒçš„å­—ç¬¦ä¸²åœ¨æ’åºé¡ºåºä¸­æ˜¯åœ¨å‚è€ƒå­—ç¬¦ä¸²ä¹‹å‰è¿˜æ˜¯ä¹‹åã€‚ï¼ˆå› ä¸ºæˆ‘ä»¬ä½¿ç”¨
    `localeCompare()` æ¥æµ‹è¯•ç›¸ç­‰æ€§ï¼Œæ’åºé¡ºåºå¹¶ä¸é‡è¦ï¼Œå¯ä»¥å¿½ç•¥ã€‚ï¼‰
- en: The second parameter of `localeCompare()` holds a string that specifies the
    locale (as explained in [â€œConverting a Numeric Value to a Formatted Stringâ€](#converting_number_to_string)).
    If you pass `undefined`, then `localeCompare()` uses the locale of the current
    computer, which is almost always what you want.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`localeCompare()` çš„ç¬¬äºŒä¸ªå‚æ•°æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œç”¨äºæŒ‡å®šåŒºåŸŸè®¾ç½®ï¼ˆå¦‚ [â€œå°†æ•°å€¼è½¬æ¢ä¸ºæ ¼å¼åŒ–å­—ç¬¦ä¸²â€](#converting_number_to_string)
    ä¸­æ‰€è¿°ï¼‰ã€‚å¦‚æœä¼ å…¥ `undefined`ï¼Œåˆ™ `localeCompare()` ä½¿ç”¨å½“å‰è®¡ç®—æœºçš„åŒºåŸŸè®¾ç½®ï¼Œè¿™é€šå¸¸æ˜¯ä½ æƒ³è¦çš„ã€‚'
- en: To perform a case-insensitive comparison, you need to set the `sensitivity`
    property. There are two values that can work. If you set `sensitivity` to `*accent*`,
    characters that have different accents (like *a* and *Ã¡*) are treated as unequal.
    But if you set `sensitivity` to `*base*`, youâ€™ll get a more permissive case-insensitive
    comparison that treats all accented letters as matches.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: è¦æ‰§è¡Œå¤§å°å†™ä¸æ•æ„Ÿçš„æ¯”è¾ƒï¼Œéœ€è¦è®¾ç½® `sensitivity` å±æ€§ã€‚æœ‰ä¸¤ä¸ªå¯ä»¥å·¥ä½œçš„å€¼ã€‚å¦‚æœå°† `sensitivity` è®¾ç½®ä¸º `*accent*`ï¼Œåˆ™å…·æœ‰ä¸åŒé‡éŸ³ç¬¦å·çš„å­—ç¬¦ï¼ˆå¦‚
    *a* å’Œ *Ã¡*ï¼‰å°†è¢«è§†ä¸ºä¸ç›¸ç­‰ã€‚ä½†å¦‚æœå°† `sensitivity` è®¾ç½®ä¸º `*base*`ï¼Œåˆ™ä¼šå¾—åˆ°ä¸€ä¸ªæ›´å®½æ¾çš„å¤§å°å†™ä¸æ•æ„Ÿæ¯”è¾ƒï¼Œå°†æ‰€æœ‰é‡éŸ³ç¬¦å·çš„å­—æ¯è§†ä¸ºåŒ¹é…ã€‚
- en: Checking If a String Contains a Specific Substring
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æ£€æŸ¥å­—ç¬¦ä¸²æ˜¯å¦åŒ…å«ç‰¹å®šå­å­—ç¬¦ä¸²
- en: Problem
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: é—®é¢˜
- en: You want to check if one string contains another substring.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ æƒ³è¦æ£€æŸ¥ä¸€ä¸ªå­—ç¬¦ä¸²æ˜¯å¦åŒ…å«å¦ä¸€ä¸ªå­å­—ç¬¦ä¸²ã€‚
- en: Solution
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: è§£å†³æ–¹æ³•
- en: 'If you simply need a yes-or-no test, you can use the `String.includes()` method:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœåªéœ€è¦ä¸€ä¸ªæ˜¯æˆ–å¦çš„æµ‹è¯•ï¼Œå¯ä»¥ä½¿ç”¨ `String.includes()` æ–¹æ³•ï¼š
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Optionally, you can tell the `includes()` method where to start its search
    by character position. For example, pass in the value 5 and the search skips to
    the sixth character in the string, and continues to the end:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: å¯é€‰åœ°ï¼Œä½ å¯ä»¥å‘Šè¯‰ `includes()` æ–¹æ³•ä»å“ªä¸ªå­—ç¬¦ä½ç½®å¼€å§‹æœç´¢ã€‚ä¾‹å¦‚ï¼Œä¼ å…¥å€¼ 5ï¼Œåˆ™æœç´¢è·³è¿‡å­—ç¬¦ä¸²ä¸­çš„ç¬¬å…­ä¸ªå­—ç¬¦ï¼Œå¹¶ç»§ç»­ç›´åˆ°æœ«å°¾ï¼š
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Discussion
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: è®¨è®º
- en: 'The search that `includes()` performs is case-sensitive. If you want a case-insensitive
    search, you can call `toLowerCase()` on both strings first:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`includes()` æ‰§è¡Œçš„æœç´¢åŒºåˆ†å¤§å°å†™ã€‚å¦‚æœéœ€è¦å¤§å°å†™ä¸æ•æ„Ÿçš„æœç´¢ï¼Œå¯ä»¥å…ˆå¯¹ä¸¤ä¸ªå­—ç¬¦ä¸²è°ƒç”¨ `toLowerCase()`ï¼š'
- en: '[PRE26]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `includes()` method doesnâ€™t provide any information about where a match
    occurs. If you want this information, consider using the `String.indexOf()` method
    instead, which is described in [â€œExtracting a List from a Stringâ€](#extracting_a_list).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`includes()` æ–¹æ³•ä¸æä¾›å…³äºåŒ¹é…å‘ç”Ÿä½ç½®çš„ä»»ä½•ä¿¡æ¯ã€‚å¦‚æœéœ€è¦æ­¤ä¿¡æ¯ï¼Œè¯·è€ƒè™‘ä½¿ç”¨ `String.indexOf()` æ–¹æ³•ï¼Œè¯¦æƒ…è¯·è§ [â€œä»å­—ç¬¦ä¸²ä¸­æå–åˆ—è¡¨â€](#extracting_a_list)ã€‚'
- en: Replacing All Occurrences of a String
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æ›¿æ¢å­—ç¬¦ä¸²çš„æ‰€æœ‰å‡ºç°
- en: Problem
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: é—®é¢˜
- en: You want to find all occurrences of a specific substring in a string, and replace
    them with something else.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ æƒ³è¦æŸ¥æ‰¾å­—ç¬¦ä¸²ä¸­ç‰¹å®šå­å­—ç¬¦ä¸²çš„æ‰€æœ‰å‡ºç°ï¼Œå¹¶ç”¨å…¶ä»–å†…å®¹æ›¿æ¢å®ƒä»¬ã€‚
- en: Solution
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: è§£å†³æ–¹æ³•
- en: 'You can use the `String.replaceAll()` method to make the change in one step.
    All you need is a substring to search for and another string to swap in its place:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: å¯ä»¥ä½¿ç”¨ `String.replaceAll()` æ–¹æ³•ä¸€æ¬¡æ€§è¿›è¡Œæ›´æ”¹ã€‚ä½ åªéœ€è¦ä¸€ä¸ªè¦æœç´¢çš„å­å­—ç¬¦ä¸²å’Œå¦ä¸€ä¸ªè¦æ›¿æ¢çš„å­—ç¬¦ä¸²ï¼š
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If you run this code, youâ€™ll see the altered string â€œI know not where I was
    born, save that the castle was somewhat old and somewhat horrible.â€ appear in
    the developer console.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœè¿è¡Œæ­¤ä»£ç ï¼Œä½ å°†åœ¨å¼€å‘è€…æ§åˆ¶å°çœ‹åˆ°æ”¹å˜åçš„å­—ç¬¦ä¸² â€œI know not where I was born, save that the castle
    was somewhat old and somewhat horrible.â€ã€‚
- en: Discussion
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: è®¨è®º
- en: The `replaceAll()` method has the ability to use a regular expression for searching
    instead of an ordinary string. You can see how this works in [â€œUsing a Regular
    Expression to Replace Patterns in a Stringâ€](#replacing_patterns_string).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`replaceAll()`æ–¹æ³•æœ‰èƒ½åŠ›ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼è¿›è¡Œæœç´¢ï¼Œè€Œä¸æ˜¯æ™®é€šå­—ç¬¦ä¸²ã€‚ä½ å¯ä»¥åœ¨[â€œä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æ›¿æ¢å­—ç¬¦ä¸²ä¸­çš„æ¨¡å¼â€](#replacing_patterns_string)ä¸­çœ‹åˆ°è¿™æ˜¯å¦‚ä½•å·¥ä½œçš„ã€‚'
- en: See Also
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å‚è§
- en: Consult Recipes and to see how you can find matches in a string and examine
    each one, instead of just replacing them outright.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: æŸ¥çœ‹[Recipes](https://example.org/recipes)æ¥äº†è§£å¦‚ä½•åœ¨å­—ç¬¦ä¸²ä¸­æŸ¥æ‰¾åŒ¹é…é¡¹å¹¶é€ä¸ªæ£€æŸ¥ï¼Œè€Œä¸ä»…ä»…æ˜¯ç›´æ¥æ›¿æ¢å®ƒä»¬ã€‚
- en: Replacing HTML Tags with Named Entities
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: å°†HTMLæ ‡ç­¾æ›¿æ¢ä¸ºå‘½åå®ä½“
- en: Problem
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: é—®é¢˜
- en: You want to insert markup into a web page, and escape the markup (so the browser
    *displays* the angle brackets rather than interpreting them as HTML tags). This
    could be because you want to show some example HTML markup, for example, in a
    tutorial article. Or it may be because you need to safely sanitize outside data,
    like text submitted by a user or pulled out of a database.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ æƒ³è¦å°†æ ‡è®°æ’å…¥åˆ°ç½‘é¡µä¸­ï¼Œå¹¶è½¬ä¹‰è¯¥æ ‡è®°ï¼ˆä½¿æµè§ˆå™¨*æ˜¾ç¤º*è§’æ‹¬å·è€Œä¸è§£é‡Šå®ƒä»¬ä¸ºHTMLæ ‡ç­¾ï¼‰ã€‚è¿™å¯èƒ½æ˜¯å› ä¸ºä½ å¸Œæœ›åœ¨æ•™ç¨‹æ–‡ç« ä¸­æ˜¾ç¤ºä¸€äº›ç¤ºä¾‹HTMLæ ‡è®°ï¼Œæˆ–è€…å› ä¸ºä½ éœ€è¦å®‰å…¨åœ°æ¸…ç†å¤–éƒ¨æ•°æ®ï¼Œå¦‚ç”¨æˆ·æäº¤çš„æ–‡æœ¬æˆ–ä»æ•°æ®åº“ä¸­æå–çš„æ–‡æœ¬ã€‚
- en: Solution
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: è§£å†³æ–¹æ¡ˆ
- en: 'Use the `String.replaceAll()` method to convert angle brackets (`< >`) into
    the named HTML entities `&lt;` and `&gt;`. Youâ€™ll need to perform two steps, one
    for each substitution:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨`String.replaceAll()`æ–¹æ³•å°†è§’æ‹¬å·(`< >`)è½¬æ¢ä¸ºå‘½åçš„HTMLå®ä½“`&lt;`å’Œ`&gt;`ã€‚ä½ éœ€è¦æ‰§è¡Œä¸¤ä¸ªæ­¥éª¤ï¼Œåˆ†åˆ«è¿›è¡Œæ›¿æ¢ï¼š
- en: '[PRE28]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If you examine the string now, youâ€™ll find it holds the text â€œ<p>This is a <span>paragraph</span></p>â€,
    which will appear as you expect (with angle brackets shown) in the web page.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœç°åœ¨æ£€æŸ¥å­—ç¬¦ä¸²ï¼Œä½ ä¼šå‘ç°å®ƒåŒ…å«æ–‡æœ¬â€œ<p>This is a <span>paragraph</span></p>â€ï¼Œåœ¨ç½‘é¡µä¸­å°†å¦‚ä½ æ‰€é¢„æœŸåœ°æ˜¾ç¤ºï¼ˆæ˜¾ç¤ºè§’æ‹¬å·ï¼‰ã€‚
- en: 'You can perform both string substitutions in one step, as long as you can keep
    the code readable:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: åªè¦ä»£ç å¯è¯»æ€§èƒ½å¤Ÿä¿æŒï¼Œä½ å¯ä»¥ä¸€æ­¥å®Œæˆä¸¤æ¬¡å­—ç¬¦ä¸²æ›¿æ¢ï¼š
- en: '[PRE29]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The first `replaceAll()` returns a new string, and the code calls `replaceAll()`
    on that second string to get a *third* string in this case. This technique of
    calling a method on a value thatâ€™s returned from a method is called *method chaining*.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬ä¸€ä¸ª`replaceAll()`è¿”å›ä¸€ä¸ªæ–°å­—ç¬¦ä¸²ï¼Œç„¶ååœ¨è¿™ä¸ªç¬¬äºŒä¸ªå­—ç¬¦ä¸²ä¸Šè°ƒç”¨`replaceAll()`æ¥è·å¾—*ç¬¬ä¸‰*ä¸ªå­—ç¬¦ä¸²ã€‚è¿™ç§åœ¨ä»ä¸€ä¸ªæ–¹æ³•è¿”å›çš„å€¼ä¸Šè°ƒç”¨æ–¹æ³•çš„æŠ€æœ¯ç§°ä¸º*æ–¹æ³•é“¾*ã€‚
- en: Discussion
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: è®¨è®º
- en: HTML escaping is critically important if youâ€™re inserting raw text into a web
    page. If you donâ€™t perform this step, youâ€™ve left open a gaping security hole.
    In fact, you should make sure all text content is escaped before you show it in
    a web page, even if you think that text doesnâ€™t contain any HTML entities (for
    example, even if itâ€™s just set as a literal in your code). Thereâ€™s no telling
    when someone might change the code and substitute a text value from somewhere
    else.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœå°†åŸå§‹æ–‡æœ¬æ’å…¥åˆ°ç½‘é¡µä¸­ï¼ŒHTMLè½¬ä¹‰éå¸¸é‡è¦ã€‚å¦‚æœä½ ä¸æ‰§è¡Œæ­¤æ­¥éª¤ï¼Œå°†ä¼šå­˜åœ¨ä¸¥é‡çš„å®‰å…¨æ¼æ´ã€‚äº‹å®ä¸Šï¼Œä½ åº”è¯¥ç¡®ä¿åœ¨æ˜¾ç¤ºæ–‡æœ¬å†…å®¹ä¹‹å‰ï¼Œå¯¹æ‰€æœ‰æ–‡æœ¬å†…å®¹è¿›è¡Œè½¬ä¹‰ï¼Œå³ä½¿ä½ è®¤ä¸ºè¯¥æ–‡æœ¬ä¸åŒ…å«ä»»ä½•HTMLå®ä½“ï¼ˆä¾‹å¦‚ï¼Œå³ä½¿å®ƒåªæ˜¯åœ¨ä½ çš„ä»£ç ä¸­ç›´æ¥è®¾ç½®ä¸ºæ–‡å­—ï¼‰ã€‚æ— æ³•é¢„æµ‹ä½•æ—¶å¯èƒ½ä¼šä»å…¶ä»–åœ°æ–¹æ›´æ”¹ä»£ç å¹¶æ›¿æ¢æ–‡æœ¬å€¼ã€‚
- en: That said, doing HTML escaping on your own usually isnâ€™t the best approach.
    You need to do it if you are deliberately creating a string that mingles your
    HTML tags with outside content. But ideally youâ€™ll put text in your web page using
    an elementâ€™s `textContent` property instead of its `innerHTML` property. When
    you use `textContent`, the browser escapes the content automatically, which means
    you donâ€™t need to use `String.replaceAll()`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: å°½ç®¡å¦‚æ­¤ï¼Œè‡ªè¡Œè¿›è¡ŒHTMLè½¬ä¹‰é€šå¸¸ä¸æ˜¯æœ€ä½³æ–¹æ³•ã€‚å¦‚æœä½ æœ‰æ„åˆ›å»ºä¸€ä¸ªå°†HTMLæ ‡ç­¾ä¸å¤–éƒ¨å†…å®¹æ··åˆçš„å­—ç¬¦ä¸²ï¼Œé‚£ä¹ˆä½ éœ€è¦è¿™æ ·åšã€‚ä½†æ˜¯ç†æƒ³æƒ…å†µä¸‹ï¼Œä½ åº”è¯¥ä½¿ç”¨å…ƒç´ çš„`textContent`å±æ€§è€Œä¸æ˜¯`innerHTML`å±æ€§å°†æ–‡æœ¬æ”¾å…¥ç½‘é¡µä¸­ã€‚ä½¿ç”¨`textContent`æ—¶ï¼Œæµè§ˆå™¨ä¼šè‡ªåŠ¨è½¬ä¹‰å†…å®¹ï¼Œè¿™æ„å‘³ç€ä½ ä¸éœ€è¦ä½¿ç”¨`String.replaceAll()`ã€‚
- en: See Also
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å‚è§
- en: See [ChapterÂ 12](ch12.html#ch12) for more information about using the HTML DOM
    to insert text content into a web page.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: æ›´å¤šå…³äºä½¿ç”¨HTML DOMå°†æ–‡æœ¬å†…å®¹æ’å…¥åˆ°ç½‘é¡µä¸­çš„ä¿¡æ¯ï¼Œè¯·å‚è§[ç¬¬12ç« ](ch12.html#ch12)ã€‚
- en: Using a Regular Expression to Replace Patterns in a String
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æ›¿æ¢å­—ç¬¦ä¸²ä¸­çš„æ¨¡å¼
- en: Problem
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: é—®é¢˜
- en: You want to search a string for a pattern, rather than an exact sequence of
    characters. You then want to create a new string, with the pattern replaced.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¸Œæœ›åœ¨å­—ç¬¦ä¸²ä¸­æœç´¢æ¨¡å¼ï¼Œè€Œä¸æ˜¯ç¡®åˆ‡çš„å­—ç¬¦åºåˆ—ã€‚ç„¶åï¼Œä½ æƒ³åˆ›å»ºä¸€ä¸ªæ–°å­—ç¬¦ä¸²ï¼Œå°†æ¨¡å¼æ›¿æ¢æ‰ã€‚
- en: Solution
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: è§£å†³æ–¹æ¡ˆ
- en: You can use the `String.replace()` or `String.replaceAll()` methods, both of
    which support regular expressions.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¯ä»¥ä½¿ç”¨`String.replace()`æˆ–`String.replaceAll()`æ–¹æ³•ï¼Œä¸¤è€…éƒ½æ”¯æŒæ­£åˆ™è¡¨è¾¾å¼ã€‚
- en: Note
  id: totrans-213
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: æ³¨æ„
- en: A *regular expression* is a sequence of characters that defines a text pattern.
    Regular expressions are a standard thatâ€™s implemented in JavaScript and many other
    programming languages. [TableÂ 2-2](#regular_expression_special_characters) gives
    a brief introduction to regular expression syntax.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '*æ­£åˆ™è¡¨è¾¾å¼*æ˜¯å®šä¹‰æ–‡æœ¬æ¨¡å¼çš„å­—ç¬¦åºåˆ—ã€‚æ­£åˆ™è¡¨è¾¾å¼æ˜¯JavaScriptå’Œè®¸å¤šå…¶ä»–ç¼–ç¨‹è¯­è¨€ä¸­å®ç°çš„æ ‡å‡†ã€‚è¯·å‚é˜…[è¡¨Â 2-2](#regular_expression_special_characters)ä»¥ç®€è¦ä»‹ç»æ­£åˆ™è¡¨è¾¾å¼è¯­æ³•ã€‚'
- en: For example, consider the regular expression pattern *`t\w{2}e`*. This translates
    into *look for any sequence of characters beginning with *t*, ending with *e*,
    and containing two other alphanumeric characters*. The solution matches *time*,
    but also matches *tame*.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ä¾‹å¦‚ï¼Œè€ƒè™‘æ­£åˆ™è¡¨è¾¾å¼æ¨¡å¼*`t\w{2}e`*ã€‚è¿™å°†è¢«ç¿»è¯‘ä¸º*æŸ¥æ‰¾ä»¥*t*å¼€å¤´ï¼Œä»¥*e*ç»“å°¾ï¼Œå¹¶åŒ…å«ä¸¤ä¸ªå…¶ä»–å­—æ¯æ•°å­—å­—ç¬¦çš„ä»»æ„å­—ç¬¦åºåˆ—*ã€‚è¯¥è§£å†³æ–¹æ¡ˆåŒ¹é…*time*ï¼Œä½†ä¹ŸåŒ¹é…*tame*ã€‚
- en: 'Hereâ€™s the code that uses this regular expression:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä½¿ç”¨æ­¤æ­£åˆ™è¡¨è¾¾å¼çš„ä»£ç ï¼š
- en: '[PRE30]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Notice that the regular expression isnâ€™t written a string. Instead, itâ€™s a literal
    that begins and ends with a slash (`/`). JavaScript recognizes this syntax and
    creates a `RegEx` object that uses your expression.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œæ­£åˆ™è¡¨è¾¾å¼ä¸æ˜¯ä½œä¸ºå­—ç¬¦ä¸²ç¼–å†™çš„ã€‚ç›¸åï¼Œå®ƒæ˜¯ä»¥æ–œæ ï¼ˆ`/`ï¼‰å¼€å§‹å’Œç»“æŸçš„æ–‡å­—ã€‚JavaScriptè¯†åˆ«è¿™ç§è¯­æ³•å¹¶åˆ›å»ºä¸€ä¸ªä½¿ç”¨æ‚¨çš„è¡¨è¾¾å¼çš„`RegEx`å¯¹è±¡ã€‚
- en: The `g` at the end of the regular expression is an additional detail called
    the *global flag*. It indicates that you are searching the whole string for matches.
    If you donâ€™t include the `g` flag, youâ€™ll receive an error when you call `replaceAll()`.
    However, you can use a regular expression without the global flag when you use
    the `replace()` method to change just one occurrence of a pattern.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£åˆ™è¡¨è¾¾å¼æœ«å°¾çš„`g`æ˜¯ç§°ä¸º*å…¨å±€æ ‡å¿—*çš„é™„åŠ ç»†èŠ‚ã€‚å®ƒè¡¨ç¤ºæ‚¨æ­£åœ¨æœç´¢æ•´ä¸ªå­—ç¬¦ä¸²ä»¥æ‰¾åˆ°åŒ¹é…é¡¹ã€‚å¦‚æœä¸åŒ…æ‹¬`g`æ ‡å¿—ï¼Œåˆ™åœ¨è°ƒç”¨`replaceAll()`æ—¶ä¼šæ”¶åˆ°é”™è¯¯æ¶ˆæ¯ã€‚ä½†æ˜¯ï¼Œå½“æ‚¨ä½¿ç”¨`replace()`æ–¹æ³•ä»…æ›´æ”¹æ¨¡å¼çš„ä¸€ä¸ªå‡ºç°æ—¶ï¼Œå¯ä»¥ä½¿ç”¨æ²¡æœ‰å…¨å±€æ ‡å¿—çš„æ­£åˆ™è¡¨è¾¾å¼ã€‚
- en: Discussion
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: è®¨è®º
- en: 'If youâ€™d rather create a regular expression without using the `/` delimiter,
    thereâ€™s another option. Instead of writing a regular expression literal, you can
    explicitly create a `RegEx` object, like this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæ‚¨ä¸æƒ³ä½¿ç”¨`/`åˆ†éš”ç¬¦åˆ›å»ºæ­£åˆ™è¡¨è¾¾å¼ï¼Œè¿˜æœ‰å¦ä¸€ç§é€‰æ‹©ã€‚æ‚¨å¯ä»¥æ˜¾å¼åˆ›å»ºä¸€ä¸ª`RegEx`å¯¹è±¡ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE31]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When you use this approach, you donâ€™t include the surrounding slashes around
    the regular expression, but you do need to escape any backslashes in the pattern
    (by replacing `/` with `//`). In addition, the global flag becomes a second argument
    to the `RegExp` constructor, instead of being added to the end of the regular
    expression.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: å½“æ‚¨ä½¿ç”¨è¿™ç§æ–¹æ³•æ—¶ï¼Œæ‚¨ä¸éœ€è¦åœ¨æ­£åˆ™è¡¨è¾¾å¼å‘¨å›´åŒ…å«æ–œæ ï¼Œä½†æ‚¨éœ€è¦è½¬ä¹‰æ¨¡å¼ä¸­çš„ä»»ä½•åæ–œæ ï¼ˆå°†`/`æ›¿æ¢ä¸º`//`ï¼‰ã€‚æ­¤å¤–ï¼Œå…¨å±€æ ‡å¿—æˆä¸º`RegExp`æ„é€ å‡½æ•°çš„ç¬¬äºŒä¸ªå‚æ•°ï¼Œè€Œä¸æ˜¯æ·»åŠ åˆ°æ­£åˆ™è¡¨è¾¾å¼çš„æœ«å°¾ã€‚
- en: 'You might find that escaping backslashes is awkward or confusing in long, complicated
    regular expressions. If so, you can get around the escaping requirement with a
    template literal (introduced in [â€œUsing Template Literals for Clearer String Concatenationâ€](#using_template_literals)).
    The trick is to combine your template literal with the `String.raw()` method.
    Remember to use backticks (`) around the expression string instead of apostrophes
    or quotes:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: æ‚¨å¯èƒ½ä¼šå‘ç°ï¼Œåœ¨é•¿è€Œå¤æ‚çš„æ­£åˆ™è¡¨è¾¾å¼ä¸­ï¼Œè½¬ä¹‰åæ–œæ æ˜¯ä»¤äººå›°æƒ‘çš„ã€‚å¦‚æœæ˜¯è¿™æ ·ï¼Œæ‚¨å¯ä»¥é€šè¿‡æ¨¡æ¿æ–‡å­—ï¼ˆåœ¨[â€œä½¿ç”¨æ¨¡æ¿æ–‡å­—è¿›è¡Œæ›´æ¸…æ™°çš„å­—ç¬¦ä¸²è¿æ¥â€](#using_template_literals)ä¸­ä»‹ç»ï¼‰æ¥é¿å…è½¬ä¹‰è¦æ±‚ã€‚çªé—¨æ˜¯å°†æ‚¨çš„æ¨¡æ¿æ–‡å­—ä¸`String.raw()`æ–¹æ³•ç»“åˆä½¿ç”¨ã€‚è¯·è®°ä½ï¼Œåœ¨è¡¨è¾¾å¼å­—ç¬¦ä¸²å‘¨å›´ä½¿ç”¨åå¼•å·ï¼ˆ`ï¼‰è€Œä¸æ˜¯æ’‡å·æˆ–å¼•å·ï¼š
- en: '[PRE32]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Extra: Regular Expressions'
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: é¢å¤–ï¼šæ­£åˆ™è¡¨è¾¾å¼
- en: 'Regular expressions are made up of regular characters that are used alone or
    in combination with special characters. For instance, the following is a regular
    expression for a pattern that matches against a string that contains the word
    *technology* and the word *book*, in that order, and separated by one or more
    whitespace characters:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£åˆ™è¡¨è¾¾å¼ç”±æ™®é€šå­—ç¬¦å•ç‹¬ä½¿ç”¨æˆ–ä¸ç‰¹æ®Šå­—ç¬¦ç»“åˆè€Œæˆã€‚ä¾‹å¦‚ï¼Œä»¥ä¸‹æ˜¯ä¸€ä¸ªæ­£åˆ™è¡¨è¾¾å¼ï¼Œç”¨äºåŒ¹é…åŒ…å«å•è¯*technology*å’Œå•è¯*book*ï¼ˆä»¥è¿™ä¸ªé¡ºåºï¼Œå¹¶ç”±ä¸€ä¸ªæˆ–å¤šä¸ªç©ºç™½å­—ç¬¦åˆ†éš”ï¼‰çš„å­—ç¬¦ä¸²æ¨¡å¼ï¼š
- en: '[PRE33]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The backslash character (`\`) serves two purposes: either itâ€™s used with a
    regular character, to designate that itâ€™s a special character, or itâ€™s used with
    a special character, such as the plus sign (+), to designate that the character
    should be treated literally. In this case, the backslash is used with *s*, which
    transforms the letter *s* to a special character designating a whitespace character
    (space, tab, line feed, or form feed). The +\s+ special character is followed
    by the plus sign, `\s`, which is a signal to match the preceding character (in
    this example, a whitespace character) one or more times. This regular expression
    would work with the following:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: åæ–œæ å­—ç¬¦ï¼ˆ`\`ï¼‰æœ‰ä¸¤ä¸ªç”¨é€”ï¼šå®ƒè¦ä¹ˆä¸æ™®é€šå­—ç¬¦ä¸€èµ·ä½¿ç”¨ï¼Œè¡¨ç¤ºå®ƒæ˜¯ä¸€ä¸ªç‰¹æ®Šå­—ç¬¦ï¼Œè¦ä¹ˆä¸ç‰¹æ®Šå­—ç¬¦ä¸€èµ·ä½¿ç”¨ï¼Œä¾‹å¦‚åŠ å·ï¼ˆ+ï¼‰ï¼Œè¡¨ç¤ºåº”å°†è¯¥å­—ç¬¦è§†ä¸ºå­—é¢é‡ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œåæ–œæ ä¸
    *s* ä¸€èµ·ä½¿ç”¨ï¼Œå°†å­—æ¯ *s* è½¬æ¢ä¸ºæŒ‡å®šç©ºæ ¼å­—ç¬¦ï¼ˆç©ºæ ¼ã€åˆ¶è¡¨ç¬¦ã€æ¢è¡Œç¬¦æˆ–æ¢é¡µç¬¦ï¼‰çš„ç‰¹æ®Šå­—ç¬¦ã€‚ +\s+ ç‰¹æ®Šå­—ç¬¦åè·ŸåŠ å·ï¼Œ`\s` æ˜¯ä¸€ä¸ªåŒ¹é…å‰ä¸€ä¸ªå­—ç¬¦ï¼ˆåœ¨è¿™ä¸ªä¾‹å­ä¸­æ˜¯ç©ºæ ¼å­—ç¬¦ï¼‰ä¸€æ¬¡æˆ–å¤šæ¬¡çš„ä¿¡å·ã€‚æ­¤æ­£åˆ™è¡¨è¾¾å¼é€‚ç”¨äºä»¥ä¸‹æƒ…å†µï¼š
- en: '[PRE34]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'It would also work with the following:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥ä¸‹ä¹Ÿæœ‰æ•ˆï¼š
- en: '[PRE35]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'It would not work with the following, because there is no whitespace between
    the words:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: å®ƒä¸é€‚ç”¨äºä»¥ä¸‹æƒ…å†µï¼Œå› ä¸ºå•è¯ä¹‹é—´æ²¡æœ‰ç©ºç™½å­—ç¬¦ï¼š
- en: '[PRE36]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: It doesnâ€™t matter how much whitespace is between *technology* and *book*, because
    of the use of `\s+`. However, using the plus sign does require at least one whitespace
    character.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äºä½¿ç”¨ `\s+`ï¼Œåœ¨ *technology* å’Œ *book* ä¹‹é—´æœ‰å¤šå°‘ç©ºç™½å­—ç¬¦å¹¶ä¸é‡è¦ã€‚ç„¶è€Œï¼Œä½¿ç”¨åŠ å·ç¡®å®éœ€è¦è‡³å°‘ä¸€ä¸ªç©ºç™½å­—ç¬¦ã€‚
- en: '[TableÂ 2-2](#regular_expression_special_characters) shows the most commonly
    used special characters in JavaScript applications.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '[è¡¨Â 2-2](#regular_expression_special_characters) å±•ç¤ºäº† JavaScript åº”ç”¨ä¸­æœ€å¸¸ç”¨çš„ç‰¹æ®Šå­—ç¬¦ã€‚'
- en: Table 2-2\. Regular expression special characters
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: è¡¨ 2-2\. æ­£åˆ™è¡¨è¾¾å¼ç‰¹æ®Šå­—ç¬¦
- en: '| Character | Matches | Example |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| å­—ç¬¦ | åŒ¹é… | ç¤ºä¾‹ |'
- en: '| --- | --- | --- |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `^` | Matches beginning of input | `/^This/` matches *This isâ€¦* |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| `^` | åŒ¹é…è¾“å…¥çš„å¼€å¤´ | `/^This/` åŒ¹é… *This isâ€¦* |'
- en: '| `$` | Matches end of input | `/end$/` matches *This is the end* |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| `$` | åŒ¹é…è¾“å…¥çš„ç»“å°¾ | `/end$/` åŒ¹é… *This is the end* |'
- en: '| `*` | Matches zero or more times | `/se*/` matches *seeee* as well as *se*
    |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| `*` | åŒ¹é…é›¶æ¬¡æˆ–å¤šæ¬¡ | `/se*/` åŒ¹é… *seeee* å’Œ *se* |'
- en: '| `?` | Matches zero or one time | `/ap?/` matches *apple* and *and* |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| `?` | åŒ¹é…é›¶æ¬¡æˆ–ä¸€æ¬¡ | `/ap?/` åŒ¹é… *apple* å’Œ *and* |'
- en: '| `+` | Matches one or more times | `/ap+/` matches *apple* but not *and* |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| `+` | åŒ¹é…ä¸€æ¬¡æˆ–å¤šæ¬¡ | `/ap+/` åŒ¹é… *apple* ä½†ä¸åŒ¹é… *and* |'
- en: '| `{n}` | Matches exactly *n* times | `/ap{2}/` matches *apple* but not *apie*
    |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| `{n}` | ç²¾ç¡®åŒ¹é… *n* æ¬¡ | `/ap{2}/` åŒ¹é… *apple* ä½†ä¸åŒ¹é… *apie* |'
- en: '| `\{n,\}` | Matches *n* or more times | `/ap{2,}/` matches all pâ€™s in *apple*
    and *appple* but not *apie* |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `\{n,\}` | åŒ¹é…è‡³å°‘ *n* æ¬¡ | `/ap{2,}/` åŒ¹é… *apple* å’Œ *appple* ä¸­çš„æ‰€æœ‰ p ä½†ä¸åŒ¹é… *apie*
    |'
- en: '| `\{n,m\}` | Matches at least *n*, at most *m* times | `/ap{2,4}/` matches
    four pâ€™s in *apppppple* |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| `\{n,m\}` | åŒ¹é…è‡³å°‘ *n* æ¬¡ï¼Œè‡³å¤š *m* æ¬¡ | `/ap{2,4}/` åŒ¹é… *appppple* ä¸­çš„å››ä¸ª p |'
- en: '| `.` | Any character except newline | `/a.e/` matches *ape* and *axe* |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `.` | é™¤æ¢è¡Œç¬¦å¤–çš„ä»»æ„å­—ç¬¦ | `/a.e/` åŒ¹é… *ape* å’Œ *axe* |'
- en: '| `[`â€¦`]` | Any character within brackets | `/a[px]e/` matches *ape* and *axe*
    but not *ale* |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| `[`â€¦`]` | æ‹¬å·å†…çš„ä»»ä½•å­—ç¬¦ | `/a[px]e/` åŒ¹é… *ape* å’Œ *axe* ä½†ä¸åŒ¹é… *ale* |'
- en: '| `[^`â€¦`]` | Any character but those within brackets | `/a[^px]/` matches *ale*
    but not *axe* or *ape* |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| `[^`â€¦`]` | é™¤æ‹¬å·å†…çš„å­—ç¬¦å¤–çš„ä»»ä½•å­—ç¬¦ | `/a[^px]/` åŒ¹é… *ale* ä½†ä¸åŒ¹é… *axe* æˆ– *ape* |'
- en: '| `\b` | Matches on word boundary | `/\bno/` matches the first *no* in *nono*
    |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| `\b` | åŒ¹é…å•è¯è¾¹ç•Œ | `/\bno/` åŒ¹é… *nono* ä¸­çš„ç¬¬ä¸€ä¸ª *no* |'
- en: '| `\B` | Matches on nonword boundary | `/\Bno/` matches the second *no* in
    *nono* |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| `\B` | åŒ¹é…éå•è¯è¾¹ç•Œ | `/\Bno/` åŒ¹é… *nono* ä¸­çš„ç¬¬äºŒä¸ª *no* |'
- en: '| `\d` | Digits from 0 to 9 | `/\d{3}/` matches *123* in *Now in 123* |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| `\d` | æ•°å­— 0 åˆ° 9 | `/\d{3}/` åŒ¹é… *Now in 123* ä¸­çš„ *123* |'
- en: '| `\D` | Any nondigit character | `/\D{2,4}/` matches *Now '' in â€˜Now in 123*;
    |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| `\D` | ä»»ä½•éæ•°å­—å­—ç¬¦ | `/\D{2,4}/` åŒ¹é… *Now '' in â€˜Now in 123*; |'
- en: '| `\w` | Matches word character (letters, digits, underscores) | `/\w/` matches
    *j* in *javascript* |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| `\w` | åŒ¹é…å•è¯å­—ç¬¦ï¼ˆå­—æ¯ã€æ•°å­—ã€ä¸‹åˆ’çº¿ï¼‰ | `/\w/` åŒ¹é… *javascript* ä¸­çš„ *j* |'
- en: '| `\W` | Matches any nonword character (not letters, digits, or underscores)
    | `\/W/` matches *%* in *100%* |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| `\W` | åŒ¹é…ä»»ä½•éå•è¯å­—ç¬¦ï¼ˆä¸æ˜¯å­—æ¯ã€æ•°å­—æˆ–ä¸‹åˆ’çº¿ï¼‰ | `\/W/` åŒ¹é… *100%* ä¸­çš„ *%* |'
- en: '| `\n` | Matches a line feed |  |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| `\n` | åŒ¹é…æ¢è¡Œç¬¦ |  |'
- en: '| `\s` | A single whitespace character |  |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| `\s` | å•ä¸ªç©ºç™½å­—ç¬¦ |  |'
- en: '| `\S` | A single character that is not whitespace |  |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| `\S` | ä»»ä½•éç©ºæ ¼å­—ç¬¦ |  |'
- en: '| `\t` | A tab |  |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| `\t` | åˆ¶è¡¨ç¬¦ |  |'
- en: '| `(x)` | Capturing parentheses | Remembers the matched characters |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| `(x)` | æ•è·æ‹¬å· | è®°ä½åŒ¹é…çš„å­—ç¬¦ |'
- en: Note
  id: totrans-262
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: æ³¨æ„
- en: Regular expressions are powerful but can be tricky. Theyâ€™re only covered lightly
    in this book. If you want more in-depth coverage of regular expressions, you can
    read the excellent *[Regular Expressions Cookbook](http://shop.oreilly.com/product/0636920023630.do)*
    by Jan Goyvaerts and Steven Levithan (Oâ€™Reilly), or consult an [online reference](https://github.com/ziishaned/learn-regex).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£åˆ™è¡¨è¾¾å¼å¾ˆå¼ºå¤§ï¼Œä½†å¯èƒ½æœ‰äº›æ£˜æ‰‹ã€‚æœ¬ä¹¦åªæ˜¯ç®€å•ä»‹ç»äº†å®ƒä»¬ã€‚å¦‚æœä½ æƒ³è¦æ›´æ·±å…¥åœ°äº†è§£æ­£åˆ™è¡¨è¾¾å¼ï¼Œä½ å¯ä»¥é˜…è¯»Jan Goyvaertså’ŒSteven Levithanï¼ˆOâ€™Reillyï¼‰çš„ä¼˜ç§€è‘—ä½œ*[æ­£åˆ™è¡¨è¾¾å¼æ‰‹å†Œ](http://shop.oreilly.com/product/0636920023630.do)*ï¼Œæˆ–è€…å‚è€ƒ[åœ¨çº¿å‚è€ƒèµ„æ–™](https://github.com/ziishaned/learn-regex)ã€‚
- en: Extracting a List from a String
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ä»å­—ç¬¦ä¸²ä¸­æå–åˆ—è¡¨
- en: Problem
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: é—®é¢˜
- en: You have a string with several sentences, one of which includes a list of items.
    The list begins with a colon (:), ends with a period (.), and separates each item
    with a comma (,). You want to extract just the list.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ æœ‰ä¸€ä¸ªåŒ…å«å¤šä¸ªå¥å­çš„å­—ç¬¦ä¸²ï¼Œå…¶ä¸­ä¸€ä¸ªå¥å­åŒ…æ‹¬ä¸€ä¸ªé¡¹ç›®åˆ—è¡¨ã€‚åˆ—è¡¨ä»¥å†’å·ï¼ˆ:ï¼‰å¼€å¤´ï¼Œä»¥å¥å·ï¼ˆ.ï¼‰ç»“å°¾ï¼Œå¹¶ç”¨é€—å·ï¼ˆ,ï¼‰åˆ†éš”æ¯ä¸ªé¡¹ç›®ã€‚ä½ æƒ³è¦æå–å‡ºåˆ—è¡¨éƒ¨åˆ†ã€‚
- en: 'Before:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ä¹‹å‰ï¼š
- en: '[PRE37]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'After:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ä¹‹åï¼š
- en: '[PRE38]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Solution
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: è§£å†³æ–¹æ¡ˆ
- en: 'The solution requires two actions: extract the string containing the list of
    items, and then convert this string into a list.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: è§£å†³æ–¹æ¡ˆéœ€è¦ä¸¤ä¸ªæ­¥éª¤ï¼šæå–åŒ…å«é¡¹ç›®åˆ—è¡¨çš„å­—ç¬¦ä¸²ï¼Œç„¶åå°†æ­¤å­—ç¬¦ä¸²è½¬æ¢ä¸ºåˆ—è¡¨ã€‚
- en: 'Use the `String.indexOf()` method twiceâ€”first to locate the colon, and again
    to find the first period following the colon:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨`String.indexOf()`æ–¹æ³•ä¸¤æ¬¡â€”â€”é¦–å…ˆå®šä½å†’å·ï¼Œç„¶åå†æ‰¾åˆ°å†’å·åé¢çš„ç¬¬ä¸€ä¸ªå¥å·ï¼š
- en: '[PRE39]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Using these two locations and the `String.slice()` method, you can extract
    the string you want:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è¿™ä¸¤ä¸ªä½ç½®å’Œ`String.slice()`æ–¹æ³•ï¼Œä½ å¯ä»¥æå–ä½ æƒ³è¦çš„å­—ç¬¦ä¸²ï¼š
- en: '[PRE40]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You could write a loop that uses the `indexOf()` method to look for commas,
    and the `slice()` method to split the `list` string into smaller pieces, one for
    each item. But thereâ€™s an easier approach. You can break the string into an array
    using the `String.split()` method:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¯ä»¥ç¼–å†™ä¸€ä¸ªå¾ªç¯ï¼Œä½¿ç”¨`indexOf()`æ–¹æ³•æŸ¥æ‰¾é€—å·ï¼Œå¹¶ä½¿ç”¨`slice()`æ–¹æ³•å°†`list`å­—ç¬¦ä¸²æ‹†åˆ†ä¸ºè¾ƒå°çš„éƒ¨åˆ†ï¼Œæ¯ä¸ªé¡¹ç›®ä¸€ä¸ªéƒ¨åˆ†ã€‚ä½†æœ‰ä¸€ç§æ›´ç®€å•çš„æ–¹æ³•ã€‚ä½ å¯ä»¥ä½¿ç”¨`String.split()`æ–¹æ³•å°†å­—ç¬¦ä¸²æ‹†åˆ†ä¸ºæ•°ç»„ï¼š
- en: '[PRE41]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: When you call `split()`, you must choose a delimiter. It could be a space, a
    comma, a series of dashes, or something else. The delimiter is used to carve up
    the string into smaller pieces, and it wonâ€™t appear in the results.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ä½ è°ƒç”¨`split()`æ—¶ï¼Œä½ å¿…é¡»é€‰æ‹©ä¸€ä¸ªåˆ†éš”ç¬¦ã€‚å®ƒå¯ä»¥æ˜¯ç©ºæ ¼ã€é€—å·ã€ä¸€ç³»åˆ—ç ´æŠ˜å·æˆ–å…¶ä»–å†…å®¹ã€‚åˆ†éš”ç¬¦ç”¨äºå°†å­—ç¬¦ä¸²åˆ‡åˆ†ä¸ºè¾ƒå°çš„éƒ¨åˆ†ï¼Œå¹¶ä¸”å®ƒä¸ä¼šå‡ºç°åœ¨ç»“æœä¸­ã€‚
- en: Discussion
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: è®¨è®º
- en: The result of splitting the extracted string is an array of list items. However,
    the items may come with artifacts (in this case, an extra leading space in all
    but the first string). Fortunately, itâ€™s easy to clean them up.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ†å‰²æå–çš„å­—ç¬¦ä¸²çš„ç»“æœæ˜¯ä¸€ä¸ªé¡¹ç›®åˆ—è¡¨çš„æ•°ç»„ã€‚ç„¶è€Œï¼Œè¿™äº›é¡¹ç›®å¯èƒ½å¸¦æœ‰ä¸€äº›ä¸å¿…è¦çš„éƒ¨åˆ†ï¼ˆåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œé™¤ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²å¤–ï¼Œæ‰€æœ‰å­—ç¬¦ä¸²éƒ½æœ‰é¢å¤–çš„å‰å¯¼ç©ºæ ¼ï¼‰ã€‚å¹¸è¿çš„æ˜¯ï¼Œæ¸…ç†å®ƒä»¬å¾ˆå®¹æ˜“ã€‚
- en: One obvious approach is to iterate over the array of strings and manually trim
    each one, using the technique described in [â€œRemoving Whitespace from the Beginning
    and End of a Stringâ€](#removing_whitespace). This works, but thereâ€™s an easier
    approach.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªæ˜æ˜¾çš„æ–¹æ³•æ˜¯éå†å­—ç¬¦ä¸²æ•°ç»„å¹¶æ‰‹åŠ¨ä¿®å‰ªæ¯ä¸ªå­—ç¬¦ä¸²ï¼Œä½¿ç”¨[â€œä»å­—ç¬¦ä¸²å¼€å¤´å’Œç»“å°¾åˆ é™¤ç©ºæ ¼â€](#removing_whitespace)ä¸­æè¿°çš„æŠ€æœ¯ã€‚è¿™æ ·åšæ˜¯æœ‰æ•ˆçš„ï¼Œä½†æœ‰ä¸€ç§æ›´ç®€å•çš„æ–¹æ³•ã€‚
- en: 'The trick is to use the `Array.map()`, which runs a piece of code you supply
    on each element in the array. You need just a single line of code to call the
    `trim()` method:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: å…³é”®æ˜¯ä½¿ç”¨`Array.map()`ï¼Œå®ƒä¼šåœ¨æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ ä¸Šè¿è¡Œä½ æä¾›çš„ä»£ç ã€‚ä½ åªéœ€è¦ä¸€è¡Œä»£ç æ¥è°ƒç”¨`trim()`æ–¹æ³•ï¼š
- en: '[PRE42]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If you arenâ€™t familiar with the arrow syntax used to supply the trimming function
    in this example, you can read a more detailed explanation of this technique in
    [â€œUsing Arrow Functionsâ€](ch06.html#arrow_functions).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ å¯¹åœ¨è¿™ä¸ªä¾‹å­ä¸­æä¾›ä¿®å‰ªå‡½æ•°æ‰€ä½¿ç”¨çš„ç®­å¤´è¯­æ³•ä¸ç†Ÿæ‚‰ï¼Œä½ å¯ä»¥åœ¨[â€œä½¿ç”¨ç®­å¤´å‡½æ•°â€](ch06.html#arrow_functions)ä¸­é˜…è¯»æ›´è¯¦ç»†çš„è§£é‡Šã€‚
- en: See Also
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å‚è§
- en: Another way to find matches in a string is to use regular expressions. For example,
    depending on the way your list is structured, you might be able to use a regular
    expression that grabs words that fall in between commas. Regular expressions are
    introduced in [â€œUsing a Regular Expression to Replace Patterns in a Stringâ€](#replacing_patterns_string),
    and using regular expressions to perform a search is covered in [â€œFinding All
    Instances of a Patternâ€](#finding_and_highlighting_all_instances_o).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å­—ç¬¦ä¸²ä¸­æŸ¥æ‰¾åŒ¹é…é¡¹çš„å¦ä¸€ç§æ–¹æ³•æ˜¯ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼ã€‚ä¾‹å¦‚ï¼Œæ ¹æ®åˆ—è¡¨çš„ç»“æ„æ–¹å¼ï¼Œä½ å¯ä»¥ä½¿ç”¨ä¸€ä¸ªæŠ“å–é€—å·ä¹‹é—´çš„å•è¯çš„æ­£åˆ™è¡¨è¾¾å¼ã€‚æ­£åˆ™è¡¨è¾¾å¼åœ¨[â€œä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æ›¿æ¢å­—ç¬¦ä¸²ä¸­çš„æ¨¡å¼â€](#replacing_patterns_string)ä¸­ä»‹ç»ï¼Œä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æ‰§è¡Œæœç´¢åœ¨[â€œæŸ¥æ‰¾æ‰€æœ‰æ¨¡å¼çš„å®ä¾‹â€](#finding_and_highlighting_all_instances_o)ä¸­ä»‹ç»ã€‚
- en: Finding All Instances of a Pattern
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æŸ¥æ‰¾æ‰€æœ‰æ¨¡å¼çš„å®ä¾‹
- en: Problem
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: é—®é¢˜
- en: You want to find all instances of a pattern within a string and iterate over
    them.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ æƒ³è¦åœ¨å­—ç¬¦ä¸²ä¸­æ‰¾åˆ°æ¨¡å¼çš„æ‰€æœ‰å®ä¾‹ï¼Œå¹¶å¯¹å®ƒä»¬è¿›è¡Œè¿­ä»£ã€‚
- en: Solution
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: è§£å†³æ–¹æ¡ˆ
- en: Use a regular expression with the `String.matchAll()` method. The `matchAll()`
    method returns an iterator that lets you loop over all the matches.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨ `String.matchAll()` æ–¹æ³•ä¸æ­£åˆ™è¡¨è¾¾å¼ã€‚`matchAll()` æ–¹æ³•è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼Œè®©ä½ å¯ä»¥éå†æ‰€æœ‰çš„åŒ¹é…é¡¹ã€‚
- en: 'The next example uses a regular expression to find any word that begins with
    *t* and ends with *e*, with any number of characters in between. It uses the template
    literal syntax from [â€œUsing Template Literals for Clearer String Concatenationâ€](#using_template_literals)
    to build a new string with results:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸‹ä¸€ä¸ªç¤ºä¾‹ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æ¥æŸ¥æ‰¾ä»¥ *t* å¼€å¤´å¹¶ä»¥ *e* ç»“å°¾çš„ä»»æ„å•è¯ï¼Œä¸­é—´åŒ…å«ä»»æ„æ•°é‡çš„å­—ç¬¦ã€‚å®ƒä½¿ç”¨æ¥è‡ª [â€œä½¿ç”¨æ¨¡æ¿å­—é¢é‡è¿›è¡Œæ›´æ¸…æ™°çš„å­—ç¬¦ä¸²è¿æ¥â€](#using_template_literals)
    çš„æ¨¡æ¿å­—é¢é‡è¯­æ³•æ„å»ºä¸€ä¸ªæ–°çš„å¸¦æœ‰ç»“æœçš„å­—ç¬¦ä¸²ï¼š
- en: '[PRE43]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here are the results from this code:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ®µä»£ç çš„ç»“æœå¦‚ä¸‹ï¼š
- en: '[PRE44]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Discussion
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: è®¨è®º
- en: When you search with `matchAll()`, each match is an object. As you iterate over
    your matches, you can examine the matched text (`match[0]`), and the index where
    the match was found (`match.index`).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ä½ ä½¿ç”¨ `matchAll()` è¿›è¡Œæœç´¢æ—¶ï¼Œæ¯ä¸ªåŒ¹é…éƒ½æ˜¯ä¸€ä¸ªå¯¹è±¡ã€‚å½“ä½ éå†ä½ çš„åŒ¹é…é¡¹æ—¶ï¼Œä½ å¯ä»¥æ£€æŸ¥åŒ¹é…çš„æ–‡æœ¬ï¼ˆ`match[0]`ï¼‰å’ŒåŒ¹é…è¢«æ‰¾åˆ°çš„ç´¢å¼•ï¼ˆ`match.index`ï¼‰ã€‚
- en: Hereâ€™s something that looks a little peculiar in the current example. Even though
    youâ€™re looking at one result at a time, you use `match[0]` to get the first item
    from an array. This array exists because a regular expression can *capture* multiple
    portions of a match using parentheses. You can then reference these captured sections
    later. For example, imagine you write a regular expression that matches a row
    of information about a person. With capturing, you can easily grab separate pieces
    of information from each match, like that personâ€™s name and birth date. When you
    use this technique with `matchAll()`, the matched substrings are provided as `match[1]`,
    `match[2]`, and so on.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å½“å‰ç¤ºä¾‹ä¸­æœ‰ä¸€äº›çœ‹èµ·æ¥æœ‰ç‚¹å¥‡æ€ªçš„åœ°æ–¹ã€‚å°½ç®¡ä½ ä¸€æ¬¡åªçœ‹ä¸€ä¸ªç»“æœï¼Œä½†ä½ ä½¿ç”¨ `match[0]` æ¥è·å–æ•°ç»„ä¸­çš„ç¬¬ä¸€ä¸ªé¡¹ç›®ã€‚è¿™ä¸ªæ•°ç»„å­˜åœ¨æ˜¯å› ä¸ºæ­£åˆ™è¡¨è¾¾å¼å¯ä»¥ä½¿ç”¨æ‹¬å·*æ•è·*å¤šä¸ªåŒ¹é…éƒ¨åˆ†ã€‚ç¨åä½ å¯ä»¥å¼•ç”¨è¿™äº›æ•è·çš„éƒ¨åˆ†ã€‚ä¾‹å¦‚ï¼Œæƒ³è±¡ä¸€ä¸‹ä½ å†™äº†ä¸€ä¸ªåŒ¹é…æœ‰å…³æŸäººä¿¡æ¯è¡Œçš„æ­£åˆ™è¡¨è¾¾å¼ã€‚é€šè¿‡æ•è·ï¼Œä½ å¯ä»¥è½»æ¾åœ°ä»æ¯ä¸ªåŒ¹é…ä¸­æŠ“å–å•ç‹¬çš„ä¿¡æ¯ç‰‡æ®µï¼Œæ¯”å¦‚é‚£ä¸ªäººçš„å§“åå’Œå‡ºç”Ÿæ—¥æœŸã€‚å½“ä½ å°†è¿™ä¸ªæŠ€æœ¯ä¸
    `matchAll()` ç»“åˆä½¿ç”¨æ—¶ï¼ŒåŒ¹é…çš„å­å­—ç¬¦ä¸²ä¼šåˆ†åˆ«ä½œä¸º `match[1]`ã€`match[2]` ç­‰æä¾›ã€‚
- en: 'And if you donâ€™t want to iterate over the results right away, you can dump
    everything into an array using the spread operator:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ ä¸æƒ³ç«‹å³éå†ç»“æœï¼Œä½ å¯ä»¥ä½¿ç”¨æ‰©å±•è¿ç®—ç¬¦å°†æ‰€æœ‰å†…å®¹è½¬å‚¨åˆ°ä¸€ä¸ªæ•°ç»„ä¸­ï¼š
- en: '[PRE45]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now you can use `foreach` to loop through your `matches` array at another time.
    But remember, `matches` isnâ€™t just an array of matching text. Itâ€™s an array of
    match *objects*. As you saw in the original example, each match object has a position
    (`match.index`) and an array with one or more matched groups of text (starting
    with `match[0]`).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ä½ å¯ä»¥ä½¿ç”¨ `foreach` åœ¨å¦ä¸€ä¸ªæ—¶é—´å¾ªç¯éå†ä½ çš„ `matches` æ•°ç»„ã€‚ä½†è¯·è®°ä½ï¼Œ`matches` ä¸ä»…ä»…æ˜¯ä¸€ä¸ªåŒ¹é…æ–‡æœ¬çš„æ•°ç»„ã€‚å®ƒæ˜¯ä¸€ä¸ªåŒ¹é…*å¯¹è±¡*çš„æ•°ç»„ã€‚æ­£å¦‚ä½ åœ¨åŸå§‹ç¤ºä¾‹ä¸­çœ‹åˆ°çš„ï¼Œæ¯ä¸ªåŒ¹é…å¯¹è±¡éƒ½æœ‰ä¸€ä¸ªä½ç½®ï¼ˆ`match.index`ï¼‰å’Œä¸€ä¸ªåŒ…å«ä¸€ä¸ªæˆ–å¤šä¸ªåŒ¹é…æ–‡æœ¬ç»„çš„æ•°ç»„ï¼ˆä»¥
    `match[0]` å¼€å¤´ï¼‰ã€‚
- en: 'Extra: Highlighting Matches'
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: è¡¥å……ï¼šé«˜äº®åŒ¹é…é¡¹
- en: Letâ€™s take a look at a more detailed example that shows how you might find and
    highlight text matches on a web page. [FigureÂ 2-1](#application_finding_and_highlighting_all)
    shows the application in action on William Wordsworthâ€™s poem, â€œThe Kitten and
    the Falling Leaves.â€
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬çœ‹ä¸€ä¸ªæ›´è¯¦ç»†çš„ä¾‹å­ï¼Œå±•ç¤ºå¦‚ä½•åœ¨ç½‘é¡µä¸ŠæŸ¥æ‰¾å¹¶é«˜äº®æ–‡æœ¬åŒ¹é…ã€‚[å›¾Â 2-1](#application_finding_and_highlighting_all)
    å±•ç¤ºäº†è¯¥åº”ç”¨åœ¨å¨å»‰Â·åå…¹åæ–¯çš„è¯—æ­Œã€Šå°çŒ«å’Œè½å¶ã€‹ä¸Šçš„è¿è¡Œæƒ…å†µã€‚
- en: '![jsc3 0201](assets/jsc3_0201.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![jsc3 0201](assets/jsc3_0201.png)'
- en: Figure 2-1\. Application finding and highlighting all matched strings
  id: totrans-306
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: å›¾ 2-1\. åº”ç”¨ç¨‹åºæŸ¥æ‰¾å’Œçªå‡ºæ˜¾ç¤ºæ‰€æœ‰åŒ¹é…çš„å­—ç¬¦ä¸²
- en: This page has a `textarea` and an input text box for entering both a search
    string and a regular expression. The pattern is used to create a `RegExp` object,
    which is then applied against the text in the `textarea` using `matchAll()`, just
    as in the previous (much shorter) example.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: è¯¥é¡µé¢æœ‰ä¸€ä¸ª `textarea` å’Œä¸€ä¸ªè¾“å…¥æ¡†ï¼Œç”¨äºè¾“å…¥æœç´¢å­—ç¬¦ä¸²å’Œæ­£åˆ™è¡¨è¾¾å¼ã€‚è¯¥æ¨¡å¼ç”¨äºåˆ›å»ºä¸€ä¸ª `RegExp` å¯¹è±¡ï¼Œç„¶ååƒå‰é¢ï¼ˆæ›´çŸ­çš„ï¼‰ç¤ºä¾‹ä¸€æ ·ï¼Œåº”ç”¨äº
    `textarea` ä¸­çš„æ–‡æœ¬ï¼Œä½¿ç”¨ `matchAll()`ã€‚
- en: As the code examines the matches, it creates a string, consisting of both the
    unmatched text and the matched text. The matched text is surrounded by a `<span>`
    element, with a CSS class used to highlight the text. The resulting string is
    then inserted into the page, using the `innerHTML` property of a `<div>` element
    (see [ExampleÂ 2-1](#highlight_all_matches)).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ä»£ç æ£€æŸ¥åŒ¹é…é¡¹æ—¶ï¼Œå®ƒåˆ›å»ºä¸€ä¸ªå­—ç¬¦ä¸²ï¼ŒåŒ…å«æœªåŒ¹é…çš„æ–‡æœ¬å’ŒåŒ¹é…çš„æ–‡æœ¬ã€‚åŒ¹é…çš„æ–‡æœ¬è¢«åŒ…å›´åœ¨ä¸€ä¸ª `<span>` å…ƒç´ ä¸­ï¼Œå¹¶ä½¿ç”¨ CSS ç±»æ¥çªå‡ºæ˜¾ç¤ºæ–‡æœ¬ã€‚ç„¶åå°†ç”Ÿæˆçš„å­—ç¬¦ä¸²æ’å…¥åˆ°é¡µé¢ä¸­ï¼Œä½¿ç”¨
    `<div>` å…ƒç´ çš„ `innerHTML` å±æ€§ï¼ˆå‚è§ [ç¤ºä¾‹Â 2-1](#highlight_all_matches)ï¼‰ã€‚
- en: Example 2-1\. Highlight all matches in a text string
  id: totrans-309
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ç¤ºä¾‹ 2-1\. åœ¨æ–‡æœ¬å­—ç¬¦ä¸²ä¸­çªå‡ºæ˜¾ç¤ºæ‰€æœ‰åŒ¹é…é¡¹
- en: '[PRE46]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In [FigureÂ 2-1](#application_finding_and_highlighting_all) this page performs
    a search with this regular expression:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨[å›¾2-1](#application_finding_and_highlighting_all)çš„é¡µé¢ä¸­ï¼Œä½¿ç”¨ä»¥ä¸‹æ­£åˆ™è¡¨è¾¾å¼è¿›è¡Œæœç´¢ï¼š
- en: '[PRE47]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The bar (`|`) is a conditional test, and will match a word based on the value
    on either side of the bar. So *leaf* matches, as well as *leaves*, but not *leap*.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: ç«–çº¿ï¼ˆ`|`ï¼‰æ˜¯æ¡ä»¶æµ‹è¯•ï¼Œå°†åŒ¹é…åŸºäºç«–çº¿ä¸¤ä¾§çš„å€¼çš„å•è¯ã€‚æ‰€ä»¥*leaf*ä¼šåŒ¹é…ï¼Œ*leaves*ä¹Ÿä¼šåŒ¹é…ï¼Œä½†*leap*ä¸ä¼šåŒ¹é…ã€‚
- en: Removing Whitespace from the Beginning and End of a String
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: å»é™¤å­—ç¬¦ä¸²å¼€å¤´å’Œç»“å°¾çš„ç©ºç™½å­—ç¬¦
- en: Problem
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: é—®é¢˜
- en: You want to trim extra spaces that pad the beginning or end of a string.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ æƒ³è¦å»é™¤å¡«å……åœ¨å­—ç¬¦ä¸²å¼€å¤´æˆ–ç»“å°¾çš„é¢å¤–ç©ºæ ¼ã€‚
- en: Solution
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: è§£å†³æ–¹æ¡ˆ
- en: Use the `String.trim()` method. It removes all whitespace from both ends of
    a string, including spaces, tabs, no-break spaces, and line terminator characters.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨`String.trim()`æ–¹æ³•ã€‚å®ƒä¼šç§»é™¤å­—ç¬¦ä¸²ä¸¤ç«¯çš„æ‰€æœ‰ç©ºç™½å­—ç¬¦ï¼ŒåŒ…æ‹¬ç©ºæ ¼ã€åˆ¶è¡¨ç¬¦ã€ä¸é—´æ–­ç©ºæ ¼å’Œè¡Œç»ˆæ­¢ç¬¦ã€‚
- en: '[PRE48]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Discussion
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: è®¨è®º
- en: The `trim()` method is straightforward, but not customizable. If you have even
    slightly more complex string alteration requirements, youâ€™ll need to use a regular
    expression.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`trim()`æ–¹æ³•å¾ˆç®€å•ï¼Œä½†ä¸å¯å®šåˆ¶ã€‚å¦‚æœä½ æœ‰ç¨å¾®å¤æ‚çš„å­—ç¬¦ä¸²ä¿®æ”¹éœ€æ±‚ï¼Œä½ å°†éœ€è¦ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼ã€‚'
- en: 'One common problem that thwarts the `trim()` method is removing excess whitespace
    *inside* a string. The `replaceAll()` method can accomplish this task with relative
    ease using a regular expression with the `\s` character to match whitespace:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªå¸¸è§çš„é—®é¢˜æ˜¯`trim()`æ–¹æ³•æ— æ³•ç§»é™¤å­—ç¬¦ä¸²*å†…éƒ¨*çš„å¤šä½™ç©ºæ ¼ã€‚`replaceAll()`æ–¹æ³•å¯ä»¥ä½¿ç”¨å¸¦æœ‰`\s`å­—ç¬¦çš„æ­£åˆ™è¡¨è¾¾å¼ç›¸å¯¹è½»æ¾åœ°å®Œæˆè¿™ä¸ªä»»åŠ¡ï¼š
- en: '[PRE49]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Of course, unwanted artifacts are possible even after processing bad data with
    extra spaces. For example, if there are multiple spaces where you donâ€™t want *any*
    space ('is long , Â Â Â with') youâ€™ll still be left with a single space after you
    run the replacement ('is long , with'). The only way to deal with issues like
    these is to manually step through each match, as demonstrated in [â€œFinding All
    Instances of a Patternâ€](#finding_and_highlighting_all_instances_o).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç„¶ï¼Œå³ä½¿åœ¨å¤„ç†å¸¦æœ‰é¢å¤–ç©ºæ ¼çš„åæ•°æ®ä¹‹åï¼Œä»ç„¶å¯èƒ½å‡ºç°ä¸éœ€è¦çš„æ®‹ç•™ç‰©ã€‚ä¾‹å¦‚ï¼Œå¦‚æœåœ¨ä½ ä¸å¸Œæœ›æœ‰ä»»ä½•ç©ºæ ¼çš„åœ°æ–¹æœ‰å¤šä¸ªç©ºæ ¼ï¼ˆ'is long , Â Â Â with'ï¼‰ï¼Œåœ¨æ›¿æ¢åä»ç„¶ä¼šç•™ä¸‹ä¸€ä¸ªç©ºæ ¼ï¼ˆ'is
    long , with'ï¼‰ã€‚å¤„ç†è¿™ç±»é—®é¢˜çš„å”¯ä¸€æ–¹æ³•æ˜¯æ‰‹åŠ¨é€ä¸ªåŒ¹é…ï¼Œæ­£å¦‚[â€œæŸ¥æ‰¾æ¨¡å¼çš„æ‰€æœ‰å®ä¾‹â€](#finding_and_highlighting_all_instances_o)æ‰€ç¤ºã€‚
- en: See Also
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å‚è§
- en: Regular expression syntax is described in [â€œUsing a Regular Expression to Replace
    Patterns in a Stringâ€](#replacing_patterns_string).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£åˆ™è¡¨è¾¾å¼è¯­æ³•åœ¨[â€œä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æ›¿æ¢å­—ç¬¦ä¸²ä¸­çš„æ¨¡å¼â€](#replacing_patterns_string)ä¸­æè¿°ã€‚
- en: Converting the First Letter of a String to Uppercase
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: å°†å­—ç¬¦ä¸²çš„ç¬¬ä¸€ä¸ªå­—æ¯è½¬æ¢ä¸ºå¤§å†™
- en: Problem
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: é—®é¢˜
- en: You want to make the first letter of a string an uppercase letter, without changing
    the rest of the string.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ æƒ³å°†å­—ç¬¦ä¸²çš„ç¬¬ä¸€ä¸ªå­—æ¯å˜æˆå¤§å†™ï¼Œä½†ä¸æ”¹å˜å­—ç¬¦ä¸²çš„å…¶ä½™éƒ¨åˆ†ã€‚
- en: Solution
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: è§£å†³æ–¹æ¡ˆ
- en: 'Split off the first letter and capitalize it with `String.toUpper()`. Join
    the uppercase letter to the remainder of the string, which you can get with `String.slice()`:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ†ç¦»ç¬¬ä¸€ä¸ªå­—æ¯å¹¶ä½¿ç”¨`String.toUpper()`å°†å…¶å¤§å†™åŒ–ã€‚ç„¶åå°†å¤§å†™å­—æ¯ä¸å­—ç¬¦ä¸²çš„å…¶ä½™éƒ¨åˆ†è¿æ¥èµ·æ¥ï¼Œä½ å¯ä»¥ä½¿ç”¨`String.slice()`æ¥è·å–å­—ç¬¦ä¸²çš„å‰©ä½™éƒ¨åˆ†ï¼š
- en: '[PRE50]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Discussion
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: è®¨è®º
- en: To get a single character from a string, you can use the stringâ€™s indexer, as
    in `original[0]`. This gets the character in position 0 (which is the first character).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: è¦ä»å­—ç¬¦ä¸²ä¸­è·å–å•ä¸ªå­—ç¬¦ï¼Œä½ å¯ä»¥ä½¿ç”¨å­—ç¬¦ä¸²çš„ç´¢å¼•å™¨ï¼Œå¦‚`original[0]`ã€‚è¿™ä¼šè·å–ä½ç½®0ï¼ˆå³ç¬¬ä¸€ä¸ªå­—ç¬¦ï¼‰çš„å­—ç¬¦ã€‚
- en: '[PRE51]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Alternatively, you can use the `String.charAt()` method, which works in exactly
    the same way.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ–è€…ï¼Œä½ å¯ä»¥ä½¿ç”¨`String.charAt()`æ–¹æ³•ï¼Œå®ƒçš„å·¥ä½œæ–¹å¼å®Œå…¨ç›¸åŒã€‚
- en: To get a fragment of a string, you use the `slice()` method. When calling `slice()`,
    you must always specify the index where you want to start your string extraction.
    For example, `text.slice(5)` starts at index position 5, continues to the end
    of the string, and copies that section of the text into a new string.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: è¦è·å–å­—ç¬¦ä¸²çš„ç‰‡æ®µï¼Œä½ å¯ä»¥ä½¿ç”¨`slice()`æ–¹æ³•ã€‚åœ¨è°ƒç”¨`slice()`æ—¶ï¼Œä½ å¿…é¡»å§‹ç»ˆæŒ‡å®šä½ å¸Œæœ›ä»å“ªé‡Œå¼€å§‹æå–å­—ç¬¦ä¸²ã€‚ä¾‹å¦‚ï¼Œ`text.slice(5)`ä»ç´¢å¼•ä½ç½®5å¼€å§‹ï¼Œä¸€ç›´åˆ°å­—ç¬¦ä¸²çš„æœ«å°¾ï¼Œå¹¶å°†è¯¥éƒ¨åˆ†æ–‡æœ¬å¤åˆ¶åˆ°ä¸€ä¸ªæ–°å­—ç¬¦ä¸²ä¸­ã€‚
- en: 'If you donâ€™t want `slice()` to continue to the end of the string, you can supply
    an optional second parameter with the index where the string copying should stop:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ ä¸å¸Œæœ›`slice()`ç»§ç»­åˆ°å­—ç¬¦ä¸²çš„æœ«å°¾ï¼Œä½ å¯ä»¥æä¾›ä¸€ä¸ªå¯é€‰çš„ç¬¬äºŒä¸ªå‚æ•°ï¼ŒæŒ‡å®šå­—ç¬¦ä¸²å¤åˆ¶åº”è¯¥åœæ­¢çš„ç´¢å¼•ä½ç½®ï¼š
- en: '[PRE52]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The example in this recipe changed a single letter to uppercase. If you want
    to change an entire sentence to use initial capitals (called *title case*), itâ€™s
    a more complex problem. You might decide to split the string into separate words,
    trim each word, and then join the results, using a variation of the technique
    from [â€œExtracting a List from a Stringâ€](#extracting_a_list).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬ç¤ºä¾‹ä¸­çš„ç¤ºä¾‹æ›´æ”¹äº†ä¸€ä¸ªå­—æ¯ä¸ºå¤§å†™ã€‚å¦‚æœè¦å°†æ•´ä¸ªå¥å­æ›´æ”¹ä¸ºä½¿ç”¨é¦–å­—æ¯å¤§å†™ï¼ˆç§°ä¸º*æ ‡é¢˜å¤§å°å†™*ï¼‰ï¼Œè¿™æ˜¯ä¸€ä¸ªæ›´å¤æ‚çš„é—®é¢˜ã€‚æ‚¨å¯èƒ½å†³å®šå°†å­—ç¬¦ä¸²æ‹†åˆ†ä¸ºå•ç‹¬çš„å•è¯ï¼Œä¿®å‰ªæ¯ä¸ªå•è¯ï¼Œç„¶åè¿æ¥ç»“æœï¼Œä½¿ç”¨ä»
    [â€œä»å­—ç¬¦ä¸²ä¸­æå–åˆ—è¡¨â€](#extracting_a_list) æŠ€æœ¯çš„å˜ä½“ã€‚
- en: See Also
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å¦è¯·å‚é˜…
- en: You can use `slice()` in conjunction with `indexOf()` to find the location of
    specific bits of text that you want to extract. For an example, see [â€œExtracting
    a List from a Stringâ€](#extracting_a_list).
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: æ‚¨å¯ä»¥å°† `slice()` ä¸ `indexOf()` ç»“åˆä½¿ç”¨ï¼Œä»¥æ‰¾åˆ°è¦æå–çš„ç‰¹å®šæ–‡æœ¬ä½çš„ä½ç½®ã€‚ä¾‹å¦‚ï¼Œè¯·å‚è§ [â€œä»å­—ç¬¦ä¸²ä¸­æå–åˆ—è¡¨â€](#extracting_a_list)ã€‚
- en: Validating an Email Address
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: éªŒè¯ç”µå­é‚®ä»¶åœ°å€
- en: Problem
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: é—®é¢˜
- en: You want to catch and reject common errors in email addresses.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: æ‚¨å¸Œæœ›æ•æ‰å’Œæ‹’ç»ç”µå­é‚®ä»¶åœ°å€ä¸­çš„å¸¸è§é”™è¯¯ã€‚
- en: Solution
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: è§£å†³æ–¹æ¡ˆ
- en: Regular expressions are useful for more than searching. You can also use them
    to validate strings by testing if a string matches a given pattern. In JavaScript,
    you test if a string matches a regular expression using the `RegEx.test()` method.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£åˆ™è¡¨è¾¾å¼ä¸ä»…å¯¹æœç´¢æœ‰ç”¨ã€‚æ‚¨è¿˜å¯ä»¥é€šè¿‡æµ‹è¯•å­—ç¬¦ä¸²æ˜¯å¦ä¸ç»™å®šæ¨¡å¼åŒ¹é…æ¥éªŒè¯å­—ç¬¦ä¸²ã€‚åœ¨ JavaScript ä¸­ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨ `RegEx.test()`
    æ–¹æ³•æµ‹è¯•å­—ç¬¦ä¸²æ˜¯å¦ä¸æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…ã€‚
- en: '[PRE53]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Discussion
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: è®¨è®º
- en: Programmers use many different regular expressions to validate email addresses.
    The best ones capture obvious mistakes and spurious values, but donâ€™t get too
    complex. Overly strict regular expressions have, from time to time, inadvertently
    disallowed valid mail addresses. And even if an email address checks out with
    the most stringent test possible, thereâ€™s no way to know if itâ€™s truly *correct*
    (at least not without sending an email message and requesting a confirmation).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: ç¨‹åºå‘˜ä½¿ç”¨è®¸å¤šä¸åŒçš„æ­£åˆ™è¡¨è¾¾å¼æ¥éªŒè¯ç”µå­é‚®ä»¶åœ°å€ã€‚æœ€å¥½çš„æ­£åˆ™è¡¨è¾¾å¼æ•è·æ˜æ˜¾çš„é”™è¯¯å’Œè™šå‡å€¼ï¼Œä½†ä¸è¦è¿‡äºå¤æ‚ã€‚è¿‡äºä¸¥æ ¼çš„æ­£åˆ™è¡¨è¾¾å¼æœ‰æ—¶ä¼šæ— æ„ä¸­ç¦æ­¢æœ‰æ•ˆçš„é‚®ä»¶åœ°å€ã€‚å³ä½¿ç”µå­é‚®ä»¶åœ°å€é€šè¿‡äº†æœ€ä¸¥æ ¼çš„æµ‹è¯•ï¼Œä¹Ÿæ²¡æœ‰åŠæ³•çŸ¥é“å®ƒæ˜¯å¦*æ­£ç¡®*ï¼ˆè‡³å°‘ä¸å‘é€ç”µå­é‚®ä»¶æ¶ˆæ¯å¹¶è¯·æ±‚ç¡®è®¤ï¼‰ã€‚
- en: The regular expression in this recipe requires that an email has a sequence
    of at least one nonwhitespace character, followed by the @ character, followed
    by one or more nonwhitespace characters, followed by a period (.), followed again
    by one or more nonwhitespace characters. It catches obviously invalid emails like
    *tomkhangmail.com* or *tomkhan@gmail*.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬ç¤ºä¾‹ä¸­çš„æ­£åˆ™è¡¨è¾¾å¼è¦æ±‚ç”µå­é‚®ä»¶åœ°å€ä»¥è‡³å°‘ä¸€ä¸ªéç©ºç™½å­—ç¬¦å¼€å¤´ï¼Œåè·Ÿ @ å­—ç¬¦ï¼Œç„¶åæ˜¯ä¸€ä¸ªæˆ–å¤šä¸ªéç©ºç™½å­—ç¬¦ï¼Œç„¶åæ˜¯ä¸€ä¸ªå¥ç‚¹ï¼ˆ.ï¼‰ï¼Œå†è·Ÿç€ä¸€ä¸ªæˆ–å¤šä¸ªéç©ºç™½å­—ç¬¦ã€‚å®ƒæ•è·äº†æ˜æ˜¾æ— æ•ˆçš„ç”µå­é‚®ä»¶åœ°å€ï¼Œå¦‚
    *tomkhangmail.com* æˆ– *tomkhan@gmail*ã€‚
- en: Often, you wonâ€™t write a regular expression for validation yourself. Instead,
    youâ€™ll use a prewritten expression that matches your data. For a massive collection
    of regular expression resources, visit the [Awesome Regex page](https://github.com/aloisdg/awesome-regex).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: é€šå¸¸ï¼Œæ‚¨ä¸ä¼šè‡ªå·±ç¼–å†™ç”¨äºéªŒè¯çš„æ­£åˆ™è¡¨è¾¾å¼ã€‚ç›¸åï¼Œæ‚¨å°†ä½¿ç”¨åŒ¹é…æ‚¨æ•°æ®çš„é¢„å®šä¹‰è¡¨è¾¾å¼ã€‚æœ‰å…³å¤§é‡æ­£åˆ™è¡¨è¾¾å¼èµ„æºï¼Œè¯·è®¿é—® [Awesome Regex é¡µé¢](https://github.com/aloisdg/awesome-regex)ã€‚
- en: See Also
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å¦è¯·å‚é˜…
- en: Regular expression syntax is described in [â€œUsing a Regular Expression to Replace
    Patterns in a Stringâ€](#replacing_patterns_string).
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£åˆ™è¡¨è¾¾å¼è¯­æ³•åœ¨ [â€œä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æ›¿æ¢å­—ç¬¦ä¸²ä¸­çš„æ¨¡å¼â€](#replacing_patterns_string) ä¸­æœ‰æè¿°ã€‚
- en: ^([1](ch02.html#idm45475190104344-marker)) In JavaScript, a *prototype* is a
    template for a specific type of object. In a more traditional object-oriented
    language, we would say that objects with the same prototype are instances of the
    same class. [ChapterÂ 8](ch08.html#ch08) has many recipes that explore prototypes
    in JavaScript.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch02.html#idm45475190104344-marker)) åœ¨ JavaScript ä¸­ï¼Œ*åŸå‹*æ˜¯ç‰¹å®šç±»å‹å¯¹è±¡çš„æ¨¡æ¿ã€‚åœ¨æ›´ä¼ ç»Ÿçš„é¢å‘å¯¹è±¡è¯­è¨€ä¸­ï¼Œæˆ‘ä»¬ä¼šè¯´å…·æœ‰ç›¸åŒåŸå‹çš„å¯¹è±¡æ˜¯åŒä¸€ç±»çš„å®ä¾‹ã€‚ã€Šç¬¬
    8 ç« ã€‹æœ‰å¾ˆå¤šç¤ºä¾‹ï¼Œæ¢è®¨äº† JavaScript ä¸­çš„åŸå‹ã€‚
