- en: Chapter 2\. Strings and Regular Expressions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章\. 字符串和正则表达式
- en: 'Here’s a trivia question for your next JavaScript party: how many data types
    are there in the world’s most popular language?'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个关于你下一个 JavaScript 聚会的趣味问题：世界上最流行的语言有多少种数据类型？
- en: 'The answer is *eight*, but they might not be what you expect. JavaScript’s
    eight data types are:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是 *eight*，但它们可能不是你所期望的。JavaScript 的八种数据类型包括：
- en: '`Number`'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Number`'
- en: '`String`'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String`'
- en: '`Boolean`'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boolean`'
- en: '`BigInt` (for very large integers)'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BigInt`（用于非常大的整数）'
- en: '`Symbol` (for unique identifiers)'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Symbol`（用于唯一标识符）'
- en: '`Object` (the root of every other JavaScript type)'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object`（其他每种 JavaScript 类型的根）'
- en: '`undefined` (a variable that hasn’t been assigned a value)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`undefined`（未分配值的变量）'
- en: '`null` (a missing object)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`null`（丢失的对象）'
- en: The recipes in this book feature all of these ingredients. In this chapter,
    you’ll turn your focus to the text-manipulating power of strings.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的配方涵盖了所有这些要点。在本章中，你将专注于字符串的文本处理能力。
- en: Checking for an Existing, Nonempty String
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查是否存在非空字符串
- en: Problem
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to verify that a variable is defined, is a string, and is not empty
    before you use it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用之前，你需要验证变量是否已定义、是否为字符串以及是否不为空。
- en: Solution
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Before you start working with a string, you often need to validate that it’s
    safe to use. When you do, there are different questions you might ask.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始处理字符串之前，通常需要验证其是否安全使用。在这样做时，可能会有不同的问题。
- en: 'If you want to make sure that your variable is a string (not just a variable
    that can be *converted* to a string), you use this test:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要确保变量是字符串（而不仅仅是可*转换*为字符串的变量），则使用此测试：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you want to check that you have a nonempty string (not the zero-length string
    `''''`), you can tighten your verification like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想检查是否有非空字符串（而不是零长度字符串 `''`），你可以像这样收紧你的验证：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Optionally, you may want to reject strings that are made up of whitespace only,
    in which case you can use the `String.trim()` method:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，你可能希望拒绝仅由空白字符组成的字符串，在这种情况下，可以使用 `String.trim()` 方法：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The order of your conditions is important. JavaScript uses *short-circuit evaluation*.
    That means it will only evaluate the second condition (the length check) if the
    first condition (the type check) succeeds. This is important because the length
    check will fail if `unknownVariable` is a different type of variable, like a number.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 条件的顺序很重要。JavaScript 使用 *短路求值*。这意味着只有在第一个条件（类型检查）成功时，它才会评估第二个条件（长度检查）。这很重要，因为如果
    `unknownVariable` 是不同类型的变量（如数字），长度检查将失败。
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There’s a potential gap when using the `typeof` operator. It’s possible to
    circumvent the string test by using a `String` object instead of a string literal:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `typeof` 运算符时存在潜在漏洞。可以通过使用 `String` 对象而不是字符串字面量来绕过字符串测试：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now the `typeof` operator will return `*object*` instead of `*string*`, because
    the string primitive is wrapped in a `String` object.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`typeof` 运算符将返回 `*object*` 而不是 `*string*`，因为字符串原始值被包装在 `String` 对象中。
- en: 'In modern JavaScript, creating a `String` object instance is discouraged for
    reasons like this. You’re better off removing this practice from any code you
    encounter than coding around it. However, if you need to accommodate possible
    `String` objects, you can use a more complex test like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代 JavaScript 中，不建议创建 `String` 对象实例，原因如上所述。最好从任何你遇到的代码中删除这种做法，而不是在其周围编码。然而，如果需要适应可能的
    `String` 对象，可以使用更复杂的测试，如下所示：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This code checks that one of two conditions are met: either you have a string
    primitive or an object that has the same prototype as `String`.^([1](ch02.html#idm45475190104344))'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码检查是否满足以下两个条件之一：要么是字符串原始值，要么是具有与 `String` 相同原型的对象。^([1](ch02.html#idm45475190104344))
- en: Discussion
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'The type-checking test in this recipe uses the `typeof` operator. It returns
    the type name of the variable as a lowercase string. The possible values are:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方中的类型检查测试使用 `typeof` 运算符。它返回变量的类型名称作为小写字符串。可能的值包括：
- en: '`undefined`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`undefined`'
- en: '`boolean`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean`'
- en: '`number`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`number`'
- en: '`bigint`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bigint`'
- en: '`string`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string`'
- en: '`symbol`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`symbol`'
- en: '`function`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`function`'
- en: '`object`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object`'
- en: These values match the list at the beginning of this chapter, but with two small
    differences. First, there’s no `*null*`, because null values return the string
    `*object*` instead. (This is considered a bug by many, but it’s kept for historical
    reasons.) Second, there’s an added `*function*` data type, even though a function
    is technically a special case of object.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值与本章开头的列表匹配，但有两个小差异。首先，没有`*null*`，因为null值返回字符串`*object*`而不是。这被许多人认为是一个错误，但出于历史原因而保留。其次，添加了`*function*`数据类型，尽管函数在技术上是对象的特例。
- en: Occasionally, you’ll see the following old-fashioned string-validation technique.
    It doesn’t require a variable to actually *be* a string. It simply verifies that
    your value can be treated as a string, and that it isn’t the empty string.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔，您会看到以下老式的字符串验证技术。它不要求变量实际上*是*一个字符串。它只是验证您的值是否可以被视为字符串，并且它不是空字符串。
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This works because `null` values, `undefined` values, and empty strings (`''`)
    are all *falsy* in JavaScript. If you evaluate any of them in a conditional expression,
    they are treated as false.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为在JavaScript中，`null`值、`undefined`值和空字符串（`''`）都被视为*假值*。如果在条件表达式中评估它们中的任何一个，它们将被视为假。
- en: This approach has a potential blindspot with the number 0, which always evaluates
    to `false`, skipping the `if` block. To be safe, it’s better to explicitly convert
    your numeric variables to strings, as described in [“Converting a Numeric Value
    to a Formatted String”](#converting_number_to_string).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在处理数字0时存在潜在的盲点，因为0始终评估为`false`，从而跳过`if`块。为了安全起见，最好显式将您的数字变量转换为字符串，如[“将数值转换为格式化字符串”](#converting_number_to_string)中所述。
- en: Converting a Numeric Value to a Formatted String
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数值转换为格式化字符串
- en: Problem
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to create a string representation of a number.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要创建一个数字的字符串表示。
- en: Solution
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'JavaScript is a loosely typed language, and it will automatically convert any
    value to a string when it needs to—for example, if you compare a number to a string
    or join a number to a string with the `+` operator. In fact, one of the easiest
    tricks that JavaScript developers use to convert numbers to strings is to simply
    concatenate an empty string on the beginning or end of the value:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是一种弱类型语言，当需要时会自动将任何值转换为字符串，例如，如果您将数字与字符串比较或使用`+`运算符将数字与字符串连接起来。事实上，JavaScript开发人员用来将数字转换为字符串的最简单的技巧之一就是简单地在值的开头或结尾连接一个空字符串：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'However, modern practice favors *explicit* variable conversions. Every JavaScript
    object has a built-in `toString()` method, including the `Number` object. You
    can call it like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现代做法更偏向于*显式*变量转换。每个JavaScript对象都有一个内置的`toString()`方法，包括`Number`对象。您可以像这样调用它：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Often, you need to customize the string representation of your number. For example,
    you might want a fixed number of decimal places (like 30.00 instead of 30). This
    might also involve rounding (for example, from 30.009 to 30.01).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 经常需要自定义数字的字符串表示。例如，您可能希望固定小数位数（如30.00而不是30）。这可能还涉及到四舍五入（例如，从30.009到30.01）。
- en: 'JavaScript has three utility methods built into the number data type that can
    help you. All of them create string representations of a number:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript有三个内置于数字数据类型中的实用方法，可以帮助您。它们都创建数字的字符串表示：
- en: '`Number.toFixed()`'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`Number.toFixed()`'
- en: Lets you specify the number of digits to keep after the decimal point.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 允许您指定小数点后要保留的位数。
- en: '`Number.toExponential()`'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`Number.toExponential()`'
- en: Uses scientific notation, and lets you specify the number of digits to show
    after the decimal point.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用科学计数法，并允许您指定小数点后要显示的位数。
- en: '`Number.toPrecision()`'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`Number.toPrecision()`'
- en: Lets you specify the number of significant digits to keep, without considering
    how large or small your number is.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 允许您指定要保留的有效数字位数，而不考虑您的数字是多么大或小。
- en: Note
  id: totrans-62
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you aren’t familiar with *significant digits*, it’s a scientific concept
    used to make sure calculations keep an appropriate degree of precision. It also
    helps to make sure a measurement is not represented in a way that implies more
    precision than it actually has. (For example, your average weight may be 162.5
    pounds, but it’s probably not meaningful to say it’s 162.503018 pounds, nor is
    it helpful to round it to 200 pounds.) Wikipedia explains the [concept in detail](https://oreil.ly/vrrPr).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不熟悉*有效数字*，这是一个科学概念，用于确保计算具有适当的精度。它还有助于确保测量结果不会以比实际精度更高的方式表示。（例如，你的平均体重可能是162.5磅，但说它是162.503018磅可能并没有实际意义，将其四舍五入到200磅也没有帮助。）维基百科详细解释了[这个概念](https://oreil.ly/vrrPr)。
- en: 'Here’s an example that demonstrates all three string conversion methods:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例，演示了所有三种字符串转换方法：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you want to apply formatting like commas, a currency symbol, or some other
    locale-specific details, you need the help of the `Intl.NumberFormat` object.
    Once you create an instance and configure it appropriately, you can use the `Intl.NumberFormat`
    to perform your number-to-string conversion.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想应用逗号、货币符号或其他区域特定细节的格式化，你需要`Intl.NumberFormat`对象的帮助。一旦你创建了一个实例并适当配置它，你可以使用`Intl.NumberFormat`执行你的数字转字符串转换。
- en: 'For example, to format a number as a US currency string, you use code like
    this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要将一个数字格式化为美元货币字符串，你可以使用以下代码：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Discussion
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: A *locale* represents a specific geographic or cultural region. Locale identifiers
    combine a language code and a region string. The locale *en-US* represents the
    English language in the United States of America. The local *en_CA* is English
    in Canada, *fr-CA* is French in Canada, *ja-JP* is Japanese in Japan, and so on.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*Locale*代表特定的地理或文化区域。语言标识符结合了语言代码和区域字符串。*en-US*代表美国的英语，*en_CA*是加拿大的英语，*fr-CA*是加拿大的法语，*ja-JP*是日本的日语，等等。'
- en: 'Depending on your locale, there are some standard number formatting rules that
    apply. For example, numbers in English language regions often use commas to separate
    thousands (as in *1,200.00*), while commas in French language regions often use
    commas instead of a decimal point (as in *1 200,00*). If you create a `Intl.NumberFormat`
    object without any constructor arguments, you get the locale settings of the current
    computer:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的区域设置，有一些标准的数字格式化规则适用。例如，英语语言区域中的数字通常使用逗号来分隔千位（如*1,200.00*），而法语语言区域中通常使用逗号而不是小数点（如*1
    200,00*）。如果你创建一个没有构造函数参数的`Intl.NumberFormat`对象，你会得到当前计算机的区域设置：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can also create an `Intl.NumberFormat` object for a specific locale, with
    no extra options:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以为特定的区域创建一个`Intl.NumberFormat`对象，不需要额外的选项：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the *en-US* region, this object will add comma separators, but it won’t apply
    a fixed number of decimal points or add a currency symbol.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在*en-US*区域，这个对象会添加逗号分隔符，但不会应用固定数量的小数点或添加货币符号。
- en: The `Intl.NumberFormat` object supports a number of options. You can change
    the way negative numbers are displayed, set minimum and maximum numbers of digits,
    show percentages, and choose different numbering systems in some languages. You
    can find comprehensive information in the [Mozilla Developer Network reference](https://oreil.ly/JEF4Q).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`Intl.NumberFormat`对象支持多种选项。你可以更改负数显示的方式，设置最小和最大数字位数，显示百分比，并在某些语言中选择不同的编号系统。你可以在[Mozilla
    开发者网络参考文档](https://oreil.ly/JEF4Q)中找到详细信息。'
- en: 'You may see an older version of this technique that uses the `Number.toLocaleString()`
    method. Here’s an example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会看到一个使用`Number.toLocaleString()`方法的旧版本技术。以下是一个示例：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This approach is perfectly valid, although if you plan to format a long series
    of numbers, creating and reusing a single `Intl.NumberFormat` object will perform
    better.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法是完全有效的，尽管如果你打算格式化一长串数字，创建和重用一个单一的`Intl.NumberFormat`对象会表现更好。
- en: See Also
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: If you need formatting support that’s more extensive than what `Intl.NumberFormat`
    provides, you can use a third-party library like [Numeral.js](https://github.com/adamwdraper/Numeral-js).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要比`Intl.NumberFormat`提供的格式支持更多的功能，你可以使用第三方库，比如[Numeral.js](https://github.com/adamwdraper/Numeral-js)。
- en: Inserting Special Characters
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入特殊字符
- en: Problem
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to insert a special character, such as a line break, into a string.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要插入特殊字符，比如换行符，到一个字符串中。
- en: Solution
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'The simplest approach with many special characters is simple: just paste the
    character you want into your editor. For example, if you need a copyright symbol
    (©), first find the character in a desktop utility like charmap (on a Windows
    computer) or just search for “copyright symbol” in Google. Select the symbol,
    copy it, and then paste it into your code.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 处理带有许多特殊字符的最简单方法很简单：只需将您需要的字符粘贴到您的编辑器中。例如，如果您需要版权符号（©），首先在桌面实用程序（如 Windows 计算机上的
    charmap）中找到该字符，或者在 Google 中搜索“版权符号”。选择符号，复制它，然后粘贴到您的代码中。
- en: If you want to use a character that wouldn’t normally be allowed in your code
    (according to the syntax rules of JavaScript), you need to use one of its *escape
    sequences*—special character code combinations that aren’t interpreted literally.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要在代码中使用通常不允许的字符（根据 JavaScript 的语法规则），您需要使用其中的一种*转义序列*—特殊的字符代码组合，这些组合不会被字面解释。
- en: 'For example, if you’re using apostrophes to delimit your strings, you can’t
    put an apostrophe character directly *in* your string. Instead, you need to use
    the `\''` escape sequence, like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你在字符串中使用撇号作为定界符，就不能直接在*字符串内*放置撇号字符。相反，你需要使用 `\'` 转义序列，就像这样：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now `favoriteMovie` holds the text *My favorite movie is ‘The Seventh Seal’.*
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `favoriteMovie` 包含文本 *My favorite movie is ‘The Seventh Seal’.*。
- en: Discussion
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The escape sequences in JavaScript all begin with the *backslash character*
    (`\`). This character signals that what follows is a sequence of characters that
    needs special handling. [Table 2-1](#escape_sequence_list) lists the other escape
    sequences that JavaScript recognizes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 中的转义序列都以*反斜杠字符*（`\`）开头。该字符表示后续的字符序列需要特殊处理。[表 2-1](#escape_sequence_list)
    列出了 JavaScript 所识别的其他转义序列。
- en: Table 2-1\. Escape sequences
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-1\. 转义序列
- en: '| Sequence | Character |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 序列 | 字符 |'
- en: '| --- | --- |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `\''` | Single quote |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `\''` | 单引号 |'
- en: '| `\"` | Double quote |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `\"` | 双引号 |'
- en: '| `\\` | Backslash |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `\\` | 反斜杠 |'
- en: '| `\n` | Newline |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `\n` | 换行符 |'
- en: '| `\t` | Horizontal tab |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `\t` | 水平制表符 |'
- en: '| `\b` | Nondestructive backspace* |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `\b` | 非破坏性退格* |'
- en: '| `\f` | Form feed* |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `\f` | 换页符* |'
- en: '| `\r` | Carriage return^([a](ch02.html#idm45475189621992)) |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `\r` | 回车符^([a](ch02.html#idm45475189621992)) |'
- en: '| `\ddd` | Octal sequence (3 digits: *`ddd`*) |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `\ddd` | 八进制序列（3 位数：*`ddd`*） |'
- en: '| `\xdd` | Hexadecimal sequence (2 digits: *`dd`*) |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `\xdd` | 十六进制序列（2 位数：*`dd`*） |'
- en: '| `\udddd` | Unicode sequence (4 hex digits: *`dddd`*) |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `\udddd` | Unicode 序列（4 个十六进制数字：*`dddd`*） |'
- en: '| ^([a](ch02.html#idm45475189621992-marker)) Some escape sequences (like the
    ones used for backspaces and form feeds) are holdovers from the original ASCII
    character standard and C language. Unless you’re dealing with a legacy scenario
    (like sending input to a terminal), these escape sequences aren’t likely to be
    useful in JavaScript. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| ^([a](ch02.html#idm45475189621992-marker)) 一些转义序列（如用于退格和换页的序列）是从原始 ASCII
    字符标准和 C 语言中保留下来的。除非您处理遗留场景（如将输入发送到终端），否则这些转义序列在 JavaScript 中不太可能有用。'
- en: 'The last three escape sequences in [Table 2-1](#escape_sequence_list) are patterns
    that require you to supply a numeric value. For example, if you don’t want to
    use the copy-and-paste trick to add a copyright symbol, you can insert it by using
    the `\u` escape sequence and the copyright symbol’s Unicode value:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 2-1](#escape_sequence_list) 中的最后三个转义序列是需要提供数值的模式。例如，如果您不想使用复制粘贴技巧来添加版权符号，您可以使用
    `\u` 转义序列和版权符号的 Unicode 值来插入它：'
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now the `copyrightNotice` string is set to *This page © Shelley Powers.*
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `copyrightNotice` 字符串设置为 *This page © Shelley Powers.*。
- en: See Also
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: For information about inserting even more specialized characters in your strings,
    see [“Inserting Emojis”](#inserting_emojis). For an alternate approach to dealing
    with line breaks without using `\n`, see [“Using Template Literals for Clearer
    String Concatenation”](#using_template_literals).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 有关在字符串中插入更专业字符的信息，请参阅 [“插入表情符号”](#inserting_emojis)。有关处理换行而不使用 `\n` 的替代方法，请参阅
    [“使用模板文字清晰地进行字符串连接”](#using_template_literals)。
- en: Inserting Emojis
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入表情符号
- en: Problem
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to insert an extended Unicode character that has a 4-byte encoding,
    like an emoji or certain types of accented non-English letters.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要插入一个具有 4 字节编码的扩展 Unicode 字符，如表情符号或某些类型的重音非英文字母。
- en: Solution
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'If you simply want to create a string with an emoji, the copy-and-paste trick
    from [“Inserting Special Characters”](#inserting_special_characters) usually works.
    In a modern code editor, you can write code like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只是想创建一个带有表情符号的字符串，通常可以从[“插入特殊字符”](#inserting_special_characters)的“复制并粘贴技巧”中工作。在现代代码编辑器中，您可以像这样编写代码：
- en: '`const hamburger = ''`🍔`'';`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const hamburger = ''`🍔`'';`'
- en: '`const hamburgerStory = ''I like hamburgers'' + hamburger;`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const hamburgerStory = ''我喜欢汉堡包'' + hamburger;`'
- en: Your code font doesn’t even need to support emojis, because your code editor
    will fall back on the emoji support provided by your operating system. (Of course,
    issues can still occur. For example, you might see a square “missing character”
    icon on an older system where the emoji isn’t available.)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由于代码编辑器将使用操作系统提供的表情符号支持作为后备，因此您的代码字体甚至无需支持表情符号。（当然，问题仍可能发生。例如，在旧系统上，表情符号不可用时，您可能会看到一个方框“缺失字符”图标。）
- en: Another option is to use the Unicode value for the emoji. The problem is that
    you can’t use a standard `\u` escape sequence to get an emoji, because every emoji
    is stored as a 4-byte value. (By comparison, the Unicode characters that map to
    the keys of your keyboard are usually encoded as 2-byte values.)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是使用表情符号的Unicode值。问题是，您不能使用标准的`\u`转义序列来获取表情符号，因为每个表情符号都存储为4字节值。（相比之下，映射到键盘键的Unicode字符通常编码为2字节值。）
- en: 'The solution is to use the `String.fromCodePoint()` method:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是使用`String.fromCodePoint()`方法：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The hamburger emoji has the hexadecimal code U+1F354\. To use it with `fromCodePoint()`,
    replace the prefix *U+* with *0x*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 汉堡包表情的十六进制代码是U+1F354。要使用它与`fromCodePoint()`，请用*0x*替换前缀*U+*。
- en: Once you’ve created an emoji-enhanced string, you can write it to the developer
    console or show it in a web page, just as you would with an ordinary string composed
    of ordinary characters.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一个富含表情符号的字符串后，您可以像处理由普通字符组成的普通字符串一样将其写入开发者控制台或显示在网页上。
- en: Discussion
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: As of 2020, there are just over three thousand emojis in the world. You can
    see them, with their corresponding hexadecimal values [at the Full Emoji List](https://oreil.ly/IIguA).
    Just because an emoji exists doesn’t mean it will be supported on the devices
    where you plan to use it, so test for compliance early.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 截至2020年，全世界仅有三千多个表情符号。您可以在[完整表情列表](https://oreil.ly/IIguA)上看到它们及其相应的十六进制值。仅仅因为一个表情符号存在并不意味着它将在您计划使用它的设备上受支持，因此请尽早测试兼容性。
- en: If you need to do string processing with strings that may include emojis, other
    issues can crawl out of the woodwork. For example, what do you expect this code
    will find?
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要处理可能包含表情符号的字符串进行字符串处理，可能会遇到其他问题。例如，您认为以下代码将找到什么？
- en: '`const hamburger = ''`🍔`'';`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const hamburger = ''`🍔`'';`'
- en: '`const hamburgerLength = hamburger.length;`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const hamburgerLength = hamburger.length;`'
- en: Even though the `hamburger` string is just one character, to your code the length
    appears to be 2 because the hamburger emoji takes twice as many bytes in memory.
    This is an unpleasant [*leaky abstraction*](https://oreil.ly/nlmvi) and a limitation
    of JavaScript’s support for Unicode.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`hamburger`字符串只有一个字符，但在你的代码中，长度看起来是2，因为汉堡包表情在内存中占用了两倍的字节。这是JavaScript对Unicode支持的一个不愉快的[*泄漏抽象*](https://oreil.ly/nlmvi)和限制。
- en: There are workarounds that people have invented to deal with emoji issues, like
    incorrect lengths and problems iterating over characters or slicing strings. But
    making a home brew solution is risky, because there are often strange edge cases.
    Instead, consider a JavaScript library with emoji support like [Grapheme Splitter](https://github.com/orling/grapheme-splitter)
    if you need to manipulate emoji-enriched text.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 有人已经发明了一些解决表情符号问题的变通方法，例如不正确的长度和在字符上进行迭代或切片的问题。但是自制解决方案风险很大，因为通常存在奇怪的边缘情况。如果需要处理富含表情符号的文本，可以考虑使用像[Grapheme
    Splitter](https://github.com/orling/grapheme-splitter)这样支持表情符号的JavaScript库。
- en: Using Template Literals for Clearer String Concatenation
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模板字面量来进行更清晰的字符串连接
- en: Problem
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want a simpler, clearer way to write long string concatenation operations.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望有一个更简单、更清晰的方法来编写长字符串的连接操作。
- en: Solution
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'A common task in programming is to combine bits of static text with variables
    to create a single, longer string. The traditional way to assemble this kind of
    string is with the concatentation operator `+`, as shown here:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中的一个常见任务是将静态文本的各个部分与变量结合起来，创建一个更长的字符串。组装这种类型的字符串的传统方式是使用连接运算符`+`，如下所示：
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It’s not awful, but it can get awkward, particularly as the fixed bits of text
    get longer. It’s also surprisingly easy to forget to add spaces around the variables.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 它并不糟糕，但在固定文本变得更长时可能会变得尴尬。而且很容易忘记在变量周围添加空格。
- en: 'A different approach is to use *template literals*, a type of string literal
    that allows embedded expressions. To create a template literal, just replace your
    standard string delimeters (apostrophes or double quotes) with the backtick (`)
    character:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用*模板字面量*，一种允许嵌入表达式的字符串字面量。要创建模板字面量，只需用反引号（`）替换标准字符串定界符（撇号或双引号）即可：
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now you can insert your variables directly into your template literal. All you
    need to do is wrap each variable in curly braces, preceded by a dollar sign, like
    `${firstName}`. This is called an *expression.*
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以直接将变量插入到模板字面量中。您只需将每个变量用花括号包裹起来，并在前面加上一个美元符号，例如`${firstName}`。这称为*表达式*。
- en: 'The advantage of the template literal approach becomes clearer when you look
    at a full example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字面量方法的优势在于当您查看完整示例时变得更加明显：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It’s even clearer when you use a modern code editor that colorizes the curly
    brace expressions, making the variables stand out from the literal text.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在现代代码编辑器中使用着色花括号表达式时，情况会变得更清晰，这使得变量从文字字面上脱颖而出。
- en: Template literals also preserve line breaks. In the examples shown here, you
    can’t see this effect, because we’ve wrapped the code to fit the page. But if
    you deliberately hit Enter to put hard line breaks in your template literal, those
    breaks will be preserved in the string, exactly as if you’d used the `\n` newline
    escape sequence (see [“Inserting Special Characters”](#inserting_special_characters)).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字面量还保留换行符。在这里显示的示例中，您看不到这种效果，因为我们已经把代码换行以适应页面。但是，如果您故意按Enter键在模板字面量中添加硬换行，这些换行将保留在字符串中，就像使用`\n`换行转义序列一样（参见[“插入特殊字符”](#inserting_special_characters)）。
- en: Note
  id: totrans-147
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Many JavaScript styte guides, including [Airbnb](https://github.com/airbnb/javascript),
    have rules that discourage string concatenation and favor template literals. You
    can use a linter like ESLint ([“Enforcing Code Standards with a Linter”](ch01.html#using_eslint))
    to enforce this practice in your code.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 许多JavaScript风格指南，包括[Airbnb](https://github.com/airbnb/javascript)，都有规则不鼓励字符串连接，而是青睐使用模板字面量。您可以使用类似ESLint的代码检查工具（[“使用ESLint执行代码标准”](ch01.html#using_eslint)）来在您的代码中强制执行这一实践。
- en: Discussion
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'When you use expressions in a template literal, you aren’t limited to inserting
    variables as they are. In fact, you can use any code expression that JavaScript
    can evaluate. For example, consider this code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板字面量中使用表达式时，不限于直接插入变量。事实上，您可以使用JavaScript能评估的任何代码表达式。例如，请考虑以下代码：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, JavaScript executes the addition in the expression `{5+3}`, gets the result,
    and creates the string *The sum of 5 + 3 is 8*.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，JavaScript执行表达式`{5+3}`中的加法，获取结果，并创建字符串*The sum of 5 + 3 is 8*。
- en: 'If you want to do something more complex, like format strings or manipulate
    objects, you can use an expression that calls a function. For example, if you’ve
    created a `getDaysSince()` function for calculating the difference between dates
    (see [“Calculating the Time Elapsed Between Two Dates”](ch04.html#calculating_time_between_dates)),
    you can use it in a template literal like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想做一些更复杂的事情，比如格式化字符串或操作对象，您可以使用调用函数的表达式。例如，如果您创建了一个用于计算日期间差异的`getDaysSince()`函数（参见[“计算两个日期间经过的时间”](ch04.html#calculating_time_between_dates)），您可以在模板字面量中像这样使用它：
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The only limit is practical—in other words don’t make your expressions so complex
    that the resulting template literal is more difficult to read than code that uses
    the traditional string-concatenation approach.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的限制是实际情况——换句话说，不要使您的表达式过于复杂，以至于生成的模板字面量比使用传统字符串连接方法的代码更难阅读。
- en: Currently, JavaScript has no built-in way to format numbers, dates, and currency
    values inside template literal expressions. Plenty of people have speculated that
    future versions of JavaScript will add this capability. There’s even a JavaScript
    library that uses an awkward extensibility feature called [*tagged templates*](https://github.com/skolmer/es2015-i18n-tag)
    to wedge it in.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，JavaScript没有内置的方法来在模板字面量表达式内格式化数字、日期和货币值。许多人猜测未来版本的JavaScript将添加此功能。甚至有一个JavaScript库，使用了一个尴尬的可扩展性特性称为[*标记模板*](https://github.com/skolmer/es2015-i18n-tag)来添加它。
- en: Performing a Case-Insensitive String Comparison
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行不区分大小写的字符串比较
- en: Problem
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to see if two strings match, while treating uppercase and lowercase
    letters as the same.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要查看两个字符串是否匹配，同时将大写和小写字母视为相同。
- en: Solution
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方法
- en: 'The off-the-cuff approach is to use the `String.toLowerCase()` method on both
    strings, and compare the result, like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一种即兴的方法是对两个字符串都使用 `String.toLowerCase()` 方法，然后比较结果，例如：
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This approach is fairly reliable, but it can suffer from edge cases with different
    languages, accents, and special characters. (For example, check out the [potential
    problems](https://oreil.ly/CiALB) with Turkish.)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法相当可靠，但在处理不同语言、重音符号和特殊字符时可能会出现边缘情况。（例如，请查看与土耳其语相关的 [潜在问题](https://oreil.ly/CiALB)。）
- en: 'An alternate, bulletproof approach is to use the `String.localeCompare()` method
    with `sensitivity` set to `*accent*`, as shown here:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种健壮的方法是使用 `String.localeCompare()` 方法，并将 `sensitivity` 设置为 `*accent*`，如下所示：
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Discussion
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: If `localeCompare()` deems that two strings match, it returns 0\. Otherwise
    it returns a positive or negative integer indicating whether the compared string
    falls before or after the referenced string in the sort order. (Because we’re
    using `localeCompare()` to test for equality, the sort order isn’t important,
    and you can ignore it.)
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `localeCompare()` 判定两个字符串匹配，则返回 0。否则，返回一个正数或负数，指示比较的字符串在排序顺序中是在参考字符串之前还是之后。（因为我们使用
    `localeCompare()` 来测试相等性，排序顺序并不重要，可以忽略。）
- en: The second parameter of `localeCompare()` holds a string that specifies the
    locale (as explained in [“Converting a Numeric Value to a Formatted String”](#converting_number_to_string)).
    If you pass `undefined`, then `localeCompare()` uses the locale of the current
    computer, which is almost always what you want.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`localeCompare()` 的第二个参数是一个字符串，用于指定区域设置（如 [“将数值转换为格式化字符串”](#converting_number_to_string)
    中所述）。如果传入 `undefined`，则 `localeCompare()` 使用当前计算机的区域设置，这通常是你想要的。'
- en: To perform a case-insensitive comparison, you need to set the `sensitivity`
    property. There are two values that can work. If you set `sensitivity` to `*accent*`,
    characters that have different accents (like *a* and *á*) are treated as unequal.
    But if you set `sensitivity` to `*base*`, you’ll get a more permissive case-insensitive
    comparison that treats all accented letters as matches.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行大小写不敏感的比较，需要设置 `sensitivity` 属性。有两个可以工作的值。如果将 `sensitivity` 设置为 `*accent*`，则具有不同重音符号的字符（如
    *a* 和 *á*）将被视为不相等。但如果将 `sensitivity` 设置为 `*base*`，则会得到一个更宽松的大小写不敏感比较，将所有重音符号的字母视为匹配。
- en: Checking If a String Contains a Specific Substring
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查字符串是否包含特定子字符串
- en: Problem
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to check if one string contains another substring.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要检查一个字符串是否包含另一个子字符串。
- en: Solution
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方法
- en: 'If you simply need a yes-or-no test, you can use the `String.includes()` method:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只需要一个是或否的测试，可以使用 `String.includes()` 方法：
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Optionally, you can tell the `includes()` method where to start its search
    by character position. For example, pass in the value 5 and the search skips to
    the sixth character in the string, and continues to the end:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，你可以告诉 `includes()` 方法从哪个字符位置开始搜索。例如，传入值 5，则搜索跳过字符串中的第六个字符，并继续直到末尾：
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Discussion
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'The search that `includes()` performs is case-sensitive. If you want a case-insensitive
    search, you can call `toLowerCase()` on both strings first:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`includes()` 执行的搜索区分大小写。如果需要大小写不敏感的搜索，可以先对两个字符串调用 `toLowerCase()`：'
- en: '[PRE26]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `includes()` method doesn’t provide any information about where a match
    occurs. If you want this information, consider using the `String.indexOf()` method
    instead, which is described in [“Extracting a List from a String”](#extracting_a_list).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`includes()` 方法不提供关于匹配发生位置的任何信息。如果需要此信息，请考虑使用 `String.indexOf()` 方法，详情请见 [“从字符串中提取列表”](#extracting_a_list)。'
- en: Replacing All Occurrences of a String
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替换字符串的所有出现
- en: Problem
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to find all occurrences of a specific substring in a string, and replace
    them with something else.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要查找字符串中特定子字符串的所有出现，并用其他内容替换它们。
- en: Solution
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方法
- en: 'You can use the `String.replaceAll()` method to make the change in one step.
    All you need is a substring to search for and another string to swap in its place:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `String.replaceAll()` 方法一次性进行更改。你只需要一个要搜索的子字符串和另一个要替换的字符串：
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If you run this code, you’ll see the altered string “I know not where I was
    born, save that the castle was somewhat old and somewhat horrible.” appear in
    the developer console.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行此代码，你将在开发者控制台看到改变后的字符串 “I know not where I was born, save that the castle
    was somewhat old and somewhat horrible.”。
- en: Discussion
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The `replaceAll()` method has the ability to use a regular expression for searching
    instead of an ordinary string. You can see how this works in [“Using a Regular
    Expression to Replace Patterns in a String”](#replacing_patterns_string).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`replaceAll()`方法有能力使用正则表达式进行搜索，而不是普通字符串。你可以在[“使用正则表达式替换字符串中的模式”](#replacing_patterns_string)中看到这是如何工作的。'
- en: See Also
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Consult Recipes and to see how you can find matches in a string and examine
    each one, instead of just replacing them outright.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[Recipes](https://example.org/recipes)来了解如何在字符串中查找匹配项并逐个检查，而不仅仅是直接替换它们。
- en: Replacing HTML Tags with Named Entities
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将HTML标签替换为命名实体
- en: Problem
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to insert markup into a web page, and escape the markup (so the browser
    *displays* the angle brackets rather than interpreting them as HTML tags). This
    could be because you want to show some example HTML markup, for example, in a
    tutorial article. Or it may be because you need to safely sanitize outside data,
    like text submitted by a user or pulled out of a database.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要将标记插入到网页中，并转义该标记（使浏览器*显示*角括号而不解释它们为HTML标签）。这可能是因为你希望在教程文章中显示一些示例HTML标记，或者因为你需要安全地清理外部数据，如用户提交的文本或从数据库中提取的文本。
- en: Solution
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use the `String.replaceAll()` method to convert angle brackets (`< >`) into
    the named HTML entities `&lt;` and `&gt;`. You’ll need to perform two steps, one
    for each substitution:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`String.replaceAll()`方法将角括号(`< >`)转换为命名的HTML实体`&lt;`和`&gt;`。你需要执行两个步骤，分别进行替换：
- en: '[PRE28]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If you examine the string now, you’ll find it holds the text “<p>This is a <span>paragraph</span></p>”,
    which will appear as you expect (with angle brackets shown) in the web page.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在检查字符串，你会发现它包含文本“<p>This is a <span>paragraph</span></p>”，在网页中将如你所预期地显示（显示角括号）。
- en: 'You can perform both string substitutions in one step, as long as you can keep
    the code readable:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 只要代码可读性能够保持，你可以一步完成两次字符串替换：
- en: '[PRE29]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The first `replaceAll()` returns a new string, and the code calls `replaceAll()`
    on that second string to get a *third* string in this case. This technique of
    calling a method on a value that’s returned from a method is called *method chaining*.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`replaceAll()`返回一个新字符串，然后在这个第二个字符串上调用`replaceAll()`来获得*第三*个字符串。这种在从一个方法返回的值上调用方法的技术称为*方法链*。
- en: Discussion
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: HTML escaping is critically important if you’re inserting raw text into a web
    page. If you don’t perform this step, you’ve left open a gaping security hole.
    In fact, you should make sure all text content is escaped before you show it in
    a web page, even if you think that text doesn’t contain any HTML entities (for
    example, even if it’s just set as a literal in your code). There’s no telling
    when someone might change the code and substitute a text value from somewhere
    else.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将原始文本插入到网页中，HTML转义非常重要。如果你不执行此步骤，将会存在严重的安全漏洞。事实上，你应该确保在显示文本内容之前，对所有文本内容进行转义，即使你认为该文本不包含任何HTML实体（例如，即使它只是在你的代码中直接设置为文字）。无法预测何时可能会从其他地方更改代码并替换文本值。
- en: That said, doing HTML escaping on your own usually isn’t the best approach.
    You need to do it if you are deliberately creating a string that mingles your
    HTML tags with outside content. But ideally you’ll put text in your web page using
    an element’s `textContent` property instead of its `innerHTML` property. When
    you use `textContent`, the browser escapes the content automatically, which means
    you don’t need to use `String.replaceAll()`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，自行进行HTML转义通常不是最佳方法。如果你有意创建一个将HTML标签与外部内容混合的字符串，那么你需要这样做。但是理想情况下，你应该使用元素的`textContent`属性而不是`innerHTML`属性将文本放入网页中。使用`textContent`时，浏览器会自动转义内容，这意味着你不需要使用`String.replaceAll()`。
- en: See Also
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: See [Chapter 12](ch12.html#ch12) for more information about using the HTML DOM
    to insert text content into a web page.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于使用HTML DOM将文本内容插入到网页中的信息，请参见[第12章](ch12.html#ch12)。
- en: Using a Regular Expression to Replace Patterns in a String
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用正则表达式替换字符串中的模式
- en: Problem
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to search a string for a pattern, rather than an exact sequence of
    characters. You then want to create a new string, with the pattern replaced.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望在字符串中搜索模式，而不是确切的字符序列。然后，你想创建一个新字符串，将模式替换掉。
- en: Solution
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: You can use the `String.replace()` or `String.replaceAll()` methods, both of
    which support regular expressions.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`String.replace()`或`String.replaceAll()`方法，两者都支持正则表达式。
- en: Note
  id: totrans-213
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A *regular expression* is a sequence of characters that defines a text pattern.
    Regular expressions are a standard that’s implemented in JavaScript and many other
    programming languages. [Table 2-2](#regular_expression_special_characters) gives
    a brief introduction to regular expression syntax.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '*正则表达式*是定义文本模式的字符序列。正则表达式是JavaScript和许多其他编程语言中实现的标准。请参阅[表 2-2](#regular_expression_special_characters)以简要介绍正则表达式语法。'
- en: For example, consider the regular expression pattern *`t\w{2}e`*. This translates
    into *look for any sequence of characters beginning with *t*, ending with *e*,
    and containing two other alphanumeric characters*. The solution matches *time*,
    but also matches *tame*.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑正则表达式模式*`t\w{2}e`*。这将被翻译为*查找以*t*开头，以*e*结尾，并包含两个其他字母数字字符的任意字符序列*。该解决方案匹配*time*，但也匹配*tame*。
- en: 'Here’s the code that uses this regular expression:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用此正则表达式的代码：
- en: '[PRE30]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Notice that the regular expression isn’t written a string. Instead, it’s a literal
    that begins and ends with a slash (`/`). JavaScript recognizes this syntax and
    creates a `RegEx` object that uses your expression.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，正则表达式不是作为字符串编写的。相反，它是以斜杠（`/`）开始和结束的文字。JavaScript识别这种语法并创建一个使用您的表达式的`RegEx`对象。
- en: The `g` at the end of the regular expression is an additional detail called
    the *global flag*. It indicates that you are searching the whole string for matches.
    If you don’t include the `g` flag, you’ll receive an error when you call `replaceAll()`.
    However, you can use a regular expression without the global flag when you use
    the `replace()` method to change just one occurrence of a pattern.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式末尾的`g`是称为*全局标志*的附加细节。它表示您正在搜索整个字符串以找到匹配项。如果不包括`g`标志，则在调用`replaceAll()`时会收到错误消息。但是，当您使用`replace()`方法仅更改模式的一个出现时，可以使用没有全局标志的正则表达式。
- en: Discussion
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'If you’d rather create a regular expression without using the `/` delimiter,
    there’s another option. Instead of writing a regular expression literal, you can
    explicitly create a `RegEx` object, like this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想使用`/`分隔符创建正则表达式，还有另一种选择。您可以显式创建一个`RegEx`对象，如下所示：
- en: '[PRE31]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When you use this approach, you don’t include the surrounding slashes around
    the regular expression, but you do need to escape any backslashes in the pattern
    (by replacing `/` with `//`). In addition, the global flag becomes a second argument
    to the `RegExp` constructor, instead of being added to the end of the regular
    expression.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用这种方法时，您不需要在正则表达式周围包含斜杠，但您需要转义模式中的任何反斜杠（将`/`替换为`//`）。此外，全局标志成为`RegExp`构造函数的第二个参数，而不是添加到正则表达式的末尾。
- en: 'You might find that escaping backslashes is awkward or confusing in long, complicated
    regular expressions. If so, you can get around the escaping requirement with a
    template literal (introduced in [“Using Template Literals for Clearer String Concatenation”](#using_template_literals)).
    The trick is to combine your template literal with the `String.raw()` method.
    Remember to use backticks (`) around the expression string instead of apostrophes
    or quotes:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会发现，在长而复杂的正则表达式中，转义反斜杠是令人困惑的。如果是这样，您可以通过模板文字（在[“使用模板文字进行更清晰的字符串连接”](#using_template_literals)中介绍）来避免转义要求。窍门是将您的模板文字与`String.raw()`方法结合使用。请记住，在表达式字符串周围使用反引号（`）而不是撇号或引号：
- en: '[PRE32]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Extra: Regular Expressions'
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 额外：正则表达式
- en: 'Regular expressions are made up of regular characters that are used alone or
    in combination with special characters. For instance, the following is a regular
    expression for a pattern that matches against a string that contains the word
    *technology* and the word *book*, in that order, and separated by one or more
    whitespace characters:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式由普通字符单独使用或与特殊字符结合而成。例如，以下是一个正则表达式，用于匹配包含单词*technology*和单词*book*（以这个顺序，并由一个或多个空白字符分隔）的字符串模式：
- en: '[PRE33]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The backslash character (`\`) serves two purposes: either it’s used with a
    regular character, to designate that it’s a special character, or it’s used with
    a special character, such as the plus sign (+), to designate that the character
    should be treated literally. In this case, the backslash is used with *s*, which
    transforms the letter *s* to a special character designating a whitespace character
    (space, tab, line feed, or form feed). The +\s+ special character is followed
    by the plus sign, `\s`, which is a signal to match the preceding character (in
    this example, a whitespace character) one or more times. This regular expression
    would work with the following:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 反斜杠字符（`\`）有两个用途：它要么与普通字符一起使用，表示它是一个特殊字符，要么与特殊字符一起使用，例如加号（+），表示应将该字符视为字面量。在这种情况下，反斜杠与
    *s* 一起使用，将字母 *s* 转换为指定空格字符（空格、制表符、换行符或换页符）的特殊字符。 +\s+ 特殊字符后跟加号，`\s` 是一个匹配前一个字符（在这个例子中是空格字符）一次或多次的信号。此正则表达式适用于以下情况：
- en: '[PRE34]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'It would also work with the following:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 以下也有效：
- en: '[PRE35]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'It would not work with the following, because there is no whitespace between
    the words:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 它不适用于以下情况，因为单词之间没有空白字符：
- en: '[PRE36]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: It doesn’t matter how much whitespace is between *technology* and *book*, because
    of the use of `\s+`. However, using the plus sign does require at least one whitespace
    character.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用 `\s+`，在 *technology* 和 *book* 之间有多少空白字符并不重要。然而，使用加号确实需要至少一个空白字符。
- en: '[Table 2-2](#regular_expression_special_characters) shows the most commonly
    used special characters in JavaScript applications.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 2-2](#regular_expression_special_characters) 展示了 JavaScript 应用中最常用的特殊字符。'
- en: Table 2-2\. Regular expression special characters
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-2\. 正则表达式特殊字符
- en: '| Character | Matches | Example |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| 字符 | 匹配 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `^` | Matches beginning of input | `/^This/` matches *This is…* |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| `^` | 匹配输入的开头 | `/^This/` 匹配 *This is…* |'
- en: '| `$` | Matches end of input | `/end$/` matches *This is the end* |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| `$` | 匹配输入的结尾 | `/end$/` 匹配 *This is the end* |'
- en: '| `*` | Matches zero or more times | `/se*/` matches *seeee* as well as *se*
    |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| `*` | 匹配零次或多次 | `/se*/` 匹配 *seeee* 和 *se* |'
- en: '| `?` | Matches zero or one time | `/ap?/` matches *apple* and *and* |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| `?` | 匹配零次或一次 | `/ap?/` 匹配 *apple* 和 *and* |'
- en: '| `+` | Matches one or more times | `/ap+/` matches *apple* but not *and* |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| `+` | 匹配一次或多次 | `/ap+/` 匹配 *apple* 但不匹配 *and* |'
- en: '| `{n}` | Matches exactly *n* times | `/ap{2}/` matches *apple* but not *apie*
    |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| `{n}` | 精确匹配 *n* 次 | `/ap{2}/` 匹配 *apple* 但不匹配 *apie* |'
- en: '| `\{n,\}` | Matches *n* or more times | `/ap{2,}/` matches all p’s in *apple*
    and *appple* but not *apie* |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `\{n,\}` | 匹配至少 *n* 次 | `/ap{2,}/` 匹配 *apple* 和 *appple* 中的所有 p 但不匹配 *apie*
    |'
- en: '| `\{n,m\}` | Matches at least *n*, at most *m* times | `/ap{2,4}/` matches
    four p’s in *apppppple* |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| `\{n,m\}` | 匹配至少 *n* 次，至多 *m* 次 | `/ap{2,4}/` 匹配 *appppple* 中的四个 p |'
- en: '| `.` | Any character except newline | `/a.e/` matches *ape* and *axe* |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `.` | 除换行符外的任意字符 | `/a.e/` 匹配 *ape* 和 *axe* |'
- en: '| `[`…`]` | Any character within brackets | `/a[px]e/` matches *ape* and *axe*
    but not *ale* |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| `[`…`]` | 括号内的任何字符 | `/a[px]e/` 匹配 *ape* 和 *axe* 但不匹配 *ale* |'
- en: '| `[^`…`]` | Any character but those within brackets | `/a[^px]/` matches *ale*
    but not *axe* or *ape* |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| `[^`…`]` | 除括号内的字符外的任何字符 | `/a[^px]/` 匹配 *ale* 但不匹配 *axe* 或 *ape* |'
- en: '| `\b` | Matches on word boundary | `/\bno/` matches the first *no* in *nono*
    |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| `\b` | 匹配单词边界 | `/\bno/` 匹配 *nono* 中的第一个 *no* |'
- en: '| `\B` | Matches on nonword boundary | `/\Bno/` matches the second *no* in
    *nono* |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| `\B` | 匹配非单词边界 | `/\Bno/` 匹配 *nono* 中的第二个 *no* |'
- en: '| `\d` | Digits from 0 to 9 | `/\d{3}/` matches *123* in *Now in 123* |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| `\d` | 数字 0 到 9 | `/\d{3}/` 匹配 *Now in 123* 中的 *123* |'
- en: '| `\D` | Any nondigit character | `/\D{2,4}/` matches *Now '' in ‘Now in 123*;
    |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| `\D` | 任何非数字字符 | `/\D{2,4}/` 匹配 *Now '' in ‘Now in 123*; |'
- en: '| `\w` | Matches word character (letters, digits, underscores) | `/\w/` matches
    *j* in *javascript* |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| `\w` | 匹配单词字符（字母、数字、下划线） | `/\w/` 匹配 *javascript* 中的 *j* |'
- en: '| `\W` | Matches any nonword character (not letters, digits, or underscores)
    | `\/W/` matches *%* in *100%* |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| `\W` | 匹配任何非单词字符（不是字母、数字或下划线） | `\/W/` 匹配 *100%* 中的 *%* |'
- en: '| `\n` | Matches a line feed |  |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| `\n` | 匹配换行符 |  |'
- en: '| `\s` | A single whitespace character |  |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| `\s` | 单个空白字符 |  |'
- en: '| `\S` | A single character that is not whitespace |  |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| `\S` | 任何非空格字符 |  |'
- en: '| `\t` | A tab |  |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| `\t` | 制表符 |  |'
- en: '| `(x)` | Capturing parentheses | Remembers the matched characters |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| `(x)` | 捕获括号 | 记住匹配的字符 |'
- en: Note
  id: totrans-262
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Regular expressions are powerful but can be tricky. They’re only covered lightly
    in this book. If you want more in-depth coverage of regular expressions, you can
    read the excellent *[Regular Expressions Cookbook](http://shop.oreilly.com/product/0636920023630.do)*
    by Jan Goyvaerts and Steven Levithan (O’Reilly), or consult an [online reference](https://github.com/ziishaned/learn-regex).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式很强大，但可能有些棘手。本书只是简单介绍了它们。如果你想要更深入地了解正则表达式，你可以阅读Jan Goyvaerts和Steven Levithan（O’Reilly）的优秀著作*[正则表达式手册](http://shop.oreilly.com/product/0636920023630.do)*，或者参考[在线参考资料](https://github.com/ziishaned/learn-regex)。
- en: Extracting a List from a String
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从字符串中提取列表
- en: Problem
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You have a string with several sentences, one of which includes a list of items.
    The list begins with a colon (:), ends with a period (.), and separates each item
    with a comma (,). You want to extract just the list.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 你有一个包含多个句子的字符串，其中一个句子包括一个项目列表。列表以冒号（:）开头，以句号（.）结尾，并用逗号（,）分隔每个项目。你想要提取出列表部分。
- en: 'Before:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 之前：
- en: '[PRE37]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'After:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 之后：
- en: '[PRE38]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Solution
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'The solution requires two actions: extract the string containing the list of
    items, and then convert this string into a list.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案需要两个步骤：提取包含项目列表的字符串，然后将此字符串转换为列表。
- en: 'Use the `String.indexOf()` method twice—first to locate the colon, and again
    to find the first period following the colon:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`String.indexOf()`方法两次——首先定位冒号，然后再找到冒号后面的第一个句号：
- en: '[PRE39]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Using these two locations and the `String.slice()` method, you can extract
    the string you want:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这两个位置和`String.slice()`方法，你可以提取你想要的字符串：
- en: '[PRE40]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You could write a loop that uses the `indexOf()` method to look for commas,
    and the `slice()` method to split the `list` string into smaller pieces, one for
    each item. But there’s an easier approach. You can break the string into an array
    using the `String.split()` method:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以编写一个循环，使用`indexOf()`方法查找逗号，并使用`slice()`方法将`list`字符串拆分为较小的部分，每个项目一个部分。但有一种更简单的方法。你可以使用`String.split()`方法将字符串拆分为数组：
- en: '[PRE41]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: When you call `split()`, you must choose a delimiter. It could be a space, a
    comma, a series of dashes, or something else. The delimiter is used to carve up
    the string into smaller pieces, and it won’t appear in the results.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用`split()`时，你必须选择一个分隔符。它可以是空格、逗号、一系列破折号或其他内容。分隔符用于将字符串切分为较小的部分，并且它不会出现在结果中。
- en: Discussion
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The result of splitting the extracted string is an array of list items. However,
    the items may come with artifacts (in this case, an extra leading space in all
    but the first string). Fortunately, it’s easy to clean them up.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 分割提取的字符串的结果是一个项目列表的数组。然而，这些项目可能带有一些不必要的部分（在这种情况下，除第一个字符串外，所有字符串都有额外的前导空格）。幸运的是，清理它们很容易。
- en: One obvious approach is to iterate over the array of strings and manually trim
    each one, using the technique described in [“Removing Whitespace from the Beginning
    and End of a String”](#removing_whitespace). This works, but there’s an easier
    approach.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 一个明显的方法是遍历字符串数组并手动修剪每个字符串，使用[“从字符串开头和结尾删除空格”](#removing_whitespace)中描述的技术。这样做是有效的，但有一种更简单的方法。
- en: 'The trick is to use the `Array.map()`, which runs a piece of code you supply
    on each element in the array. You need just a single line of code to call the
    `trim()` method:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是使用`Array.map()`，它会在数组中的每个元素上运行你提供的代码。你只需要一行代码来调用`trim()`方法：
- en: '[PRE42]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If you aren’t familiar with the arrow syntax used to supply the trimming function
    in this example, you can read a more detailed explanation of this technique in
    [“Using Arrow Functions”](ch06.html#arrow_functions).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对在这个例子中提供修剪函数所使用的箭头语法不熟悉，你可以在[“使用箭头函数”](ch06.html#arrow_functions)中阅读更详细的解释。
- en: See Also
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Another way to find matches in a string is to use regular expressions. For example,
    depending on the way your list is structured, you might be able to use a regular
    expression that grabs words that fall in between commas. Regular expressions are
    introduced in [“Using a Regular Expression to Replace Patterns in a String”](#replacing_patterns_string),
    and using regular expressions to perform a search is covered in [“Finding All
    Instances of a Pattern”](#finding_and_highlighting_all_instances_o).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在字符串中查找匹配项的另一种方法是使用正则表达式。例如，根据列表的结构方式，你可以使用一个抓取逗号之间的单词的正则表达式。正则表达式在[“使用正则表达式替换字符串中的模式”](#replacing_patterns_string)中介绍，使用正则表达式执行搜索在[“查找所有模式的实例”](#finding_and_highlighting_all_instances_o)中介绍。
- en: Finding All Instances of a Pattern
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找所有模式的实例
- en: Problem
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to find all instances of a pattern within a string and iterate over
    them.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要在字符串中找到模式的所有实例，并对它们进行迭代。
- en: Solution
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use a regular expression with the `String.matchAll()` method. The `matchAll()`
    method returns an iterator that lets you loop over all the matches.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `String.matchAll()` 方法与正则表达式。`matchAll()` 方法返回一个迭代器，让你可以遍历所有的匹配项。
- en: 'The next example uses a regular expression to find any word that begins with
    *t* and ends with *e*, with any number of characters in between. It uses the template
    literal syntax from [“Using Template Literals for Clearer String Concatenation”](#using_template_literals)
    to build a new string with results:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例使用正则表达式来查找以 *t* 开头并以 *e* 结尾的任意单词，中间包含任意数量的字符。它使用来自 [“使用模板字面量进行更清晰的字符串连接”](#using_template_literals)
    的模板字面量语法构建一个新的带有结果的字符串：
- en: '[PRE43]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here are the results from this code:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的结果如下：
- en: '[PRE44]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Discussion
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: When you search with `matchAll()`, each match is an object. As you iterate over
    your matches, you can examine the matched text (`match[0]`), and the index where
    the match was found (`match.index`).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `matchAll()` 进行搜索时，每个匹配都是一个对象。当你遍历你的匹配项时，你可以检查匹配的文本（`match[0]`）和匹配被找到的索引（`match.index`）。
- en: Here’s something that looks a little peculiar in the current example. Even though
    you’re looking at one result at a time, you use `match[0]` to get the first item
    from an array. This array exists because a regular expression can *capture* multiple
    portions of a match using parentheses. You can then reference these captured sections
    later. For example, imagine you write a regular expression that matches a row
    of information about a person. With capturing, you can easily grab separate pieces
    of information from each match, like that person’s name and birth date. When you
    use this technique with `matchAll()`, the matched substrings are provided as `match[1]`,
    `match[2]`, and so on.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前示例中有一些看起来有点奇怪的地方。尽管你一次只看一个结果，但你使用 `match[0]` 来获取数组中的第一个项目。这个数组存在是因为正则表达式可以使用括号*捕获*多个匹配部分。稍后你可以引用这些捕获的部分。例如，想象一下你写了一个匹配有关某人信息行的正则表达式。通过捕获，你可以轻松地从每个匹配中抓取单独的信息片段，比如那个人的姓名和出生日期。当你将这个技术与
    `matchAll()` 结合使用时，匹配的子字符串会分别作为 `match[1]`、`match[2]` 等提供。
- en: 'And if you don’t want to iterate over the results right away, you can dump
    everything into an array using the spread operator:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想立即遍历结果，你可以使用扩展运算符将所有内容转储到一个数组中：
- en: '[PRE45]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now you can use `foreach` to loop through your `matches` array at another time.
    But remember, `matches` isn’t just an array of matching text. It’s an array of
    match *objects*. As you saw in the original example, each match object has a position
    (`match.index`) and an array with one or more matched groups of text (starting
    with `match[0]`).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以使用 `foreach` 在另一个时间循环遍历你的 `matches` 数组。但请记住，`matches` 不仅仅是一个匹配文本的数组。它是一个匹配*对象*的数组。正如你在原始示例中看到的，每个匹配对象都有一个位置（`match.index`）和一个包含一个或多个匹配文本组的数组（以
    `match[0]` 开头）。
- en: 'Extra: Highlighting Matches'
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 补充：高亮匹配项
- en: Let’s take a look at a more detailed example that shows how you might find and
    highlight text matches on a web page. [Figure 2-1](#application_finding_and_highlighting_all)
    shows the application in action on William Wordsworth’s poem, “The Kitten and
    the Falling Leaves.”
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个更详细的例子，展示如何在网页上查找并高亮文本匹配。[图 2-1](#application_finding_and_highlighting_all)
    展示了该应用在威廉·华兹华斯的诗歌《小猫和落叶》上的运行情况。
- en: '![jsc3 0201](assets/jsc3_0201.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![jsc3 0201](assets/jsc3_0201.png)'
- en: Figure 2-1\. Application finding and highlighting all matched strings
  id: totrans-306
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-1\. 应用程序查找和突出显示所有匹配的字符串
- en: This page has a `textarea` and an input text box for entering both a search
    string and a regular expression. The pattern is used to create a `RegExp` object,
    which is then applied against the text in the `textarea` using `matchAll()`, just
    as in the previous (much shorter) example.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 该页面有一个 `textarea` 和一个输入框，用于输入搜索字符串和正则表达式。该模式用于创建一个 `RegExp` 对象，然后像前面（更短的）示例一样，应用于
    `textarea` 中的文本，使用 `matchAll()`。
- en: As the code examines the matches, it creates a string, consisting of both the
    unmatched text and the matched text. The matched text is surrounded by a `<span>`
    element, with a CSS class used to highlight the text. The resulting string is
    then inserted into the page, using the `innerHTML` property of a `<div>` element
    (see [Example 2-1](#highlight_all_matches)).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码检查匹配项时，它创建一个字符串，包含未匹配的文本和匹配的文本。匹配的文本被包围在一个 `<span>` 元素中，并使用 CSS 类来突出显示文本。然后将生成的字符串插入到页面中，使用
    `<div>` 元素的 `innerHTML` 属性（参见 [示例 2-1](#highlight_all_matches)）。
- en: Example 2-1\. Highlight all matches in a text string
  id: totrans-309
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-1\. 在文本字符串中突出显示所有匹配项
- en: '[PRE46]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In [Figure 2-1](#application_finding_and_highlighting_all) this page performs
    a search with this regular expression:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图2-1](#application_finding_and_highlighting_all)的页面中，使用以下正则表达式进行搜索：
- en: '[PRE47]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The bar (`|`) is a conditional test, and will match a word based on the value
    on either side of the bar. So *leaf* matches, as well as *leaves*, but not *leap*.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 竖线（`|`）是条件测试，将匹配基于竖线两侧的值的单词。所以*leaf*会匹配，*leaves*也会匹配，但*leap*不会匹配。
- en: Removing Whitespace from the Beginning and End of a String
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 去除字符串开头和结尾的空白字符
- en: Problem
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to trim extra spaces that pad the beginning or end of a string.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要去除填充在字符串开头或结尾的额外空格。
- en: Solution
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `String.trim()` method. It removes all whitespace from both ends of
    a string, including spaces, tabs, no-break spaces, and line terminator characters.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`String.trim()`方法。它会移除字符串两端的所有空白字符，包括空格、制表符、不间断空格和行终止符。
- en: '[PRE48]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Discussion
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The `trim()` method is straightforward, but not customizable. If you have even
    slightly more complex string alteration requirements, you’ll need to use a regular
    expression.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`trim()`方法很简单，但不可定制。如果你有稍微复杂的字符串修改需求，你将需要使用正则表达式。'
- en: 'One common problem that thwarts the `trim()` method is removing excess whitespace
    *inside* a string. The `replaceAll()` method can accomplish this task with relative
    ease using a regular expression with the `\s` character to match whitespace:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的问题是`trim()`方法无法移除字符串*内部*的多余空格。`replaceAll()`方法可以使用带有`\s`字符的正则表达式相对轻松地完成这个任务：
- en: '[PRE49]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Of course, unwanted artifacts are possible even after processing bad data with
    extra spaces. For example, if there are multiple spaces where you don’t want *any*
    space ('is long ,    with') you’ll still be left with a single space after you
    run the replacement ('is long , with'). The only way to deal with issues like
    these is to manually step through each match, as demonstrated in [“Finding All
    Instances of a Pattern”](#finding_and_highlighting_all_instances_o).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，即使在处理带有额外空格的坏数据之后，仍然可能出现不需要的残留物。例如，如果在你不希望有任何空格的地方有多个空格（'is long ,    with'），在替换后仍然会留下一个空格（'is
    long , with'）。处理这类问题的唯一方法是手动逐个匹配，正如[“查找模式的所有实例”](#finding_and_highlighting_all_instances_o)所示。
- en: See Also
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Regular expression syntax is described in [“Using a Regular Expression to Replace
    Patterns in a String”](#replacing_patterns_string).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式语法在[“使用正则表达式替换字符串中的模式”](#replacing_patterns_string)中描述。
- en: Converting the First Letter of a String to Uppercase
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将字符串的第一个字母转换为大写
- en: Problem
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to make the first letter of a string an uppercase letter, without changing
    the rest of the string.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 你想将字符串的第一个字母变成大写，但不改变字符串的其余部分。
- en: Solution
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Split off the first letter and capitalize it with `String.toUpper()`. Join
    the uppercase letter to the remainder of the string, which you can get with `String.slice()`:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 分离第一个字母并使用`String.toUpper()`将其大写化。然后将大写字母与字符串的其余部分连接起来，你可以使用`String.slice()`来获取字符串的剩余部分：
- en: '[PRE50]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Discussion
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: To get a single character from a string, you can use the string’s indexer, as
    in `original[0]`. This gets the character in position 0 (which is the first character).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字符串中获取单个字符，你可以使用字符串的索引器，如`original[0]`。这会获取位置0（即第一个字符）的字符。
- en: '[PRE51]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Alternatively, you can use the `String.charAt()` method, which works in exactly
    the same way.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用`String.charAt()`方法，它的工作方式完全相同。
- en: To get a fragment of a string, you use the `slice()` method. When calling `slice()`,
    you must always specify the index where you want to start your string extraction.
    For example, `text.slice(5)` starts at index position 5, continues to the end
    of the string, and copies that section of the text into a new string.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取字符串的片段，你可以使用`slice()`方法。在调用`slice()`时，你必须始终指定你希望从哪里开始提取字符串。例如，`text.slice(5)`从索引位置5开始，一直到字符串的末尾，并将该部分文本复制到一个新字符串中。
- en: 'If you don’t want `slice()` to continue to the end of the string, you can supply
    an optional second parameter with the index where the string copying should stop:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不希望`slice()`继续到字符串的末尾，你可以提供一个可选的第二个参数，指定字符串复制应该停止的索引位置：
- en: '[PRE52]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The example in this recipe changed a single letter to uppercase. If you want
    to change an entire sentence to use initial capitals (called *title case*), it’s
    a more complex problem. You might decide to split the string into separate words,
    trim each word, and then join the results, using a variation of the technique
    from [“Extracting a List from a String”](#extracting_a_list).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例中的示例更改了一个字母为大写。如果要将整个句子更改为使用首字母大写（称为*标题大小写*），这是一个更复杂的问题。您可能决定将字符串拆分为单独的单词，修剪每个单词，然后连接结果，使用从
    [“从字符串中提取列表”](#extracting_a_list) 技术的变体。
- en: See Also
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: You can use `slice()` in conjunction with `indexOf()` to find the location of
    specific bits of text that you want to extract. For an example, see [“Extracting
    a List from a String”](#extracting_a_list).
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将 `slice()` 与 `indexOf()` 结合使用，以找到要提取的特定文本位的位置。例如，请参见 [“从字符串中提取列表”](#extracting_a_list)。
- en: Validating an Email Address
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证电子邮件地址
- en: Problem
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to catch and reject common errors in email addresses.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望捕捉和拒绝电子邮件地址中的常见错误。
- en: Solution
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Regular expressions are useful for more than searching. You can also use them
    to validate strings by testing if a string matches a given pattern. In JavaScript,
    you test if a string matches a regular expression using the `RegEx.test()` method.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式不仅对搜索有用。您还可以通过测试字符串是否与给定模式匹配来验证字符串。在 JavaScript 中，您可以使用 `RegEx.test()`
    方法测试字符串是否与正则表达式匹配。
- en: '[PRE53]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Discussion
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Programmers use many different regular expressions to validate email addresses.
    The best ones capture obvious mistakes and spurious values, but don’t get too
    complex. Overly strict regular expressions have, from time to time, inadvertently
    disallowed valid mail addresses. And even if an email address checks out with
    the most stringent test possible, there’s no way to know if it’s truly *correct*
    (at least not without sending an email message and requesting a confirmation).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员使用许多不同的正则表达式来验证电子邮件地址。最好的正则表达式捕获明显的错误和虚假值，但不要过于复杂。过于严格的正则表达式有时会无意中禁止有效的邮件地址。即使电子邮件地址通过了最严格的测试，也没有办法知道它是否*正确*（至少不发送电子邮件消息并请求确认）。
- en: The regular expression in this recipe requires that an email has a sequence
    of at least one nonwhitespace character, followed by the @ character, followed
    by one or more nonwhitespace characters, followed by a period (.), followed again
    by one or more nonwhitespace characters. It catches obviously invalid emails like
    *tomkhangmail.com* or *tomkhan@gmail*.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例中的正则表达式要求电子邮件地址以至少一个非空白字符开头，后跟 @ 字符，然后是一个或多个非空白字符，然后是一个句点（.），再跟着一个或多个非空白字符。它捕获了明显无效的电子邮件地址，如
    *tomkhangmail.com* 或 *tomkhan@gmail*。
- en: Often, you won’t write a regular expression for validation yourself. Instead,
    you’ll use a prewritten expression that matches your data. For a massive collection
    of regular expression resources, visit the [Awesome Regex page](https://github.com/aloisdg/awesome-regex).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您不会自己编写用于验证的正则表达式。相反，您将使用匹配您数据的预定义表达式。有关大量正则表达式资源，请访问 [Awesome Regex 页面](https://github.com/aloisdg/awesome-regex)。
- en: See Also
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Regular expression syntax is described in [“Using a Regular Expression to Replace
    Patterns in a String”](#replacing_patterns_string).
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式语法在 [“使用正则表达式替换字符串中的模式”](#replacing_patterns_string) 中有描述。
- en: ^([1](ch02.html#idm45475190104344-marker)) In JavaScript, a *prototype* is a
    template for a specific type of object. In a more traditional object-oriented
    language, we would say that objects with the same prototype are instances of the
    same class. [Chapter 8](ch08.html#ch08) has many recipes that explore prototypes
    in JavaScript.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch02.html#idm45475190104344-marker)) 在 JavaScript 中，*原型*是特定类型对象的模板。在更传统的面向对象语言中，我们会说具有相同原型的对象是同一类的实例。《第
    8 章》有很多示例，探讨了 JavaScript 中的原型。
