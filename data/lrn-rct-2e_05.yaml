- en: Chapter 5\. React with JSX
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章\. JSX与React
- en: 'In the last chapter, we dove deep into how React works, breaking down our React
    applications into small reusable pieces called components. These components render
    trees of elements and other components. Using the `createElement` function is
    a good way to see how React works, but as React developers, that’s not what we
    do. We don’t go around composing complex, barely readable trees of JavaScript
    syntax and call it fun. In order to work efficiently with React, we need one more
    thing: JSX.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们深入探讨了React的工作原理，将我们的React应用程序拆分成称为组件的小型可重复使用部件。这些组件渲染元素和其他组件的树形结构。使用`createElement`函数是了解React工作原理的一种好方法，但作为React开发人员，这不是我们所做的。我们不会简单地组合复杂、难以阅读的JavaScript语法树然后称之为有趣。为了有效地使用React，我们还需要一件东西：JSX。
- en: JSX combines the *JS* from JavaScript and the *X* from XML. It is a JavaScript
    extension that allows us to define React elements using a tag-based syntax directly
    within our JavaScript code. Sometimes JSX is confused with HTML because they look
    similar. JSX is just another way of creating React elements, so you don’t have
    to pull your hair out looking for the missing comma in a complex `createElement`
    call.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: JSX结合了JavaScript的*JS*和XML的*X*。它是一种JavaScript扩展，允许我们使用基于标签的语法直接在我们的JavaScript代码中定义React元素。有时JSX与HTML混淆，因为它们看起来很相似。JSX只是创建React元素的另一种方式，因此您无需在复杂的`createElement`调用中寻找遗失的逗号而抓狂。
- en: In this chapter, we’re going to discuss how to use JSX to construct a React
    application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论如何使用JSX构建React应用程序。
- en: React Elements as JSX
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React元素作为JSX
- en: Facebook’s React team released JSX when they released React to provide a concise
    syntax for creating complex DOM trees with attributes. They also hoped to make
    React more readable like HTML and XML. In JSX, an element’s type is specified
    with a tag. The tag’s attributes represent the properties. The element’s children
    can be added between the opening and closing tags.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Facebook的React团队在发布React时发布了JSX，以提供一种用于创建带属性的复杂DOM树的简洁语法。他们还希望使React更像HTML和XML一样可读。在JSX中，元素的类型由标签指定。标签的属性表示属性。元素的子元素可以添加在开放和关闭标签之间。
- en: 'You can also add other JSX elements as children. If you have an unordered list,
    you can add child list item elements to it with JSX tags. It looks very similar
    to HTML:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将其他JSX元素添加为子级。如果您有一个无序列表，您可以使用JSX标记将子列表项元素添加到其中。这看起来非常类似于HTML：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: JSX works with components as well. Simply define the component using the class
    name. We pass an array of ingredients to the `IngredientsList` as a property with
    JSX, as shown in [Figure 5-1](#ingredients_jsx).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: JSX也适用于组件。只需使用类名定义组件。我们使用JSX将食材数组作为属性传递给`IngredientsList`，如图[5-1](#ingredients_jsx)所示。
- en: '![image](assets/lrc2_0501.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/lrc2_0501.png)'
- en: Figure 5-1\. Creating the IngredientsList with JSX
  id: totrans-10
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-1\. 使用JSX创建IngredientsList
- en: 'When we pass the array of ingredients to this component, we need to surround
    it with curly braces. This is called a JavaScript *expression*, and we must use
    these when passing JavaScript values to components as properties. Component properties
    will take two types: either a string or a JavaScript expression. JavaScript expressions
    can include arrays, objects, and even functions. In order to include them, you
    must surround them in curly braces.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将食材数组传递给此组件时，我们需要用花括号括起来。这被称为JavaScript *表达式*，在将JavaScript值作为属性传递给组件时必须使用这些表达式。组件属性将有两种类型：字符串或JavaScript表达式。JavaScript表达式可以包括数组、对象，甚至函数。为了包含它们，您必须将它们用花括号括起来。
- en: JSX Tips
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSX提示
- en: JSX might look familiar, and most of the rules result in syntax that’s similar
    to HTML. However, there are a few considerations you should understand when working
    with JSX.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: JSX可能看起来很熟悉，大多数规则导致的语法与HTML类似。但是，在使用JSX时，有几点需要注意。
- en: Nested components
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 嵌套组件
- en: 'JSX allows you to add components as children of other components. For example,
    inside the `IngredientsList`, we can render another component called `Ingredient`
    multiple times:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: JSX允许您将组件添加为其他组件的子级。例如，在`IngredientsList`内部，我们可以多次渲染称为`Ingredient`的另一个组件：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: className
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: className
- en: 'Since `class` is a reserved word in JavaScript, `className` is used to define
    the `class` attribute instead:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`class`在JavaScript中是保留字，因此使用`className`来定义`class`属性：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: JavaScript expressions
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaScript表达式
- en: 'JavaScript expressions are wrapped in curly braces and indicate where variables
    will be evaluated and their resulting values returned. For example, if we want
    to display the value of the `title` property in an element, we can insert that
    value using a JavaScript expression. The variable will be evaluated and its value
    returned:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 表达式被大括号包裹，指示变量在哪里被计算，并返回它们的结果值。例如，如果我们想要在一个元素中显示 `title` 属性的值，我们可以使用
    JavaScript 表达式插入该值。变量将被计算并返回其值：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Values of types other than string should also appear as JavaScript expressions:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 除了字符串之外的类型的值也应出现为 JavaScript 表达式：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Evaluation
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 评估
- en: 'The JavaScript that’s added in between the curly braces will get evaluated.
    This means that operations such as concatenation or addition will occur. This
    also means that functions found in JavaScript expressions will be invoked:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 大括号中添加的 JavaScript 将被计算。这意味着会执行连接或加法等操作。这也意味着 JavaScript 表达式中找到的函数将被调用：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Mapping Arrays with JSX
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 JSX 映射数组
- en: 'JSX is JavaScript, so you can incorporate JSX directly inside of JavaScript
    functions. For example, you can map an array to JSX elements:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: JSX 就是 JavaScript，因此可以直接将 JSX 嵌入到 JavaScript 函数中。例如，你可以将数组映射为 JSX 元素：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'JSX looks clean and readable, but it can’t be interpreted with a browser. All
    JSX must be converted into `createElement` calls. Luckily, there’s an excellent
    tool for this task: Babel.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: JSX 看起来干净易读，但不能直接在浏览器中解释。所有的 JSX 必须转换为 `createElement` 调用。幸运的是，有一个非常好的工具可以完成这项任务：[Babel](https://babeljs.io)。
- en: Babel
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[Babel](https://babeljs.io)'
- en: 'Many software languages require you to compile your source code. JavaScript
    is an interpreted language: the browser interprets the code as text, so there’s
    no need to compile JavaScript. However, not all browsers support the latest JavaScript
    syntax, and no browser supports JSX syntax. Since we want to use the latest features
    of JavaScript along with JSX, we’re going to need a way to convert our fancy source
    code into something that the browser can interpret. This process is called compiling,
    and it’s what [Babel](https://babeljs.io) is designed to do.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 许多软件语言要求您编译源代码。JavaScript 是一种解释性语言：浏览器将代码解释为文本，因此不需要编译 JavaScript。但不是所有的浏览器都支持最新的
    JavaScript 语法，也没有浏览器支持 JSX 语法。由于我们想要使用 JavaScript 的最新功能以及 JSX，我们需要一种将我们的源代码转换为浏览器可以解释的东西的方法。这个过程称为编译，这正是
    [Babel](https://babeljs.io) 的设计初衷。
- en: The first version of the project was called 6to5, and it was released in September
    2014\. 6to5 was a tool that could be used to convert ES6 syntax to ES5 syntax,
    which was more widely supported by web browsers. As the project grew, it aimed
    to be a platform to support all of the latest changes in ECMAScript. It also grew
    to support converting JSX into JavaScript. The project was renamed Babel in February
    2015.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的第一个版本被称为 6to5，并于 2014 年 9 月发布。6to5 是一个工具，可以将 ES6 语法转换为更广泛支持的 ES5 语法，以便 Web
    浏览器使用。随着项目的发展，它的目标是支持 ECMAScript 的所有最新变化。它还增加了支持将 JSX 转换为 JavaScript 的功能。该项目于
    2015 年 2 月更名为 Babel。
- en: Babel is used in production at Facebook, Netflix, PayPal, Airbnb, and more.
    Previously, Facebook had created a JSX transformer that was their standard, but
    it was soon retired in favor of Babel.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Babel 在 Facebook、Netflix、PayPal、Airbnb 等地的生产环境中被广泛使用。在此之前，Facebook 曾经创建了一个 JSX
    转换器作为他们的标准，但很快就被 Babel 取代了。
- en: 'There are many ways of working with Babel. The easiest way to get started is
    to include a link to the Babel CDN directly in your HTML, which will compile any
    code in script blocks that have a type of “text/babel.” Babel will compile the
    source code on the client before running it. Although this may not be the best
    solution for production, it’s a great way to get started with JSX:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多使用 Babel 的方法。开始的最简单方法是直接在你的 HTML 中包含 Babel CDN 的链接，这将编译任何带有“text/babel”类型的
    script 块中的代码。Babel 将在客户端运行之前编译源代码。虽然这可能不是生产环境的最佳解决方案，但这是开始使用 JSX 的一个很好的方法：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Console Warning in the Browser with In-Browser Babel
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在浏览器中使用 In-Browser Babel 时会看到控制台警告。
- en: When using the in-browser transformer, you’ll see a warning that says to precompile
    scripts for production. Don’t worry about that warning for the purposes of this
    and any other small demos. We’ll upgrade to production-ready Babel later in the
    chapter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用浏览器内转换器时，你会看到一个警告，提示要为生产环境预编译脚本。对于这个和其他小型演示项目，不必担心这个警告。我们将在本章后面升级到生产准备好的
    Babel。
- en: Recipes as JSX
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSX 作为食谱
- en: JSX provides us with a nice, clean way to express React elements in our code
    that makes sense to us and is immediately readable by developers. The drawback
    of JSX is that it’s not readable by the browser. Before our code can be interpreted
    by the browser, it needs to be converted from JSX into JavaScript.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: JSX 为我们提供了一种漂亮而干净的方式来在代码中表达 React 元素，这对我们来说很有意义，并且对开发人员来说是立即可读的。JSX 的缺点是它对浏览器不可读。在我们的代码可以被浏览器解释之前，它需要从
    JSX 转换为 JavaScript。
- en: 'This data array contains two recipes, and this represents our application’s
    current state:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此数据数组包含两个食谱，并代表我们应用程序的当前状态：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The data is expressed in an array of two JavaScript objects. Each object contains
    the name of the recipe, a list of the ingredients required, and a list of steps
    necessary to cook the recipe.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 数据表达为一个包含两个 JavaScript 对象的数组。每个对象包含食谱的名称、所需的配料列表和烹饪食谱所需的步骤列表。
- en: 'We can create a UI for these recipes with two components: a `Menu` component
    for listing the recipes and a `Recipe` component that describes the UI for each
    recipe. It’s the `Menu` component that we’ll render to the DOM. We’ll pass our
    data to the `Menu` component as a property called `recipes`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用两个组件创建这些食谱的 UI：一个 `Menu` 组件用于列出食谱，一个 `Recipe` 组件用于描述每个食谱的 UI。我们将渲染 `Menu`
    组件到 DOM 中。我们将我们的数据作为名为 `recipes` 的属性传递给 `Menu` 组件：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The React elements within the `Menu` component are expressed as JSX. Everything
    is contained within an `article` element. A `header` element, an `h1` element,
    and a `div.recipes` element are used to describe the DOM for our menu. The value
    for the `title` property will be displayed as text within the `h1`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`Menu` 组件中的 React 元素被表达为 JSX。所有内容都包含在 `article` 元素内。使用 `header` 元素、`h1` 元素和
    `div.recipes` 元素来描述我们菜单的 DOM。`title` 属性的值将作为文本显示在 `h1` 元素内：'
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Inside of the `div.recipes` element, we add a component for each recipe:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `div.recipes` 元素内部，我们为每个食谱添加一个组件：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In order to list the recipes within the `div.recipes` element, we use curly
    braces to add a JavaScript expression that will return an array of children. We
    can use the `map` function on the `props.recipes` array to return a component
    for each object within the array. As mentioned previously, each recipe contains
    a name, some ingredients, and cooking instructions (steps). We’ll need to pass
    this data to each `Recipe` as props. Also remember that we should use the `key`
    property to uniquely identify each element.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 `div.recipes` 元素内列出食谱，我们使用花括号添加一个 JavaScript 表达式，该表达式将返回一个子元素数组。我们可以在 `props.recipes`
    数组上使用 `map` 函数，为数组中的每个对象返回一个组件。如前所述，每个食谱包含名称、一些配料和烹饪说明（步骤）。我们需要将这些数据作为 props 传递给每个
    `Recipe`。同时记住，我们应该使用 `key` 属性来唯一标识每个元素。
- en: 'You could also refactor this to use spread syntax. The JSX spread operator
    works like the object spread operator. It will add each field of the `recipe`
    object as a property of the `Recipe` component. The syntax here will supply all
    properties to the component:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以重构此处以使用展开语法。JSX 展开操作符类似于对象展开操作符。它将 `recipe` 对象的每个字段添加为 `Recipe` 组件的属性。这里的语法将向组件提供所有属性：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Remember that this shortcut will provide all the properties to the `Recipe`
    component. This could be a good thing but might also add too many properties to
    the component.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这种快捷方式将向 `Recipe` 组件提供所有属性。这可能是一件好事，但也可能使组件添加过多的属性。
- en: 'Another place we can make a syntax improvement to our `Menu` component is where
    we take in the `props` argument. We can use object destructuring to scope the
    variables to this function. This allows us to access the `title` and `recipes`
    variables directly, no longer having to prefix them with `props`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在接受 `props` 参数的 `Menu` 组件的另一个位置进行语法改进。我们可以使用对象解构将变量作用域限定到这个函数中。这使我们可以直接访问
    `title` 和 `recipes` 变量，而无需再以 `props` 为前缀：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now let’s code the component for each individual recipe:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为每个单独的食谱编写组件：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Each recipe has a string for the name, an array of objects for ingredients,
    and an array of strings for the steps. Using object destructuring, we can tell
    this component to locally scope those fields by name so we can access them directly
    without having to use `props.name`, `props.ingredients`, or `props.steps`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 每个食谱都有一个名称字符串，一个对象数组作为配料，以及一个字符串数组作为步骤。使用对象解构，我们可以告诉这个组件通过名称将这些字段本地作用域化，这样我们可以直接访问它们，而不必使用
    `props.name`、`props.ingredients` 或 `props.steps`。
- en: The first JavaScript expression we see is being used to set the `id` attribute
    for the root `section` element. It’s converting the recipe’s name to a lowercase
    string and globally replacing spaces with dashes. The result is that “Baked Salmon”
    will be converted to “baked-salmon” (and likewise, if we had a recipe with the
    name “Boston Baked Beans,” it would be converted to “boston-baked-beans”) before
    it’s used as the `id` attribute in our UI. The value for `name` is also being
    displayed in an `h1` as a text node.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到的第一个JavaScript表达式用于为根`section`元素设置`id`属性。它将配方名称转换为小写字符串，并全局替换空格为破折号。结果是“烤鲑鱼”将被转换为“baked-salmon”（同样地，如果我们有一个名为“Boston
    Baked Beans”的配方，它将被转换为“boston-baked-beans”），然后用作UI中的`id`属性。`name`的值也作为文本节点显示在`h1`中。
- en: Inside of the unordered list, a JavaScript expression is mapping each ingredient
    to an `li` element that displays the name of the ingredient. Within our instructions
    section, we see the same pattern being used to return a paragraph element where
    each step is displayed. These `map` functions are returning arrays of child elements.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在无序列表内部，JavaScript表达式正在将每个成分映射到显示成分名称的`li`元素。在我们的说明部分中，我们看到相同的模式被用来返回一个段落元素，其中显示每个步骤。这些`map`函数返回子元素的数组。
- en: 'The complete code for the application should look like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的完整代码应如下所示：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When we run this code in the browser, React will construct a UI using our instructions
    with the recipe data as shown in [Figure 5-2](#delicious_recipes).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在浏览器中运行此代码时，React将使用我们的说明和配方数据构建UI，如[图 5-2](#delicious_recipes)所示。
- en: If you’re using Google Chrome and have the React Developer Tools Extension installed,
    you can take a look at the present state of the component tree. To do this, open
    the developer tools and select the Components tab, as shown in [Figure 5-3](#react_tab5).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用Google Chrome并安装了React开发者工具扩展程序，您可以查看组件树的当前状态。要做到这一点，请打开开发者工具并选择组件选项卡，如[图 5-3](#react_tab5)所示。
- en: Here we can see the `Menu` and its child elements. The `data` array contains
    two objects for recipes, and we have two `Recipe` elements. Each `Recipe` element
    has properties for the recipe name, ingredients, and steps. The ingredients and
    steps are passed down to their own components as `data`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们可以看到`Menu`及其子元素。`data`数组包含两个配方对象，我们有两个`Recipe`元素。每个`Recipe`元素都有配方名称、成分和步骤属性。成分和步骤作为`data`传递给它们自己的组件。
- en: The components are constructed based on the application’s data being passed
    to the `Menu` component as a property. If we change the `recipes` array and rerender
    our `Menu` component, React will change this DOM as efficiently as possible.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件是基于应用程序传递给`Menu`组件的数据构建的属性。如果我们更改`recipes`数组并重新渲染我们的`Menu`组件，React会尽可能高效地更改这个DOM。
- en: '![image](assets/lrc2_0502.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/lrc2_0502.png)'
- en: Figure 5-2\. Delicious Recipes output
  id: totrans-69
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-2\. 美味食谱输出
- en: '![image](assets/lrc2_0503.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/lrc2_0503.png)'
- en: Figure 5-3\. Resulting virtual DOM in React Developer Tools
  id: totrans-71
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-3\. React开发者工具中的结果虚拟DOM
- en: React Fragments
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React Fragments
- en: 'In the previous section, we rendered the `Menu` component, a parent component
    that rendered the `Recipe` component. We want to take a moment to look at a small
    example of rendering two sibling components using a React fragment. Let’s start
    by creating a new component called `Cat` that we’ll render to the DOM at the `root`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们渲染了`Menu`组件，一个渲染`Recipe`组件的父组件。我们想花点时间看一个使用React片段渲染两个兄弟组件的小例子。让我们从创建一个称为`Cat`的新组件开始，在`root`上将其呈现到DOM中：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This will render the `h1` as expected, but what might happen if we added a `p`
    tag to the `Cat` component at the same level as the `h1`?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这将按预期渲染`h1`，但如果我们在`Cat`组件的与`h1`同级添加了`p`标签，会发生什么呢？
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Immediately, we’ll see an error in the console that reads `Adjacent JSX elements
    must be wrapped in an enclosing tag` and recommends using a fragment. This is
    where fragments come into play! React will not render two or more adjacent or
    sibling elements as a component, so we used to have to wrap these in an enclosing
    tag like a `div`. This led to a lot of unnecessary tags being created, though,
    and a bunch of wrappers without much purpose. If we use a React fragment, we can
    mimic the behavior of a wrapper without actually creating a new tag.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 立即，在控制台中我们将看到一个错误，显示`相邻的JSX元素必须包裹在一个封闭标签中`并建议使用片段。这就是片段发挥作用的地方！React不会将两个或更多相邻或兄弟元素渲染为一个组件，所以我们过去必须将它们包装在像`div`这样的封闭标签中。然而，这导致创建了许多不必要的标签和一堆没有太多用途的包装器。如果我们使用React片段，我们可以模仿包装器的行为，而不实际创建一个新标签。
- en: 'Start by wrapping the adjacent tags, the `h1` and `p`, with a `React.Fragment`
    tag:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 首先用一个`React.Fragment`标签包装相邻的标签，比如`h1`和`p`：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Adding this clears the warning. You also can use a fragment shorthand to make
    this look even cleaner:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这个可以清除警告。您还可以使用片段的简写方式，使其看起来更加清晰：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you look at the DOM, the fragment is not visible in the resulting tree:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看DOM，您将看不到片段在生成树中的存在：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Fragments are a relatively new feature of React and do away with the need for
    extra wrapper tags that can pollute the DOM.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 片段是React的一个相对较新的功能，摒弃了需要额外包装标签的需求，这些标签可能会污染DOM。
- en: Intro to webpack
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: webpack简介
- en: 'Once we start working with React in real projects, there are a lot of questions
    to consider: How do we want to deal with JSX and ESNext transformation? How can
    we manage our dependencies? How can we optimize our images and CSS?'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在实际项目中开始使用React，就会有很多问题需要考虑：我们如何处理JSX和ESNext转换？我们如何管理我们的依赖关系？如何优化我们的图像和CSS？
- en: Many different tools have emerged to answer these questions, including Browserify,
    gulp, Grunt, Prepack, and more. Due to its features and widespread adoption by
    large companies, *webpack* has also emerged as one of the leading tools for bundling.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 出现了许多不同的工具来解决这些问题，包括Browserify、gulp、Grunt、Prepack等等。由于其功能和大公司的广泛采用，*webpack*也成为了捆绑工具中的领先者之一。
- en: The React ecosystem has matured to include tools like create-react-app, Gatsby,
    and Code Sandbox. When you use these tools, a lot of the details about how the
    code gets compiled are abstracted away. For the remainder of this chapter, we
    are going to set up our own webpack build. This day in age, understanding that
    your JavaScript/React code is being compiled by something like webpack is vital,
    but knowing *how* to compile your JavaScript/React with something like webpack
    is not as important. We understand if you want to skip ahead.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: React生态系统已经发展成包括create-react-app、Gatsby和Code Sandbox等工具。当您使用这些工具时，关于代码如何被编译的细节被抽象掉了很多。在当前这个时代，了解您的JavaScript/React代码是如何通过webpack之类的工具进行编译是至关重要的，但知道如何通过webpack之类的工具编译您的JavaScript/React并不是那么重要。如果您想跳过这部分，我们完全理解。
- en: Webpack is billed as a module bundler. A module bundler takes all of our different
    files (JavaScript, LESS, CSS, JSX, ESNext, and so on) and turns them into a single
    file. The two main benefits of bundling are *modularity* and *network performance*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack被宣传为一个模块捆绑工具。模块捆绑工具将我们的各种不同文件（JavaScript、LESS、CSS、JSX、ESNext等）转换为单一文件。捆绑的两个主要好处是*模块化*和*网络性能*。
- en: Modularity will allow you to break down your source code into parts, or modules,
    that are easier to work with, especially in a team environment.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化将允许您将源代码分解为更容易在团队环境中使用的部分或模块。
- en: 'Network performance is gained by only needing to load one dependency in the
    browser: the bundle. Each `script` tag makes an HTTP request, and there’s a latency
    penalty for each HTTP request. Bundling all the dependencies into a single file
    allows you to load everything with one HTTP request, thereby avoiding additional
    latency.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 网络性能通过在浏览器中仅需加载一个依赖项来获得：捆绑包。每个`script`标签都会发起一个HTTP请求，并且每个HTTP请求都会有延迟惩罚。将所有依赖项捆绑到一个单一文件中，可以通过一个HTTP请求加载所有内容，从而避免额外的延迟。
- en: 'Aside from code compilation, webpack also can handle:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 除了代码编译之外，webpack还可以处理：
- en: Code splitting
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 代码分割
- en: Splits up your code into different chunks that can be loaded when you need them.
    Sometimes these are called *rollups* or *layers*; the aim is to break up code
    as needed for different pages or devices.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的代码分割成不同的块，需要时可以加载这些块。有时这些被称为*rollups*或*layers*；其目的是根据不同的页面或设备需要分割代码。
- en: Minification
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 缩小
- en: Removes whitespace, line breaks, lengthy variable names, and unnecessary code
    to reduce the file size.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 删除空白、换行、冗长的变量名和不必要的代码以减少文件大小。
- en: Feature Flagging
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 功能标志
- en: Sends code to one or more—but not all—environments when testing out features.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 发送代码到一个或多个环境（但不是所有环境）以测试功能。
- en: Hot Module Replacement (HMR)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 热模块替换（HMR）
- en: Watches for changes in source code. Changes only the updated modules immediately.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 监视源代码的更改。仅更新模块会立即进行更改。
- en: 'The Recipes app we built earlier in this chapter has some limitations that
    webpack will help us alleviate. Using a tool like webpack to statically build
    client JavaScript makes it possible for teams to work together on large-scale
    web applications. We can also gain the following benefits by incorporating the
    webpack module bundler:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章早些时候构建的Recipes应用程序存在一些限制，webpack将帮助我们缓解这些限制。使用类似webpack的工具静态构建客户端JavaScript使得团队能够共同开发大型Web应用程序成为可能。通过集成webpack模块打包器，我们还可以获得以下好处：
- en: Modularity
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化
- en: Using the module pattern to export modules that will later be imported or required
    by another part of the application makes source code more approachable. It allows
    development teams to work together, by allowing them to create and work with separate
    files that will be statically combined into a single file before sending to production.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模块模式导出模块，这些模块稍后将被应用程序的另一部分导入或要求，使源代码更易于理解。它允许开发团队一起工作，通过允许他们创建和使用将在发送到生产之前静态组合成单个文件的单独文件。
- en: Composition
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 组合
- en: With modules, we can build small, simple, reusable React components that we
    can compose efficiently into applications. Smaller components are easier to comprehend,
    test, and reuse. They’re also easier to replace down the line when enhancing applications.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模块，我们可以构建小型、简单、可重用的React组件，可以高效地组合到应用程序中。较小的组件更容易理解、测试和重用。在增强应用程序时，它们也更容易替换。
- en: Speed
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 速度
- en: Packaging all the application’s modules and dependencies into a single client
    bundle will reduce the load time of an application because there’s latency associated
    with each HTTP request. Packaging everything together in a single file means that
    the client will only need to make a single request. Minifying the code in the
    bundle will improve load time as well.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序的所有模块和依赖项打包成一个单一的客户端包将减少应用程序的加载时间，因为每个HTTP请求都有延迟。将所有内容打包到单个文件中意味着客户端只需发出一个请求。在包中进行代码缩小也会改善加载时间。
- en: Consistency
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性
- en: Since webpack will compile JSX and JavaScript, we can start using tomorrow’s
    JavaScript syntax today. Babel supports a wide range of ESNext syntax, which means
    we don’t have to worry about whether the browser supports our code. It allows
    developers to consistently use cutting-edge JavaScript syntax.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于webpack将编译JSX和JavaScript，我们可以开始使用未来的JavaScript语法。Babel支持广泛的ESNext语法，这意味着我们不必担心浏览器是否支持我们的代码。它允许开发人员始终使用最新的JavaScript语法。
- en: Creating the Project
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建项目
- en: 'To demonstrate how we might set up a React project from scratch, let’s go ahead
    and create a new folder on our computer called *recipes-app*:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何从头开始设置一个React项目，让我们在计算机上创建一个名为*recipes-app*的新文件夹：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'For this project, we’re going to go through the following steps:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们将按以下步骤进行：
- en: Create the project.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建项目。
- en: Break down the recipe app into components that live in different files.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将配方应用程序分解为存储在不同文件中的组件。
- en: Set up a webpack build that incorporates Babel.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个集成了Babel的webpack构建。
- en: create-react-app
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: create-react-app
- en: There’s a tool called Create React App that can be used to autogenerate a React
    project with all of this preconfigured. We’re going to take a closer look at what’s
    happening behind the scenes before abstracting these steps away with a tool.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个工具叫做Create React App，可以用来自动配置预先配置的React项目。在使用工具之前，我们将更仔细地看看幕后发生了什么。
- en: 1\. Create the project
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1\. 创建项目
- en: 'Next, we’ll create the project and *package.json* file with npm, sending the
    `-y` flag to use all of the defaults. We’ll also install webpack, webpack-cli,
    react, and react-dom:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用npm创建项目和*package.json*文件，发送`-y`标志以使用所有默认值。我们还将安装webpack，webpack-cli，react和react-dom：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If we’re using npm 5, we don’t need to send the `--save` flag when installing.
    Next, we’ll create the following directory structure to house the components:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用npm 5，则在安装时不需要发送`--save`标志。接下来，我们将创建以下目录结构来存放组件：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: File Organization
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件组织
- en: There’s no one way to organize the files in a React project. This is just one
    possible strategy.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一种固定的方法可以组织 React 项目中的文件。这只是一种可能的策略。
- en: 2\. Break components into modules
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2\. 将组件拆分为模块
- en: 'Currently, the `Recipe` component is doing quite a bit. We’re displaying the
    name of the recipe, constructing an unordered list of ingredients, and displaying
    the instructions, with each step getting its own paragraph element. This component
    should be placed in the *Recipe.js* file. In any file where we’re using JSX, we’ll
    need to import React at the top:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`Recipe` 组件做了相当多的工作。我们显示了食谱的名称，构建了一个无序的食材列表，并显示了说明，每个步骤都有自己的段落元素。此组件应该放置在
    *Recipe.js* 文件中。在任何使用 JSX 的文件中，我们都需要在顶部导入 React：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: A more functional approach to the `Recipe` component would be to break it down
    into smaller, more focused function components and compose them together. We can
    start by pulling the instructions out into their own component and creating a
    module in a separate file we can use for any set of instructions.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `Recipe` 组件的功能性方法更改为将其分解为更小、更专注的函数组件，并将它们组合在一起会更加有效。我们可以从中将说明提取出来，并在单独的文件模块中创建一个我们可以用于任何说明集的模块。
- en: 'In that new file called *Instructions.js*, create the following component:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在名为 *Instructions.js* 的新文件中，创建以下组件：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, we’ve created a new component called `Instructions`. We’ll pass the title
    of the instructions and the steps to this component. This way, we can reuse this
    component for “Cooking Instructions,” “Baking Instructions,” “Prep Instructions,”
    or a “Pre-cook Checklist”—anything that has steps.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为 `Instructions` 的新组件。我们将标题和步骤传递给这个组件。这样，我们可以为“烹饪说明”、“烘焙说明”、“准备说明”或“预先烹饪清单”等任何具有步骤的内容重复使用此组件。
- en: 'Now think about the ingredients. In the `Recipe` component, we’re only displaying
    the ingredient names, but each ingredient in the data for the recipe has an amount
    and measurement as well. We’ll create a component called `Ingredient` for this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑食材。在 `Recipe` 组件中，我们仅显示食材的名称，但是食谱数据中的每个食材还具有数量和测量单位。我们将创建一个名为 `Ingredient`
    的组件来处理这个问题：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, we assume each ingredient has an amount, a measurement, and a name. We
    destructure those values from our `props` object and display them each in independent
    classed `span` elements.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们假设每个食材都有数量、测量单位和名称。我们从 `props` 对象中解构这些值，并分别在独立的 `span` 元素中显示它们。
- en: 'Using the `Ingredient` component, we can construct an `IngredientsList` component
    that can be used any time we need to display a list of ingredients:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Ingredient` 组件，我们可以构建一个 `IngredientsList` 组件，可以在需要显示食材列表的任何时候使用：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this file, we first import the `Ingredient` component because we’re going
    to use it for each ingredient. The ingredients are passed to this component as
    an array in a property called `list`. Each ingredient in the `list` array will
    be mapped to the `Ingredient` component. The JSX spread operator is used to pass
    all the data to the `Ingredient` component as props.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我们首先导入 `Ingredient` 组件，因为我们将在每个食材中使用它。食材被作为名为 `list` 的属性的数组传递给此组件。数组中的每个食材将被映射到
    `Ingredient` 组件。使用 JSX 展开运算符将所有数据传递给 `Ingredient` 组件作为 props。
- en: 'Using spread operator:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用展开运算符：
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'is another way of expressing:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 是另一种表达方式：
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'So, given an ingredient with these fields:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，给定具有以下字段的成分：
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We get:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到：
- en: '[PRE31]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now that we have components for ingredients and instructions, we can compose
    recipes using these components:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了用于食材和说明的组件，我们可以使用这些组件组合食谱：
- en: '[PRE32]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'First, we import the components we’re going to use: `IngredientsList` and `Instructions`.
    Now we can use them to create the `Recipe` component. Instead of a bunch of complicated
    code building out the entire recipe in one place, we’ve expressed our recipe more
    declaratively by composing smaller components. Not only is the code nice and simple,
    but it also reads well. This shows us that a recipe should display the name of
    the recipe, a list of ingredients, and some cooking instructions. We’ve abstracted
    away what it means to display ingredients and instructions into smaller, simple
    components.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入我们将要使用的组件：`IngredientsList` 和 `Instructions`。现在我们可以使用它们来创建 `Recipe` 组件。与在一个地方构建整个食谱的一堆复杂代码不同，我们通过组合较小的组件更声明式地表达了我们的食谱。不仅代码简洁易懂，而且阅读起来也很舒适。这告诉我们，一个食谱应该显示食谱的名称、食材列表和一些烹饪说明。我们将显示食材和说明的含义抽象成了更小更简单的组件。
- en: 'In a modular approach, the `Menu` component would look pretty similar. The
    key difference is that it would live in its own file, import the modules it needs
    to use, and export itself:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块化方法中，`Menu`组件看起来会非常相似。关键区别在于它将存在于自己的文件中，导入它需要使用的模块，并将自身导出：
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We still need to use ReactDOM to render the `Menu` component. The main file
    for the project is *index.js*. This will be responsible for rendering the component
    to the DOM.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要使用ReactDOM来渲染`Menu`组件。项目的主文件是*index.js*。这将负责将组件渲染到DOM中。
- en: 'Let’s create this file:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建这个文件：
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The first four statements import the necessary modules for our app to work.
    Instead of loading `react` and `react-dom` via the `script` tag, we import them
    so webpack can add them to our bundle. We also need the `Menu` component and a
    sample data array that has been moved to a separate module. It still contains
    two recipes: Baked Salmon and Fish Tacos.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 前四个语句导入了我们应用程序工作所需的模块。我们不是通过`script`标签加载`react`和`react-dom`，而是导入它们，以便webpack将它们添加到我们的捆绑包中。我们还需要`Menu`组件和已移至单独模块的样本数据数组。它仍然包含两个食谱：烤三文鱼和鱼肉玉米饼。
- en: All of our imported variables are local to the *index.js* file. When we render
    the `Menu` component, we pass the array of recipe data to this component as a
    property.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所有导入的变量都是局限于*index.js*文件。当我们渲染`Menu`组件时，我们将食谱数据数组作为属性传递给此组件。
- en: 'The data is being pulled from the *recipes.json* file. This is the same data
    we used earlier in the chapter, but now it’s following valid JSON formatting rules:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 数据来自*recipes.json*文件。这与我们本章早些时候使用的数据相同，但现在遵循有效的JSON格式化规则：
- en: '[PRE35]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now that we’ve pulled our code apart into separate modules and files, let’s
    create a build process with webpack that will put everything back together into
    a single file. You may be thinking, “Wait, we just did all of that work to break
    everything apart, and now we’re going to use a tool to put it back together? Why
    on Earth…?” Splitting projects into separate files typically makes larger projects
    easier to manage because team members can work on separate components without
    overlap. It also means that files can be easier to test.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将代码拆分为单独的模块和文件，让我们使用webpack创建一个构建过程，将所有内容重新组合到一个单一文件中。你可能会想，“等等，我们刚刚把所有工作都分开了，现在我们要使用一个工具把它们重新放在一起？为什么会这样……？”将项目拆分为单独文件通常使得更大的项目更易于管理，因为团队成员可以在没有重叠的情况下工作在不同的组件上。这也意味着文件可能更容易测试。
- en: 3\. Creating the webpack build
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3\. 创建webpack构建
- en: 'In order to create a static build process with webpack, we’ll need to install
    a few things. Everything we need can be installed with npm:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用webpack创建静态构建过程，我们需要安装一些东西。我们需要的所有内容都可以通过npm安装：
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Remember that we’ve already installed React and ReactDOM.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们已经安装了React和ReactDOM。
- en: For this modular Recipes app to work, we’re going to need to tell webpack how
    to bundle our source code into a single file. As of version 4.0.0, webpack does
    not require a configuration file to bundle a project. If we don’t include a config
    file, webpack will run the defaults to package our code. Using a config file,
    though, means we’ll be able to customize our setup. Plus, this shows us some of
    the magic of webpack instead of hiding it away. The default webpack configuration
    file is always *webpack.config.js*.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要使此模块化Recipes应用程序正常工作，我们需要告诉webpack如何将我们的源代码捆绑成一个单独的文件。从版本4.0.0开始，webpack不需要配置文件来捆绑项目。如果我们不包含配置文件，webpack将运行默认设置来打包我们的代码。不过，使用配置文件意味着我们可以自定义我们的设置。此外，这也展示了webpack的一些魔法而不是将其隐藏起来。默认的webpack配置文件始终是*webpack.config.js*。
- en: The starting file for our Recipes app is *index.js*. It imports React, ReactDOM,
    and the *Menu.js* file. This is what we want to run in the browser first. Wherever
    webpack finds an `import` statement, it will find the associated module in the
    filesystem and include it in the bundle. *index.js* imports *Menu.js*, *Menu.js*
    imports *Recipe.js*, *Recipe.js* imports *Instructions.js* and *IngredientsList.js*,
    and *IngredientsList.js* imports *Ingredient.js*. Webpack will follow this import
    tree and include all of these necessary modules in our bundle. Traversal through
    all these files creates what’s called a *dependency graph*. A dependency is just
    something our app needs, like a component file, a library file like React, or
    an image. Picture each file we need as a circle on the graph, with webpack drawing
    all the lines between the circles to create the graph. That graph is the bundle.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Recipes 应用程序的起始文件是 *index.js*。它导入了 React、ReactDOM 和 *Menu.js* 文件。这是我们首先要在浏览器中运行的内容。无论
    webpack 在哪里找到 `import` 语句，它都会在文件系统中找到关联的模块并将其包含在捆绑包中。*index.js* 导入 *Menu.js*，*Menu.js*
    导入 *Recipe.js*，*Recipe.js* 导入 *Instructions.js* 和 *IngredientsList.js*，*IngredientsList.js*
    导入 *Ingredient.js*。Webpack 将遵循这个导入树并在捆绑包中包含所有必要的模块。遍历所有这些文件创建了所谓的 *依赖图*。依赖只是我们应用程序需要的东西，例如组件文件、像
    React 这样的库文件或图像。想象一下，我们需要的每个文件都是图上的一个圆圈，webpack 会在这些圆圈之间画线来创建图。这个图就是捆绑包。
- en: Import Statements
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入语句
- en: We’re using `import` statements, which are not presently supported by most browsers
    or by Node.js. The reason `import` statements work is that Babel will convert
    them into `require('module/path');` statements in our final code. The `require`
    function is how CommonJS modules are typically loaded.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用 `import` 语句，这在大多数浏览器或 Node.js 中目前不受支持。`import` 语句能工作的原因是，Babel 将它们转换为我们最终代码中的
    `require('module/path');` 语句。`require` 函数通常是加载 CommonJS 模块的方式。
- en: As webpack builds our bundle, we need to tell it to transform JSX to React elements.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当 webpack 构建我们的捆绑包时，我们需要告诉它将 JSX 转换为 React 元素。
- en: 'The *webpack.config.js* file is just another module that exports a JavaScript
    literal object that describes the actions webpack should take. The configuration
    file should be saved to the root folder of the project, right next to the *index.js*
    file:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*webpack.config.js* 文件只是另一个模块，它导出一个描述 webpack 应采取的操作的 JavaScript 字面对象。配置文件应保存在项目的根文件夹中，就在
    *index.js* 文件旁边：'
- en: '[PRE37]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: First, we tell webpack that our client entry file is *./src/index.js*. It will
    automatically build the dependency graph based on `import` statements starting
    in that file. Next, we specify that we want to output a bundled JavaScript file
    to *./dist/bundle.js*. This is where webpack will place the final packaged JavaScript.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们告诉 webpack 我们的客户端入口文件是 *./src/index.js*。它将根据该文件中的 `import` 语句自动构建依赖图。接下来，我们指定我们希望输出到
    *./dist/bundle.js* 的捆绑 JavaScript 文件。这是 webpack 将最终打包的 JavaScript 放置的地方。
- en: 'Next, let’s install the necessary Babel dependencies. We’ll need `babel-loader`
    and `@babel/core`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们安装必要的 Babel 依赖项。我们需要 `babel-loader` 和 `@babel/core`：
- en: '[PRE38]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The next set of instructions for webpack consists of a list of loaders to run
    on specified modules. This will be added to the config file under the `module`
    field:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: webpack 的下一组指令包括要在指定模块上运行的加载器列表。这将添加到配置文件的 `module` 字段下：
- en: '[PRE39]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `rules` field is an array because there are many types of loaders you can
    incorporate with webpack. In this example, we’re only incorporating the `babel-loader`.
    Each loader is a JavaScript object. The `test` field is a regular expression that
    matches the file path of each module that the loader should operate on. In this
    case, we’re running the `babel-loader` on all imported JavaScript files except
    those found in the *node_modules* folder.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`rules` 字段是一个数组，因为有许多类型的加载器可以与 webpack 配合使用。在这个例子中，我们只集成了 `babel-loader`。每个加载器都是一个
    JavaScript 对象。`test` 字段是一个正则表达式，匹配加载器应该操作的每个模块的文件路径。在这种情况下，我们在所有导入的 JavaScript
    文件上运行 `babel-loader`，除了在 *node_modules* 文件夹中找到的那些文件。'
- en: 'At this point, we need to specify presets for running Babel. When we set a
    preset, we tell Babel which transforms to perform. In other words, we can say,
    “Hey Babel. If you see some ESNext syntax here, go ahead and transform that code
    into syntax we’re sure the browser understands. If you see some JSX, transform
    that too.” Start by installing the presets:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们需要为运行 Babel 指定预设。当我们设置预设时，我们告诉 Babel 应该执行哪些转换。换句话说，我们可以说，“嘿，Babel。如果你在这里看到一些
    ESNext 语法，请将该代码转换为我们确保浏览器理解的语法。如果你看到一些 JSX，请也进行转换。”首先安装预设：
- en: '[PRE40]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then create one more file at the root of the project: `.babelrc`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在项目的根目录创建另一个文件：`.babelrc`：
- en: '[PRE41]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'All right! We’ve created something pretty cool: a project that resembles a
    real React app! Let’s go ahead and run webpack to make sure this works.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 好了！我们创建了一个看起来像是真正的 React 应用程序的项目！让我们继续运行 webpack 来确保它可以工作。
- en: 'Webpack is run statically. Typically, bundles are created before the app is
    deployed to the server. You can run it from the command line using npx:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack 是静态运行的。通常，在将应用程序部署到服务器之前就会创建捆绑文件。你可以使用 npx 命令行运行它：
- en: '[PRE42]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Webpack will either succeed and create a bundle or fail and show you an error.
    Most errors have to do with broken import references. When debugging webpack errors,
    look closely at the filenames and file paths used in `import` statements.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack 要么成功创建一个捆绑包，要么失败并显示错误。大多数错误与损坏的导入引用有关。在调试 webpack 错误时，仔细查看 `import`
    语句中使用的文件名和文件路径。
- en: 'You can also add an npm script to your *package.json* file to create a shortcut:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在 *package.json* 文件中添加一个 npm 脚本来创建一个快捷方式：
- en: '[PRE43]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then you can run the shortcut to generate the bundle:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以运行一个快捷方式来生成捆绑包：
- en: '[PRE44]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Loading the Bundle
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载捆绑包
- en: 'We have a bundle, so now what? We exported the bundle to the *dist* folder.
    This folder contains the files we want to run on the web server. The *dist* folder
    is where the *index.html* file should be placed. This file needs to include a
    target `div` element where the React `Menu` component will be mounted. It also
    requires a single `script` tag that will load our bundled JavaScript:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有了一个捆绑包，现在怎么办？我们将捆绑包导出到 *dist* 文件夹中。这个文件夹包含我们希望在 Web 服务器上运行的文件。*dist* 文件夹是应该放置
    *index.html* 文件的地方。这个文件需要包含一个目标 `div` 元素，用于安装 React `Menu` 组件。它还需要一个单独的 `script`
    标签来加载我们捆绑的 JavaScript：
- en: '[PRE45]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This is the home page for your app. It will load everything it needs from one
    file, one HTTP request: *bundle.js*. You’ll need to deploy these files to your
    web server or build a web server application that will serve these files with
    something like Node.js or Ruby on Rails.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你的应用程序的主页。它将从一个文件中加载所有需要的内容，一个 HTTP 请求：*bundle.js*。你需要将这些文件部署到你的 Web 服务器上，或者构建一个
    Web 服务器应用程序，使用类似 Node.js 或 Ruby on Rails 这样的工具来提供这些文件。
- en: Source Mapping
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 源映射
- en: Bundling our code into a single file can cause some setbacks when it comes time
    to debug the application in the browser. We can eliminate this problem by providing
    a *source map*. A source map is a file that maps a bundle to the original source
    files. With webpack, all we have to do is add a couple lines to our *webpack.config.js*
    file.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的代码打包成一个单独的文件可能导致在浏览器中调试应用程序时遇到一些问题。我们可以通过提供一个 *source map* 来消除这个问题。源映射是一个将捆绑文件映射到原始源文件的文件。使用
    webpack，我们只需在 *webpack.config.js* 文件中添加几行代码即可。
- en: '[PRE46]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Setting the `devtool` property to `''#source-map''` tells webpack that you
    want to use source mapping. The next time you run webpack, you’ll see that two
    output files are generated and added to the *dist* folder: the original *bundle.js*
    and *bundle.js.map*.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `devtool` 属性设置为 `'#source-map'` 告诉 webpack 你想要使用源映射。下次运行 webpack 时，你会看到生成并添加到
    *dist* 文件夹中的两个输出文件：原始的 *bundle.js* 和 *bundle.js.map*。
- en: The source map is going to let you debug using your original source files. In
    the Sources tab of your browser’s developer tools, you should find a folder named
    *webpack://*. Inside of this folder, you’ll see all the source files in your bundle,
    as shown in [Figure 5-4](#sources_panel).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用源映射将让你可以使用原始的源文件进行调试。在浏览器开发者工具的 Sources 标签页中，你应该会找到一个名为 *webpack://* 的文件夹。在这个文件夹中，你会看到捆绑包中的所有源文件，如
    [图 5-4](#sources_panel) 所示。
- en: '![image](assets/lrc2_0504.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/lrc2_0504.png)'
- en: Figure 5-4\. Sources panel of Chrome Developer Tools
  id: totrans-199
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-4\. Chrome 开发者工具的 Sources 面板
- en: You can debug from these files using the browser step-through debugger. Clicking
    on any line number adds a breakpoint. Refreshing the browser will pause JavaScript
    processing when any breakpoints are reached in your source file. You can inspect
    scoped variables in the Scope panel or add variables to watch in the Watch panel.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用浏览器的逐步调试器从这些文件中调试。点击任何行号都会添加一个断点。刷新浏览器将会在你的源文件中的任何断点处暂停 JavaScript 处理。你可以在
    Scope 面板中检查作用域变量或在 Watch 面板中添加要监视的变量。
- en: Create React App
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 React 应用程序
- en: A pretty amazing tool to have at your disposal as a React developer is Create
    React App, a command-line tool that autogenerates a React project. Create React
    App was inspired by the [Ember CLI project](https://ember-cli.com), and it lets
    developers get started with React projects quickly without the manual configuration
    of webpack, Babel, ESLint, and associated tools.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 作为React开发者的一个非常棒的工具是Create React App，一个命令行工具，可以自动生成React项目。Create React App的灵感来自于[Ember
    CLI项目](https://ember-cli.com)，它使开发者可以快速开始React项目，无需手动配置webpack、Babel、ESLint和相关工具。
- en: 'To get started with Create React App, install the package globally:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Create React App，请全局安装该包：
- en: '[PRE47]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Then, use the command and the name of the folder where you’d like the app to
    be created:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用命令和您想要创建应用程序的文件夹的名称：
- en: '[PRE48]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: npx
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: npx
- en: You can also use npx to run Create React App without the need for a global install.
    Simply run `npx create-react-app my-project`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用npx运行Create React App，而无需全局安装。只需运行`npx create-react-app my-project`。
- en: 'This will create a React project in that directory with just three dependencies:
    React, ReactDOM, and `react-scripts`. `react-scripts` was also created by Facebook
    and is where the real magic happens. It installs Babel, ESLint, webpack, and more
    so that you don’t have to configure them manually. Within the generated project
    folder, you’ll also find a *src* folder containing an *App.js* file. Here, you
    can edit the root component and import other component files.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在该目录中创建一个React项目，仅依赖于三个库：React、ReactDOM和`react-scripts`。`react-scripts`也是由Facebook创建的，是真正魔力发生的地方。它安装了Babel、ESLint、webpack等，让您无需手动配置它们。在生成的项目文件夹中，您还会找到一个*src*文件夹，其中包含一个*App.js*文件。在这里，您可以编辑根组件并导入其他组件文件。
- en: From within the *my-react-project* folder, you can run `npm start`. If you prefer,
    you can also run `yarn start`. This will start your application on port 3000.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 从*my-react-project*文件夹内部，您可以运行`npm start`。如果您喜欢，也可以运行`yarn start`。这将在端口3000上启动您的应用程序。
- en: You can run tests with `npm test` or `yarn test`. This runs all of the test
    files in the project in an interactive mode.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`npm test`或`yarn test`来运行测试。这将以交互模式运行项目中的所有测试文件。
- en: You can also run the `npm run build` command. Using yarn, run `yarn build`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以运行`npm run build`命令。使用yarn，运行`yarn build`。
- en: This will create a production-ready bundle that has been transformed and minified.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个经过转换和缩小的生产就绪捆绑包。
- en: Create React App is a great tool for beginners and experienced React developers
    alike. As the tool evolves, more functionality will likely be added, so you can
    keep an eye on the changes on [GitHub](https://github.com/facebook/create-react-app).
    Another way to get started with React without having to worry about setting up
    your own customized webpack build is to use CodeSandbox. CodeSandbox is an IDE
    that runs online at [*https://codesandbox.io*](https://codesandbox.io).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Create React App不仅适合初学者，也适合有经验的React开发者。随着工具的发展，可能会增加更多功能，您可以关注[GitHub](https://github.com/facebook/create-react-app)上的变化。另一个不必担心设置自定义webpack构建的React起步方式是使用CodeSandbox。CodeSandbox是一个在线运行的IDE，网址为[*https://codesandbox.io*](https://codesandbox.io)。
- en: In this chapter, we leveled up our React skills by learning about JSX. We created
    components. We broke those components into a project structure, and we learned
    more about Babel and webpack. Now we’re ready to take our knowledge of components
    to the next level. It’s time to talk about Hooks.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过学习JSX提升了我们的React技能。我们创建了组件。我们将这些组件分解成一个项目结构，并且我们更多地了解了Babel和webpack。现在我们准备将组件知识提升到下一个级别。是时候谈谈Hooks了。
