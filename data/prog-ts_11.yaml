- en: Chapter 11\. Interoperating with JavaScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。与 JavaScript 的互操作
- en: We don’t live in a perfect world. Your coffee can be too hot and burn your mouth
    a little when you drink it, your parents might call and leave you voicemails a
    little too often, that pothole by your driveway is still there no matter how many
    times you call the city, and your code might not be completely covered with static
    types.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不生活在一个完美的世界。你的咖啡可能太烫，喝的时候会烫到嘴；你的父母可能会频繁地打电话给你留言；你家门口的坑洼无论你怎么打电话给市政府都还在那里；你的代码可能不完全涵盖静态类型。
- en: 'Most of us are in this boat: though once in a while you’ll have the leeway
    to start a greenfield project in TypeScript, most of the time it will start as
    a little island of safety, embedded in a larger, less safe codebase. Maybe you
    have a well-isolated component that you want to try TypeScript on even though
    your company uses regular ES6 JavaScript everywhere else, or maybe you’re fed
    up with getting paged at 6 A.M. because you refactored some code and forgot to
    update a call site (it’s now 7 A.M., and you’re ninja-merging TSC into your codebase
    before your coworkers wake up). Either way, you will probably start with an island
    of TypeScript in a type-less sea.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人都处于这种情况中：尽管偶尔你会有机会在 TypeScript 中启动一个全新的项目，但大多数情况下，它将作为一个安全的小岛，嵌入在一个更大、不太安全的代码库中。也许你有一个良好隔离的组件，想要尝试在上面使用
    TypeScript，即使你的公司在其他地方都使用常规的 ES6 JavaScript，或者你因为重构了某些代码但忘记更新调用点而在凌晨 6 点被叫醒（现在已经
    7 点了，你在同事们醒来之前正在快速合并 TypeScript 编译器到你的代码库中）。无论哪种情况，你可能会从一个 TypeScript 的孤岛开始。
- en: 'So far in this book I’ve been teaching you to write TypeScript the right way.
    This chapter is about writing TypeScript the practical way, in real codebases
    that are in the process of migrating away from untyped languages, that use third-party
    JavaScript libraries, that at times sacrifice type safety for a quick hot patch
    to unbreak prod. This chapter is dedicated to working with JavaScript. We’ll explore:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中我教你如何正确编写 TypeScript。本章是关于在真实代码库中以实用的方式编写 TypeScript，这些代码库正在迁移远离无类型语言，使用第三方的
    JavaScript 库，并且有时为了快速修复生产问题而牺牲类型安全性。本章专注于与 JavaScript 的交互。我们将探讨：
- en: Using type declarations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类型声明
- en: Gradually migrating from JavaScript to TypeScript
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逐步从 JavaScript 迁移到 TypeScript
- en: Using third-party JavaScript and TypeScript
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用第三方的 JavaScript 和 TypeScript
- en: Type Declarations
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型声明
- en: 'A *type declaration* is a file with the extension *.d.ts*. Along with JSDoc
    annotations (see [“Step 2b: Add JSDoc Annotations (Optional)”](#step-2b-jsdoc)),
    it’s a way to attach TypeScript types to JavaScript code that would otherwise
    be untyped.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型声明* 是一个扩展名为 *.d.ts* 的文件。除了 JSDoc 注释（参见[“第2步b：添加 JSDoc 注释（可选）”](#step-2b-jsdoc)）外，它是将
    TypeScript 类型附加到本来无类型的 JavaScript 代码的一种方式。'
- en: 'Type declarations have a similar syntax to regular TypeScript, with a few differences:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 类型声明的语法与常规的 TypeScript 类似，但也有一些区别：
- en: Type declarations can only contain types, and can’t contain values. That means
    no function, class, object, or variable implementations, and no default values
    for parameters.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型声明只能包含类型，不能包含值。这意味着不能包括函数、类、对象或变量的实现，也不能为参数提供默认值。
- en: While type declarations can’t define values, they can declare that there *exists*
    a value defined somewhere in your JavaScript. We use the special `declare` keyword
    for this.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然类型声明不能定义值，但它们可以声明在你的 JavaScript 中的某处存在一个值。我们使用特殊的`declare`关键字来实现这一点。
- en: Type declarations only declare types for things that are visible to consumers.
    We don’t include things like types that aren’t exported, or types for local variables
    inside of function bodies.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型声明只声明对消费者可见的内容的类型。我们不包括未导出的内容，或者函数体内部的局部变量的类型。
- en: 'Let’s jump into an example, and take a look at a piece of TypeScript (*.ts*)
    code and its equivalent type declaration (*.d.ts*). This example is a fairly involved
    piece of code from the popular RxJS library; feel free to gloss over the details
    of what it’s doing, and instead pay attention to which language features it’s
    using (imports, classes, interfaces, class fields, function overloads, and so
    on):'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个示例，看看 TypeScript (*.ts*) 代码片段及其相应的类型声明 (*.d.ts*)。这个示例是来自流行的 RxJS 库的一段相当复杂的代码；可以忽略它正在做什么的细节，而是关注它使用了哪些语言特性（导入、类、接口、类字段、函数重载等）：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Running this code through TSC with the `declarations` flag enabled (`tsc -d
    Observable.ts`) yields the following *Observable.d.ts* type declaration:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带有`declarations`标志的TSC运行此代码（`tsc -d Observable.ts`）会生成以下*Observable.d.ts*类型声明：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](assets/1.png)](#co_interoperating_with_javascript_CO1-1)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_interoperating_with_javascript_CO1-1)'
- en: 'Notice the `declare` keyword before `class`. We can’t actually define a class
    in a type declaration, but we can *declare* that we defined a class in the *.d.ts*
    file’s corresponding JavaScript file. Think of `declare` like an affirmation:
    “I swear that my JavaScript exports a class of this type.”'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在`class`之前的`declare`关键字。我们实际上不能在类型声明中定义类，但可以声明在*.d.ts*文件的对应JavaScript文件中定义了一个类。可以将`declare`想象成一种确认：“我保证我的JavaScript导出了这种类型的类。”
- en: '[![2](assets/2.png)](#co_interoperating_with_javascript_CO1-2)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_interoperating_with_javascript_CO1-2)'
- en: Because type declarations don’t contain implementations, we only keep the two
    overloads for `subscribe`, and not the signature for its implementation.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因为类型声明不包含实现，所以我们只保留了`subscribe`的两个重载，而没有保留其实现的签名。
- en: Notice how *Observable.d.ts* is just *Observable.ts*, minus the implementations.
    In other words, it’s just the types from *Observable.ts*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意*Observable.d.ts*只是*Observable.ts*的一个版本，去掉了实现部分。换句话说，它只包含了*Observable.ts*中的类型信息。
- en: This type declaration isn’t useful to other files in the RxJS library that use
    *Observable.ts*, since they have access to the *Observable.ts* source TypeScript
    file itself and can use it directly. It is useful, however, if you consume RxJS
    in your TypeScript application.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型声明对于RxJS库中使用*Observable.ts*的其他文件并不有用，因为它们可以直接访问*Observable.ts*源TypeScript文件。但是，如果您在TypeScript应用程序中使用RxJS，则这很有用。
- en: 'Think about it: if the authors of RxJS wanted to package in typing information
    on NPM for their TypeScript-wielding users (RxJS can be used in both TypeScript
    and JavaScript applications), they would have two options: package *both* source
    TypeScript files (for TypeScript users) and compiled JavaScript files (for JavaScript
    users), or ship compiled JavaScript files along with type declarations for TypeScript
    users. The latter reduces the file size, and makes it unambiguous what the correct
    import to use is. It also helps keep compile times for your application fast,
    since your TSC instance doesn’t have to recompile RxJS every time you compile
    your own app (in fact, it’s the reason the optimization strategy we introduce
    in [“Project References”](ch12.html#improving-compile-times) works!).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 想想看：如果RxJS的作者想要在NPM上为他们的TypeScript用户提供打包的类型信息（RxJS可用于TypeScript和JavaScript应用程序），他们有两个选择：打包源TypeScript文件（供TypeScript用户使用）和已编译的JavaScript文件（供JavaScript用户使用），或者只提供已编译的JavaScript文件以及TypeScript用户的类型声明。后者可以减少文件大小，并明确正确的导入使用方式。它还有助于保持应用程序的编译时间快速，因为您的TSC实例不需要在每次编译应用程序时重新编译RxJS（实际上，这就是我们在[“项目引用”](ch12.html#improving-compile-times)中介绍的优化策略的原因！）。
- en: 'Type declaration files have a few uses:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 类型声明文件有几个用途：
- en: When someone else uses your compiled TypeScript from their TypeScript application,
    their TSC instance will look for *.d.ts* files corresponding to your generated
    JavaScript files. This tells TypeScript what the types are for your project.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当其他人在他们的TypeScript应用程序中使用您编译的TypeScript时，他们的TSC实例将查找与您生成的JavaScript文件对应的*.d.ts*文件。这告诉TypeScript您项目的类型信息。
- en: Code editors with TypeScript support (like VSCode) will read these *.d.ts* files
    to give your users helpful type hints as they type, even if they don’t use TypeScript.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 带有TypeScript支持的代码编辑器（如VSCode）将读取这些*.d.ts*文件，以在用户键入时为他们提供有用的类型提示，即使他们不使用TypeScript。
- en: They speed up compile times significantly by avoiding unnecessarily re-compiling
    your TypeScript code.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们通过避免不必要地重新编译您的TypeScript代码显著加快了编译时间。
- en: A type declaration is a way to tell TypeScript, “There exists this thing that’s
    defined in JavaScript, and I’m going to describe it to you.” When we talk about
    type declarations, we often call them *ambient* in order to differentiate them
    from regular declarations that contain values; for example, an *ambient variable
    declaration* uses the `declare` keyword to declare that a variable is defined
    somewhere in JavaScript, while a regular nonambient variable declaration is a
    normal `let` or `const` declaration that declares a variable without using the
    `declare` keyword.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 类型声明是告诉 TypeScript：“JavaScript 中有这样一个定义，我将描述给你。” 当我们谈论类型声明时，为了与包含值的常规声明区分开来，我们通常将它们称为
    *环境* 声明；例如，*环境变量声明* 使用 `declare` 关键字声明变量在 JavaScript 中某处定义，而常规的非环境变量声明则是使用 `let`
    或 `const` 声明一个变量，而无需使用 `declare` 关键字。
- en: 'You can use type declarations for a few things:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为几件事情使用类型声明：
- en: To tell TypeScript about a global variable that’s defined in JavaScript somewhere.
    For example, if you polyfilled the `Promise` global or defined `process.env` in
    a browser environment, you might use an *ambient variable declaration* to give
    TypeScript a heads-up.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要告诉 TypeScript 有关某个在 JavaScript 中某处定义的全局变量。例如，如果你在浏览器环境中填充了 `Promise` 全局变量或者定义了
    `process.env`，你可以使用 *环境变量声明* 来提醒 TypeScript。
- en: To define a type that’s globally available everywhere in your project, so to
    use it you don’t have to import it first (we call this an ambient type declaration).
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个在整个项目中都全局可用的类型，因此在使用时不需要先导入它（我们称之为环境类型声明）。
- en: To tell TypeScript about a third-party module that you installed with NPM (an
    *ambient module declaration*).
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 告诉 TypeScript 关于你使用 NPM 安装的第三方模块的信息（*环境模块声明*）。
- en: A type declaration, regardless of what you’re using it for, has to live in a
    script-mode *.ts* or *.d.ts* file (recall our earlier discussion of script mode
    in [“Module Mode Versus Script Mode”](ch10.html#module-mode)). By convention,
    we give our file a *.d.ts* extension if it has a corresponding *.js* file; otherwise,
    we use a *.ts* extension. It doesn’t matter what you call the file—for example,
    I like to stick to a single top-level *types.ts* until it gets unwieldy—and a
    single type declaration file can contain as many type declarations as you want.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用类型声明做什么，它都必须存在于脚本模式的 *.ts* 或 *.d.ts* 文件中（回想一下我们早前讨论的模块模式与脚本模式 [“模块模式与脚本模式”](ch10.html#module-mode)）。按照惯例，如果文件有对应的
    *.js* 文件，我们会给文件一个 *.d.ts* 扩展名；否则，我们使用 *.ts* 扩展名。文件的名称并不重要——例如，我喜欢将所有类型声明放在一个顶级文件
    *types.ts* 中，直到文件变得难以管理——一个类型声明文件可以包含任意多个类型声明。
- en: Finally, while top-level values in a type declaration file need the `declare`
    keyword (`declare let`, `declare function`, `declare class`, and so on), top-level
    types and interfaces do not.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，虽然类型声明文件中的顶级值需要使用 `declare` 关键字（如 `declare let`、`declare function`、`declare
    class` 等），但顶级类型和接口则不需要。
- en: With those ground rules out of the way, let’s briefly look at some examples
    of each kind of type declaration.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在明确了这些基本规则后，让我们简要看一些每种类型声明的例子。
- en: Ambient Variable Declarations
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 环境变量声明
- en: An ambient variable declaration is a way to tell TypeScript about a global variable
    that can be used in any *.ts* or *.d.ts* file in your project without explicitly
    importing it first.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量声明是一种告诉 TypeScript 在项目中任何 *.ts* 或 *.d.ts* 文件中可以使用的全局变量的方式，而无需首先显式导入它。
- en: 'Let’s say you’re running a NodeJS program in your browser, and the program
    checks `process.env.NODE_ENV` (which is either `"development"` or `"production"`)
    at some point. When you run the program, you get an ugly runtime error:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在浏览器中运行 NodeJS 程序，并且在某一时刻程序检查 `process.env.NODE_ENV`（可能是 `"development"`
    或 `"production"`）。当你运行程序时，你会得到一个难看的运行时错误：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You sleuth around Stack Overflow a bit, and realize that the quickest hack
    to get your program running is to polyfill `process.env.NODE_ENV` yourself and
    hardcode it. So you create a new file, *polyfills.ts*, and define a global `process.env`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你在 Stack Overflow 上搜寻了一下，意识到让程序运行起来的最快方法是自己填充 `process.env.NODE_ENV` 并将其硬编码。所以你创建了一个新文件
    *polyfills.ts*，并定义了一个全局的 `process.env`：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Of course, TypeScript then comes to the rescue, throwing a red squiggly at
    you to try to save you from the mistake you’re clearly making by augmenting the
    `window` global:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，TypeScript 会挺身而出，用红色波浪线提醒你，试图通过增强全局 `window` 来阻止你显然正在犯的错误：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: But in this case, TypeScript is being overprotective. You really do want to
    augment `window`, and you want to do it safely.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这种情况下，TypeScript 显得过于保守了。实际上，你确实希望增强 `window`，并且希望安全地进行操作。
- en: 'So what do you do? You pop open *polyfills.ts* in Vim (you see where this is
    going) and type:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 那么你该怎么办呢？你在 Vim 中打开*polyfills.ts*（你知道这将发生什么）并输入：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You’re declaring to TypeScript that there’s a global object `process` that has
    a single property `env`, that has a property `NODE_ENV`. Once you tell TypeScript
    about that, the red squiggly disappears and you can safely define your `process`
    global.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你在告诉 TypeScript 存在一个全局对象`process`，它有一个名为`env`的属性，其中包含一个名为`NODE_ENV`的属性。一旦你告诉
    TypeScript 这一点，红色波浪线消失了，你可以安全地定义你的`process`全局对象。
- en: 'TSC Setting: lib'
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TSC 设置：lib
- en: TypeScript comes with a set of type declarations for describing the JavaScript
    standard library that includes built-in JavaScript types, like `Array` and `Promise`,
    and methods on built-in types, like `''.toUpperCase`. It also includes global
    objects like `window` and `document` (in a browser environment), and `onmessage`
    (in a Web Worker environment).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 自带一组类型声明，用于描述包括内置 JavaScript 类型（如`Array`和`Promise`）和内置类型的方法（如`''.toUpperCase`）在内的
    JavaScript 标准库，还包括全局对象如`window`和`document`（在浏览器环境中），以及`onmessage`（在 Web Worker
    环境中）。
- en: You can pull in TypeScript’s built-in type declarations using your *tsconfig.json*’s
    `lib` field. Jump ahead to [“lib”](ch12.html#lib) for a deep dive into how to
    dial in your project’s `lib` setting.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过你的*tsconfig.json*文件的`lib`字段引入 TypeScript 的内置类型声明。查看[“lib”](ch12.html#lib)以深入了解如何调整项目的`lib`设置。
- en: Ambient Type Declarations
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 环境类型声明
- en: 'Ambient type declarations follow the same rules as ambient variable declarations:
    the declaration has to live in a script-mode *.ts* or *.d.ts* file, and it’ll
    be available globally to the other files in your project without an explicit import.
    For example, let’s declare a global utility type `ToArray<T>` that lifts `T` to
    an array, if it isn’t an array already. We can define this type in any script-mode
    file in our project—for this example, let’s define it in a top-level *types.ts*
    file:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 环境类型声明遵循环境变量声明相同的规则：声明必须位于脚本模式的*.ts*或*.d.ts*文件中，并且它将在项目中的其他文件中全局可用，无需显式导入。例如，让我们声明一个全局实用程序类型`ToArray<T>`，如果`T`尚不是数组，则将其提升为数组。我们可以在项目的任何脚本模式文件中定义这种类型——例如，让我们在顶层的*types.ts*文件中定义它：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can now use this type from any project file, without an explicit import:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在任何项目文件中使用这种类型，而无需显式导入：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Consider using ambient type declarations to model data types that are used
    throughout your application. For example, you might use them to make the `UserID`
    type we developed in [“Simulating Nominal Types”](ch06.html#nominal-types) globally
    available:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑使用环境类型声明来建模应用程序中始终使用的数据类型。例如，你可以用它们来使我们在[“模拟名义类型”](ch06.html#nominal-types)中开发的`UserID`类型全局可用：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, you can use `UserID` anywhere in your application without having to explicitly
    import it first.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在应用程序的任何地方使用`UserID`，而无需先显式导入它。
- en: Ambient Module Declarations
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 环境模块声明
- en: When you consume a JavaScript module and want to quickly declare some types
    for it so you can use it safely—without having to contribute the type declarations
    back to the JavaScript module’s GitHub repository or DefinitelyTyped first—ambient
    module declarations are the tool to use.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 JavaScript 模块并希望快速为其声明一些类型，以便安全地使用它——而无需首先将类型声明贡献回 JavaScript 模块的 GitHub
    存储库或 DefinitelyTyped——环境模块声明就是你要使用的工具。
- en: 'An ambient module declaration is a regular type declaration, surrounded by
    a special `declare module` syntax:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 环境模块声明是一个常规的类型声明，被包围在特殊的`declare module`语法中：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A module name (`''module-name''` in this example) corresponds to an exact `import`
    path. When you import that path, your ambient module declaration tells TypeScript
    what’s available:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，模块名（`'module-name'`）对应于一个确切的`import`路径。当你导入这个路径时，你的环境模块声明告诉 TypeScript
    可用的内容：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you have a nested module, make sure you include the whole `import` path
    in its declaration:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个嵌套的模块，请确保在其声明中包含整个`import`路径：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you just want to quickly tell TypeScript “I’m importing this module—I’ll
    type it later, just assume it’s an `any` for now,” keep the header but omit the
    actual declaration:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只是想快速告诉 TypeScript “我正在导入这个模块——稍后我会为它添加类型，现在就假设它是`any`”，保留头部但省略实际声明：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now if you consume this module, it’s less safe:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你使用这个模块，它就不太安全了：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Module declarations support wildcard imports, so you can give a type to any
    `import` path that matches the given pattern. Use a wildcard (`*`) to match an
    `import` path:^([1](ch11.html#idm46304950957208))
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 模块声明支持通配符导入，因此你可以为任何匹配给定模式的`import`路径提供类型。使用通配符（`*`）来匹配一个`import`路径：^([1](ch11.html#idm46304950957208))
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, you can load JSON and CSS files:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以加载JSON和CSS文件：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-75
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: For the last two examples to work, you’ll need to configure your build system
    to load *.json* and *.css* files. You can declare to TypeScript that these path
    patterns are safe to import, but TypeScript won’t be able to build them by itself.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使最后两个示例工作，你需要配置你的构建系统来加载*.json*和*.css*文件。你可以告诉TypeScript这些路径模式是安全导入的，但TypeScript本身不能构建它们。
- en: Jump ahead to [“JavaScript That Doesn’t Have Type Declarations on DefinitelyTyped”](#writing-3rd-party-typings)
    for an example of how to use ambient module declarations to declare types for
    untyped third-party JavaScript.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 直接跳转到[“没有在DefinitelyTyped上具有类型声明的JavaScript”](#writing-3rd-party-typings)，了解如何使用环境模块声明为无类型第三方JavaScript声明类型的示例。
- en: Gradually Migrating from JavaScript to TypeScript
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逐步从JavaScript迁移到TypeScript
- en: TypeScript was designed with JavaScript interoperability in mind, not as an
    afterthought. So while it’s not painless, migrating to TypeScript is a good experience,
    letting you convert your codebase over a file at a time, opting into stricter
    levels of safety as you migrate, showing your boss and your coworkers just how
    impactful statically typing your code can be, one commit at a time.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript的设计考虑了与JavaScript的互操作性，并非事后补救。因此，尽管不是毫不费力，迁移到TypeScript是一种很好的体验，它允许你逐个文件地将代码库转换过来，随着迁移逐步选择更严格的安全级别，向老板和同事展示静态类型化代码可以有多么有影响力，一次提交一个。
- en: 'At a high level, here’s where you want to end up: your codebase should be completely
    written in TypeScript with strict type coverage, and third-party JavaScript libraries
    you depend on should come with high-quality, strict types of their own. Any bugs
    that could be caught at compile time are, and TypeScript’s rich autocompletion
    halves the time it takes to write each line of code. You might have to take a
    few baby steps to get there:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，你希望的目标是：你的代码库完全用TypeScript编写，具有严格的类型覆盖，而你依赖的第三方JavaScript库应该具有高质量且严格的类型。任何可以在编译时捕获的错误都会被捕获，TypeScript丰富的自动补全功能可以减少每行代码编写所需的时间。你可能需要采取一些小步骤来达到这个目标：
- en: Add TSC to your project.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将TSC添加到你的项目中。
- en: Start typechecking your existing JavaScript code.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始对你现有的JavaScript代码进行类型检查。
- en: Migrate your JavaScript code to TypeScript, a file at a time.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将你的JavaScript代码逐步迁移到TypeScript。
- en: Install type declarations for your dependencies, either stubbing out types for
    dependencies that don’t have types or writing type declarations for untyped dependencies
    and contributing them back to DefinitelyTyped.^([2](ch11.html#idm46304950868968))
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的依赖安装类型声明，可以是为没有类型的依赖存根出类型，也可以是为无类型依赖编写类型声明，并将其贡献回DefinitelyTyped。^([2](ch11.html#idm46304950868968))
- en: Flip on `strict` mode for your codebase.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的代码库打开`strict`模式。
- en: This process can take a while, but you will see safety and productivity gains
    right away, and uncover more gains as you keep going. Let’s walk through the steps
    one at a time.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程可能需要一些时间，但你会立即看到安全性和生产力的提升，随着你的进展，还会发现更多的收益。让我们一步步来看看这些步骤。
- en: 'Step 1: Add TSC'
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 步骤1：添加TSC
- en: 'When working on a codebase that combines TypeScript and JavaScript, start by
    letting TSC compile JavaScript files alongside your TypeScript. In your *tsconfig.json*:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理结合了TypeScript和JavaScript的代码库时，首先让TSC编译JavaScript文件与你的TypeScript并行工作。在你的*tsconfig.json*中：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With this one change, you can now use TSC to compile your JavaScript. Just add
    TSC to your build process, and either run every existing JavaScript file through
    TSC,^([3](ch11.html#idm46304950805784)) or continue running legacy JavaScript
    files through your existing build process and run new TypeScript files through
    TSC.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一个改变，你现在可以使用TSC来编译你的JavaScript。只需将TSC添加到你的构建流程中，并且通过TSC运行每个现有的JavaScript文件，^([3](ch11.html#idm46304950805784))
    或者继续通过现有的构建流程运行传统的JavaScript文件，并通过TSC运行新的TypeScript文件。
- en: With `allowJs` set to `true`, TypeScript won’t typecheck your existing JavaScript
    code, but it will transpile it (to ES3, ES5, or whatever `target` is set to in
    your *tsconfig.json*) using the module system you asked for (in your *tsconfig.json*’s
    `module` field). First step, done. Commit it, and give yourself a pat on the back—your
    codebase now uses TypeScript!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`allowJs`为`true`后，TypeScript不会对你现有的JavaScript代码进行类型检查，但它会根据你在*tsconfig.json*中设置的目标（ES3、ES5或其他）转译它，使用你要求的模块系统（在*tsconfig.json*的`module`字段中）。第一步完成。提交它，并给自己一个鼓励——你的代码库现在使用TypeScript了！
- en: 'Step 2a: Enable Typechecking for JavaScript (Optional)'
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 步骤2a：启用JavaScript的类型检查（可选）
- en: 'Now that TSC is processing your JavaScript, why not typecheck it too? While
    you might not have explicit type annotations in your JavaScript, remember how
    great TypeScript is at inferring types for you; it can infer types in your JavaScript
    the same way it does in your TypeScript code. Enable this in your *tsconfig.json*:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 TSC 正在处理您的 JavaScript，为什么不也对其进行类型检查呢？虽然您的 JavaScript 中可能没有显式的类型注释，请记住 TypeScript
    在推断类型方面有多么出色；它可以像在常规 TypeScript 代码中那样推断出您 JavaScript 中的类型。在您的*tsconfig.json*中启用此功能：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, whenever TypeScript compiles a JavaScript file it’ll do its best to infer
    types and typecheck as it goes, like it does for regular TypeScript code.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当 TypeScript 编译 JavaScript 文件时，它都会尽力推断类型并进行类型检查，就像对常规 TypeScript 代码一样。
- en: If your codebase is big and flipping on `checkJs` reports too many type errors
    at once, turn it off, and instead enable checking for a JavaScript file at a time
    by adding the `// @ts-check` directive (a regular comment at the top of the file).
    Or, if a few big files are throwing the bulk of your errors and you don’t want
    to fix them just yet, keep `checkJs` on and add the `// @ts-nocheck` directive
    to just those files.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的代码库很大，并且打开`checkJs`会同时报告太多类型错误，请关闭它，而是通过在文件顶部添加`// @ts-check`指令（普通注释）来逐个文件启用
    JavaScript 文件的检查。或者，如果一些大文件引发了大部分错误，而您暂时不想修复它们，请保持`checkJs`开启，并仅为这些文件添加`// @ts-nocheck`指令。
- en: Note
  id: totrans-97
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Because TypeScript can’t infer everything (e.g., function parameter types),
    it will infer a lot of types in your JavaScript code as `any`. If you have `strict`
    mode enabled in your *tsconfig.json* (you should!), you may want to temporarily
    allow implicit `any`s while you migrate. In your *tsconfig.json*, add:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 TypeScript 无法推断一切（例如函数参数类型），它将在您的 JavaScript 代码中推断大量类型为`any`。如果您在*tsconfig.json*中启用了`strict`模式（应该！），您可能希望在迁移时暂时允许隐式`any`。在您的*tsconfig.json*中添加：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Don’t forget to turn `noImplicitAny` on again when you’ve migrated a critical
    mass of code to TypeScript! It will probably reveal a bunch of real errors that
    you missed (unless, of course, you’re Xenithar, disciple of Bathmorda the JavaScript
    witch, able to typecheck in your mind’s eye with the help of nothing but a cauldronful
    of mugwort).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在迁移了大量代码到 TypeScript 后再次打开`noImplicitAny`！它可能会显示出您错过的一堆真实错误（当然，除非您是 Xenithar，巴思莫尔达的
    JavaScript 巫师的弟子，能够仅凭一锅满满的艾蒿进行心眼中的类型检查）。
- en: 'When TypeScript runs over JavaScript code, it uses a more lenient inference
    algorithm than it does for TypeScript code. Specifically:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当 TypeScript 对 JavaScript 代码进行处理时，它会使用比对 TypeScript 代码更宽松的推断算法。具体而言：
- en: All function parameters are optional.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有函数参数都是可选的。
- en: 'The types of properties on functions and classes are inferred from usage (rather
    than having to be declared up front):'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数和类的属性类型是从使用中推断出来的（而不是必须一开始就声明的）：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: After declaring an object, class, or function, you can assign extra properties
    to it. Under the hood, TypeScript does this by generating a corresponding namespace
    for each class and function declaration, and automatically adding an index signature
    to every object literal.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在声明对象、类或函数后，您可以为其分配额外的属性。在幕后，TypeScript 通过为每个类和函数声明生成相应的命名空间，并自动向每个对象字面量添加索引签名来实现这一点。
- en: 'Step 2b: Add JSDoc Annotations (Optional)'
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 步骤 2b：添加 JSDoc 注释（可选）
- en: Maybe you’re in a hurry, and just need to add a single type annotation for a
    new function you added to an old JavaScript file. Until you get a chance to convert
    that file to TypeScript, you can use a JSDoc annotation to type your new function.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 也许您很忙，只需为添加到旧 JavaScript 文件中的新函数添加单个类型注释。在有机会将该文件转换为 TypeScript 之前，您可以使用 JSDoc
    注释为您的新函数类型。
- en: You’ve probably seen JSDoc before; it’s those funny-looking comments above some
    JavaScript and TypeScript code with `@`-annotations like `@param`, `@returns`,
    and so on. TypeScript understands JSDoc, and uses it as input to its typechecker
    the same way that it uses explicit type annotations in TypeScript code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能以前见过 JSDoc；它是那些带有`@`注释的奇怪看起来的 JavaScript 和 TypeScript 代码上方的注释，如`@param`、`@returns`等。
    TypeScript 理解 JSDoc，并将其作为输入传递给其类型检查器，方式与其在 TypeScript 代码中使用显式类型注释相同。
- en: 'Let’s say you have a 3,000-line utilities file (yes, I know your “friend” wrote
    it). You add a new utility function to it:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一个 3000 行的实用程序文件（是的，我知道您的“朋友”写的）。您向其中添加一个新的实用程序函数：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Without converting *utils.js* to TypeScript full sail—which would probably
    catch a bunch of bugs you’d then have to fix—you can annotate just your `toPascalCase`
    function, carving out a little island of safety in a sea of untyped JavaScript:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 不必将*utils.js*全面转换为TypeScript，这样可能会捕捉到一堆你接下来需要修复的错误；你只需注释你的`toPascalCase`函数，就在未经类型定义的JavaScript海洋中创造出一个小小的安全岛：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Without that JSDoc annotation, TypeScript would have inferred `toPascalCase`’s
    type as `(word: any) => string`. Now, when TypeScript compiles your code it knows
    `toPascalCase`’s type is `(word: string) => string`. And you got some nice documentation
    out of it!'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '没有JSDoc注释的话，TypeScript会将`toPascalCase`的类型推断为`(word: any) => string`。现在，当TypeScript编译你的代码时，它知道`toPascalCase`的类型是`(word:
    string) => string`。而且你还得到了一些不错的文档！'
- en: Head over to the [TypeScript Wiki](http://bit.ly/2YCTWBf) to learn more about
    supported JSDoc annotations.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 前往[TypeScript Wiki](http://bit.ly/2YCTWBf)了解更多支持的JSDoc注释。
- en: 'Step 3: Rename Your Files to .ts'
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 步骤 3：将文件重命名为.ts
- en: Once you’ve added TSC to your build process, and optionally started typechecking
    and annotating JavaScript where possible, it’s time to start switching over to
    TypeScript.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将TSC添加到构建流程中，并可选择在可能的情况下开始对JavaScript进行类型检查和注释，现在是时候开始切换到TypeScript了。
- en: 'One file at a time, update your files’ extensions from *.js* (or *.coffee*,
    *.es6*, etc.) to *.ts*. As soon as you rename a file in your code editor, you’ll
    see your friends the red squigglies appear (the TypeError, not the kids’ TV show),
    uncovering type errors, missed cases, forgotten `null` checks, and misspelled
    variable names. There are two strategies for fixing these errors:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 逐个文件，将文件扩展名从*.js*（或*.coffee*、*.es6*等）更改为*.ts*。一旦你在代码编辑器中重命名文件，你会看到你的朋友红色的波浪线出现（TypeError，而不是儿童电视节目），揭示了类型错误、遗漏的情况、忘记的`null`检查和拼写错误的变量名。修复这些错误有两种策略：
- en: Do it right. Take your time to type shapes, fields, and functions correctly,
    so you can catch errors in all the files that consume them. If you have `checkJs`
    enabled, turn on `noImplicitAny` in your *tsconfig.json* to uncover `any`s and
    type them, then turn it back off to make the output of typechecking your remaining
    JavaScript files less noisy.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 做正确的事情。花时间正确地为形状、字段和函数类型化，这样你可以捕捉到所有使用它们的文件中的错误。如果启用了`checkJs`，在*tsconfig.json*中打开`noImplicitAny`来揭示`any`并为其添加类型，然后关闭它以减少对余下JavaScript文件类型检查输出的干扰。
- en: Do it fast. Mass-rename your JavaScript files to the *.ts* extension, and keep
    your *tsconfig.json* settings lax (meaning `strict` set to `false`) to throw as
    few type errors as possible after renaming. Type complex types as `any` to appease
    the typechecker. Fix whatever type errors remain, and commit. Once this is done,
    flip on the `strict` mode flags (`noImplicitAny`, `noImplicitThis`, `strictNullChecks`,
    and so on) one by one, and fix the errors that pop up. (See [Appendix F](app06.html#compiler-flags)
    for a full list of these flags.)
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 快速行动。将你的JavaScript文件批量重命名为*.ts*扩展名，并保持*tsconfig.json*设置宽松（即将`strict`设置为`false`），以在重命名后尽可能少地抛出类型错误。将复杂类型定义为`any`以满足类型检查器的要求。修复剩下的类型错误并提交。完成后，逐个打开`strict`模式标志（如`noImplicitAny`、`noImplicitThis`、`strictNullChecks`等），并修复弹出的错误。（参见[附录 F](app06.html#compiler-flags)获取完整的标志列表。）
- en: Tip
  id: totrans-120
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you choose to go the quick-and-dirty route, a useful trick is to define
    an ambient type declaration `TODO` as a type alias for `any`, and use that instead
    of `any` so that you can more easily find and track missing types. You can also
    call it something more specific, so it’s easier to find in a project-wide code
    search:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择快速而不拘一格的方式，一个有用的技巧是将环境类型声明`TODO`定义为`any`类型的别名，并使用它而不是`any`，这样你可以更轻松地找到和跟踪缺少的类型。你也可以将其命名得更加具体，以便在项目范围的代码搜索中更容易找到：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Both ways of doing it are fair game, and it’s up to you which you want to go
    with. Because TypeScript is a gradually typed language, it’s built from the ground
    up to interoperate with untyped JavaScript code as safely as possible. Regardless
    of whether you’re interoperating strictly typed TypeScript with untyped JavaScript
    or strictly typed TypeScript with loosely typed TypeScript, TypeScript will do
    its best to make sure that you’re doing it as safely as possible, and that on
    the strictly typed island that you’ve so carefully built, everything is as safe
    as it can be.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都是可以接受的，你可以自行选择。因为TypeScript是一种逐渐类型化的语言，它从根本上构建起与未经类型定义的JavaScript代码尽可能安全地进行互操作。无论你是在严格类型化的TypeScript中与未经类型定义的JavaScript互操作，还是与松散类型化的TypeScript互操作，TypeScript都会尽最大努力确保你的安全，并保证在你精心构建的严格类型化岛上，一切都尽可能安全。
- en: 'Step 4: Make It strict'
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 步骤 4：使其严格
- en: Once you’ve migrated a critical mass of your JavaScript over to TypeScript,
    you’ll want to make your code as safe as possible by opting into TSC’s more stringent
    flags one by one (see [Appendix F](app06.html#compiler-flags) for a full list
    of flags).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将大量 JavaScript 迁移到 TypeScript，你会希望通过逐步选择 TSC 更严格的标志来尽可能地使代码更安全（详见 [附录 F](app06.html#compiler-flags)
    获取完整的标志列表）。
- en: 'Finally, you can disable TSC’s JavaScript interoperability flags, enforcing
    that all of your code is written in strictly typed TypeScript:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以禁用 TSC 的 JavaScript 互操作标志，强制所有代码都以严格类型化的 TypeScript 编写：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This will surface the final rounds of type-related errors. Fix these, and you’re
    left with a pristine, safe codebase that the most hardcore OCaml engineer would
    give you a pat on the back for (were you to ask nicely).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示与类型相关的最终错误。修复这些错误，您将得到一个干净且安全的代码库，即使是最顽固的 OCaml 工程师也会为您竖起大拇指（如果您礼貌地问的话）。
- en: Following these steps will get you far when adding types to JavaScript you control,
    but what about JavaScript you don’t control, like code you installed from NPM?
    To get there, we’re first going to have to take a small detour…
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循这些步骤将有助于您在控制的 JavaScript 中添加类型，但对于您无法控制的 JavaScript（例如从 NPM 安装的代码），该如何处理呢？为了达到这个目标，我们首先需要稍微改变方向…
- en: Type Lookup for JavaScript
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 的类型查找
- en: When you import a JavaScript file from a TypeScript file, TypeScript follows
    an algorithm that looks like this to look up type declarations for your JavaScript
    code (remember that “file” and “module” are interchangeable when we talk about
    TypeScript):^([4](ch11.html#idm46304950368856))
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当您从 TypeScript 文件导入 JavaScript 文件时，TypeScript 遵循以下类似的算法来查找您的 JavaScript 代码的类型声明（请记住，在
    TypeScript 中我们谈论“文件”和“模块”时是可以互换的）：^([4](ch11.html#idm46304950368856))
- en: Look for a sibling *.d.ts* file with the same name as your *.js* file. If it
    exists, use it as the type declaration for the *.js* file.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找与您的 *.js* 文件同名的兄弟 *.d.ts* 文件。如果存在，则将其用作 *.js* 文件的类型声明。
- en: 'For example, say you have the following folder structure:'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，假设您的文件夹结构如下所示：
- en: '[PRE24]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You then import *old-file* from *index.ts*:'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后从 *index.ts* 中导入 *old-file*：
- en: '[PRE25]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: TypeScript will use *src/legacy/old-file.d.ts* as the source of type declarations
    for *./legacy/old-file*.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: TypeScript 将使用 *src/legacy/old-file.d.ts* 作为 *./legacy/old-file* 的类型声明源。
- en: Otherwise, if `allowJs` and `checkJs` are true, infer the *.js* file’s types
    (informed by any JSDoc annotations in the *.js* file).
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，如果 `allowJs` 和 `checkJs` 为 true，则根据 *.js* 文件中的任何 JSDoc 注释推断出类型。
- en: Otherwise, treat the whole module as an `any`.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，将整个模块视为 `any`。
- en: 'When importing a third-party JavaScript module—that is, an NPM package that
    you installed to *node modules*—TypeScript uses a slightly different algorithm:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当导入第三方 JavaScript 模块——即您安装到 *node modules* 的 NPM 包时，TypeScript 使用稍微不同的算法：
- en: Look for a local type declaration for the module. If it exists, use it.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找模块的本地类型声明。如果存在，则使用它。
- en: 'For example, say your app’s folder structure looks like this:'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，假设您的应用程序文件夹结构如下所示：
- en: '[PRE26]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'And *types.d.ts* looks like this:'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 并且 *types.d.ts* 看起来像这样：
- en: '[PRE27]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If you then import `foo`, TypeScript will use the ambient module declaration
    in *types.d.ts* as the source of types for `foo`:'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果接着导入 `foo`，TypeScript 将使用 *types.d.ts* 中的环境模块声明作为 `foo` 的类型源：
- en: '[PRE28]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Otherwise, look at the module’s *package.json*. If it defines a field called
    `types` or `typings`, use the *.d.ts* file that field points to as the source
    of type declarations for the module.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，请查看模块的 *package.json*。如果它定义了一个名为 `types` 或 `typings` 的字段，请使用该字段指向的 *.d.ts*
    文件作为模块类型声明的源。
- en: Otherwise, traverse out a directory at a time, and look for a *node modules/@types*
    directory that has type declarations for the module.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，逐级向外遍历目录，并查找具有模块类型声明的 *node modules/@types* 目录。
- en: 'For example, say you installed React:'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，假设你安装了 React：
- en: '[PRE29]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'When you import React, TypeScript will find the *@types/react* folder and use
    that as the source of type declarations for React:'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当您导入 React 时，TypeScript 将找到 *@types/react* 文件夹，并将其用作 React 的类型声明源：
- en: '[PRE31]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Otherwise, proceed to steps 1–3 of the local type lookup algorithm.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，按照本地类型查找算法的步骤 1–3 进行。
- en: That was a lot of steps, but it’s remarkably intuitive once you get the hang
    of it.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然步骤很多，但一旦你掌握了，它实际上非常直观。
- en: 'TSC Settings: types and typeRoots'
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TSC 设置：types 和 typeRoots
- en: By default, TypeScript looks in *node modules/@types* in your project’s folder
    and containing folders (*../node modules/@types* and so on) for third-party type
    declarations. Most of the time, you want to leave this behavior as is.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，TypeScript在项目文件夹中的*node modules/@types*及其包含的文件夹（*../node modules/@types*等）中查找第三方类型声明。大多数情况下，你应该保留这种行为。
- en: 'To override this default behavior for global type declarations, configure `typeRoots`
    in your *tsconfig.json* with an array of folders to look in for type declarations.
    For example, you can tell TypeScript to look for type declarations in the *typings*
    folder as well as *node modules/@types*:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要覆盖全局类型声明的默认行为，请在你的*tsconfig.json*中配置`typeRoots`，并用一个包含文件夹路径的数组来查找类型声明。例如，你可以告诉TypeScript在*typings*文件夹和*node
    modules/@types*中查找类型声明：
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'For even more granular control, use the `types` option in your *tsconfig.json*
    to specify which packages you want TypeScript to look up types for. For example,
    the following config ignores all third-party type declarations except the ones
    for React:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行更精细的控制，可以在你的*tsconfig.json*中使用`types`选项来指定希望TypeScript查找类型的包。例如，以下配置忽略除了React外的所有第三方类型声明：
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Using Third-Party JavaScript
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用第三方JavaScript
- en: Note
  id: totrans-164
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: I’ll assume you’re using a package manager like NPM or Yarn to install third-party
    JavaScript. And if you’re one of those people that prefers to copy and paste code
    manually instead—shame on you.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设你正在使用像NPM或Yarn这样的包管理器来安装第三方JavaScript。如果你是那些喜欢手动复制粘贴代码的人——你真是可耻。
- en: 'When you `npm install` third-party JavaScript code into your project, there
    are three possible scenarios:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过`npm install`将第三方JavaScript代码安装到你的项目中时，可能会有三种情况：
- en: The code you installed comes with type declarations out of the box.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你安装的代码自带类型声明。
- en: The code you installed doesn’t come with type declarations, but declarations
    are available on DefinitelyTyped.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你安装的代码没有类型声明，但在DefinitelyTyped上可以找到声明。
- en: The code you installed doesn’t come with type declarations, and declarations
    are not available on DefinitelyTyped.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你安装的代码没有类型声明，并且在DefinitelyTyped上也找不到声明。
- en: Let’s dig into each of these.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解每种情况。
- en: JavaScript That Comes with Type Declarations
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自带类型声明的JavaScript
- en: 'You know that a package comes with type declarations out of the box if you
    `import` it with `{"noImplicitAny": true}` and TypeScript doesn’t throw a red
    squiggly at you.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '如果一个包默认带有类型声明，当你使用`{"noImplicitAny": true}`导入它时，TypeScript不会给你抛出红色波浪线。'
- en: If the code you’re installing is compiled from TypeScript, or its authors were
    kind enough to include type declarations in its NPM package, then you’re in luck.
    Just install the code and start using it with full type support.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你安装的代码是从TypeScript编译而来的，或者其作者在其NPM包中包含了类型声明，那么你很幸运。只需安装该代码并开始使用它，就可以获得完整的类型支持。
- en: 'Some examples of NPM packages that come with built-in type declarations are:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一些带有内置类型声明的NPM包示例包括：
- en: '[PRE34]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Warning
  id: totrans-176
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Unless the code you’re installing was actually compiled from TypeScript, you
    always run the risk that the type declarations it comes with don’t match up to
    the code those declarations describe. When type declarations come packaged with
    source code the risk of this happening is pretty low (especially for popular packages),
    but it’s something to be aware of.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你安装的代码实际上是从TypeScript编译而来的，否则始终存在类型声明与描述该代码的实际代码不匹配的风险。当类型声明与源代码打包在一起时，这种情况发生的风险非常低（尤其是对于流行的包而言），但仍需注意。
- en: JavaScript That Has Type Declarations on DefinitelyTyped
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在DefinitelyTyped上有类型声明的JavaScript
- en: Even if the third-party code you’re importing doesn’t come with type declarations,
    declarations for it are probably available on [DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped),
    TypeScript’s community-maintained, centralized repository for ambient module declarations
    for open source projects.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你导入的第三方代码没有类型声明，也可能在[DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped)上找到它的声明，这是TypeScript的社区维护的用于开源项目环境模块声明的集中存储库。
- en: 'To check if the package you installed has type declarations available on DefinitelyTyped,
    either search on [TypeSearch](https://microsoft.github.io/TypeSearch/) or just
    try installing the declarations. All DefinitelyTyped type declarations are published
    to NPM under the `@types` scope, so you can just `npm install` from that scope:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查你安装的包是否在 DefinitelyTyped 上有可用的类型声明，可以在 [TypeSearch](https://microsoft.github.io/TypeSearch/)
    上搜索，或者尝试安装声明。所有 DefinitelyTyped 类型声明都发布到 NPM 的 `@types` 范围下，因此你可以直接从该范围进行 `npm
    install`：
- en: '[PRE35]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Most of the time, you’ll want to use `npm install`’s `--save-dev` flag to add
    your installed type declarations to your *package.json*’s `devDependencies` field.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，你会想要使用 `npm install` 的 `--save-dev` 标志将已安装的类型声明添加到 *package.json* 的 `devDependencies`
    字段中。
- en: Note
  id: totrans-183
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Since type declarations on DefinitelyTyped are community-maintained, they run
    the risk of being incomplete, inaccurate, or stale. While most popular packages
    have well-maintained type declarations, if you find that the declarations you’re
    using can be improved, take the time to improve them and [contribute them back
    to DefinitelyTyped](http://bit.ly/2U7QYWP) so other TypeScript users can take
    advantage of your hard work.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 DefinitelyTyped 上的类型声明是由社区维护的，它们可能存在不完整、不准确或过时的风险。虽然大多数流行的包都有良好维护的类型声明，但如果发现你使用的声明可以改进，花时间改进它们并将其贡献回
    DefinitelyTyped，以便其他 TypeScript 用户可以利用你的辛勤工作。
- en: JavaScript That Doesn’t Have Type Declarations on DefinitelyTyped
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 DefinitelyTyped 上没有类型声明的 JavaScript
- en: 'This is the least common case of the three. You have several options here,
    from the cheapest and least safe to the most time-intensive and safest:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这是三种情况中最不常见的情况。在这里，你有几个选项，从最便宜且最不安全的到最耗时且最安全的：
- en: '*Whitelist the specific import* by adding a `// @ts-ignore` directive above
    your untyped import. TypeScript will let you use the untyped module, but the module
    and all of its contents will be typed as `any`:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*通过添加 `// @ts-ignore` 指令在未经类型化的导入之上*，将特定导入列入白名单。TypeScript 将允许你使用未经类型化的模块，但该模块及其所有内容将被类型化为
    `any`：'
- en: '[PRE36]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*Whitelist all usages of this module* by creating an empty type declaration
    file and stubbing out the module. For example, if you installed the rarely used
    package `nearby-ferret-alerter`, you could make a new type declaration (e.g.,
    *types.d.ts*) and add to it the ambient type declaration:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*通过创建一个空的类型声明文件并为该模块创建存根*，将该模块的所有用法列入白名单。例如，如果你安装了很少使用的包 `nearby-ferret-alerter`，你可以创建一个新的类型声明文件（例如
    *types.d.ts*），并向其中添加环境类型声明：'
- en: '[PRE37]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This tells TypeScript that there exists a module that you can import (`import
    alert from 'nearby-ferret-alerter'`), but it doesn’t tell TypeScript anything
    about the types contained in that module. This approach is a slightly better alternative
    to the first, in that now there’s a central *types.d.ts* file that enumerates
    all the untyped modules in your application, but it’s equally unsafe because `nearby-ferret-alerter`
    and all of its exports will still be typed as `any`.
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这告诉 TypeScript 存在一个模块，你可以导入（`import alert from 'nearby-ferret-alerter'`），但它并不告诉
    TypeScript 有关该模块中包含的类型。这种方法略好于第一种，因为现在有一个中心的 *types.d.ts* 文件列举了应用程序中所有未经类型化的模块，但同样不安全，因为
    `nearby-ferret-alerter` 及其所有导出仍将被类型化为 `any`。
- en: '*Create an ambient module declaration*. Like in the previous approach, create
    a file called *types.d.ts* and add an empty declaration (`declare module ''nearby-ferret-alerter''`).
    Now, fill in the type declaration. For example, the result might look like this:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*创建一个环境模块声明*。就像在前一种方法中一样，创建一个名为 *types.d.ts* 的文件，并添加一个空的声明（`declare module
    ''nearby-ferret-alerter''`）。现在，填写类型声明。例如，结果可能如下所示：'
- en: '[PRE38]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now when you `import alert from ''nearby-ferret-alerter''`, TypeScript will
    know exactly what `alert`’s type is. It’s no longer an `any`, but `(loudness:
    ''quiet'' | ''loud'') => Promise<void>`.'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '现在当你 `import alert from ''nearby-ferret-alerter''` 时，TypeScript 将准确知道 `alert`
    的类型。它不再是 `any`，而是 `(loudness: ''quiet'' | ''loud'') => Promise<void>`。'
- en: '*Create a type declaration and contribute it back to NPM*. If you got as far
    as the third option and now have a local type declaration for your module, consider
    contributing it back to NPM so the next person that needs type declarations for
    the awesome `nearby-ferret-alerter` package can use it too. To do this you can
    either submit a pull request to the `nearby-ferret-alerter` Git repository and
    contribute the type declarations directly, or, if the maintainers of that repository
    don’t want to be on the hook for maintaining TypeScript type declarations, contribute
    your declarations to DefinitelyTyped instead.'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*创建类型声明并贡献给 NPM*。如果您已经为您的模块创建了本地类型声明，并且达到了第三个选项，考虑将其贡献回 NPM，以便下一个需要为 `nearby-ferret-alerter`
    包获取类型声明的人也可以使用它。要实现这一点，您可以向 `nearby-ferret-alerter` 的 Git 存储库提交拉取请求，直接贡献类型声明，或者如果该存储库的维护者不想负责维护
    TypeScript 类型声明，可以将您的声明贡献给 DefinitelyTyped。'
- en: Writing type declarations for third-party JavaScript is straightforward, but
    how it’s done depends on the type of module you’re typing. There are a few common
    patterns that come up when typing different kinds of JavaScript modules (from
    NodeJS modules to jQuery augmentations and Lodash mixins to React and Angular
    components). Head over to [Appendix D](app04.html#module-typing-recipes) for a
    list of recipes for typing third-party JavaScript modules.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为第三方 JavaScript 编写类型声明是直截了当的，但其具体操作方式取决于您正在为其编写类型的模块类型。在为不同类型的 JavaScript 模块（从
    NodeJS 模块到 jQuery 增强，再到 Lodash 混入和 React、Angular 组件）编写类型时，会出现一些常见的模式。转到 [附录 D](app04.html#module-typing-recipes)
    查看针对第三方 JavaScript 模块的各种类型编写方法。
- en: Note
  id: totrans-197
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: Automatically generating type declarations for untyped JavaScript is an active
    area of research. Check out [`dts-gen`](https://www.npmjs.com/package/dts-gen)
    for a way to automatically generate type declaration scaffolding for any third-party
    JavaScript module.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 自动为未类型化的 JavaScript 生成类型声明是一个活跃的研究领域。查看 [`dts-gen`](https://www.npmjs.com/package/dts-gen)
    以了解一种自动生成任何第三方 JavaScript 模块类型声明框架的方法。
- en: Summary
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: There are a few ways to use JavaScript from TypeScript. [Table 11-1](#javascript-ts-table)
    summarizes the options.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以从 TypeScript 中使用 JavaScript。[表 11-1](#javascript-ts-table) 总结了这些选项。
- en: Table 11-1\. Ways to use JavaScript from TypeScript
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-1\. 使用 JavaScript 从 TypeScript 的方法总结
- en: '| Approach | tsconfig.json flags | Type safety |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | tsconfig.json 标志 | 类型安全性 |'
- en: '| --- | --- | --- |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Import untyped JavaScript | `{"allowJs": true}` | Poor |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| 导入未类型化的 JavaScript | `{"allowJs": true}` | 差 |'
- en: '| Import and check JavaScript | `{"allowJs": true, "checkJs": true}` | OK |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| 导入和检查 JavaScript | `{"allowJs": true, "checkJs": true}` | 良好 |'
- en: '| Import and check JSDoc-annotated JavaScript | `{"allowJs": true, "checkJs":
    true, "strict": true}` | Excellent |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| 导入和检查带有 JSDoc 注释的 JavaScript | `{"allowJs": true, "checkJs": true, "strict":
    true}` | 优秀 |'
- en: '| Import JavaScript with type declarations | `{"allowJs": false, "strict":
    true}` | Excellent |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| 导入具有类型声明的 JavaScript | `{"allowJs": false, "strict": true}` | 优秀 |'
- en: '| Import TypeScript | `{"allowJs": false, "strict": true}` | Excellent |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| 导入 TypeScript | `{"allowJs": false, "strict": true}` | 优秀 |'
- en: In this chapter we covered various aspects of using JavaScript and TypeScript
    together, from the different kinds of type declarations and how to use them, to
    migrating your existing JavaScript project to TypeScript piece by piece, to using
    third-party JavaScript safely (and unsafely). Interoperating with JavaScript can
    be one of the trickiest aspects of TypeScript; with all the tools at your disposal,
    you’re now equipped to do it in your own project.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了一些使用 JavaScript 和 TypeScript 结合的各个方面，从不同类型声明的种类及其使用方式，到逐步将现有 JavaScript
    项目逐步迁移到 TypeScript，再到安全（以及不安全地）使用第三方 JavaScript。与 JavaScript 的互操作可能是 TypeScript
    中最棘手的方面之一；通过手头的所有工具，您现在已经具备在自己的项目中进行操作的能力了。
- en: ^([1](ch11.html#idm46304950957208-marker)) Wildcard matching with `*` follows
    the same rules as regular [glob pattern matching.](https://en.wikipedia.org/wiki/Glob_(programming))
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch11.html#idm46304950957208-marker)) 使用 `*` 进行通配符匹配遵循与常规 [glob 模式匹配](https://en.wikipedia.org/wiki/Glob_(programming))
    相同的规则。
- en: ^([2](ch11.html#idm46304950868968-marker)) DefinitelyTyped is the open source
    repository for JavaScript type declarations. Read on to learn more.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch11.html#idm46304950868968-marker)) DefinitelyTyped 是 JavaScript 类型声明的开源存储库。继续阅读以了解更多信息。
- en: ^([3](ch11.html#idm46304950805784-marker)) For really big projects it can be
    slow to run every single file through TSC. For a way to improve performance for
    large projects, see [“Project References”](ch12.html#improving-compile-times).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch11.html#idm46304950805784-marker)) 对于非常大的项目，逐个文件通过 TSC 可能会很慢。有关如何提升大型项目性能的方法，请参见[“项目引用”](ch12.html#improving-compile-times)。
- en: ^([4](ch11.html#idm46304950368856-marker)) Strictly speaking, this is true for
    module-mode, but not script-mode, files. Read more in [“Module Mode Versus Script
    Mode”](ch10.html#module-mode).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch11.html#idm46304950368856-marker)) 严格来说，这对于模块模式而言是正确的，但对于脚本模式则不是。详细了解请参阅[“模块模式与脚本模式”](ch10.html#module-mode)。
