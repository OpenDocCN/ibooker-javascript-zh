# 第六章：设计模式的类别

本章记录了三大主要设计模式类别及其下属的不同模式。虽然每个设计模式都解决了特定的面向对象设计问题或问题，但我们可以根据它们解决这些问题的方式之间的相似性来划分类别。这形成了设计模式分类的基础。

# 背景

Gamma、Helm、Johnson 和 Vlissides（1995）在他们的书籍[*可重用面向对象软件的设计模式*](https://oreil.ly/viJe6)中将设计模式描述为：

> 设计模式命名、抽象并确定了常见设计结构的关键方面，使其能够用于创建可重用的面向对象设计。设计模式确定参与类及其实例、它们的角色和协作，以及责任的分配。
> 
> 每个设计模式专注于特定的面向对象设计问题或问题。它描述了何时适用，是否可以应用于其他设计约束条件，并且其使用的后果和权衡。由于我们最终必须实现我们的设计，设计模式还提供了示例…​代码来说明其实现。
> 
> 虽然设计模式描述了面向对象的设计，但它们基于实际在主流面向对象编程语言中实现的解决方案…​。

设计模式可以根据它们解决的问题类型进行分类。设计模式的三个主要类别是：

+   创建型设计模式

+   结构设计模式

+   行为设计模式

在接下来的章节中，我们将回顾这三种类别中属于每种类别的模式的几个示例。

# 创建型设计模式

创建型设计模式专注于处理对象创建机制，其中对象根据给定情况以合适的方式创建。在项目中，基本的对象创建方法可能会增加复杂性，而这些模式旨在通过*控制*创建过程来解决这个问题。

属于这一类别的一些模式包括构造器（Constructor）、工厂（Factory）、抽象工厂（Abstract）、原型（Prototype）、单例（Singleton）和建造者（Builder）。

# 结构设计模式

结构模式涉及对象组合，通常识别实现不同对象之间关系的简单方法。它们确保当系统的某一部分发生变化时，系统的整体结构无需改变。它们还有助于将系统中不适合特定目的的部分重塑为适合特定目的的部分。

属于这一类别的模式包括装饰器（Decorator）、外观（Facade）、享元（Flyweight）、适配器（Adapter）和代理（Proxy）。

# 行为设计模式

行为模式专注于改进或简化系统中不同对象之间的通信。它们识别对象之间的常见通信模式，并提供将通信责任分配给不同对象的解决方案，从而增加通信的灵活性。基本上，行为模式将动作从执行动作的对象中抽象出来。

一些行为模式包括迭代器、中介者、观察者和访问者。

# 设计模式类

2004 年，Elyse Nielsen 创建了一个“类”表格，总结了 23 种 GoF 设计模式。在我学习设计模式的早期阶段，我发现这个表格非常有用。我根据需要修改了它，以适应我们对设计模式的讨论。

我建议将此表作为参考，但请记住，我们将在本书的后续章节中讨论其他未提及的几种模式。

###### 注释

我们在第五章中讨论了 JavaScript ES2015+类。当您审查以下表格时，JavaScript 类和对象将会相关。

现在让我们继续审查表格：

| **创建型** | 基于创建对象的概念 |
| --- | --- |
| **类** |   |
| *工厂方法* | 根据接口数据或事件创建多个派生类的实例 |
| **对象** |   |
| *抽象工厂* | 创建多个类族的实例，而不详细说明具体类 |
| *构建者* | 将对象构建与其表示分离；始终创建相同类型的对象 |
| *原型* | 用于复制或克隆的完全初始化的实例 |
| *单例* | 具有全局访问点的仅有单个实例的类 |
|   |   |
| **结构型** | 基于对象的构建块的概念 |
| **类** |   |
| *适配器* | 匹配不同类的接口，使得类能够共同工作，尽管接口不兼容 |
| **对象** |   |
| *桥接* | 将对象的接口与其实现分离，以便两者可以独立变化 |
| *组合* | 由简单和复合对象构成的结构，使得总对象不仅仅是其部分的总和 |
| *装饰器* | 动态地为对象添加替代处理 |
| *外观* | 一个单一的类，隐藏了整个子系统的复杂性 |
| *享元* | 用于有效共享信息的细粒度实例，信息实际上存储在其他地方 |
| *代理* | 表示真实对象的占位符对象 |
|   |   |
| **行为型** | 基于对象如何协同工作和互动的方式 |
| **类** |   |
| *解释器* | 将语言元素包含到应用程序中，以匹配预期语言的语法 |
| *模板方法* | 在方法中创建算法的框架，然后将确切的步骤推迟到子类 |
| **对象** |   |
| *责任链* | 通过对象链传递请求，以找到能处理请求的对象 |
| *命令模式* | 将命令的执行与调用者分离的方法 |
| *迭代器模式* | 顺序访问集合的元素而不需了解集合的内部工作机制 |
| *中介者模式* | 定义简化类之间通信的方式，以防止一组类显式地相互引用 |
| *备忘录模式* | 捕获对象的内部状态，以便稍后恢复 |
| *观察者模式* | 一种通知多个类进行变化以确保类之间一致性的方法 |
| *状态模式* | 当对象状态改变时改变其行为 |
| *策略模式* | 将算法封装在一个类中，将选择和实现分离 |
| *访问者模式* | 在不改变类本身的情况下为类添加新操作 |

# 概要

本章介绍了设计模式的类别，并解释了创建型、结构型和行为型模式之间的区别。我们讨论了这三类模式及其 GoF 模式在每个类别中的差异。我们还回顾了显示 GoF 模式如何与类和对象的概念相关联的“类”表。

这几章详细讲解了设计模式的理论细节和 JavaScript 语法的基础知识。在这个基础上，我们现在可以开始进入 JavaScript 设计模式的一些实际例子。
