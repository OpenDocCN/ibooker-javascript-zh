# 第二十二章：维护

你发布了网站！恭喜恭喜，现在你永远不用再去考虑它了。什么？你*还是*得继续考虑它？好吧，在这种情况下，请继续阅读。

尽管在我的职业生涯中这种情况已经发生了几次，但完成一个网站然后永远不再碰它的情况并不常见（当它确实发生时，通常是因为有其他人在做这项工作，而不是因为工作不需要做）。我清楚地记得一个网站发布的“事后分析”。我插嘴说：“我们真的应该称它为*产后*吧？”^(1) 发布网站确实更像是一种诞生而非死亡。一旦它发布了，你就会紧盯着分析数据，焦急地等待客户的反应，半夜三点醒来检查网站是否还在运行。这是你的宝贝。

规划一个网站、设计一个网站、构建一个网站：这些都是可以计划到死的活动。但通常被忽视的是*规划网站维护*。本章将为你提供一些关于如何航行在这些波涛汹涌的建议。

# 维护原则

## 拥有长期计划

当客户同意建立一个网站的价格时，我总是感到惊讶，但从未讨论过网站预计的寿命有多长。我的经验是，如果你做得好，客户愿意为此付费。客户*不*欣赏的是意外情况：例如在三年后告知他们他们的网站必须重建，而他们默默地期望它能维持五年。

互联网发展迅速。如果你用你能找到的最好和最新的技术构建了一个网站，也许两年后它会感觉像是一个老旧的遗物。或者它可以坚持七年，虽然老化，但做得很优雅（这种情况不太常见！）。

关于网站寿命的预期设定，这部分是艺术、销售技巧和科学的结合体。其中的科学部分涉及到一些所有科学家都做但很少有网页开发者做的事情：保持记录。想象一下，如果你有你的团队曾经发布的每一个网站的记录，维护请求和故障的历史记录，使用的技术以及每个网站需要重建前的使用时长。显然存在许多变量，从涉及的团队成员，到经济情况，到技术的变动，但这并不意味着数据中不能发现有意义的趋势。你可能会发现某些开发方法对你的团队效果更好，或者某些平台或技术。我几乎可以保证你会发现“拖延”和缺陷之间存在着相关性：你越长时间推迟导致痛苦的基础设施更新或平台升级，问题就会越严重。拥有良好的问题跟踪系统并保持详细的记录将使你能够向客户提供更好（也更现实）的项目生命周期图景。

它的推销点归结为当然是钱的问题。如果客户能够负担得起每三年完全重建他们的网站，那么他们不太可能因为老化基础设施而遭受损失（尽管他们会有其他问题）。另一方面，有些客户希望他们的预算能够延伸尽可能远，希望网站能够持续五年甚至七年之久。（我知道有些网站甚至拖延了更长时间，但我认为七年是有希望继续有用的网站的最大现实寿命。）你有责任对待这两类客户，它们各自带来了不同的挑战。对于那些有很多钱的客户，不要仅仅因为他们有钱而接受他们的钱：要利用这些额外的钱为他们提供一些非凡的东西。对于预算紧张的客户，你将不得不找到创造性的方法，在技术不断变化的情况下设计他们的网站，使其更具长期性。这两个极端都有各自的挑战，但都可以解决。然而重要的是，你要*知道*客户的期望是什么。

最后，还有这个事情的艺术性。这就是把所有事情联系在一起的东西：了解客户能承受多少，以及在哪些地方你可以诚实地说服客户多花点钱，以便他们在需要的地方得到价值。这也是理解技术未来的艺术，能够预测哪些技术在五年内将会彻底过时，哪些将继续强大。

当然，没有办法绝对确定任何事情。你可能对技术下错注，人员变动可能完全改变你组织的技术文化，技术供应商可能会倒闭（虽然在开源世界中这通常不是问题）。你认为会在产品寿命内稳定的技术可能会被证明是一种时尚，你可能会发现自己面临比预期更早重建的决定。另一方面，有时候确切的团队在确切的时间以及确切的技术下来到一起，创造出远超过任何合理期望的东西。然而，所有这些不确定性都不应阻止你制定计划：有一个走样的计划总比一直没有方向好。

现在对你来说应该是清楚的，我认为 JavaScript 和 Node 是将会持续存在一段时间的技术。Node 社区充满活力和热情，明智地基于一种显然已经*胜利*的语言。也许最重要的是，JavaScript 是一种多范式语言：面向对象的，函数式的，过程式的，同步的，异步的——它应有尽有。这使得 JavaScript 成为一个吸引来自不同背景开发者的平台，并且在很大程度上推动了 JavaScript 生态系统的创新步伐。

## 使用源代码控制

这对你可能显而易见，但不仅仅是*使用*源代码控制，而是要*好好使用*它。你为什么使用源代码控制？理解原因，并确保工具支持这些原因。使用源代码控制有许多原因，但我认为最大的回报始终是归因：知道究竟是什么改变了什么时间，以及谁做了这些改变，这样我就可以在必要时询问更多信息。版本控制是我们了解项目历史和团队协作方式的最重要工具之一。

## 使用问题追踪器

问题追踪器回到了开发的科学。没有系统记录项目历史的方法，就不可能得到洞察。你可能听说过“疯狂的定义是‘一遍又一遍地做同样的事情，但期待不同的结果’”（通常是被错误地归因于阿尔伯特·爱因斯坦）。如果你不知道自己在犯什么错误，如何避免重复这些错误看起来是疯狂的呢？

记录一切：客户报告的每一个缺陷；在客户看到之前你发现的每一个缺陷；每一个投诉，每一个问题，每一点赞。记录花费了多少时间，谁修复了它，涉及了哪些 Git 提交，以及谁批准了修复。关键在于找到不会使这变得过于耗时或繁重的工具。一个糟糕的问题追踪系统会闲置不用，比没用还糟糕。一个好的问题追踪系统将为你的业务、团队和客户提供重要的洞察。

## 保持良好的卫生习惯

我不是在说刷牙——虽然你也应该这样做——我是在说版本控制、测试、代码审查和问题追踪。你使用的工具只有在正确使用时才是有用的。代码审查是鼓励卫生习惯的好方法，因为可以触及*所有*内容，从讨论请求来源于哪个问题追踪系统，到必须添加的用于验证修复的测试，再到版本控制提交注释。

你从问题追踪系统收集的数据应定期审查并与团队讨论。通过这些数据，你可以获得关于什么有效和什么无效的见解。你可能会对你所发现的内容感到惊讶。

## 不要拖延

机构性拖延可能是最难对抗的事情之一。通常情况下，看起来不那么糟糕：你注意到你的团队每周在一个本可以通过稍加重构大幅改善的周更新上浪费了大量时间。每一周你推迟重构，就是另一周你在支付效率成本。^(2) 更糟的是，有些成本可能会随着时间的推移而增加。

一个很好的例子是未能更新软件依赖关系。随着软件的老化和团队成员的变动，要找到记得（或者曾经理解过）这个老旧软件的人变得更加困难。支持社区开始消失，不久后，技术被淘汰，你将无法获得任何支持。人们经常将此描述为*技术债务*，这是一个非常真实的问题。虽然你应该避免拖延，但理解网站的长期存在性可以影响这些决策：如果你正准备重新设计整个网站，消除一直积累的技术债务就没有太大的价值。

## 进行例行的质量保证检查

对于你的每个网站，你应该有一个*记录的*例行质量保证检查。该检查应包括链接检查器、HTML 和 CSS 验证以及运行你的测试。关键在于*记录*：如果组成质量保证检查的项目没有记录，你必然会错过一些事情。每个网站的记录质量保证检查清单不仅有助于防止忽视检查，还允许新团队成员立即生效。理想情况下，质量保证检查清单可以由非技术团队成员执行。这将增强你（可能是）非技术经理对团队的信心，并且如果你没有专门的质量保证部门，将允许你分担质量保证的责任。根据你与客户的关系，你可能还想与客户分享你的质量保证检查清单（或其部分）；这是提醒他们他们为何支付费用以及你在为他们的最佳利益着想的好方法。

作为例行的质量保证检查的一部分，我建议使用[Google 网站管理员工具](http://bit.ly/2qH3Y7L)和[Bing 网站管理员工具](https://binged.it/2qPwF2c)。它们易于设置，并且可以让你非常重要地查看你的网站：主要搜索引擎如何看待它。它会提醒你关于你的*robots.txt*文件、干扰良好搜索结果的 HTML 问题、安全问题等等的任何问题。

## 监控分析数据

如果你的网站上没有运行分析，你现在就需要开始：它不仅提供了网站的流行度关键洞察，还告诉你用户如何使用它。Google Analytics（GA）非常出色（而且免费！），即使你用其他分析服务来补充，也没有理由不在你的网站上包含 GA。

通常情况下，通过关注分析数据，您可以发现一些微妙的用户体验问题。某些页面是否没有获得预期的流量？这可能表明导航、促销或 SEO 问题。跳出率是否很高？这可能意味着您的页面内容需要调整（人们通过搜索进入您的网站，但一到达后发现并非他们寻找的内容）。您应该有一个分析检查清单，与您的质量保证清单一起使用（它甚至可以成为质量保证清单的一部分）。该清单应该是一个“活文件”，因为在您的网站生命周期内，您或您的客户可能会对内容的重要性有所变化。

## 优化性能

研究表明，性能对网站流量有显著影响。在快节奏的世界中，人们期望内容快速交付，尤其是在移动平台上。性能调优的首要原则是*先进行分析，然后进行优化*。“分析”意味着找出实际拖慢网站速度的因素。如果您花费数天加快内容呈现速度，而问题实际上出在社交媒体插件上，那么您就浪费了宝贵的时间和金钱。

[Google PageSpeed Insights](http://bit.ly/2Qa3l15) 是衡量网站性能的好方法（现在 PageSpeed 数据也记录在 Google Analytics 中，所以您可以监控性能趋势）。它不仅会为移动端和桌面端性能给出综合评分，还会提出如何优化性能的优先建议。

如果您目前没有性能问题，可能不需要定期进行性能检查（监控 Google Analytics 是否有性能分数显著变化应该足够）。然而，当您提高性能时，观察流量的增加是令人满意的。

## 优先考虑潜在客户追踪

在互联网世界中，访客能够向您发出的最强信号，表明他们对您的产品或服务感兴趣的是联系信息。您应该非常谨慎地处理这些信息。任何收集电子邮件或电话号码的表单都应定期作为质量保证检查的一部分进行测试，并且在收集信息时应始终保持冗余。对潜在客户做的最糟糕的事情之一就是收集联系信息，然后丢失它。

由于潜在客户追踪对您的网站成功至关重要，我建议您遵循以下五个原则来收集信息：

在 JavaScript 失效时有备用方案

通过 Ajax 收集客户信息是可以的——这通常会带来更好的用户体验。但是，如果由于任何原因 JavaScript 失败（用户可能禁用它，或者您网站上的脚本可能出现错误，导致您的 Ajax 功能不正常），表单提交应仍然可以工作。测试这一点的一个好方法是禁用 JavaScript 并使用您的表单。如果用户体验不理想也没关系：关键是不要丢失用户数据。为了实现这一点，*始终*在您的 `<form>` 标签中有一个有效且可用的 `action` 参数，即使您通常使用 Ajax。

如果使用 Ajax，请从表单的 `action` 参数获取 URL。

虽然这不是严格必要的，但这有助于防止您在 `<form>` 标签上意外忘记 `action` 参数。如果将您的 Ajax 绑定到无 JavaScript 提交成功，那么丢失客户数据将更加困难。例如，您的表单标签可以是 `<form action="/submit/email" method="POST">`；然后在您的 Ajax 代码中，您会从 DOM 获取表单的 `action`，并在 Ajax 提交代码中使用它。

提供至少一级冗余。

您可能希望将潜在客户信息保存到数据库或外部服务，如 Campaign Monitor。但是，如果您的数据库出现故障，或者 Campaign Monitor 停机，或者存在网络问题，您仍然不希望丢失该潜在客户。提供冗余的常见方法是除了存储潜在客户信息外，还发送电子邮件。如果采用这种方法，您不应使用个人电子邮件地址，而应使用共享电子邮件地址（如*dev@meadowlarktravel.com*）：如果将其发送给一个人并且该人离开组织，冗余就没有意义。您还可以将潜在客户信息存储在备份数据库或甚至 CSV 文件中。然而，*每当*主要存储失败时，应有一些机制来提醒您失败。收集冗余备份是战斗的前半段；意识到故障并采取适当措施是后半段。

在完全存储失败的情况下，通知用户。

假设您有三级冗余：您的主要存储是 Campaign Monitor，如果它失败了，您会备份到 CSV 文件并发送邮件至 *dev@meadowlarktravel.com*。如果*所有*这些渠道都失败了，用户应该收到类似于“很抱歉，我们遇到技术困难，请稍后重试，或联系*support@meadowlarktravel.com*”的消息。

检查肯定确认，而不是错误的缺失。

Ajax 处理程序通常会返回一个带有`err`属性的对象以表示失败；然后客户端代码会像这样：`if(data.err){ /* 通知用户操作失败 */ } else { /* 感谢用户提交成功 */ }`。避免这种方法。设置`err`属性没有问题，但如果在 Ajax 处理程序中出现错误，导致服务器响应 500 错误代码或者响应不是有效的 JSON，*这种方法可能会静默失败*。用户的信息将消失无踪，他们对此一无所知。相反，为成功的提交提供一个`success`属性（即使主要存储失败：如果用户的信息被*某种方式*记录，你可以返回`success`）。然后你的客户端代码变成`if(data.success){ /* 感谢用户提交成功 */ } else { /* 通知用户操作失败 */ }`。

## 防止“隐形”故障

我经常看到这种情况：因为开发人员赶时间，他们记录错误的方式从未得到检查。无论是日志文件，数据库中的表格，客户端控制台日志，还是发往死信箱的电子邮件，最终结果都是一样的：*你的网站存在质量问题，这些问题没有被注意到*。

你可以对抗这个问题的头号防御措施是*提供一种简单标准的错误日志记录方法*。文档化它。不要让它变得复杂。不要让它变得晦涩。确保每个接触到你项目的开发人员都知道它。可以简单地暴露一个`meadowlarkLog`函数（其他包经常使用`log`）。函数是否记录到数据库、平面文件、电子邮件或其组合并不重要：重要的是它是标准化的。它还允许你改进日志机制（例如，当你扩展服务器时，平面文件的用处变小，因此你会修改`meadowlarkLog`函数以改为记录到数据库）。一旦日志记录机制就位，文档化并且你的团队每个人都知晓，将“检查日志”添加到你的质量保证清单中，并提供如何执行的指导。

# 代码重用和重构

我经常看到的一个悲剧是反复发明轮子。通常这只是一些小事情：碎片化的内容感觉重写比挖掘几个月前的项目更容易。所有这些小片段的重写累积起来。更糟糕的是，这与良好的质量保证相悖：你可能不会费心为所有这些小片段编写测试（如果你这样做了，那么浪费时间就会加倍，因为你没有重用现有的代码）。每个相同的片段可能会有不同的错误。这是一个不好的习惯。

在 Node 和 Express 中进行开发提供了一些很好的方法来解决这个问题。Node 通过模块带来了命名空间，通过 npm 带来了包的概念，而 Express 则引入了中间件的概念。有了这些工具，开发可复用的代码变得更加容易。

## 私有 npm 注册表

npm 注册表是存储共享代码的好地方；毕竟，这正是 npm 设计的初衷。除了简单的存储外，你还得到了版本控制，以及在其他项目中包含这些包的便捷方法。

然而，这里有一个小问题：除非你在一个完全开放源码的组织中工作，否则你可能不想为所有可复用的代码创建 npm 包。（除了知识产权保护之外，还可能有其他原因：你的包可能是如此特定于组织或项目，以至于在公共注册表上发布它们没有意义。）

处理这个问题的一种方法是*私有 npm 注册表*。npm 现在提供了 Orgs 功能，允许你发布私有包，并给你的开发者提供付费登录，以便让他们访问这些私有包。有关 npm Orgs 和私有包的更多信息，请参阅 [npm](https://www.npmjs.com/products)。

## 中间件

如同本书中所见，编写中间件并不是什么复杂可怕的事情：在本书中我们已经做了很多次了，久而久之，你甚至可以不假思索地完成。因此，下一步就是将可复用的中间件放入一个包中，并将其发布到 npm 注册表中。

如果你发现你的中间件过于特定于某个项目而无法放入一个可复用的包中，那么你应该考虑重构中间件，以便能够为更一般的用途进行配置。记住，你可以传递配置对象到中间件中，使其在各种情况下都能派上用场。下面是在 Node 模块中公开中间件的最常见方法概述。以下所有内容都假设你正在将这些模块作为一个名为`meadowlark-stuff`的包使用。

### 模块直接公开中间件函数

如果你的中间件不需要配置对象，请使用这种方法：

```
module.exports = (req, res, next) => {
  // your middleware goes here...remember to call next()
  // or next('route') unless this middleware is expected
  // to be an endpoint
  next()
}
```

使用这个中间件的方法：

```
const stuff = require('meadowlark-stuff')

app.use(stuff)
```

### 模块公开一个返回中间件的函数

如果你的中间件需要配置对象或其他信息，请使用这种方法：

```
module.exports = config => {
  // it's common to create the config object
  // if it wasn't passed in:
  if(!config) config = {}

	return (req, res, next) => {
    // your middleware goes here...remember to call next()
    // or next('route') unless this middleware is expected
    // to be an endpoint
    next()
	}
}
```

使用这个中间件的方法：

```
const stuff = require('meadowlark-stuff')({ option: 'my choice' })

app.use(stuff)
```

### 模块公开一个包含中间件的对象

如果你希望公开多个相关的中间件，可以选择使用这个选项：

```
module.exports = config => {
  // it's common to create the config object
  // if it wasn't passed in:
  if(!config) config = {}

	return {
    m1: (req, res, next) => {
      // your middleware goes here...remember to call next()
      // or next('route') unless this middleware is expected
      // to be an endpoint
      next()
		},
    m2: (req, res, next) => {
      next()
    },
  }
}
```

使用这个中间件的方法：

```
const stuff = require('meadowlark-stuff')({ option: 'my choice' })

app.use(stuff.m1)
app.use(stuff.m2)
```

# 结论

在构建网站时，焦点通常放在上线上，这是有充分理由的：上线是非常令人兴奋的。然而，一个对新上线网站感到满意的客户，如果在维护网站时不注意，很快就会变成一个不满意的客户。以同样的细心对待维护计划，将会提供客户喜欢的体验，从而使客户不断回头。

^(1) 事实证明，“产后”这个术语有点过于直接。我们现在称之为“回顾”。

^(2) [Fuel](http://www.fuelyouth.com)的麦克·威尔逊有一条经验法则：“当你第三次做某事时，花点时间自动化它。”
