# 第十七章：静态内容

*静态内容* 指的是你的应用程序将提供的在每个请求基础上不会改变的资源。以下是通常的资源：

多媒体

图像，视频和音频文件。当然，完全可以动态生成图像文件（以及视频和音频，虽然后两者较少见），但大多数多媒体资源是静态的。

HTML

如果我们的 Web 应用程序使用视图来渲染动态 HTML，通常不会被视为静态 HTML（尽管出于性能原因，您可以动态生成 HTML，将其缓存并作为静态资源提供）。正如我们所见，SPA 应用程序通常向客户端发送单个静态 HTML 文件，这是将 HTML 视为静态资源的最常见原因。请注意，要求客户端使用*.html*扩展名并不是很现代化，因此大多数服务器现在允许在不带扩展名的情况下提供静态 HTML 资源（因此`/foo`和`/foo.html`将返回相同的内容）。

CSS

即使您使用像 LESS，Sass 或 Stylus 等抽象 CSS 语言，归根结底，您的浏览器需要普通的 CSS，这是一种静态资源。^(1)

JavaScript

即使服务器正在运行 JavaScript，也不意味着没有客户端 JavaScript。客户端 JavaScript 被视为静态资源。当然，现在这条界限开始变得有些模糊：如果有我们想在后端和客户端使用的通用代码怎么办？有解决这个问题的方法，但归根结底，发送给客户端的 JavaScript 通常是静态的。

二进制下载

这是一个涵盖所有内容的类别：任何 PDF 文档，ZIP 文件，Word 文档，安装程序等。

###### 注意

如果你只是在构建一个 API，可能没有静态资源。如果是这样的话，你可以跳过这一章节。

# 性能考虑

处理静态资源的方式显著影响您网站的实际性能，特别是如果您的网站包含大量多媒体内容。两个主要的性能考虑因素是*减少请求数量* 和 *减少内容大小*。

在这两者之间，减少（HTTP）请求的数量更为关键，尤其是对于移动设备（在移动网络上进行 HTTP 请求的开销显著更高）。减少请求可以通过两种方式实现：资源合并和浏览器缓存。

结合资源主要是架构和前端关注的问题：尽可能将小图像合并为单个精灵。然后使用 CSS 设置偏移和大小，以仅显示您想要的图像部分。有关创建精灵，我强烈推荐免费服务[SpritePad](http://bit.ly/33GYvwm)。它使生成精灵非常简单，并为您生成 CSS。再也没有比这更简单的事情了。SpritePad 的免费功能可能是您所需的一切，但如果您发现自己经常创建大量的精灵图，您可能会发现他们的高级服务值得一试。

浏览器缓存通过将常用的静态资源存储在客户端浏览器中来帮助减少 HTTP 请求。虽然浏览器尽可能使缓存自动化，但这并非魔法：您可以并且应该做很多事情来启用浏览器缓存您的静态资源。

最后，我们可以通过减少静态资源的大小来提高性能。一些技术是*无损*的（可以在不丢失任何数据的情况下实现大小减小），而一些技术是*有损*的（通过降低静态资源的质量来实现大小减小）。无损技术包括 JavaScript 和 CSS 的缩小以及优化 PNG 图像。有损技术包括增加 JPEG 和视频压缩级别。在本章中，我们将讨论缩小和捆绑（这也减少了 HTTP 请求）。

###### 提示

随着 HTTP/2 变得越来越普遍，减少 HTTP 请求的重要性将逐渐减弱。HTTP/2 的主要改进之一是*请求和响应复用*，它减少了并行获取多个资源的开销。有关更多信息，请参见[Ilya Grigorik 的《HTTP/2 简介》](http://bit.ly/34TXhxR)。

# 内容传递网络

当您将网站投入生产时，静态资源必须托管在互联网的某个地方。您可能习惯于将它们托管在生成所有动态 HTML 的同一服务器上。到目前为止，我们的示例也采用了这种方法：当我们输入`node meadowlark.js`时，我们启动的 Node/Express 服务器会提供所有 HTML 以及静态资源。然而，如果您希望最大化网站的性能（或为将来做好准备），您将希望轻松地将静态资源托管在*内容传递网络*（CDN）上。CDN 是专为提供静态资源而优化的服务器。它利用特殊的标头（我们很快将学习到）来启用浏览器缓存。

CDN 还可以实现*地理优化*（通常称为*边缘缓存*）；也就是说，它们可以从地理位置更靠近您的客户端的服务器提供您的静态内容。虽然互联网的速度确实非常快（虽然不是光速，但已经足够接近了），但将数据传输一百英里比一千英里要快得多。单个时间节省可能很小，但如果乘以所有用户、请求和资源，这些时间节省将迅速累积起来。

您的大多数静态资源将在 HTML 视图中引用（`<link>` 元素用于 CSS 文件，`<script>` 引用用于 JavaScript 文件，`<img>` 标签用于图像，以及多媒体嵌入标签）。通常还会在 CSS 中引用静态资源，通常是 `background-image` 属性。最后，有时也会在 JavaScript 中引用静态资源，例如动态更改或插入 `<img>` 标签或 `background-image` 属性的 JavaScript 代码。

###### 注意

使用 CDN 时，通常无需担心跨域资源共享（CORS）。在 HTML 中加载的外部资源不受 CORS 策略限制：您只需为通过 Ajax 加载的资源启用 CORS 即可（参见第十五章）。

# 面向 CDN 的设计

您站点的架构将影响您如何使用 CDN。大多数 CDN 允许您配置路由规则以确定从何处发送传入请求。虽然您可以通过这些路由规则变得非常复杂，但通常归结为将对静态资产的请求发送到一个位置（通常由您的 CDN 提供），将对动态端点（如动态页面或 API 端点）的请求发送到另一个位置。

选择和配置 CDN 是一个大课题，我不会在这里详细介绍，但我会为您提供背景知识，以帮助您配置您选择的 CDN。

构建您的应用程序的最简单方法是，使动态资产与静态资产易于区分，以使 CDN 路由规则尽可能简单。虽然可以使用子域（例如，动态资产由 `meadowlark.com` 提供，静态资产由 `static.meadowlark.com` 提供），但这种方法会增加额外的复杂性，并使本地开发更加困难。更简单的方法是使用请求路径：以 `/public/` 开头的所有内容都是静态资产，其他所有内容都是动态资产，例如。如果您是使用 Express 生成内容或者使用 Express 为单页面应用程序提供 API，则可能需要采用不同的方法。

## 服务器渲染网站

如果您正在使用 Express 渲染动态 HTML，简单地说，“以 `/static/` 开头的所有内容都是静态资产，其他所有内容都是动态的。”通过这种方法，您的所有（动态生成的）URL 将是您想要的任何内容（当然，前提是它们不以 `/static/` 开头！），而所有静态资产都将以 `/static/` 作为前缀：

```
  <img src="/static/img/meadowlark-logo-1.png" alt="Meadowlark Logo">
  Welcome to <a href="/about">Meadowlark Travel</a>.
```

到目前为止，在这本书中，我们一直在使用 Express 的`static`中间件，就好像它在根目录托管了所有静态资产。也就是说，如果我们把静态资产*foo.png*放在*public*目录中，我们会使用 URL 路径*/foo.png*来引用它，而不是*/static/foo.png*。当然，我们可以在现有的*public*目录中创建一个子目录*static*，这样*/public/static/foo.png*就会有 URL*/static/foo.png*，但这似乎有点愚蠢。幸运的是，`static`中间件帮我们避免了这种愚蠢。我们在调用`app.use`时只需指定不同的路径即可：

```
app.use('/static', express.static('public'))
```

现在我们可以在开发环境中使用与生产环境相同的 URL 结构。如果我们仔细保持*public*目录与 CDN 中的内容同步，我们可以在两个地方引用相同的静态资产，并在开发和生产环境之间无缝切换。

当我们配置 CDN 的路由时（您需要查阅 CDN 的文档），您的路由将如下所示：

| URL 路径 | 路由目的地 / 源 |
| --- | --- |
| /static/* | 静态 CDN 文件存储 |
| /*（所有其他内容） | 您的 Node/Express 服务器、代理或负载均衡器 |

## 单页面应用程序

单页面应用程序通常与服务器渲染的网站相反：只有 API 将被路由到您的服务器（例如，任何以*/api*前缀的请求），而其他所有内容将被重定向到您的静态文件存储。

正如我们在第十六章中所看到的，您将有某种方式为您的应用程序创建一个生产捆绑包，其中将包含所有静态资源，然后您将上传到您的 CDN。然后，您所需做的就是确保正确配置路由到您的 API。因此，您的路由将如下所示：

| URL 路径 | 路由目的地 / 源 |
| --- | --- |
| /api/* | 您的 Node/Express 服务器、代理或负载均衡器 |
| /*（所有其他内容） | 静态 CDN 文件存储 |

现在我们已经看到了如何构建一个应用程序，以便我们可以在开发和生产环境之间无缝切换，让我们将注意力转向缓存的实际操作及其如何提升性能。

# 缓存静态资产

无论您是使用 Express 来提供静态资产还是使用 CDN，了解您的浏览器用来确定何时以及如何缓存静态资产的 HTTP 响应头是很有帮助的：

`Expires`/`Cache-Control`

这两个头部告诉浏览器资源可以被缓存的最长时间。浏览器会认真对待它们：如果它们告诉浏览器缓存某物一个月，只要它在缓存中，浏览器一个月内就不会重新下载。重要的是要理解，浏览器可能会因为你无法控制的原因提前清除图像缓存。例如，用户可能手动清除缓存，或者浏览器可能清除资源以为用户频繁访问的其他资源腾出空间。你只需要其中一个头部，而`Expires`更广泛支持，因此最好使用它。如果资源在缓存中且尚未过期，浏览器根本不会发出`GET`请求，这尤其在移动设备上提升了性能。

`Last-Modified`/`ETag`

这两个标签提供了一种类似版本控制的功能：如果浏览器需要获取资源，它会在下载内容之前检查这些标签。仍会向服务器发出`GET`请求，但如果这些标签的值满足浏览器资源未更改的条件，浏览器就不会继续下载文件。正如名称所示，`Last-Modified`允许你指定资源的最后修改日期。`ETag`允许你使用任意字符串，通常是版本字符串或内容哈希值。

在提供静态资源时，应该使用`Expires`头部和`Last-Modified`或者`ETag`之一。Express 内置的`static`中间件设置了`Cache-Control`，但并不处理`Last-Modified`或者`ETag`。因此，虽然适合开发时使用，但不是部署的理想解决方案。

如果选择在 CDN 上托管静态资源，比如 Amazon CloudFront、Microsoft Azure、Fastly、Cloudflare、Akamai 或 StackPath，优势在于它们会为你处理大部分这些细节。你可以微调这些细节，但这些服务的默认设置通常是非常好的。

# 改变你的静态内容

缓存显著提升了网站的性能，但也不是没有后果的。特别是，如果你改变了任何静态资源，客户端可能要等到浏览器中的缓存版本过期后才能看到变化。Google 建议缓存一个月，最好一年。想象一下，一个用户每天都在同一个浏览器上使用你的网站：那个人可能整整一年都看不到你的更新！

显然，这是一个不愿看到的情况，你不能只告诉用户清除他们的缓存。解决方案是缓存破解。*缓存破解* 是一种技术，可以让你控制用户的浏览器何时被迫重新下载资产。通常这意味着给资产加上版本号（*main.2.css* 或 *main.css?version=2*）或者添加某种哈希值（*main.e16b7e149dccfcc399e025e0c454bf77.css*）。无论使用什么技术，当你更新资产时，资源名称会改变，浏览器就知道需要重新下载它。

我们可以对我们的多媒体资产采取相同的方法。例如，让我们拿我们的标志来说（*/static/img/meadowlark_logo.png*）。如果我们将它托管在 CDN 上以达到最佳性能，设置一年的过期时间，然后更改标志，那么用户可能需要一年才能看到更新后的标志。然而，如果你将标志重命名为 */static/img/meadowlark_logo-1.png*（并在 HTML 中反映这个名称更改），浏览器将被迫重新下载它，因为它看起来像一个新资源。

如果你正在使用单页应用框架，例如 `create-react-app` 或类似的，它们会提供一个构建步骤来创建生产就绪的资源包，并附加哈希值。

如果你从头开始，你可能会想研究一下 *打包工具*（这是 SPA 框架在幕后使用的工具）。打包工具将你的 JavaScript、CSS 和其他某些静态资产尽可能地合并，并对结果进行缩小（使其尽可能小）。打包工具的配置是一个大话题，但幸运的是，有很多好的文档可以参考。目前最流行的打包工具如下：

[Webpack](https://webpack.js.org)

Webpack 是第一个真正火起来的打包工具之一，至今仍保持着庞大的用户群。它非常复杂，但这种复杂性是有代价的：学习曲线很陡峭。然而，至少了解基础是很有好处的。

[Parcel](https://parceljs.org)

Parcel 是新进入者，并且引起了轰动。它有极其详细的文档，运行速度极快，最重要的是，学习曲线最短。如果你想快速完成任务，而不想烦扰太多，从这里开始。

[Rollup](https://rollupjs.org)

Rollup 介于 Webpack 和 Parcel 之间。像 Webpack 一样，它非常强大并且具有许多功能。然而，它比 Webpack 更容易入门，但不像 Parcel 那样简单。

# 结论

对于看似如此简单的事情，静态资源可能会带来很多麻烦。然而，它们很可能代表着实际传输给访问者的大部分数据，因此花些时间来优化它们将会带来可观的回报。

另一种未曾提及的静态资源的可行解决方案是从一开始就简单地将您的静态资源托管在 CDN 上，并始终在视图和 CSS 中使用资源的完整 URL。这样做的好处在于简单性，但如果您想在没有互联网访问的树林小屋里度过周末编程马拉松，您可能会遇到麻烦！

如果您的应用程序不值得进行复杂的捆绑和最小化处理，您可以在这方面节省时间。特别是，如果您的网站只包含一两个 JavaScript 文件，并且所有的 CSS 都放在一个文件中，您可能完全可以跳过捆绑，但实际应用程序往往会随时间增长。

无论您选择哪种技术来提供您的静态资源，我强烈建议您将它们分开托管，最好是在 CDN 上。如果这听起来很麻烦，让我保证，这并不像听起来那么困难，特别是如果您在部署系统上花一点时间，使得将静态资源部署到一个位置，应用程序部署到另一个位置是自动的。

如果您担心 CDN 的托管成本，请查看一下您目前托管的费用。大多数托管提供商实际上会按照带宽收费，即使您不知道。然而，如果突然您的网站被 Slashdot 提到，并且您被“Slashdotted”，您可能会发现自己有一张意想不到的托管账单。CDN 托管通常设置为按使用付费。举个例子，我曾经为一家中型地区公司管理的网站，每月带宽使用量约为 20 GB，只需每月支付几美元来托管静态资源（而且这是一个非常媒体密集的网站）。

通过将您的静态资源托管在 CDN 上，您可以实现显著的性能提升，而且这样做的成本和不便是最小的，因此我强烈建议您选择这条路线。

^(1) 在浏览器中使用未编译的 LESS 是可能的，借助一些 JavaScript 魔法。这种方法会带来性能上的后果，因此我不建议这样做。
