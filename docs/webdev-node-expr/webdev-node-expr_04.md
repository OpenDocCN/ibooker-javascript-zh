# 第四章：整理

在前两章中，我们只是在试验：可以说是试探水温。在我们继续进行更复杂的功能之前，我们将进行一些日常管理，并在我们的工作中养成一些良好的习惯。

在本章中，我们将认真开始我们的 Meadowlark Travel 项目。不过，在我们开始构建网站本身之前，我们将确保我们拥有制作高质量产品所需的工具。

###### 提示

本书中的示例不一定是你必须遵循的示例。如果你渴望构建自己的网站，你可以按照本书示例的框架进行修改，以便在本书结束时，你可以拥有一个完成的网站！

# 文件和目录结构

构建应用程序的结构引发了很多宗教性的辩论，没有一种正确的方法。然而，有一些常见的惯例是有帮助的。

试图限制项目根目录中文件的数量是很典型的。通常你会找到配置文件（如*package.json*）、一个*README.md*文件和一堆目录。大多数源代码放在一个通常称为*src*的目录下。出于简洁起见，我们在本书中不会使用这种约定（令人惊讶的是，即使 Express 脚手架应用程序也不会这样做）。对于真实项目，如果你把源代码放在项目根目录中，你可能最终会发现项目根目录变得混乱，你会想把这些文件收集到类似*src*的目录下。

我曾提到我更喜欢将我的主应用程序文件（有时称为*入口点*）命名为项目本身的名称（*meadowlark.js*），而不是像*index.js*、*app.js*或*server.js*这样的通用名称。

如何构建应用程序的结构主要由你决定，我建议在*README.md*文件（或其链接的自述文件）中提供一个结构路线图。

至少，我建议你的项目根目录中始终有以下两个文件：*package.json*和*README.md*。其余的取决于你的想象力。

# 最佳实践

“最佳实践”这个词汇现在被广泛使用，意味着你应该“做正确的事情”，而不是走捷径（我们稍后会具体讨论这是什么意思）。毫无疑问，你听过工程行话：“快速”、“便宜”和“好”，你可以选择其中两个。关于这种模型一直让我困扰的是，它没有考虑到正确执行事务的*累积价值*。第一次正确执行某事可能要比快速而肮脏地完成花费五倍的时间。但第二次只需三倍的时间。当你做了十几次正确的事情时，你几乎能和快速而肮脏的方式做得一样快。

我以前有一个击剑教练，他总是提醒我们，练习并不能造就完美；练习造就*永久性*。也就是说，如果你反复做某事，最终它会变得自动化，成为惯例。这种说法没错，但它并未评价你所练习事物的质量。如果你练习了不良习惯，那不良习惯也会变成惯例。相反，你应该遵循*完美*练习造就完美的原则。基于这种精神，我鼓励你在本书中的其余部分，像是在制作真实的网站一样，就好像你的声誉和报酬取决于结果的质量一样。利用本书不仅学习新技能，还要练习养成良好的习惯。

我们将专注于版本控制和质量保证的实践。在本章中，我们将讨论版本控制，下一章我们将讨论质量保证。

# 版本控制

希望我无需说服你版本控制的价值（如果需要的话，可能要写一整本书）。广义上来说，版本控制提供以下好处：

文档

能够回顾项目历史，了解所做决策的过程和组件开发顺序，可以成为有价值的文档。拥有项目的技术历史记录非常有用。

归因

如果你在团队中工作，归因可能非常重要。当你在代码中发现不透明或可疑的内容时，知道谁做出了这些改变可以节省你很多时间。也许与这些改变相关的注释足以回答你的问题，如果不行，你也知道应该找谁询问。

实验

一个好的版本控制系统能够促进实验。你可以随意尝试新事物，不必担心会影响项目的稳定性。如果实验成功，你可以将其融入项目中；如果失败，你可以放弃它。

多年前，我转向了分布式版本控制系统（DVCS）。我把选择范围缩小到 Git 和 Mercurial，最终选择了 Git，因为它普及广泛且灵活。两者都是优秀且免费的版本控制系统，我推荐你使用其中之一。在本书中，我们将使用 Git，但你也可以选择 Mercurial（或者其他版本控制系统）。

如果你对 Git 不熟悉，我推荐 Jon Loeliger 的优秀著作*[Version Control with Git](http://bit.ly/Version_Ctrl_Git)*（O’Reilly）。此外，GitHub 有一个很好的[Git 学习资源列表](https://try.github.io)。

# 如何使用 Git 本书

首先确保你已经安装了 Git。输入`git --version`检查版本号。如果没有显示版本号，你需要安装 Git。参见[Git 文档](https://git-scm.com)获取安装指南。

本书中跟随示例的两种方法。一种是自己打出示例并跟随 Git 命令。另一种是克隆我用于所有示例的伴随存储库，并检出每个示例的相关文件。有些人通过打出示例学得更好，而有些人则更喜欢只是看并运行更改，而无需全部输入。

## 如果您通过自己做来进行跟随

我们已经为我们的项目建立了一个非常粗略的框架：一些视图，一个布局，一个标志，一个主应用程序文件和一个*package.json*文件。让我们继续创建一个 Git 存储库并添加所有这些文件。

首先，我们进入项目目录并在那里初始化一个 Git 存储库：

```
git init
```

现在，在我们添加所有文件之前，我们将创建一个*.gitignore*文件，以帮助防止我们意外添加不想添加的内容。在项目目录中创建一个名为*.gitignore*的文本文件，您可以在其中添加任何希望 Git 默认忽略的文件或目录（每行一个）。它还支持通配符。例如，如果您的编辑器创建带有波浪线结尾的备份文件（如*meadowlark.js~*），您可以在*.gitignore*文件中放置`*~`。如果您使用 Mac，您会想在那里放置`.DS_Store`。您还需要把`node_modules`放在那里（稍后将讨论原因）。因此，目前文件可能如下所示：

```
node_modules
*~
.DS_Store
```

###### 注意

*.gitignore*文件中的条目也适用于子目录。因此，如果您在项目根目录的*.gitignore*中放置了`*~`，则所有这样的备份文件都将被忽略，即使它们位于子目录中。

现在，我们可以添加所有现有文件。在 Git 中有很多方法可以做到这一点。我通常喜欢`git add -A`，这是所有变体中最全面的。如果您是 Git 的新手，我建议您逐个添加文件（例如`git add meadowlark.js`），如果只想提交一两个文件，或者使用`git add -A`添加所有更改（包括您可能删除的任何文件）。由于我们想添加所有已完成的工作，我们将使用以下操作：

```
git add -A
```

###### 提示

Git 的新手通常会对`git add`命令感到困惑；它添加的是*更改*，而不是文件。因此，如果您修改了*meadowlark.js*，然后输入`git add meadowlark.js`，您实际上是在添加您所做的更改。

Git 有一个“暂存区”，当您运行`git add`时，更改会进入其中。因此，我们添加的更改实际上还没有提交，但它们已经准备就绪。要提交更改，请使用`git commit`：

```
git commit -m "Initial commit."
```

`-m "Initial commit."`允许您编写与此提交相关联的消息。Git 甚至不会让您提交没有消息的提交，这是有道理的。始终努力编写有意义的提交消息；它们应简要但简洁地描述您所做的工作。

## 如果您通过使用官方存储库进行跟随

要获取本书的官方存储库，请运行`git clone`：

```
git clone https://github.com/EthanRBrown/web-development-with-node-and-express-2e
```

本仓库为每个章节设有包含代码示例的目录。例如，本章的源代码可以在`ch04`目录中找到。每章的代码示例通常按顺序编号以便参考。在整个仓库中，我还大量添加了*README.md*文件，其中包含有关示例的额外说明。

###### 注意

在本书的第一版中，我采用了一种不同的方法处理仓库，以线性历史记录的形式开发一个越来越复杂的项目。虽然这种方法愉快地反映了现实世界中项目可能发展的方式，但它给我和我的读者带来了很多困扰。随着 npm 包的更改，代码示例也会改变，除非重新编写整个仓库的历史记录，否则没有好的方法更新仓库或记录文本中的更改。虽然每个目录对应一个章节的方法更为人为，但它允许文本与仓库更紧密地同步，并且还便于社区的贡献。

当本书更新和改进时，仓库也会进行相应更新。当仓库更新时，我会添加一个版本标签，这样你就可以查看与当前阅读版本对应的仓库版本。目前仓库的版本是 2.0.0。在这里，我大致遵循*语义化版本*原则（本章后面将详细介绍）；PATCH 增量（最后一个数字）代表了不应影响你跟进书中内容的小改动。也就是说，如果仓库版本是 2.0.15，它仍应与本书版本对应。然而，如果 MINOR 增量（第二个数字）不同（2.1.0），这意味着伴随仓库中的内容可能已偏离你当前阅读的内容，你可能需要查看一个以 2.0 开头的标签。

伴随仓库广泛使用*README.md*文件来为代码示例添加额外解释。

###### 注意

如果你想进行任何实验，请记住你所检出的标签会让你进入 Git 所谓的“分离 HEAD”状态。虽然你可以自由编辑任何文件，但在未创建分支的情况下提交所做的任何更改是不安全的。因此，如果你想基于标签创建一个实验分支，只需执行一个命令：`git checkout` `-b` `experiment`（其中`experiment`是你的分支名称；你可以随意取名）。然后你可以在该分支上安全地进行编辑和提交任意数量的更改。

# npm 包

你的项目依赖的 npm 包存放在一个名为 *node_modules* 的目录中。（遗憾的是这被称为 *node_modules* 而不是 *npm_packages*，因为 Node 模块是一个相关但不同的概念。）随意探索这个目录以满足你的好奇心或调试你的程序，但你不应该修改这个目录中的任何代码。除了这是一种不良实践之外，你所有的更改很容易就会被 npm 撤销。

如果你需要修改项目依赖的某个包，正确的做法是创建该包的分支（fork）。如果你确实采取了这种方法，并且认为你的改进对其他人有用，那么恭喜你：你现在参与了一个开源项目！你可以提交你的改动，如果它们符合项目标准，它们将被包含在官方包中。贡献到现有包和创建定制版本超出了本书的范围，但在那里有一个充满活力的开发者社区，可以在你想要贡献到现有包时提供帮助。

*package.json* 文件的两个主要目的是描述你的项目和列出它的依赖项。现在就去查看你的 *package.json* 文件吧。你应该看到类似以下内容（确切的版本号可能会不同，因为这些包经常更新）：

```
{
  "dependencies": {
    "express": "⁴.16.4",
    "express-handlebars": "³.0.0"
  }
}
```

现在，我们的 *package.json* 文件只包含关于依赖项的信息。在包版本前面的插入符（`^`）表示以指定版本号开头的任何版本——直到下一个主要版本号——都可以工作。例如，这个 *package.json* 表明任何以 4.0.0 开头的 Express 版本都可以工作，所以 4.0.1 和 4.9.9 都可以工作，但 3.4.7 和 5.0.0 则不行。这是使用 `npm install` 时的默认版本特定性，并且通常是一个相当安全的选择。采用这种方法的后果是，如果你想升级到一个更新的版本，你将不得不编辑文件以指定新版本。总的来说，这是件好事，因为它可以防止依赖关系的变化在你不知情的情况下破坏你的项目。npm 中的版本号由一个名为 *semver*（语义化版本）的组件解析。如果你想了解更多关于 npm 中版本控制的信息，请参考[Tamas Piros 的这篇文章](http://bit.ly/34Vr3lX)。

###### 注意

语义化版本规范（[Semantic Versioning Specification](http://try.github.io/)）规定，使用语义化版本的软件必须声明“公共 API”。我一直觉得这个措辞很令人困惑；他们真正的意思是“有人必须关心与你的软件的接口”。如果你从最广泛的意义上考虑，这实际上可以被理解为任何事物。因此，不要过分纠结于规范的这一部分；重要的细节在于格式。

由于 *package.json* 文件列出了所有依赖项，*node_modules* 目录实际上是一个衍生的产物。也就是说，如果你删除了它，只需运行 `npm install` 即可重新创建这个目录并放置所有必要的依赖项，从而使项目重新工作起来。因此，我建议将 `node_modules` 放入你的 *.gitignore* 文件中，不要将其纳入源代码控制。然而，有些人认为你的存储库应包含运行项目所需的一切，并希望将 `node_modules` 保留在源代码控制中。我发现这在存储库中只是“噪音”，我更倾向于省略它。

###### 注

从 npm 的版本 5 开始，还会创建一个额外的文件 *package-lock.json*。虽然 *package.json* 可以在指定依赖版本时是“宽松”的（使用 `^` 和 `~` 版本修饰符），*package-lock.json* 记录了安装的 *确切* 版本，如果你需要在项目中重新创建确切的依赖版本，这将非常有帮助。我建议你将这个文件纳入源代码控制，并且不要手动修改它。请参阅 [*package-lock.json* 文档](http://bit.ly/2O8IjNK) 了解更多信息。

# 项目元数据

*package.json* 文件的另一个目的是存储项目元数据，例如项目名称、作者、许可信息等等。如果你使用 `npm init` 来最初创建你的 *package.json* 文件，它将为你填充文件所需的字段，并且你随时可以更新它们。如果你打算在 npm 或 GitHub 上公开你的项目，这些元数据就变得至关重要。如果你想了解更多关于 *package.json* 文件中字段的信息，请参阅 [*package.json* 文档](http://bit.ly/2X7GVPs)。另一个重要的元数据是 *README.md* 文件。这个文件可以方便地描述网站的整体架构，以及新加入项目的人可能需要的任何关键信息。它是一种名为 Markdown 的文本基础的 wiki 格式。请参阅 [Markdown 文档](http://bit.ly/2q7BQur) 了解更多信息。

# Node 模块

正如前面提到的，Node 模块和 npm 包是相关但不同的概念。*Node 模块*，顾名思义，提供了一种模块化和封装的机制。*npm 包* 提供了一种标准化的方案来存储、版本化和引用项目（不仅限于模块）。例如，我们在主应用程序文件中将 Express 本身作为一个模块导入：

```
const express = require('express')
```

`require`是一个用于导入模块的 Node 函数。默认情况下，Node 在*node_modules*目录中查找模块（因此，在*node_modules*目录中有一个*express*目录应该并不奇怪）。然而，Node 也提供了创建自己模块的机制（你绝不应该在*node_modules*目录中创建自己的模块）。除了通过包管理器安装到*node_modules*中的模块外，Node 还提供了 30 多个“核心模块”，如`fs`、`http`、`os`和`path`。要查看完整列表，请参阅[这个启发性的 Stack Overflow 问题](http://bit.ly/2NDIkKH)，并参考[官方 Node 文档](https://nodejs.org/en/docs/)。

让我们看看如何将我们在前一章节中实现的幸运饼干功能模块化。

首先让我们创建一个目录来存储我们的模块。你可以随意命名，但是*lib*（代表“库”）是一个常见选择。在那个文件夹中，创建一个名为*fortune.js*的文件（在伴随的存储库中是*ch04/lib/fortune.js*）：

```
const fortuneCookies = [
  "Conquer your fears or they will conquer you.",
  "Rivers need springs.",
  "Do not fear what you don't know.",
  "You will have a pleasant surprise.",
  "Whenever possible, keep it simple.",
]

exports.getFortune = () => {
  const idx = Math.floor(Math.random()*fortuneCookies.length)
  return fortuneCookies[idx]
}
```

这里需要注意的重要事项是使用全局变量`exports`。如果你希望某些内容在模块外可见，你必须将其添加到`exports`中。在这个例子中，函数`getFortune`将在此模块外部可用，但我们的数组`fortuneCookies`将*完全隐藏*。这是件好事：封装允许更少出错和更不易破碎的代码。

###### 注意

有几种方法可以从一个模块中导出功能。我们将在本书中涵盖不同的方法，并在第二十二章中总结它们。

现在在*meadowlark.js*中，我们可以移除`fortuneCookies`数组（虽然留下它也没有什么问题；它不会与在*lib/fortune.js*中定义的同名数组产生任何冲突）。在文件的顶部指定导入是传统的（但不是必需的），因此在*meadowlark.js*文件的顶部添加以下行（在伴随的存储库中是*ch04/meadowlark.js*）：

```
const fortune = require('./lib/fortune')
```

注意我们的模块名前缀为`./`。这告诉 Node 不要在*node_modules*目录中查找模块；如果我们省略了这个前缀，这将会失败。

现在在关于页面的路由中，我们可以利用来自我们模块的`getFortune`方法：

```
app.get('/about', (req, res) => {
  res.render('about', { fortune: fortune.getFortune() } )
})
```

如果你一直在跟进，让我们提交这些更改：

```
git add -A git commit -m "Moved 'fortune cookie' into module."
```

你会发现模块是一种强大且易于封装功能的方式，这将提高项目的整体设计和可维护性，并且使得测试更容易。查看[官方 Node 模块文档](https://nodejs.org/api/modules.html)获取更多信息。

###### 注意

Node 模块有时被称为*CommonJS（CJS）模块*，这是因为 Node 受到了一个旧规范的启发。JavaScript 语言正在采用一种官方的打包机制，称为 ECMAScript 模块（ESM）。如果你已经在 React 或其他前端语言中编写 JavaScript，你可能已经熟悉了 ESM，它使用`import`和`export`（而不是`exports`、`module.exports`和`require`）。欲了解更多信息，请参阅 Axel Rauschmayer 博士的博文[“ECMAScript 6 modules: the final syntax”](http://bit.ly/2X8ZSkM)。

# 结论

现在我们对 Git、npm 和模块有了更多的信息，我们准备讨论如何通过在编码中采用良好的质量保证（QA）实践来生产更好的产品。

我鼓励你牢记本章节的以下几点教训：

+   版本控制使软件开发过程更安全、更可预测，我鼓励你即使在小项目中也要使用它；这将养成良好的习惯！

+   模块化是管理软件复杂性的重要技术。除了通过 npm 提供的丰富模块生态系统外，你还可以将自己的代码打包成模块，以更好地组织项目。

+   Node 模块（也称为 CJS）使用与 ECMAScript 模块（ESM）不同的语法，当你在前端和后端代码之间切换时可能需要转换这两种语法。熟悉这两种语法是个不错的主意。
