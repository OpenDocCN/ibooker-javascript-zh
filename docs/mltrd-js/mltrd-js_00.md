# 序言

您现在手中的这本书非常有趣。它是一本 JavaScript 书籍，以 C 语言编写的示例开篇，使用显式单线程编程语言讨论多线程，并提供了何时以及如何有意地阻塞事件循环的绝佳示例，这与多年来专家一直告诉您绝不能这样做形成了鲜明对比，并以关于为什么您实际上可能不想使用本书描述的机制的优缺点的出色列表结束。更重要的是，这是一本我认为无论您的代码将被部署和运行在何处，都应该阅读的 JavaScript 开发者必读书籍。

当我与公司合作帮助它们构建更高效、性能更优的 Node.js 和 JavaScript 应用程序时，我经常不得不退后一步，首先讨论许多开发者在编程语言方面的常见误解。例如，我曾经与一位有着悠久 Java 和.NET 开发经验的工程师辩论，他认为在 JavaScript 中创建一个新的 Promise 很像在 Java 中创建一个新线程（事实并非如此），并且 Promise 允许 JavaScript 并行执行（实际上并不允许）。在另一次对话中，有人创建了一个 Node.js 应用程序，同时产生了超过一千个并行的工作线程，但在仅有八个逻辑 CPU 核心的机器上测试时，并没有看到预期的性能改进。从这些对话中得到的教训很明显：多线程、并发和并行仍然对很大比例的 JavaScript 开发者来说是非常陌生和困难的主题。

处理这些误解直接导致我（与我的同事和 Node.js 技术指导委员会成员 Matteo Collina 合作）开发了“破碎的承诺”研讨会，我们在其中阐述了 JavaScript 异步编程的基础，教导工程团队如何更有效地推理他们的代码执行顺序和各种事件的时序。这也直接导致了与 Node.js 核心贡献者 Anna Henningsen 合作开发的 Piscina 开源项目，该项目提供了在 Node.js worker 线程之上的工作池模型的最佳实践实现。但这些只是帮助解决挑战的一部分。

在这本书中，Bryan 和 Thomas 精心阐述了多线程开发的基础知识，巧妙地展示了各种 JavaScript 运行时（如 Web 浏览器和 Node.js）如何在不具备内置机制的编程语言中实现并行计算。因为多线程支持的责任已落在运行时上，并且这些运行时之间存在许多差异，因此浏览器和 Node.js 等平台采用了不同的多线程实现方式。虽然它们共享类似的 API，但 Node.js 中的工作线程并不真正等同于 Web 浏览器中的 Web Worker。在浏览器中，对共享工作者、Web Worker 和 Service Worker 的支持几乎是普遍存在的，而 Node.js 中的工作线程已经存在了好几年，但对于 JavaScript 开发者来说，它们依然是一个相对较新的概念。无论你的 JavaScript 运行在哪里，这本书都会提供重要的见解和信息。然而，最重要的是，作者们花时间详细解释为什么你应该关心在你的 JavaScript 应用程序中使用多线程。

James Snell，

Node.js 技术指导委员会成员
