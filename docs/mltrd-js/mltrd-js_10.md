# 附录。结构化克隆算法

*结构化克隆算法*是 JavaScript 引擎在使用特定 API 复制对象时采用的一种机制。尤其是在传递数据给工作线程时，它被广泛应用，尽管其他 API 也在使用。通过这种机制，数据被序列化，然后在另一个 JavaScript 领域内作为对象进行反序列化。

当以这种方式克隆对象（例如从主线程到工作线程或从一个工作线程到另一个）时，在一侧修改对象不会影响另一侧的对象。现在数据实际上有两个副本。结构化克隆算法的目的是为开发人员提供比 `JSON.stringify` 更友好的机制，同时施加合理的限制。

在浏览器和 Node.js 之间复制数据时，会使用结构化克隆算法。类似地，Node.js 在工作线程之间复制数据时也会使用它。基本上，当您看到 `.postMessage()` 调用时，传递的数据是以这种方式克隆的。浏览器和 Node.js 遵循相同的规则，但它们都支持可以复制的额外对象实例。

作为一个快速的经验法则，任何可以干净地表示为 JSON 的数据都可以安全地通过这种方式进行克隆。遵循以这种方式表示的数据将确保几乎没有令人惊讶的情况。即便如此，结构化克隆算法还支持其他几种类型的数据。

首先，除了 `Symbol` 类型之外，JavaScript 中所有的原始数据类型都可以表示。这包括 `Boolean`、`null`、`undefined`、`Number`、`BigInt` 和 `String` 类型。

`Array`、`Map` 和 `Set` 的实例，它们分别用于存储数据集合，也可以以这种方式进行克隆。甚至存储二进制数据的 `ArrayBuffer`、`ArrayBufferView` 和 `Blob` 实例也可以传递。

一些更复杂的对象实例，只要它们是相当通用和被广泛理解的，也可以通过。这包括使用 `Boolean` 和 `String` 构造函数创建的对象，`Date`，甚至 `RegExp` 实例。^(1)

在浏览器端，像 `File`、`FileList`、`ImageBitmap` 和 `ImageData` 这样更复杂且不太为人知的对象实例也可以被克隆。

在 Node.js 方面，可以复制的特殊对象实例包括 `WebAssembly.Module`、`CryptoKey`、`FileHandle`、`Histogram`、`KeyObject`、`MessagePort`、`net.BlockList`、`net.SocketAddress` 和 `X509Certificate`。甚至可以复制 `R⁠e⁠a⁠da⁠b⁠l⁠e⁠S⁠t⁠r⁠e⁠a⁠m`、`WritableStream` 和 `TransformStream` 的实例。

另一个与结构化克隆算法兼容但与 JSON 对象不兼容的显著差异是，递归对象（具有引用另一个属性的嵌套属性的对象）也可以被克隆。一旦遇到重复的嵌套对象，算法就足够智能地停止对对象的序列化。

有一些限制可能会影响您的实现。首先，不能以这种方式克隆函数。函数可能是非常复杂的东西。例如，它们有一个可用的作用域并且可以访问在它们外部声明的变量。在不同领域之间传递这样的内容并没有太多意义。

另一个缺失的特性可能会影响您的实现，即浏览器中的 DOM 元素不能传递。这是否意味着 Web Worker 执行的工作不能显示给用户在 DOM 中？绝对不是。相反，您需要让 Web Worker 返回一个值，然后主 JavaScript Realm 能够转换并显示给用户。例如，如果在 Web Worker 中计算`fibonacci`的 1,000 次迭代，则可以返回数值，并且调用 JavaScript 代码可以取得该值并将其放置在 DOM 中。

JavaScript 中的对象相当复杂。有时可以使用对象字面语法创建它们。其他时候可以通过实例化基类来创建它们。还有时可以通过设置属性描述符和设置器/获取器来修改它们。在结构化克隆算法中，只保留对象的基本值。

大多数显著的是，这意味着，当您定义自己的类并传递一个实例进行克隆时，只会克隆该实例的自有属性，结果对象将是`Object`的一个实例。原型中定义的属性也不会被克隆。即使您在调用端和 Web Worker 内部都定义了`class Foo {}`，值仍然是`Object`的一个实例。这是因为没有真正的方法来保证克隆的双方处理的是完全相同的`Foo`类。^(2)

某些对象将完全拒绝被克隆。例如，如果尝试将`window`从主线程传递到工作线程，或者反向尝试返回`self`，您可能会收到以下错误之一，具体取决于浏览器：

```
Uncaught DOMException: The object could not be cloned.
DataCloneError: The object could not be cloned.
```

在不同的 JavaScript 引擎之间存在一些不一致，因此最好在多个浏览器中测试您的代码。例如，Chrome 和 Node.js 支持克隆`Error`实例，但当前 Firefox 不支持。^(3) 一般的经验法则是 JSON 兼容的对象通常不会有问题，但更复杂的数据可能会有。因此，传递更简单的数据通常是最好的选择。

^(1) 对于`RegExp`实例存在一个小的特例。它们包含一个`.lastIndex`属性，该属性在多次运行正则表达式时用于知道表达式最后结束的位置。此属性不会被传递。

^(2) 已有提案允许序列化和反序列化类实例，比如[“JavaScript 对象的用户定义结构化克隆”](https://oreil.ly/HZUyz)，因此这一限制可能不是永久性的。

^(3) Firefox 最终计划支持这一功能。参见[“允许结构化克隆原生错误类型”](https://oreil.ly/wT4NG)。
